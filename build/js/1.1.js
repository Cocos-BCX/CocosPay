webpackJsonp_name_([1],[
/* 0 */,
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */,
/* 5 */,
/* 6 */,
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.Login = exports.FetchChain = exports.ChainValidation = exports.TransactionHelper = exports.NumberUtils = exports.ObjectId = exports.EmitterInstance = exports.ChainTypes = exports.FetchChainObjects = exports.TransactionBuilder = exports.ChainStore = exports.key = exports.hash = exports.brainKey = exports.Signature = exports.PublicKey = exports.PrivateKey = exports.Aes = exports.Address = exports.SerializerValidation = exports.template = exports.ops = exports.types = exports.fp = exports.Serializer = undefined;

var _serializer = __webpack_require__(213);

var _serializer2 = _interopRequireDefault(_serializer);

var _FastParser = __webpack_require__(214);

var _FastParser2 = _interopRequireDefault(_FastParser);

var _types = __webpack_require__(218);

var _types2 = _interopRequireDefault(_types);

var _operations = __webpack_require__(381);

var ops = _interopRequireWildcard(_operations);

var _template = __webpack_require__(382);

var _template2 = _interopRequireDefault(_template);

var _SerializerValidation = __webpack_require__(145);

var _SerializerValidation2 = _interopRequireDefault(_SerializerValidation);

var _address = __webpack_require__(220);

var _address2 = _interopRequireDefault(_address);

var _aes = __webpack_require__(221);

var _aes2 = _interopRequireDefault(_aes);

var _PrivateKey = __webpack_require__(146);

var _PrivateKey2 = _interopRequireDefault(_PrivateKey);

var _PublicKey = __webpack_require__(97);

var _PublicKey2 = _interopRequireDefault(_PublicKey);

var _signature = __webpack_require__(377);

var _signature2 = _interopRequireDefault(_signature);

var _BrainKey = __webpack_require__(379);

var _BrainKey2 = _interopRequireDefault(_BrainKey);

var _hash = __webpack_require__(58);

var hash = _interopRequireWildcard(_hash);

var _KeyUtils = __webpack_require__(222);

var _KeyUtils2 = _interopRequireDefault(_KeyUtils);

var _ChainStore = __webpack_require__(467);

var _ChainStore2 = _interopRequireDefault(_ChainStore);

var _TransactionBuilder = __webpack_require__(487);

var _TransactionBuilder2 = _interopRequireDefault(_TransactionBuilder);

var _ChainTypes = __webpack_require__(131);

var _ChainTypes2 = _interopRequireDefault(_ChainTypes);

var _ObjectId = __webpack_require__(374);

var _ObjectId2 = _interopRequireDefault(_ObjectId);

var _NumberUtils = __webpack_require__(488);

var _NumberUtils2 = _interopRequireDefault(_NumberUtils);

var _TransactionHelper = __webpack_require__(489);

var _TransactionHelper2 = _interopRequireDefault(_TransactionHelper);

var _ChainValidation = __webpack_require__(383);

var _ChainValidation2 = _interopRequireDefault(_ChainValidation);

var _EmitterInstance = __webpack_require__(384);

var _EmitterInstance2 = _interopRequireDefault(_EmitterInstance);

var _AccountLogin = __webpack_require__(490);

var _AccountLogin2 = _interopRequireDefault(_AccountLogin);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* Serializer */
exports.Serializer = _serializer2.default;
exports.fp = _FastParser2.default;
exports.types = _types2.default;
exports.ops = ops;
exports.template = _template2.default;
exports.SerializerValidation = _SerializerValidation2.default;

/* ECC */

exports.Address = _address2.default;
exports.Aes = _aes2.default;
exports.PrivateKey = _PrivateKey2.default;
exports.PublicKey = _PublicKey2.default;
exports.Signature = _signature2.default;
exports.brainKey = _BrainKey2.default;
exports.hash = hash;
exports.key = _KeyUtils2.default;

/* Chain */

var FetchChainObjects = _ChainStore2.default.FetchChainObjects,
    FetchChain = _ChainStore2.default.FetchChain;
exports.ChainStore = _ChainStore2.default;
exports.TransactionBuilder = _TransactionBuilder2.default;
exports.FetchChainObjects = FetchChainObjects;
exports.ChainTypes = _ChainTypes2.default;
exports.EmitterInstance = _EmitterInstance2.default;
exports.ObjectId = _ObjectId2.default;
exports.NumberUtils = _NumberUtils2.default;
exports.TransactionHelper = _TransactionHelper2.default;
exports.ChainValidation = _ChainValidation2.default;
exports.FetchChain = FetchChain;
exports.Login = _AccountLogin2.default;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.Manager = exports.ChainConfig = exports.Apis = undefined;

var _ApiInstances = __webpack_require__(368);

var _ApiInstances2 = _interopRequireDefault(_ApiInstances);

var _ConnectionManager = __webpack_require__(444);

var _ConnectionManager2 = _interopRequireDefault(_ConnectionManager);

var _ChainConfig = __webpack_require__(370);

var _ChainConfig2 = _interopRequireDefault(_ChainConfig);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.Apis = _ApiInstances2.default;
exports.ChainConfig = _ChainConfig2.default;
exports.Manager = _ConnectionManager2.default;

/***/ }),
/* 9 */,
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assets = __webpack_require__(367);

var _assets2 = _interopRequireDefault(_assets);

var _account = __webpack_require__(388);

var _account2 = _interopRequireDefault(_account);

var _connection = __webpack_require__(493);

var _connection2 = _interopRequireDefault(_connection);

var _chainListener = __webpack_require__(224);

var _chainListener2 = _interopRequireDefault(_chainListener);

var _transactions = __webpack_require__(494);

var _transactions2 = _interopRequireDefault(_transactions);

var _market = __webpack_require__(393);

var _market2 = _interopRequireDefault(_market);

var _operations = __webpack_require__(514);

var _operations2 = _interopRequireDefault(_operations);

var _contract = __webpack_require__(517);

var _contract2 = _interopRequireDefault(_contract);

var _vote = __webpack_require__(518);

var _vote2 = _interopRequireDefault(_vote);

var _nhAssets = __webpack_require__(519);

var _nhAssets2 = _interopRequireDefault(_nhAssets);

var _explorer = __webpack_require__(520);

var _explorer2 = _interopRequireDefault(_explorer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var API = {
  Connection: _connection2.default,
  Assets: _assets2.default,
  Account: _account2.default,
  ChainListener: _chainListener2.default,
  Transactions: _transactions2.default,
  Market: _market2.default,
  Operations: _operations2.default,
  Contract: _contract2.default,
  Vote: _vote2.default,
  NHAssets: _nhAssets2.default,
  Explorer: _explorer2.default
};

exports.default = API;

/***/ }),
/* 11 */,
/* 12 */,
/* 13 */,
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var WS_CONNECTED = exports.WS_CONNECTED = 'connection/WS_CONNECTED';
var WS_DISCONNECTED = exports.WS_DISCONNECTED = 'connection/WS_DISCONNECTED';
var SET_WS_CONNECTING = exports.SET_WS_CONNECTING = 'connection/SET_WS_CONNECTING';
var RPC_STATUS_UPDATE = exports.RPC_STATUS_UPDATE = 'connection/RPC_STATUS_UPDATE';
var SET_RPC_STATUS_CALLBACK = exports.SET_RPC_STATUS_CALLBACK = 'connection/SET_RPC_STATUS_CALLBACK';

var FETCH_USER_REQUEST = exports.FETCH_USER_REQUEST = 'FETCH_USER_REQUEST';
var FETCH_USER_COMPLETE = exports.FETCH_USER_COMPLETE = 'FETCH_USER_COMPLETE';
var FETCH_USER_ERROR = exports.FETCH_USER_ERROR = 'FETCH_USER_ERROR';

var ACCOUNT_SIGNUP_REQUEST = exports.ACCOUNT_SIGNUP_REQUEST = 'ACCOUNT_SIGNUP_REQUEST';
var ACCOUNT_SIGNUP_COMPLETE = exports.ACCOUNT_SIGNUP_COMPLETE = 'ACCOUNT_SIGNUP_COMPLETE';
var ACCOUNT_SIGNUP_ERROR = exports.ACCOUNT_SIGNUP_ERROR = 'ACCOUNT_SIGNUP_ERROR';
var ACCOUNT_LOGIN_REQUEST = exports.ACCOUNT_LOGIN_REQUEST = 'ACCOUNT_LOGIN_REQUEST';
var ACCOUNT_LOGIN_COMPLETE = exports.ACCOUNT_LOGIN_COMPLETE = 'ACCOUNT_LOGIN_COMPLETE';
var ACCOUNT_LOGIN_ERROR = exports.ACCOUNT_LOGIN_ERROR = 'ACCOUNT_LOGIN_ERROR';
var ACCOUNT_LOCK_WALLET = exports.ACCOUNT_LOCK_WALLET = 'ACCOUNT_LOCK_WALLET';
var ACCOUNT_UNLOCK_WALLET = exports.ACCOUNT_UNLOCK_WALLET = 'ACCOUNT_UNLOCK_WALLET';
var ACCOUNT_BRAINKEY_BACKUP = exports.ACCOUNT_BRAINKEY_BACKUP = 'ACCOUNT_BRAINKEY_BACKUP';
var SET_ACCOUNT_USER_DATA = exports.SET_ACCOUNT_USER_DATA = 'SET_ACCOUNT_USER_DATA';
var ACCOUNT_LOGOUT = exports.ACCOUNT_LOGOUT = 'ACCOUNT_LOGOUT';
var FETCH_CURRENT_USER_REQUEST = exports.FETCH_CURRENT_USER_REQUEST = 'FETCH_CURRENT_USER_REQUEST';
var FETCH_CURRENT_USER_COMPLETE = exports.FETCH_CURRENT_USER_COMPLETE = 'FETCH_CURRENT_USER_COMPLETE';
var FETCH_CURRENT_USER_ERROR = exports.FETCH_CURRENT_USER_ERROR = 'FETCH_CURRENT_USER_ERROR';
var CLEAR_CURRENT_USER_DATA = exports.CLEAR_CURRENT_USER_DATA = 'CLEAR_CURRENT_USER_DATA';
var CLEAR_CURRENT_USER_WALLET_DATA = exports.CLEAR_CURRENT_USER_WALLET_DATA = 'CLEAR_CURRENT_USER_WALLET_DATA';

var FETCH_USER_OPERATIONS_REQUEST = exports.FETCH_USER_OPERATIONS_REQUEST = 'FETCH_USER_OPERATIONS_REQUEST';
var FETCH_USER_OPERATIONS_COMPLETE = exports.FETCH_USER_OPERATIONS_COMPLETE = 'FETCH_USER_OPERATIONS_COMPLETE';
var FETCH_USER_OPERATIONS_ERROR = exports.FETCH_USER_OPERATIONS_ERROR = 'FETCH_USER_OPERATIONS_ERROR';
var UNSUBSCRIBE_FROM_USER_OPERATIONS = exports.UNSUBSCRIBE_FROM_USER_OPERATIONS = 'UNSUBSCRIBE_FROM_USER_OPERATIONS';
var SUBSCRIBE_TO_USER_OPERATIONS = exports.SUBSCRIBE_TO_USER_OPERATIONS = 'SUBSCRIBE_TO_USER_OPERATIONS';
var ADD_USER_OPERATION = exports.ADD_USER_OPERATION = 'ADD_USER_OPERATION';
var RESET_OPERATIONS = exports.RESET_OPERATIONS = 'RESET_OPERATIONS';

var FETCH_ASSETS_REQUEST = exports.FETCH_ASSETS_REQUEST = 'FETCH_ASSETS_REQUEST';
var FETCH_ASSETS_COMPLETE = exports.FETCH_ASSETS_COMPLETE = 'FETCH_ASSETS_COMPLETE';
var FETCH_ASSETS_ERROR = exports.FETCH_ASSETS_ERROR = 'FETCH_ASSETS_ERROR';
var FETCH_DEFAULT_ASSETS_REQUEST = exports.FETCH_DEFAULT_ASSETS_REQUEST = 'FETCH_DEFAULT_ASSETS_REQUEST';
var FETCH_DEFAULT_ASSETS_COMPLETE = exports.FETCH_DEFAULT_ASSETS_COMPLETE = 'FETCH_DEFAULT_ASSETS_COMPLETE';
var FETCH_DEFAULT_ASSETS_ERROR = exports.FETCH_DEFAULT_ASSETS_ERROR = 'FETCH_DEFAULT_ASSETS_ERROR';

var SAVE_DEFAULT_ASSETS_IDS = exports.SAVE_DEFAULT_ASSETS_IDS = 'SAVE_DEFAULT_ASSETS_IDS';

var FETCH_MARKET_HISTORY_REQUEST = exports.FETCH_MARKET_HISTORY_REQUEST = 'FETCH_MARKET_HISTORY_REQUEST';
var FETCH_MARKET_HISTORY_COMPLETE = exports.FETCH_MARKET_HISTORY_COMPLETE = 'FETCH_MARKET_HISTORY_COMPLETE';
var FETCH_MARKET_HISTORY_ERROR = exports.FETCH_MARKET_HISTORY_ERROR = 'FETCH_MARKET_HISTORY_ERROR';
var UPDATE_MARKET_PRICE = exports.UPDATE_MARKET_PRICE = 'UPDATE_MARKET_PRICE';
var SUB_TO_MARKET_COMPLETE = exports.SUB_TO_MARKET_COMPLETE = 'SUB_TO_MARKET_COMPLETE';
var UNSUB_FROM_MARKET_COMPLETE = exports.UNSUB_FROM_MARKET_COMPLETE = 'UNSUB_FROM_MARKET_COMPLETE';

var TRANSFER_ASSET_REQUEST = exports.TRANSFER_ASSET_REQUEST = 'TRANSFER_ASSET_REQUEST';
var TRANSFER_ASSET_ERROR = exports.TRANSFER_ASSET_ERROR = 'TRANSFER_ASSET_ERROR';
var TRANSFER_ASSET_COMPLETE = exports.TRANSFER_ASSET_COMPLETE = 'TRANSFER_ASSET_COMPLETE';
var UPDATE_PENDING_ORDERS = exports.UPDATE_PENDING_ORDERS = 'UPDATE_PENDING_ORDERS';
var SET_PENDING_DISTRIBUTION = exports.SET_PENDING_DISTRIBUTION = 'SET_PENDING_DISTRIBUTION';
var REMOVE_PENDING_DISTRIBUTION = exports.REMOVE_PENDING_DISTRIBUTION = 'REMOVE_PENDING_DISTRIBUTION';
var RESET_PENDING_ORDERS = exports.RESET_PENDING_ORDERS = 'RESET_PENDING_ORDERS';
var PROCESS_PENDING_ORDERS_REQUEST = exports.PROCESS_PENDING_ORDERS_REQUEST = 'PROCESS_PENDING_ORDERS_REQUEST';
var PROCESS_PENDING_ORDERS_COMPLETE = exports.PROCESS_PENDING_ORDERS_COMPLETE = 'PROCESS_PENDING_ORDERS_COMPLETE';
var PROCESS_PENDING_ORDERS_ERROR = exports.PROCESS_PENDING_ORDERS_ERROR = 'PROCESS_PENDING_ORDERS_ERROR';
var PROCESS_PENDING_ORDERS_SELL_COMPLETE = exports.PROCESS_PENDING_ORDERS_SELL_COMPLETE = 'PROCESS_PENDING_ORDERS_SELL_COMPLETE';

var FETCH_FEES = exports.FETCH_FEES = 'FETCH_FEES';

var SET_PENDING_TRANSFER = exports.SET_PENDING_TRANSFER = 'SET_PENDING_TRANSFER';

var STORE_BACKUP_DATE = exports.STORE_BACKUP_DATE = 'STORE_BACKUP_DATE';

var FETCH_OPENLEDGER_DEPOSIT_ADDRESS_REQUEST = exports.FETCH_OPENLEDGER_DEPOSIT_ADDRESS_REQUEST = 'FETCH_OPENLEDGER_DEPOSIT_ADDRESS_REQUEST';
var FETCH_OPENLEDGER_DEPOSIT_ADDRESS_COMPLETE = exports.FETCH_OPENLEDGER_DEPOSIT_ADDRESS_COMPLETE = 'FETCH_OPENLEDGER_DEPOSIT_ADDRESS_COMPLETE';
var FETCH_OPENLEDGER_DEPOSIT_ADDRESS_ERROR = exports.FETCH_OPENLEDGER_DEPOSIT_ADDRESS_ERROR = 'FETCH_OPENLEDGER_DEPOSIT_ADDRESS_ERROR';

var FETCH_OPENLEDGER_COINS_REQUEST = exports.FETCH_OPENLEDGER_COINS_REQUEST = 'FETCH_OPENLEDGER_COINS_REQUEST';
var FETCH_OPENLEDGER_COINS_COMPLETE = exports.FETCH_OPENLEDGER_COINS_COMPLETE = 'FETCH_OPENLEDGER_COINS_COMPLETE';
var FETCH_OPENLEDGER_COINS_ERROR = exports.FETCH_OPENLEDGER_COINS_ERROR = 'FETCH_OPENLEDGER_COINS_ERROR';

var FETCH_PRICES_HISTORY_REQUEST = exports.FETCH_PRICES_HISTORY_REQUEST = 'FETCH_PRICES_HISTORY_REQUEST';
var FETCH_PRICES_HISTORY_COMPLETE = exports.FETCH_PRICES_HISTORY_COMPLETE = 'FETCH_PRICES_HISTORY_COMPLETE';
var FETCH_PRICES_HISTORY_ERROR = exports.FETCH_PRICES_HISTORY_ERROR = 'FETCH_PRICES_HISTORY_ERROR';

var SET_CALLBACK = exports.SET_CALLBACK = 'SET_CALLBACK';
var SET_OP_CALLBACK = exports.SET_OP_CALLBACK = 'SET_OP_CALLBACK';

var SET_ORDER_DATA = exports.SET_ORDER_DATA = 'SET_ORDER_DATA';
var SET_TRX_DATA = exports.SET_TRX_DATA = 'SET_TRX_DATA';
var SET_PASSWORD_LONGIN_KEY = exports.SET_PASSWORD_LONGIN_KEY = 'SET_PASSWORD_LONGIN_KEY';

var SET_MARKET_STATS = exports.SET_MARKET_STATS = 'SET_MARKET_STATS';

var SET_KEYS = exports.SET_KEYS = 'SET_KEYS';

var SET_PASSWORD_KEY = exports.SET_PASSWORD_KEY = 'SET_PASSWORD_KEY';

var SET_AES_PRIVATE = exports.SET_AES_PRIVATE = 'SET_AES_PRIVATE';

var SET_VOTES_STATE = exports.SET_VOTES_STATE = 'SET_VOTES_STATE';

var SET_ALL_WITNESSES_COMMITTEE = exports.SET_ALL_WITNESSES_COMMITTEE = 'SET_ALL_WITNESSES_COMMITTEE';

var SET_ALL_TYPE = exports.SET_ALL_TYPE = 'SET_ALL_TYPE';

var SET_VOTE_IDS = exports.SET_VOTE_IDS = 'SET_VOTE_IDS';

var SET_GLOBAL_OBJECT = exports.SET_GLOBAL_OBJECT = 'SET_GLOBAL_OBJECT';

var set_getVoteObjects_callback = exports.set_getVoteObjects_callback = 'set_getVoteObjects_callback';

var set_publishVotes_callback = exports.set_publishVotes_callback = 'set_publishVotes_callback';

var SET_VOTE_IDS_OBJ = exports.SET_VOTE_IDS_OBJ = 'SET_VOTE_IDS_OBJ';

var SET_SETTINGS_APIS = exports.SET_SETTINGS_APIS = 'setting/SET_SETTINGS_APIS';
var SET_SELECT_WS_NODE = exports.SET_SELECT_WS_NODE = 'setting/SET_SELECT_WS_NODE';
var ADD_API_NODE = exports.ADD_API_NODE = "setting/ADD_API_NODE";
var DELETE_API_NODE = exports.DELETE_API_NODE = "setting/DELETE_API_NODE";
var SET_AUTO_RECONNECT = exports.SET_AUTO_RECONNECT = "setting/SET_AUTO_RECONNECT";
var SET_CONNECTING_URL = exports.SET_CONNECTING_URL = "setting/SET_CONNECTING_URL";

var SET_LAST_CURRENT_ASLOT = exports.SET_LAST_CURRENT_ASLOT = "SET_LAST_CURRENT_ASLOT";

var SET_ASSETS = exports.SET_ASSETS = "SET_ASSETS";

var SET_APP_KEYS = exports.SET_APP_KEYS = "SET_APP_KEYS";

var CLEAR_KEYS = exports.CLEAR_KEYS = "CLEAR_KEYS";

var CLEAR_ACCOUNT = exports.CLEAR_ACCOUNT = "CLEAR_ACCOUNT";

var SET_ONLY_GET_OP_FEE = exports.SET_ONLY_GET_OP_FEE = "SET_ONLY_GET_OP_FEE";

var SET_QUERY_ACCOUNT = exports.SET_QUERY_ACCOUNT = "SET_QUERY_ACCOUNT";

/***/ }),
/* 15 */,
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(36);
var isNil = __webpack_require__(53);
var fail = __webpack_require__(553);
var stringify = __webpack_require__(397);

function assert(guard, message) {
  if (guard !== true) {
    if (isFunction(message)) { // handle lazy messages
      message = message();
    }
    else if (isNil(message)) { // use a default message
      message = 'Assert failed (turn on "Pause on exceptions" in your Source panel)';
    }
    assert.fail(message);
  }
}

assert.fail = fail;
assert.stringify = stringify;

module.exports = assert;

/***/ }),
/* 21 */,
/* 22 */,
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

(function (global, factory) {
   true ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.Immutable = factory());
}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;

  function createClass(ctor, superClass) {
    if (superClass) {
      ctor.prototype = Object.create(superClass.prototype);
    }
    ctor.prototype.constructor = ctor;
  }

  function Iterable(value) {
      return isIterable(value) ? value : Seq(value);
    }


  createClass(KeyedIterable, Iterable);
    function KeyedIterable(value) {
      return isKeyed(value) ? value : KeyedSeq(value);
    }


  createClass(IndexedIterable, Iterable);
    function IndexedIterable(value) {
      return isIndexed(value) ? value : IndexedSeq(value);
    }


  createClass(SetIterable, Iterable);
    function SetIterable(value) {
      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
    }



  function isIterable(maybeIterable) {
    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
  }

  function isKeyed(maybeKeyed) {
    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
  }

  function isIndexed(maybeIndexed) {
    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
  }

  function isAssociative(maybeAssociative) {
    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
  }

  function isOrdered(maybeOrdered) {
    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
  }

  Iterable.isIterable = isIterable;
  Iterable.isKeyed = isKeyed;
  Iterable.isIndexed = isIndexed;
  Iterable.isAssociative = isAssociative;
  Iterable.isOrdered = isOrdered;

  Iterable.Keyed = KeyedIterable;
  Iterable.Indexed = IndexedIterable;
  Iterable.Set = SetIterable;


  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

  // Used for setting prototype methods that IE8 chokes on.
  var DELETE = 'delete';

  // Constants describing the size of trie nodes.
  var SHIFT = 5; // Resulted in best performance after ______?
  var SIZE = 1 << SHIFT;
  var MASK = SIZE - 1;

  // A consistent shared value representing "not set" which equals nothing other
  // than itself, and nothing that could be provided externally.
  var NOT_SET = {};

  // Boolean references, Rough equivalent of `bool &`.
  var CHANGE_LENGTH = { value: false };
  var DID_ALTER = { value: false };

  function MakeRef(ref) {
    ref.value = false;
    return ref;
  }

  function SetRef(ref) {
    ref && (ref.value = true);
  }

  // A function which returns a value representing an "owner" for transient writes
  // to tries. The return value will only ever equal itself, and will not equal
  // the return of any subsequent call of this function.
  function OwnerID() {}

  // http://jsperf.com/copy-array-inline
  function arrCopy(arr, offset) {
    offset = offset || 0;
    var len = Math.max(0, arr.length - offset);
    var newArr = new Array(len);
    for (var ii = 0; ii < len; ii++) {
      newArr[ii] = arr[ii + offset];
    }
    return newArr;
  }

  function ensureSize(iter) {
    if (iter.size === undefined) {
      iter.size = iter.__iterate(returnTrue);
    }
    return iter.size;
  }

  function wrapIndex(iter, index) {
    // This implements "is array index" which the ECMAString spec defines as:
    //
    //     A String property name P is an array index if and only if
    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
    //     to 2^32âˆ’1.
    //
    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
    if (typeof index !== 'number') {
      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
      if ('' + uint32Index !== index || uint32Index === 4294967295) {
        return NaN;
      }
      index = uint32Index;
    }
    return index < 0 ? ensureSize(iter) + index : index;
  }

  function returnTrue() {
    return true;
  }

  function wholeSlice(begin, end, size) {
    return (begin === 0 || (size !== undefined && begin <= -size)) &&
      (end === undefined || (size !== undefined && end >= size));
  }

  function resolveBegin(begin, size) {
    return resolveIndex(begin, size, 0);
  }

  function resolveEnd(end, size) {
    return resolveIndex(end, size, size);
  }

  function resolveIndex(index, size, defaultIndex) {
    return index === undefined ?
      defaultIndex :
      index < 0 ?
        Math.max(0, size + index) :
        size === undefined ?
          index :
          Math.min(size, index);
  }

  /* global Symbol */

  var ITERATE_KEYS = 0;
  var ITERATE_VALUES = 1;
  var ITERATE_ENTRIES = 2;

  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator';

  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;


  function Iterator(next) {
      this.next = next;
    }

    Iterator.prototype.toString = function() {
      return '[Iterator]';
    };


  Iterator.KEYS = ITERATE_KEYS;
  Iterator.VALUES = ITERATE_VALUES;
  Iterator.ENTRIES = ITERATE_ENTRIES;

  Iterator.prototype.inspect =
  Iterator.prototype.toSource = function () { return this.toString(); }
  Iterator.prototype[ITERATOR_SYMBOL] = function () {
    return this;
  };


  function iteratorValue(type, k, v, iteratorResult) {
    var value = type === 0 ? k : type === 1 ? v : [k, v];
    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {
      value: value, done: false
    });
    return iteratorResult;
  }

  function iteratorDone() {
    return { value: undefined, done: true };
  }

  function hasIterator(maybeIterable) {
    return !!getIteratorFn(maybeIterable);
  }

  function isIterator(maybeIterator) {
    return maybeIterator && typeof maybeIterator.next === 'function';
  }

  function getIterator(iterable) {
    var iteratorFn = getIteratorFn(iterable);
    return iteratorFn && iteratorFn.call(iterable);
  }

  function getIteratorFn(iterable) {
    var iteratorFn = iterable && (
      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
      iterable[FAUX_ITERATOR_SYMBOL]
    );
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  function isArrayLike(value) {
    return value && typeof value.length === 'number';
  }

  createClass(Seq, Iterable);
    function Seq(value) {
      return value === null || value === undefined ? emptySequence() :
        isIterable(value) ? value.toSeq() : seqFromValue(value);
    }

    Seq.of = function(/*...values*/) {
      return Seq(arguments);
    };

    Seq.prototype.toSeq = function() {
      return this;
    };

    Seq.prototype.toString = function() {
      return this.__toString('Seq {', '}');
    };

    Seq.prototype.cacheResult = function() {
      if (!this._cache && this.__iterateUncached) {
        this._cache = this.entrySeq().toArray();
        this.size = this._cache.length;
      }
      return this;
    };

    // abstract __iterateUncached(fn, reverse)

    Seq.prototype.__iterate = function(fn, reverse) {
      return seqIterate(this, fn, reverse, true);
    };

    // abstract __iteratorUncached(type, reverse)

    Seq.prototype.__iterator = function(type, reverse) {
      return seqIterator(this, type, reverse, true);
    };



  createClass(KeyedSeq, Seq);
    function KeyedSeq(value) {
      return value === null || value === undefined ?
        emptySequence().toKeyedSeq() :
        isIterable(value) ?
          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :
          keyedSeqFromValue(value);
    }

    KeyedSeq.prototype.toKeyedSeq = function() {
      return this;
    };



  createClass(IndexedSeq, Seq);
    function IndexedSeq(value) {
      return value === null || value === undefined ? emptySequence() :
        !isIterable(value) ? indexedSeqFromValue(value) :
        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
    }

    IndexedSeq.of = function(/*...values*/) {
      return IndexedSeq(arguments);
    };

    IndexedSeq.prototype.toIndexedSeq = function() {
      return this;
    };

    IndexedSeq.prototype.toString = function() {
      return this.__toString('Seq [', ']');
    };

    IndexedSeq.prototype.__iterate = function(fn, reverse) {
      return seqIterate(this, fn, reverse, false);
    };

    IndexedSeq.prototype.__iterator = function(type, reverse) {
      return seqIterator(this, type, reverse, false);
    };



  createClass(SetSeq, Seq);
    function SetSeq(value) {
      return (
        value === null || value === undefined ? emptySequence() :
        !isIterable(value) ? indexedSeqFromValue(value) :
        isKeyed(value) ? value.entrySeq() : value
      ).toSetSeq();
    }

    SetSeq.of = function(/*...values*/) {
      return SetSeq(arguments);
    };

    SetSeq.prototype.toSetSeq = function() {
      return this;
    };



  Seq.isSeq = isSeq;
  Seq.Keyed = KeyedSeq;
  Seq.Set = SetSeq;
  Seq.Indexed = IndexedSeq;

  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';

  Seq.prototype[IS_SEQ_SENTINEL] = true;



  createClass(ArraySeq, IndexedSeq);
    function ArraySeq(array) {
      this._array = array;
      this.size = array.length;
    }

    ArraySeq.prototype.get = function(index, notSetValue) {
      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
    };

    ArraySeq.prototype.__iterate = function(fn, reverse) {
      var array = this._array;
      var maxIndex = array.length - 1;
      for (var ii = 0; ii <= maxIndex; ii++) {
        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };

    ArraySeq.prototype.__iterator = function(type, reverse) {
      var array = this._array;
      var maxIndex = array.length - 1;
      var ii = 0;
      return new Iterator(function() 
        {return ii > maxIndex ?
          iteratorDone() :
          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}
      );
    };



  createClass(ObjectSeq, KeyedSeq);
    function ObjectSeq(object) {
      var keys = Object.keys(object);
      this._object = object;
      this._keys = keys;
      this.size = keys.length;
    }

    ObjectSeq.prototype.get = function(key, notSetValue) {
      if (notSetValue !== undefined && !this.has(key)) {
        return notSetValue;
      }
      return this._object[key];
    };

    ObjectSeq.prototype.has = function(key) {
      return this._object.hasOwnProperty(key);
    };

    ObjectSeq.prototype.__iterate = function(fn, reverse) {
      var object = this._object;
      var keys = this._keys;
      var maxIndex = keys.length - 1;
      for (var ii = 0; ii <= maxIndex; ii++) {
        var key = keys[reverse ? maxIndex - ii : ii];
        if (fn(object[key], key, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };

    ObjectSeq.prototype.__iterator = function(type, reverse) {
      var object = this._object;
      var keys = this._keys;
      var maxIndex = keys.length - 1;
      var ii = 0;
      return new Iterator(function()  {
        var key = keys[reverse ? maxIndex - ii : ii];
        return ii++ > maxIndex ?
          iteratorDone() :
          iteratorValue(type, key, object[key]);
      });
    };

  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;


  createClass(IterableSeq, IndexedSeq);
    function IterableSeq(iterable) {
      this._iterable = iterable;
      this.size = iterable.length || iterable.size;
    }

    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var iterable = this._iterable;
      var iterator = getIterator(iterable);
      var iterations = 0;
      if (isIterator(iterator)) {
        var step;
        while (!(step = iterator.next()).done) {
          if (fn(step.value, iterations++, this) === false) {
            break;
          }
        }
      }
      return iterations;
    };

    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterable = this._iterable;
      var iterator = getIterator(iterable);
      if (!isIterator(iterator)) {
        return new Iterator(iteratorDone);
      }
      var iterations = 0;
      return new Iterator(function()  {
        var step = iterator.next();
        return step.done ? step : iteratorValue(type, iterations++, step.value);
      });
    };



  createClass(IteratorSeq, IndexedSeq);
    function IteratorSeq(iterator) {
      this._iterator = iterator;
      this._iteratorCache = [];
    }

    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var iterator = this._iterator;
      var cache = this._iteratorCache;
      var iterations = 0;
      while (iterations < cache.length) {
        if (fn(cache[iterations], iterations++, this) === false) {
          return iterations;
        }
      }
      var step;
      while (!(step = iterator.next()).done) {
        var val = step.value;
        cache[iterations] = val;
        if (fn(val, iterations++, this) === false) {
          break;
        }
      }
      return iterations;
    };

    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterator = this._iterator;
      var cache = this._iteratorCache;
      var iterations = 0;
      return new Iterator(function()  {
        if (iterations >= cache.length) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          cache[iterations] = step.value;
        }
        return iteratorValue(type, iterations, cache[iterations++]);
      });
    };




  // # pragma Helper functions

  function isSeq(maybeSeq) {
    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
  }

  var EMPTY_SEQ;

  function emptySequence() {
    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
  }

  function keyedSeqFromValue(value) {
    var seq =
      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :
      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :
      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :
      typeof value === 'object' ? new ObjectSeq(value) :
      undefined;
    if (!seq) {
      throw new TypeError(
        'Expected Array or iterable object of [k, v] entries, '+
        'or keyed object: ' + value
      );
    }
    return seq;
  }

  function indexedSeqFromValue(value) {
    var seq = maybeIndexedSeqFromValue(value);
    if (!seq) {
      throw new TypeError(
        'Expected Array or iterable object of values: ' + value
      );
    }
    return seq;
  }

  function seqFromValue(value) {
    var seq = maybeIndexedSeqFromValue(value) ||
      (typeof value === 'object' && new ObjectSeq(value));
    if (!seq) {
      throw new TypeError(
        'Expected Array or iterable object of values, or keyed object: ' + value
      );
    }
    return seq;
  }

  function maybeIndexedSeqFromValue(value) {
    return (
      isArrayLike(value) ? new ArraySeq(value) :
      isIterator(value) ? new IteratorSeq(value) :
      hasIterator(value) ? new IterableSeq(value) :
      undefined
    );
  }

  function seqIterate(seq, fn, reverse, useKeys) {
    var cache = seq._cache;
    if (cache) {
      var maxIndex = cache.length - 1;
      for (var ii = 0; ii <= maxIndex; ii++) {
        var entry = cache[reverse ? maxIndex - ii : ii];
        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
          return ii + 1;
        }
      }
      return ii;
    }
    return seq.__iterateUncached(fn, reverse);
  }

  function seqIterator(seq, type, reverse, useKeys) {
    var cache = seq._cache;
    if (cache) {
      var maxIndex = cache.length - 1;
      var ii = 0;
      return new Iterator(function()  {
        var entry = cache[reverse ? maxIndex - ii : ii];
        return ii++ > maxIndex ?
          iteratorDone() :
          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
      });
    }
    return seq.__iteratorUncached(type, reverse);
  }

  function fromJS(json, converter) {
    return converter ?
      fromJSWith(converter, json, '', {'': json}) :
      fromJSDefault(json);
  }

  function fromJSWith(converter, json, key, parentJSON) {
    if (Array.isArray(json)) {
      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
    }
    if (isPlainObj(json)) {
      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
    }
    return json;
  }

  function fromJSDefault(json) {
    if (Array.isArray(json)) {
      return IndexedSeq(json).map(fromJSDefault).toList();
    }
    if (isPlainObj(json)) {
      return KeyedSeq(json).map(fromJSDefault).toMap();
    }
    return json;
  }

  function isPlainObj(value) {
    return value && (value.constructor === Object || value.constructor === undefined);
  }

  /**
   * An extension of the "same-value" algorithm as [described for use by ES6 Map
   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
   *
   * NaN is considered the same as NaN, however -0 and 0 are considered the same
   * value, which is different from the algorithm described by
   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
   *
   * This is extended further to allow Objects to describe the values they
   * represent, by way of `valueOf` or `equals` (and `hashCode`).
   *
   * Note: because of this extension, the key equality of Immutable.Map and the
   * value equality of Immutable.Set will differ from ES6 Map and Set.
   *
   * ### Defining custom values
   *
   * The easiest way to describe the value an object represents is by implementing
   * `valueOf`. For example, `Date` represents a value by returning a unix
   * timestamp for `valueOf`:
   *
   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
   *     var date2 = new Date(1234567890000);
   *     date1.valueOf(); // 1234567890000
   *     assert( date1 !== date2 );
   *     assert( Immutable.is( date1, date2 ) );
   *
   * Note: overriding `valueOf` may have other implications if you use this object
   * where JavaScript expects a primitive, such as implicit string coercion.
   *
   * For more complex types, especially collections, implementing `valueOf` may
   * not be performant. An alternative is to implement `equals` and `hashCode`.
   *
   * `equals` takes another object, presumably of similar type, and returns true
   * if the it is equal. Equality is symmetrical, so the same result should be
   * returned if this and the argument are flipped.
   *
   *     assert( a.equals(b) === b.equals(a) );
   *
   * `hashCode` returns a 32bit integer number representing the object which will
   * be used to determine how to store the value object in a Map or Set. You must
   * provide both or neither methods, one must not exist without the other.
   *
   * Also, an important relationship between these methods must be upheld: if two
   * values are equal, they *must* return the same hashCode. If the values are not
   * equal, they might have the same hashCode; this is called a hash collision,
   * and while undesirable for performance reasons, it is acceptable.
   *
   *     if (a.equals(b)) {
   *       assert( a.hashCode() === b.hashCode() );
   *     }
   *
   * All Immutable collections implement `equals` and `hashCode`.
   *
   */
  function is(valueA, valueB) {
    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
      return true;
    }
    if (!valueA || !valueB) {
      return false;
    }
    if (typeof valueA.valueOf === 'function' &&
        typeof valueB.valueOf === 'function') {
      valueA = valueA.valueOf();
      valueB = valueB.valueOf();
      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
        return true;
      }
      if (!valueA || !valueB) {
        return false;
      }
    }
    if (typeof valueA.equals === 'function' &&
        typeof valueB.equals === 'function' &&
        valueA.equals(valueB)) {
      return true;
    }
    return false;
  }

  function deepEqual(a, b) {
    if (a === b) {
      return true;
    }

    if (
      !isIterable(b) ||
      a.size !== undefined && b.size !== undefined && a.size !== b.size ||
      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||
      isKeyed(a) !== isKeyed(b) ||
      isIndexed(a) !== isIndexed(b) ||
      isOrdered(a) !== isOrdered(b)
    ) {
      return false;
    }

    if (a.size === 0 && b.size === 0) {
      return true;
    }

    var notAssociative = !isAssociative(a);

    if (isOrdered(a)) {
      var entries = a.entries();
      return b.every(function(v, k)  {
        var entry = entries.next().value;
        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
      }) && entries.next().done;
    }

    var flipped = false;

    if (a.size === undefined) {
      if (b.size === undefined) {
        if (typeof a.cacheResult === 'function') {
          a.cacheResult();
        }
      } else {
        flipped = true;
        var _ = a;
        a = b;
        b = _;
      }
    }

    var allEqual = true;
    var bSize = b.__iterate(function(v, k)  {
      if (notAssociative ? !a.has(v) :
          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
        allEqual = false;
        return false;
      }
    });

    return allEqual && a.size === bSize;
  }

  createClass(Repeat, IndexedSeq);

    function Repeat(value, times) {
      if (!(this instanceof Repeat)) {
        return new Repeat(value, times);
      }
      this._value = value;
      this.size = times === undefined ? Infinity : Math.max(0, times);
      if (this.size === 0) {
        if (EMPTY_REPEAT) {
          return EMPTY_REPEAT;
        }
        EMPTY_REPEAT = this;
      }
    }

    Repeat.prototype.toString = function() {
      if (this.size === 0) {
        return 'Repeat []';
      }
      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
    };

    Repeat.prototype.get = function(index, notSetValue) {
      return this.has(index) ? this._value : notSetValue;
    };

    Repeat.prototype.includes = function(searchValue) {
      return is(this._value, searchValue);
    };

    Repeat.prototype.slice = function(begin, end) {
      var size = this.size;
      return wholeSlice(begin, end, size) ? this :
        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
    };

    Repeat.prototype.reverse = function() {
      return this;
    };

    Repeat.prototype.indexOf = function(searchValue) {
      if (is(this._value, searchValue)) {
        return 0;
      }
      return -1;
    };

    Repeat.prototype.lastIndexOf = function(searchValue) {
      if (is(this._value, searchValue)) {
        return this.size;
      }
      return -1;
    };

    Repeat.prototype.__iterate = function(fn, reverse) {
      for (var ii = 0; ii < this.size; ii++) {
        if (fn(this._value, ii, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };

    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;
      var ii = 0;
      return new Iterator(function() 
        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}
      );
    };

    Repeat.prototype.equals = function(other) {
      return other instanceof Repeat ?
        is(this._value, other._value) :
        deepEqual(other);
    };


  var EMPTY_REPEAT;

  function invariant(condition, error) {
    if (!condition) throw new Error(error);
  }

  createClass(Range, IndexedSeq);

    function Range(start, end, step) {
      if (!(this instanceof Range)) {
        return new Range(start, end, step);
      }
      invariant(step !== 0, 'Cannot step a Range by 0');
      start = start || 0;
      if (end === undefined) {
        end = Infinity;
      }
      step = step === undefined ? 1 : Math.abs(step);
      if (end < start) {
        step = -step;
      }
      this._start = start;
      this._end = end;
      this._step = step;
      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
      if (this.size === 0) {
        if (EMPTY_RANGE) {
          return EMPTY_RANGE;
        }
        EMPTY_RANGE = this;
      }
    }

    Range.prototype.toString = function() {
      if (this.size === 0) {
        return 'Range []';
      }
      return 'Range [ ' +
        this._start + '...' + this._end +
        (this._step !== 1 ? ' by ' + this._step : '') +
      ' ]';
    };

    Range.prototype.get = function(index, notSetValue) {
      return this.has(index) ?
        this._start + wrapIndex(this, index) * this._step :
        notSetValue;
    };

    Range.prototype.includes = function(searchValue) {
      var possibleIndex = (searchValue - this._start) / this._step;
      return possibleIndex >= 0 &&
        possibleIndex < this.size &&
        possibleIndex === Math.floor(possibleIndex);
    };

    Range.prototype.slice = function(begin, end) {
      if (wholeSlice(begin, end, this.size)) {
        return this;
      }
      begin = resolveBegin(begin, this.size);
      end = resolveEnd(end, this.size);
      if (end <= begin) {
        return new Range(0, 0);
      }
      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
    };

    Range.prototype.indexOf = function(searchValue) {
      var offsetValue = searchValue - this._start;
      if (offsetValue % this._step === 0) {
        var index = offsetValue / this._step;
        if (index >= 0 && index < this.size) {
          return index
        }
      }
      return -1;
    };

    Range.prototype.lastIndexOf = function(searchValue) {
      return this.indexOf(searchValue);
    };

    Range.prototype.__iterate = function(fn, reverse) {
      var maxIndex = this.size - 1;
      var step = this._step;
      var value = reverse ? this._start + maxIndex * step : this._start;
      for (var ii = 0; ii <= maxIndex; ii++) {
        if (fn(value, ii, this) === false) {
          return ii + 1;
        }
        value += reverse ? -step : step;
      }
      return ii;
    };

    Range.prototype.__iterator = function(type, reverse) {
      var maxIndex = this.size - 1;
      var step = this._step;
      var value = reverse ? this._start + maxIndex * step : this._start;
      var ii = 0;
      return new Iterator(function()  {
        var v = value;
        value += reverse ? -step : step;
        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
      });
    };

    Range.prototype.equals = function(other) {
      return other instanceof Range ?
        this._start === other._start &&
        this._end === other._end &&
        this._step === other._step :
        deepEqual(this, other);
    };


  var EMPTY_RANGE;

  createClass(Collection, Iterable);
    function Collection() {
      throw TypeError('Abstract');
    }


  createClass(KeyedCollection, Collection);function KeyedCollection() {}

  createClass(IndexedCollection, Collection);function IndexedCollection() {}

  createClass(SetCollection, Collection);function SetCollection() {}


  Collection.Keyed = KeyedCollection;
  Collection.Indexed = IndexedCollection;
  Collection.Set = SetCollection;

  var imul =
    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?
    Math.imul :
    function imul(a, b) {
      a = a | 0; // int
      b = b | 0; // int
      var c = a & 0xffff;
      var d = b & 0xffff;
      // Shift by 0 fixes the sign on the high part.
      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int
    };

  // v8 has an optimization for storing 31-bit signed numbers.
  // Values which have either 00 or 11 as the high order bits qualify.
  // This function drops the highest order bit in a signed number, maintaining
  // the sign bit.
  function smi(i32) {
    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);
  }

  function hash(o) {
    if (o === false || o === null || o === undefined) {
      return 0;
    }
    if (typeof o.valueOf === 'function') {
      o = o.valueOf();
      if (o === false || o === null || o === undefined) {
        return 0;
      }
    }
    if (o === true) {
      return 1;
    }
    var type = typeof o;
    if (type === 'number') {
      if (o !== o || o === Infinity) {
        return 0;
      }
      var h = o | 0;
      if (h !== o) {
        h ^= o * 0xFFFFFFFF;
      }
      while (o > 0xFFFFFFFF) {
        o /= 0xFFFFFFFF;
        h ^= o;
      }
      return smi(h);
    }
    if (type === 'string') {
      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
    }
    if (typeof o.hashCode === 'function') {
      return o.hashCode();
    }
    if (type === 'object') {
      return hashJSObj(o);
    }
    if (typeof o.toString === 'function') {
      return hashString(o.toString());
    }
    throw new Error('Value type ' + type + ' cannot be hashed.');
  }

  function cachedHashString(string) {
    var hash = stringHashCache[string];
    if (hash === undefined) {
      hash = hashString(string);
      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
        STRING_HASH_CACHE_SIZE = 0;
        stringHashCache = {};
      }
      STRING_HASH_CACHE_SIZE++;
      stringHashCache[string] = hash;
    }
    return hash;
  }

  // http://jsperf.com/hashing-strings
  function hashString(string) {
    // This is the hash from JVM
    // The hash code for a string is computed as
    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
    // where s[i] is the ith character of the string and n is the length of
    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
    // (exclusive) by dropping high bits.
    var hash = 0;
    for (var ii = 0; ii < string.length; ii++) {
      hash = 31 * hash + string.charCodeAt(ii) | 0;
    }
    return smi(hash);
  }

  function hashJSObj(obj) {
    var hash;
    if (usingWeakMap) {
      hash = weakMap.get(obj);
      if (hash !== undefined) {
        return hash;
      }
    }

    hash = obj[UID_HASH_KEY];
    if (hash !== undefined) {
      return hash;
    }

    if (!canDefineProperty) {
      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
      if (hash !== undefined) {
        return hash;
      }

      hash = getIENodeHash(obj);
      if (hash !== undefined) {
        return hash;
      }
    }

    hash = ++objHashUID;
    if (objHashUID & 0x40000000) {
      objHashUID = 0;
    }

    if (usingWeakMap) {
      weakMap.set(obj, hash);
    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
      throw new Error('Non-extensible objects are not allowed as keys.');
    } else if (canDefineProperty) {
      Object.defineProperty(obj, UID_HASH_KEY, {
        'enumerable': false,
        'configurable': false,
        'writable': false,
        'value': hash
      });
    } else if (obj.propertyIsEnumerable !== undefined &&
               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
      // Since we can't define a non-enumerable property on the object
      // we'll hijack one of the less-used non-enumerable properties to
      // save our hash on it. Since this is a function it will not show up in
      // `JSON.stringify` which is what we want.
      obj.propertyIsEnumerable = function() {
        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
      };
      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
    } else if (obj.nodeType !== undefined) {
      // At this point we couldn't get the IE `uniqueID` to use as a hash
      // and we couldn't use a non-enumerable property to exploit the
      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
      // itself.
      obj[UID_HASH_KEY] = hash;
    } else {
      throw new Error('Unable to set a non-enumerable property on object.');
    }

    return hash;
  }

  // Get references to ES5 object methods.
  var isExtensible = Object.isExtensible;

  // True if Object.defineProperty works as expected. IE8 fails this test.
  var canDefineProperty = (function() {
    try {
      Object.defineProperty({}, '@', {});
      return true;
    } catch (e) {
      return false;
    }
  }());

  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
  // and avoid memory leaks from the IE cloneNode bug.
  function getIENodeHash(node) {
    if (node && node.nodeType > 0) {
      switch (node.nodeType) {
        case 1: // Element
          return node.uniqueID;
        case 9: // Document
          return node.documentElement && node.documentElement.uniqueID;
      }
    }
  }

  // If possible, use a WeakMap.
  var usingWeakMap = typeof WeakMap === 'function';
  var weakMap;
  if (usingWeakMap) {
    weakMap = new WeakMap();
  }

  var objHashUID = 0;

  var UID_HASH_KEY = '__immutablehash__';
  if (typeof Symbol === 'function') {
    UID_HASH_KEY = Symbol(UID_HASH_KEY);
  }

  var STRING_HASH_CACHE_MIN_STRLEN = 16;
  var STRING_HASH_CACHE_MAX_SIZE = 255;
  var STRING_HASH_CACHE_SIZE = 0;
  var stringHashCache = {};

  function assertNotInfinite(size) {
    invariant(
      size !== Infinity,
      'Cannot perform this action with an infinite size.'
    );
  }

  createClass(Map, KeyedCollection);

    // @pragma Construction

    function Map(value) {
      return value === null || value === undefined ? emptyMap() :
        isMap(value) && !isOrdered(value) ? value :
        emptyMap().withMutations(function(map ) {
          var iter = KeyedIterable(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v, k)  {return map.set(k, v)});
        });
    }

    Map.of = function() {var keyValues = SLICE$0.call(arguments, 0);
      return emptyMap().withMutations(function(map ) {
        for (var i = 0; i < keyValues.length; i += 2) {
          if (i + 1 >= keyValues.length) {
            throw new Error('Missing value for key: ' + keyValues[i]);
          }
          map.set(keyValues[i], keyValues[i + 1]);
        }
      });
    };

    Map.prototype.toString = function() {
      return this.__toString('Map {', '}');
    };

    // @pragma Access

    Map.prototype.get = function(k, notSetValue) {
      return this._root ?
        this._root.get(0, undefined, k, notSetValue) :
        notSetValue;
    };

    // @pragma Modification

    Map.prototype.set = function(k, v) {
      return updateMap(this, k, v);
    };

    Map.prototype.setIn = function(keyPath, v) {
      return this.updateIn(keyPath, NOT_SET, function()  {return v});
    };

    Map.prototype.remove = function(k) {
      return updateMap(this, k, NOT_SET);
    };

    Map.prototype.deleteIn = function(keyPath) {
      return this.updateIn(keyPath, function()  {return NOT_SET});
    };

    Map.prototype.update = function(k, notSetValue, updater) {
      return arguments.length === 1 ?
        k(this) :
        this.updateIn([k], notSetValue, updater);
    };

    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {
      if (!updater) {
        updater = notSetValue;
        notSetValue = undefined;
      }
      var updatedValue = updateInDeepMap(
        this,
        forceIterator(keyPath),
        notSetValue,
        updater
      );
      return updatedValue === NOT_SET ? undefined : updatedValue;
    };

    Map.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._root = null;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyMap();
    };

    // @pragma Composition

    Map.prototype.merge = function(/*...iters*/) {
      return mergeIntoMapWith(this, undefined, arguments);
    };

    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return mergeIntoMapWith(this, merger, iters);
    };

    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
      return this.updateIn(
        keyPath,
        emptyMap(),
        function(m ) {return typeof m.merge === 'function' ?
          m.merge.apply(m, iters) :
          iters[iters.length - 1]}
      );
    };

    Map.prototype.mergeDeep = function(/*...iters*/) {
      return mergeIntoMapWith(this, deepMerger, arguments);
    };

    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return mergeIntoMapWith(this, deepMergerWith(merger), iters);
    };

    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
      return this.updateIn(
        keyPath,
        emptyMap(),
        function(m ) {return typeof m.mergeDeep === 'function' ?
          m.mergeDeep.apply(m, iters) :
          iters[iters.length - 1]}
      );
    };

    Map.prototype.sort = function(comparator) {
      // Late binding
      return OrderedMap(sortFactory(this, comparator));
    };

    Map.prototype.sortBy = function(mapper, comparator) {
      // Late binding
      return OrderedMap(sortFactory(this, comparator, mapper));
    };

    // @pragma Mutability

    Map.prototype.withMutations = function(fn) {
      var mutable = this.asMutable();
      fn(mutable);
      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
    };

    Map.prototype.asMutable = function() {
      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
    };

    Map.prototype.asImmutable = function() {
      return this.__ensureOwner();
    };

    Map.prototype.wasAltered = function() {
      return this.__altered;
    };

    Map.prototype.__iterator = function(type, reverse) {
      return new MapIterator(this, type, reverse);
    };

    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      var iterations = 0;
      this._root && this._root.iterate(function(entry ) {
        iterations++;
        return fn(entry[1], entry[0], this$0);
      }, reverse);
      return iterations;
    };

    Map.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        this.__altered = false;
        return this;
      }
      return makeMap(this.size, this._root, ownerID, this.__hash);
    };


  function isMap(maybeMap) {
    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
  }

  Map.isMap = isMap;

  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';

  var MapPrototype = Map.prototype;
  MapPrototype[IS_MAP_SENTINEL] = true;
  MapPrototype[DELETE] = MapPrototype.remove;
  MapPrototype.removeIn = MapPrototype.deleteIn;


  // #pragma Trie Nodes



    function ArrayMapNode(ownerID, entries) {
      this.ownerID = ownerID;
      this.entries = entries;
    }

    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      var entries = this.entries;
      for (var ii = 0, len = entries.length; ii < len; ii++) {
        if (is(key, entries[ii][0])) {
          return entries[ii][1];
        }
      }
      return notSetValue;
    };

    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      var removed = value === NOT_SET;

      var entries = this.entries;
      var idx = 0;
      for (var len = entries.length; idx < len; idx++) {
        if (is(key, entries[idx][0])) {
          break;
        }
      }
      var exists = idx < len;

      if (exists ? entries[idx][1] === value : removed) {
        return this;
      }

      SetRef(didAlter);
      (removed || !exists) && SetRef(didChangeSize);

      if (removed && entries.length === 1) {
        return; // undefined
      }

      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
        return createNodes(ownerID, entries, key, value);
      }

      var isEditable = ownerID && ownerID === this.ownerID;
      var newEntries = isEditable ? entries : arrCopy(entries);

      if (exists) {
        if (removed) {
          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
        } else {
          newEntries[idx] = [key, value];
        }
      } else {
        newEntries.push([key, value]);
      }

      if (isEditable) {
        this.entries = newEntries;
        return this;
      }

      return new ArrayMapNode(ownerID, newEntries);
    };




    function BitmapIndexedNode(ownerID, bitmap, nodes) {
      this.ownerID = ownerID;
      this.bitmap = bitmap;
      this.nodes = nodes;
    }

    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));
      var bitmap = this.bitmap;
      return (bitmap & bit) === 0 ? notSetValue :
        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);
    };

    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var bit = 1 << keyHashFrag;
      var bitmap = this.bitmap;
      var exists = (bitmap & bit) !== 0;

      if (!exists && value === NOT_SET) {
        return this;
      }

      var idx = popCount(bitmap & (bit - 1));
      var nodes = this.nodes;
      var node = exists ? nodes[idx] : undefined;
      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);

      if (newNode === node) {
        return this;
      }

      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
      }

      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
        return nodes[idx ^ 1];
      }

      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
        return newNode;
      }

      var isEditable = ownerID && ownerID === this.ownerID;
      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
      var newNodes = exists ? newNode ?
        setIn(nodes, idx, newNode, isEditable) :
        spliceOut(nodes, idx, isEditable) :
        spliceIn(nodes, idx, newNode, isEditable);

      if (isEditable) {
        this.bitmap = newBitmap;
        this.nodes = newNodes;
        return this;
      }

      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
    };




    function HashArrayMapNode(ownerID, count, nodes) {
      this.ownerID = ownerID;
      this.count = count;
      this.nodes = nodes;
    }

    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var node = this.nodes[idx];
      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
    };

    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var removed = value === NOT_SET;
      var nodes = this.nodes;
      var node = nodes[idx];

      if (removed && !node) {
        return this;
      }

      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
      if (newNode === node) {
        return this;
      }

      var newCount = this.count;
      if (!node) {
        newCount++;
      } else if (!newNode) {
        newCount--;
        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
          return packNodes(ownerID, nodes, newCount, idx);
        }
      }

      var isEditable = ownerID && ownerID === this.ownerID;
      var newNodes = setIn(nodes, idx, newNode, isEditable);

      if (isEditable) {
        this.count = newCount;
        this.nodes = newNodes;
        return this;
      }

      return new HashArrayMapNode(ownerID, newCount, newNodes);
    };




    function HashCollisionNode(ownerID, keyHash, entries) {
      this.ownerID = ownerID;
      this.keyHash = keyHash;
      this.entries = entries;
    }

    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      var entries = this.entries;
      for (var ii = 0, len = entries.length; ii < len; ii++) {
        if (is(key, entries[ii][0])) {
          return entries[ii][1];
        }
      }
      return notSetValue;
    };

    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }

      var removed = value === NOT_SET;

      if (keyHash !== this.keyHash) {
        if (removed) {
          return this;
        }
        SetRef(didAlter);
        SetRef(didChangeSize);
        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
      }

      var entries = this.entries;
      var idx = 0;
      for (var len = entries.length; idx < len; idx++) {
        if (is(key, entries[idx][0])) {
          break;
        }
      }
      var exists = idx < len;

      if (exists ? entries[idx][1] === value : removed) {
        return this;
      }

      SetRef(didAlter);
      (removed || !exists) && SetRef(didChangeSize);

      if (removed && len === 2) {
        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
      }

      var isEditable = ownerID && ownerID === this.ownerID;
      var newEntries = isEditable ? entries : arrCopy(entries);

      if (exists) {
        if (removed) {
          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
        } else {
          newEntries[idx] = [key, value];
        }
      } else {
        newEntries.push([key, value]);
      }

      if (isEditable) {
        this.entries = newEntries;
        return this;
      }

      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
    };




    function ValueNode(ownerID, keyHash, entry) {
      this.ownerID = ownerID;
      this.keyHash = keyHash;
      this.entry = entry;
    }

    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
    };

    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      var removed = value === NOT_SET;
      var keyMatch = is(key, this.entry[0]);
      if (keyMatch ? value === this.entry[1] : removed) {
        return this;
      }

      SetRef(didAlter);

      if (removed) {
        SetRef(didChangeSize);
        return; // undefined
      }

      if (keyMatch) {
        if (ownerID && ownerID === this.ownerID) {
          this.entry[1] = value;
          return this;
        }
        return new ValueNode(ownerID, this.keyHash, [key, value]);
      }

      SetRef(didChangeSize);
      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
    };



  // #pragma Iterators

  ArrayMapNode.prototype.iterate =
  HashCollisionNode.prototype.iterate = function (fn, reverse) {
    var entries = this.entries;
    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
        return false;
      }
    }
  }

  BitmapIndexedNode.prototype.iterate =
  HashArrayMapNode.prototype.iterate = function (fn, reverse) {
    var nodes = this.nodes;
    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
      var node = nodes[reverse ? maxIndex - ii : ii];
      if (node && node.iterate(fn, reverse) === false) {
        return false;
      }
    }
  }

  ValueNode.prototype.iterate = function (fn, reverse) {
    return fn(this.entry);
  }

  createClass(MapIterator, Iterator);

    function MapIterator(map, type, reverse) {
      this._type = type;
      this._reverse = reverse;
      this._stack = map._root && mapIteratorFrame(map._root);
    }

    MapIterator.prototype.next = function() {
      var type = this._type;
      var stack = this._stack;
      while (stack) {
        var node = stack.node;
        var index = stack.index++;
        var maxIndex;
        if (node.entry) {
          if (index === 0) {
            return mapIteratorValue(type, node.entry);
          }
        } else if (node.entries) {
          maxIndex = node.entries.length - 1;
          if (index <= maxIndex) {
            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
          }
        } else {
          maxIndex = node.nodes.length - 1;
          if (index <= maxIndex) {
            var subNode = node.nodes[this._reverse ? maxIndex - index : index];
            if (subNode) {
              if (subNode.entry) {
                return mapIteratorValue(type, subNode.entry);
              }
              stack = this._stack = mapIteratorFrame(subNode, stack);
            }
            continue;
          }
        }
        stack = this._stack = this._stack.__prev;
      }
      return iteratorDone();
    };


  function mapIteratorValue(type, entry) {
    return iteratorValue(type, entry[0], entry[1]);
  }

  function mapIteratorFrame(node, prev) {
    return {
      node: node,
      index: 0,
      __prev: prev
    };
  }

  function makeMap(size, root, ownerID, hash) {
    var map = Object.create(MapPrototype);
    map.size = size;
    map._root = root;
    map.__ownerID = ownerID;
    map.__hash = hash;
    map.__altered = false;
    return map;
  }

  var EMPTY_MAP;
  function emptyMap() {
    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
  }

  function updateMap(map, k, v) {
    var newRoot;
    var newSize;
    if (!map._root) {
      if (v === NOT_SET) {
        return map;
      }
      newSize = 1;
      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
    } else {
      var didChangeSize = MakeRef(CHANGE_LENGTH);
      var didAlter = MakeRef(DID_ALTER);
      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
      if (!didAlter.value) {
        return map;
      }
      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
    }
    if (map.__ownerID) {
      map.size = newSize;
      map._root = newRoot;
      map.__hash = undefined;
      map.__altered = true;
      return map;
    }
    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
  }

  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
    if (!node) {
      if (value === NOT_SET) {
        return node;
      }
      SetRef(didAlter);
      SetRef(didChangeSize);
      return new ValueNode(ownerID, keyHash, [key, value]);
    }
    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
  }

  function isLeafNode(node) {
    return node.constructor === ValueNode || node.constructor === HashCollisionNode;
  }

  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
    if (node.keyHash === keyHash) {
      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
    }

    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;

    var newNode;
    var nodes = idx1 === idx2 ?
      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :
      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);

    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
  }

  function createNodes(ownerID, entries, key, value) {
    if (!ownerID) {
      ownerID = new OwnerID();
    }
    var node = new ValueNode(ownerID, hash(key), [key, value]);
    for (var ii = 0; ii < entries.length; ii++) {
      var entry = entries[ii];
      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
    }
    return node;
  }

  function packNodes(ownerID, nodes, count, excluding) {
    var bitmap = 0;
    var packedII = 0;
    var packedNodes = new Array(count);
    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
      var node = nodes[ii];
      if (node !== undefined && ii !== excluding) {
        bitmap |= bit;
        packedNodes[packedII++] = node;
      }
    }
    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
  }

  function expandNodes(ownerID, nodes, bitmap, including, node) {
    var count = 0;
    var expandedNodes = new Array(SIZE);
    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
    }
    expandedNodes[including] = node;
    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
  }

  function mergeIntoMapWith(map, merger, iterables) {
    var iters = [];
    for (var ii = 0; ii < iterables.length; ii++) {
      var value = iterables[ii];
      var iter = KeyedIterable(value);
      if (!isIterable(value)) {
        iter = iter.map(function(v ) {return fromJS(v)});
      }
      iters.push(iter);
    }
    return mergeIntoCollectionWith(map, merger, iters);
  }

  function deepMerger(existing, value, key) {
    return existing && existing.mergeDeep && isIterable(value) ?
      existing.mergeDeep(value) :
      is(existing, value) ? existing : value;
  }

  function deepMergerWith(merger) {
    return function(existing, value, key)  {
      if (existing && existing.mergeDeepWith && isIterable(value)) {
        return existing.mergeDeepWith(merger, value);
      }
      var nextValue = merger(existing, value, key);
      return is(existing, nextValue) ? existing : nextValue;
    };
  }

  function mergeIntoCollectionWith(collection, merger, iters) {
    iters = iters.filter(function(x ) {return x.size !== 0});
    if (iters.length === 0) {
      return collection;
    }
    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
      return collection.constructor(iters[0]);
    }
    return collection.withMutations(function(collection ) {
      var mergeIntoMap = merger ?
        function(value, key)  {
          collection.update(key, NOT_SET, function(existing )
            {return existing === NOT_SET ? value : merger(existing, value, key)}
          );
        } :
        function(value, key)  {
          collection.set(key, value);
        }
      for (var ii = 0; ii < iters.length; ii++) {
        iters[ii].forEach(mergeIntoMap);
      }
    });
  }

  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
    var isNotSet = existing === NOT_SET;
    var step = keyPathIter.next();
    if (step.done) {
      var existingValue = isNotSet ? notSetValue : existing;
      var newValue = updater(existingValue);
      return newValue === existingValue ? existing : newValue;
    }
    invariant(
      isNotSet || (existing && existing.set),
      'invalid keyPath'
    );
    var key = step.value;
    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
    var nextUpdated = updateInDeepMap(
      nextExisting,
      keyPathIter,
      notSetValue,
      updater
    );
    return nextUpdated === nextExisting ? existing :
      nextUpdated === NOT_SET ? existing.remove(key) :
      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
  }

  function popCount(x) {
    x = x - ((x >> 1) & 0x55555555);
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
    x = (x + (x >> 4)) & 0x0f0f0f0f;
    x = x + (x >> 8);
    x = x + (x >> 16);
    return x & 0x7f;
  }

  function setIn(array, idx, val, canEdit) {
    var newArray = canEdit ? array : arrCopy(array);
    newArray[idx] = val;
    return newArray;
  }

  function spliceIn(array, idx, val, canEdit) {
    var newLen = array.length + 1;
    if (canEdit && idx + 1 === newLen) {
      array[idx] = val;
      return array;
    }
    var newArray = new Array(newLen);
    var after = 0;
    for (var ii = 0; ii < newLen; ii++) {
      if (ii === idx) {
        newArray[ii] = val;
        after = -1;
      } else {
        newArray[ii] = array[ii + after];
      }
    }
    return newArray;
  }

  function spliceOut(array, idx, canEdit) {
    var newLen = array.length - 1;
    if (canEdit && idx === newLen) {
      array.pop();
      return array;
    }
    var newArray = new Array(newLen);
    var after = 0;
    for (var ii = 0; ii < newLen; ii++) {
      if (ii === idx) {
        after = 1;
      }
      newArray[ii] = array[ii + after];
    }
    return newArray;
  }

  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;

  createClass(List, IndexedCollection);

    // @pragma Construction

    function List(value) {
      var empty = emptyList();
      if (value === null || value === undefined) {
        return empty;
      }
      if (isList(value)) {
        return value;
      }
      var iter = IndexedIterable(value);
      var size = iter.size;
      if (size === 0) {
        return empty;
      }
      assertNotInfinite(size);
      if (size > 0 && size < SIZE) {
        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
      }
      return empty.withMutations(function(list ) {
        list.setSize(size);
        iter.forEach(function(v, i)  {return list.set(i, v)});
      });
    }

    List.of = function(/*...values*/) {
      return this(arguments);
    };

    List.prototype.toString = function() {
      return this.__toString('List [', ']');
    };

    // @pragma Access

    List.prototype.get = function(index, notSetValue) {
      index = wrapIndex(this, index);
      if (index >= 0 && index < this.size) {
        index += this._origin;
        var node = listNodeFor(this, index);
        return node && node.array[index & MASK];
      }
      return notSetValue;
    };

    // @pragma Modification

    List.prototype.set = function(index, value) {
      return updateList(this, index, value);
    };

    List.prototype.remove = function(index) {
      return !this.has(index) ? this :
        index === 0 ? this.shift() :
        index === this.size - 1 ? this.pop() :
        this.splice(index, 1);
    };

    List.prototype.insert = function(index, value) {
      return this.splice(index, 0, value);
    };

    List.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = this._origin = this._capacity = 0;
        this._level = SHIFT;
        this._root = this._tail = null;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyList();
    };

    List.prototype.push = function(/*...values*/) {
      var values = arguments;
      var oldSize = this.size;
      return this.withMutations(function(list ) {
        setListBounds(list, 0, oldSize + values.length);
        for (var ii = 0; ii < values.length; ii++) {
          list.set(oldSize + ii, values[ii]);
        }
      });
    };

    List.prototype.pop = function() {
      return setListBounds(this, 0, -1);
    };

    List.prototype.unshift = function(/*...values*/) {
      var values = arguments;
      return this.withMutations(function(list ) {
        setListBounds(list, -values.length);
        for (var ii = 0; ii < values.length; ii++) {
          list.set(ii, values[ii]);
        }
      });
    };

    List.prototype.shift = function() {
      return setListBounds(this, 1);
    };

    // @pragma Composition

    List.prototype.merge = function(/*...iters*/) {
      return mergeIntoListWith(this, undefined, arguments);
    };

    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return mergeIntoListWith(this, merger, iters);
    };

    List.prototype.mergeDeep = function(/*...iters*/) {
      return mergeIntoListWith(this, deepMerger, arguments);
    };

    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return mergeIntoListWith(this, deepMergerWith(merger), iters);
    };

    List.prototype.setSize = function(size) {
      return setListBounds(this, 0, size);
    };

    // @pragma Iteration

    List.prototype.slice = function(begin, end) {
      var size = this.size;
      if (wholeSlice(begin, end, size)) {
        return this;
      }
      return setListBounds(
        this,
        resolveBegin(begin, size),
        resolveEnd(end, size)
      );
    };

    List.prototype.__iterator = function(type, reverse) {
      var index = 0;
      var values = iterateList(this, reverse);
      return new Iterator(function()  {
        var value = values();
        return value === DONE ?
          iteratorDone() :
          iteratorValue(type, index++, value);
      });
    };

    List.prototype.__iterate = function(fn, reverse) {
      var index = 0;
      var values = iterateList(this, reverse);
      var value;
      while ((value = values()) !== DONE) {
        if (fn(value, index++, this) === false) {
          break;
        }
      }
      return index;
    };

    List.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        return this;
      }
      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
    };


  function isList(maybeList) {
    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
  }

  List.isList = isList;

  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';

  var ListPrototype = List.prototype;
  ListPrototype[IS_LIST_SENTINEL] = true;
  ListPrototype[DELETE] = ListPrototype.remove;
  ListPrototype.setIn = MapPrototype.setIn;
  ListPrototype.deleteIn =
  ListPrototype.removeIn = MapPrototype.removeIn;
  ListPrototype.update = MapPrototype.update;
  ListPrototype.updateIn = MapPrototype.updateIn;
  ListPrototype.mergeIn = MapPrototype.mergeIn;
  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
  ListPrototype.withMutations = MapPrototype.withMutations;
  ListPrototype.asMutable = MapPrototype.asMutable;
  ListPrototype.asImmutable = MapPrototype.asImmutable;
  ListPrototype.wasAltered = MapPrototype.wasAltered;



    function VNode(array, ownerID) {
      this.array = array;
      this.ownerID = ownerID;
    }

    // TODO: seems like these methods are very similar

    VNode.prototype.removeBefore = function(ownerID, level, index) {
      if (index === level ? 1 << level : 0 || this.array.length === 0) {
        return this;
      }
      var originIndex = (index >>> level) & MASK;
      if (originIndex >= this.array.length) {
        return new VNode([], ownerID);
      }
      var removingFirst = originIndex === 0;
      var newChild;
      if (level > 0) {
        var oldChild = this.array[originIndex];
        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
        if (newChild === oldChild && removingFirst) {
          return this;
        }
      }
      if (removingFirst && !newChild) {
        return this;
      }
      var editable = editableVNode(this, ownerID);
      if (!removingFirst) {
        for (var ii = 0; ii < originIndex; ii++) {
          editable.array[ii] = undefined;
        }
      }
      if (newChild) {
        editable.array[originIndex] = newChild;
      }
      return editable;
    };

    VNode.prototype.removeAfter = function(ownerID, level, index) {
      if (index === (level ? 1 << level : 0) || this.array.length === 0) {
        return this;
      }
      var sizeIndex = ((index - 1) >>> level) & MASK;
      if (sizeIndex >= this.array.length) {
        return this;
      }

      var newChild;
      if (level > 0) {
        var oldChild = this.array[sizeIndex];
        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
          return this;
        }
      }

      var editable = editableVNode(this, ownerID);
      editable.array.splice(sizeIndex + 1);
      if (newChild) {
        editable.array[sizeIndex] = newChild;
      }
      return editable;
    };



  var DONE = {};

  function iterateList(list, reverse) {
    var left = list._origin;
    var right = list._capacity;
    var tailPos = getTailOffset(right);
    var tail = list._tail;

    return iterateNodeOrLeaf(list._root, list._level, 0);

    function iterateNodeOrLeaf(node, level, offset) {
      return level === 0 ?
        iterateLeaf(node, offset) :
        iterateNode(node, level, offset);
    }

    function iterateLeaf(node, offset) {
      var array = offset === tailPos ? tail && tail.array : node && node.array;
      var from = offset > left ? 0 : left - offset;
      var to = right - offset;
      if (to > SIZE) {
        to = SIZE;
      }
      return function()  {
        if (from === to) {
          return DONE;
        }
        var idx = reverse ? --to : from++;
        return array && array[idx];
      };
    }

    function iterateNode(node, level, offset) {
      var values;
      var array = node && node.array;
      var from = offset > left ? 0 : (left - offset) >> level;
      var to = ((right - offset) >> level) + 1;
      if (to > SIZE) {
        to = SIZE;
      }
      return function()  {
        do {
          if (values) {
            var value = values();
            if (value !== DONE) {
              return value;
            }
            values = null;
          }
          if (from === to) {
            return DONE;
          }
          var idx = reverse ? --to : from++;
          values = iterateNodeOrLeaf(
            array && array[idx], level - SHIFT, offset + (idx << level)
          );
        } while (true);
      };
    }
  }

  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
    var list = Object.create(ListPrototype);
    list.size = capacity - origin;
    list._origin = origin;
    list._capacity = capacity;
    list._level = level;
    list._root = root;
    list._tail = tail;
    list.__ownerID = ownerID;
    list.__hash = hash;
    list.__altered = false;
    return list;
  }

  var EMPTY_LIST;
  function emptyList() {
    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
  }

  function updateList(list, index, value) {
    index = wrapIndex(list, index);

    if (index !== index) {
      return list;
    }

    if (index >= list.size || index < 0) {
      return list.withMutations(function(list ) {
        index < 0 ?
          setListBounds(list, index).set(0, value) :
          setListBounds(list, 0, index + 1).set(index, value)
      });
    }

    index += list._origin;

    var newTail = list._tail;
    var newRoot = list._root;
    var didAlter = MakeRef(DID_ALTER);
    if (index >= getTailOffset(list._capacity)) {
      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
    } else {
      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
    }

    if (!didAlter.value) {
      return list;
    }

    if (list.__ownerID) {
      list._root = newRoot;
      list._tail = newTail;
      list.__hash = undefined;
      list.__altered = true;
      return list;
    }
    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
  }

  function updateVNode(node, ownerID, level, index, value, didAlter) {
    var idx = (index >>> level) & MASK;
    var nodeHas = node && idx < node.array.length;
    if (!nodeHas && value === undefined) {
      return node;
    }

    var newNode;

    if (level > 0) {
      var lowerNode = node && node.array[idx];
      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
      if (newLowerNode === lowerNode) {
        return node;
      }
      newNode = editableVNode(node, ownerID);
      newNode.array[idx] = newLowerNode;
      return newNode;
    }

    if (nodeHas && node.array[idx] === value) {
      return node;
    }

    SetRef(didAlter);

    newNode = editableVNode(node, ownerID);
    if (value === undefined && idx === newNode.array.length - 1) {
      newNode.array.pop();
    } else {
      newNode.array[idx] = value;
    }
    return newNode;
  }

  function editableVNode(node, ownerID) {
    if (ownerID && node && ownerID === node.ownerID) {
      return node;
    }
    return new VNode(node ? node.array.slice() : [], ownerID);
  }

  function listNodeFor(list, rawIndex) {
    if (rawIndex >= getTailOffset(list._capacity)) {
      return list._tail;
    }
    if (rawIndex < 1 << (list._level + SHIFT)) {
      var node = list._root;
      var level = list._level;
      while (node && level > 0) {
        node = node.array[(rawIndex >>> level) & MASK];
        level -= SHIFT;
      }
      return node;
    }
  }

  function setListBounds(list, begin, end) {
    // Sanitize begin & end using this shorthand for ToInt32(argument)
    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
    if (begin !== undefined) {
      begin = begin | 0;
    }
    if (end !== undefined) {
      end = end | 0;
    }
    var owner = list.__ownerID || new OwnerID();
    var oldOrigin = list._origin;
    var oldCapacity = list._capacity;
    var newOrigin = oldOrigin + begin;
    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
      return list;
    }

    // If it's going to end after it starts, it's empty.
    if (newOrigin >= newCapacity) {
      return list.clear();
    }

    var newLevel = list._level;
    var newRoot = list._root;

    // New origin might need creating a higher root.
    var offsetShift = 0;
    while (newOrigin + offsetShift < 0) {
      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
      newLevel += SHIFT;
      offsetShift += 1 << newLevel;
    }
    if (offsetShift) {
      newOrigin += offsetShift;
      oldOrigin += offsetShift;
      newCapacity += offsetShift;
      oldCapacity += offsetShift;
    }

    var oldTailOffset = getTailOffset(oldCapacity);
    var newTailOffset = getTailOffset(newCapacity);

    // New size might need creating a higher root.
    while (newTailOffset >= 1 << (newLevel + SHIFT)) {
      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
      newLevel += SHIFT;
    }

    // Locate or create the new tail.
    var oldTail = list._tail;
    var newTail = newTailOffset < oldTailOffset ?
      listNodeFor(list, newCapacity - 1) :
      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;

    // Merge Tail into tree.
    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
      newRoot = editableVNode(newRoot, owner);
      var node = newRoot;
      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
        var idx = (oldTailOffset >>> level) & MASK;
        node = node.array[idx] = editableVNode(node.array[idx], owner);
      }
      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
    }

    // If the size has been reduced, there's a chance the tail needs to be trimmed.
    if (newCapacity < oldCapacity) {
      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
    }

    // If the new origin is within the tail, then we do not need a root.
    if (newOrigin >= newTailOffset) {
      newOrigin -= newTailOffset;
      newCapacity -= newTailOffset;
      newLevel = SHIFT;
      newRoot = null;
      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);

    // Otherwise, if the root has been trimmed, garbage collect.
    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
      offsetShift = 0;

      // Identify the new top root node of the subtree of the old root.
      while (newRoot) {
        var beginIndex = (newOrigin >>> newLevel) & MASK;
        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {
          break;
        }
        if (beginIndex) {
          offsetShift += (1 << newLevel) * beginIndex;
        }
        newLevel -= SHIFT;
        newRoot = newRoot.array[beginIndex];
      }

      // Trim the new sides of the new root.
      if (newRoot && newOrigin > oldOrigin) {
        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
      }
      if (newRoot && newTailOffset < oldTailOffset) {
        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
      }
      if (offsetShift) {
        newOrigin -= offsetShift;
        newCapacity -= offsetShift;
      }
    }

    if (list.__ownerID) {
      list.size = newCapacity - newOrigin;
      list._origin = newOrigin;
      list._capacity = newCapacity;
      list._level = newLevel;
      list._root = newRoot;
      list._tail = newTail;
      list.__hash = undefined;
      list.__altered = true;
      return list;
    }
    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
  }

  function mergeIntoListWith(list, merger, iterables) {
    var iters = [];
    var maxSize = 0;
    for (var ii = 0; ii < iterables.length; ii++) {
      var value = iterables[ii];
      var iter = IndexedIterable(value);
      if (iter.size > maxSize) {
        maxSize = iter.size;
      }
      if (!isIterable(value)) {
        iter = iter.map(function(v ) {return fromJS(v)});
      }
      iters.push(iter);
    }
    if (maxSize > list.size) {
      list = list.setSize(maxSize);
    }
    return mergeIntoCollectionWith(list, merger, iters);
  }

  function getTailOffset(size) {
    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);
  }

  createClass(OrderedMap, Map);

    // @pragma Construction

    function OrderedMap(value) {
      return value === null || value === undefined ? emptyOrderedMap() :
        isOrderedMap(value) ? value :
        emptyOrderedMap().withMutations(function(map ) {
          var iter = KeyedIterable(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v, k)  {return map.set(k, v)});
        });
    }

    OrderedMap.of = function(/*...values*/) {
      return this(arguments);
    };

    OrderedMap.prototype.toString = function() {
      return this.__toString('OrderedMap {', '}');
    };

    // @pragma Access

    OrderedMap.prototype.get = function(k, notSetValue) {
      var index = this._map.get(k);
      return index !== undefined ? this._list.get(index)[1] : notSetValue;
    };

    // @pragma Modification

    OrderedMap.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._map.clear();
        this._list.clear();
        return this;
      }
      return emptyOrderedMap();
    };

    OrderedMap.prototype.set = function(k, v) {
      return updateOrderedMap(this, k, v);
    };

    OrderedMap.prototype.remove = function(k) {
      return updateOrderedMap(this, k, NOT_SET);
    };

    OrderedMap.prototype.wasAltered = function() {
      return this._map.wasAltered() || this._list.wasAltered();
    };

    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return this._list.__iterate(
        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},
        reverse
      );
    };

    OrderedMap.prototype.__iterator = function(type, reverse) {
      return this._list.fromEntrySeq().__iterator(type, reverse);
    };

    OrderedMap.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map.__ensureOwner(ownerID);
      var newList = this._list.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        this._list = newList;
        return this;
      }
      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
    };


  function isOrderedMap(maybeOrderedMap) {
    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
  }

  OrderedMap.isOrderedMap = isOrderedMap;

  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;



  function makeOrderedMap(map, list, ownerID, hash) {
    var omap = Object.create(OrderedMap.prototype);
    omap.size = map ? map.size : 0;
    omap._map = map;
    omap._list = list;
    omap.__ownerID = ownerID;
    omap.__hash = hash;
    return omap;
  }

  var EMPTY_ORDERED_MAP;
  function emptyOrderedMap() {
    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
  }

  function updateOrderedMap(omap, k, v) {
    var map = omap._map;
    var list = omap._list;
    var i = map.get(k);
    var has = i !== undefined;
    var newMap;
    var newList;
    if (v === NOT_SET) { // removed
      if (!has) {
        return omap;
      }
      if (list.size >= SIZE && list.size >= map.size * 2) {
        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});
        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();
        if (omap.__ownerID) {
          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
        }
      } else {
        newMap = map.remove(k);
        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
      }
    } else {
      if (has) {
        if (v === list.get(i)[1]) {
          return omap;
        }
        newMap = map;
        newList = list.set(i, [k, v]);
      } else {
        newMap = map.set(k, list.size);
        newList = list.set(list.size, [k, v]);
      }
    }
    if (omap.__ownerID) {
      omap.size = newMap.size;
      omap._map = newMap;
      omap._list = newList;
      omap.__hash = undefined;
      return omap;
    }
    return makeOrderedMap(newMap, newList);
  }

  createClass(ToKeyedSequence, KeyedSeq);
    function ToKeyedSequence(indexed, useKeys) {
      this._iter = indexed;
      this._useKeys = useKeys;
      this.size = indexed.size;
    }

    ToKeyedSequence.prototype.get = function(key, notSetValue) {
      return this._iter.get(key, notSetValue);
    };

    ToKeyedSequence.prototype.has = function(key) {
      return this._iter.has(key);
    };

    ToKeyedSequence.prototype.valueSeq = function() {
      return this._iter.valueSeq();
    };

    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;
      var reversedSequence = reverseFactory(this, true);
      if (!this._useKeys) {
        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};
      }
      return reversedSequence;
    };

    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;
      var mappedSequence = mapFactory(this, mapper, context);
      if (!this._useKeys) {
        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};
      }
      return mappedSequence;
    };

    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      var ii;
      return this._iter.__iterate(
        this._useKeys ?
          function(v, k)  {return fn(v, k, this$0)} :
          ((ii = reverse ? resolveSize(this) : 0),
            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),
        reverse
      );
    };

    ToKeyedSequence.prototype.__iterator = function(type, reverse) {
      if (this._useKeys) {
        return this._iter.__iterator(type, reverse);
      }
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      var ii = reverse ? resolveSize(this) : 0;
      return new Iterator(function()  {
        var step = iterator.next();
        return step.done ? step :
          iteratorValue(type, reverse ? --ii : ii++, step.value, step);
      });
    };

  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;


  createClass(ToIndexedSequence, IndexedSeq);
    function ToIndexedSequence(iter) {
      this._iter = iter;
      this.size = iter.size;
    }

    ToIndexedSequence.prototype.includes = function(value) {
      return this._iter.includes(value);
    };

    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      var iterations = 0;
      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);
    };

    ToIndexedSequence.prototype.__iterator = function(type, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      var iterations = 0;
      return new Iterator(function()  {
        var step = iterator.next();
        return step.done ? step :
          iteratorValue(type, iterations++, step.value, step)
      });
    };



  createClass(ToSetSequence, SetSeq);
    function ToSetSequence(iter) {
      this._iter = iter;
      this.size = iter.size;
    }

    ToSetSequence.prototype.has = function(key) {
      return this._iter.includes(key);
    };

    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);
    };

    ToSetSequence.prototype.__iterator = function(type, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      return new Iterator(function()  {
        var step = iterator.next();
        return step.done ? step :
          iteratorValue(type, step.value, step.value, step);
      });
    };



  createClass(FromEntriesSequence, KeyedSeq);
    function FromEntriesSequence(entries) {
      this._iter = entries;
      this.size = entries.size;
    }

    FromEntriesSequence.prototype.entrySeq = function() {
      return this._iter.toSeq();
    };

    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return this._iter.__iterate(function(entry ) {
        // Check if entry exists first so array access doesn't throw for holes
        // in the parent iteration.
        if (entry) {
          validateEntry(entry);
          var indexedIterable = isIterable(entry);
          return fn(
            indexedIterable ? entry.get(1) : entry[1],
            indexedIterable ? entry.get(0) : entry[0],
            this$0
          );
        }
      }, reverse);
    };

    FromEntriesSequence.prototype.__iterator = function(type, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      return new Iterator(function()  {
        while (true) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          // Check if entry exists first so array access doesn't throw for holes
          // in the parent iteration.
          if (entry) {
            validateEntry(entry);
            var indexedIterable = isIterable(entry);
            return iteratorValue(
              type,
              indexedIterable ? entry.get(0) : entry[0],
              indexedIterable ? entry.get(1) : entry[1],
              step
            );
          }
        }
      });
    };


  ToIndexedSequence.prototype.cacheResult =
  ToKeyedSequence.prototype.cacheResult =
  ToSetSequence.prototype.cacheResult =
  FromEntriesSequence.prototype.cacheResult =
    cacheResultThrough;


  function flipFactory(iterable) {
    var flipSequence = makeSequence(iterable);
    flipSequence._iter = iterable;
    flipSequence.size = iterable.size;
    flipSequence.flip = function()  {return iterable};
    flipSequence.reverse = function () {
      var reversedSequence = iterable.reverse.apply(this); // super.reverse()
      reversedSequence.flip = function()  {return iterable.reverse()};
      return reversedSequence;
    };
    flipSequence.has = function(key ) {return iterable.includes(key)};
    flipSequence.includes = function(key ) {return iterable.has(key)};
    flipSequence.cacheResult = cacheResultThrough;
    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);
    }
    flipSequence.__iteratorUncached = function(type, reverse) {
      if (type === ITERATE_ENTRIES) {
        var iterator = iterable.__iterator(type, reverse);
        return new Iterator(function()  {
          var step = iterator.next();
          if (!step.done) {
            var k = step.value[0];
            step.value[0] = step.value[1];
            step.value[1] = k;
          }
          return step;
        });
      }
      return iterable.__iterator(
        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
        reverse
      );
    }
    return flipSequence;
  }


  function mapFactory(iterable, mapper, context) {
    var mappedSequence = makeSequence(iterable);
    mappedSequence.size = iterable.size;
    mappedSequence.has = function(key ) {return iterable.has(key)};
    mappedSequence.get = function(key, notSetValue)  {
      var v = iterable.get(key, NOT_SET);
      return v === NOT_SET ?
        notSetValue :
        mapper.call(context, v, key, iterable);
    };
    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
      return iterable.__iterate(
        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},
        reverse
      );
    }
    mappedSequence.__iteratorUncached = function (type, reverse) {
      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
      return new Iterator(function()  {
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        var key = entry[0];
        return iteratorValue(
          type,
          key,
          mapper.call(context, entry[1], key, iterable),
          step
        );
      });
    }
    return mappedSequence;
  }


  function reverseFactory(iterable, useKeys) {
    var reversedSequence = makeSequence(iterable);
    reversedSequence._iter = iterable;
    reversedSequence.size = iterable.size;
    reversedSequence.reverse = function()  {return iterable};
    if (iterable.flip) {
      reversedSequence.flip = function () {
        var flipSequence = flipFactory(iterable);
        flipSequence.reverse = function()  {return iterable.flip()};
        return flipSequence;
      };
    }
    reversedSequence.get = function(key, notSetValue) 
      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};
    reversedSequence.has = function(key )
      {return iterable.has(useKeys ? key : -1 - key)};
    reversedSequence.includes = function(value ) {return iterable.includes(value)};
    reversedSequence.cacheResult = cacheResultThrough;
    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;
      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);
    };
    reversedSequence.__iterator =
      function(type, reverse)  {return iterable.__iterator(type, !reverse)};
    return reversedSequence;
  }


  function filterFactory(iterable, predicate, context, useKeys) {
    var filterSequence = makeSequence(iterable);
    if (useKeys) {
      filterSequence.has = function(key ) {
        var v = iterable.get(key, NOT_SET);
        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
      };
      filterSequence.get = function(key, notSetValue)  {
        var v = iterable.get(key, NOT_SET);
        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?
          v : notSetValue;
      };
    }
    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
      var iterations = 0;
      iterable.__iterate(function(v, k, c)  {
        if (predicate.call(context, v, k, c)) {
          iterations++;
          return fn(v, useKeys ? k : iterations - 1, this$0);
        }
      }, reverse);
      return iterations;
    };
    filterSequence.__iteratorUncached = function (type, reverse) {
      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
      var iterations = 0;
      return new Iterator(function()  {
        while (true) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          var key = entry[0];
          var value = entry[1];
          if (predicate.call(context, value, key, iterable)) {
            return iteratorValue(type, useKeys ? key : iterations++, value, step);
          }
        }
      });
    }
    return filterSequence;
  }


  function countByFactory(iterable, grouper, context) {
    var groups = Map().asMutable();
    iterable.__iterate(function(v, k)  {
      groups.update(
        grouper.call(context, v, k, iterable),
        0,
        function(a ) {return a + 1}
      );
    });
    return groups.asImmutable();
  }


  function groupByFactory(iterable, grouper, context) {
    var isKeyedIter = isKeyed(iterable);
    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();
    iterable.__iterate(function(v, k)  {
      groups.update(
        grouper.call(context, v, k, iterable),
        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}
      );
    });
    var coerce = iterableClass(iterable);
    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});
  }


  function sliceFactory(iterable, begin, end, useKeys) {
    var originalSize = iterable.size;

    // Sanitize begin & end using this shorthand for ToInt32(argument)
    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
    if (begin !== undefined) {
      begin = begin | 0;
    }
    if (end !== undefined) {
      if (end === Infinity) {
        end = originalSize;
      } else {
        end = end | 0;
      }
    }

    if (wholeSlice(begin, end, originalSize)) {
      return iterable;
    }

    var resolvedBegin = resolveBegin(begin, originalSize);
    var resolvedEnd = resolveEnd(end, originalSize);

    // begin or end will be NaN if they were provided as negative numbers and
    // this iterable's size is unknown. In that case, cache first so there is
    // a known size and these do not resolve to NaN.
    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
    }

    // Note: resolvedEnd is undefined when the original sequence's length is
    // unknown and this slice did not supply an end and should contain all
    // elements after resolvedBegin.
    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
    var resolvedSize = resolvedEnd - resolvedBegin;
    var sliceSize;
    if (resolvedSize === resolvedSize) {
      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
    }

    var sliceSeq = makeSequence(iterable);

    // If iterable.size is undefined, the size of the realized sliceSeq is
    // unknown at this point unless the number of items to slice is 0
    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;

    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
      sliceSeq.get = function (index, notSetValue) {
        index = wrapIndex(this, index);
        return index >= 0 && index < sliceSize ?
          iterable.get(index + resolvedBegin, notSetValue) :
          notSetValue;
      }
    }

    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;
      if (sliceSize === 0) {
        return 0;
      }
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var skipped = 0;
      var isSkipping = true;
      var iterations = 0;
      iterable.__iterate(function(v, k)  {
        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
          iterations++;
          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&
                 iterations !== sliceSize;
        }
      });
      return iterations;
    };

    sliceSeq.__iteratorUncached = function(type, reverse) {
      if (sliceSize !== 0 && reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      // Don't bother instantiating parent iterator if taking 0.
      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
      var skipped = 0;
      var iterations = 0;
      return new Iterator(function()  {
        while (skipped++ < resolvedBegin) {
          iterator.next();
        }
        if (++iterations > sliceSize) {
          return iteratorDone();
        }
        var step = iterator.next();
        if (useKeys || type === ITERATE_VALUES) {
          return step;
        } else if (type === ITERATE_KEYS) {
          return iteratorValue(type, iterations - 1, undefined, step);
        } else {
          return iteratorValue(type, iterations - 1, step.value[1], step);
        }
      });
    }

    return sliceSeq;
  }


  function takeWhileFactory(iterable, predicate, context) {
    var takeSequence = makeSequence(iterable);
    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var iterations = 0;
      iterable.__iterate(function(v, k, c) 
        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}
      );
      return iterations;
    };
    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
      var iterating = true;
      return new Iterator(function()  {
        if (!iterating) {
          return iteratorDone();
        }
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        var k = entry[0];
        var v = entry[1];
        if (!predicate.call(context, v, k, this$0)) {
          iterating = false;
          return iteratorDone();
        }
        return type === ITERATE_ENTRIES ? step :
          iteratorValue(type, k, v, step);
      });
    };
    return takeSequence;
  }


  function skipWhileFactory(iterable, predicate, context, useKeys) {
    var skipSequence = makeSequence(iterable);
    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var isSkipping = true;
      var iterations = 0;
      iterable.__iterate(function(v, k, c)  {
        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
          iterations++;
          return fn(v, useKeys ? k : iterations - 1, this$0);
        }
      });
      return iterations;
    };
    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
      var skipping = true;
      var iterations = 0;
      return new Iterator(function()  {
        var step, k, v;
        do {
          step = iterator.next();
          if (step.done) {
            if (useKeys || type === ITERATE_VALUES) {
              return step;
            } else if (type === ITERATE_KEYS) {
              return iteratorValue(type, iterations++, undefined, step);
            } else {
              return iteratorValue(type, iterations++, step.value[1], step);
            }
          }
          var entry = step.value;
          k = entry[0];
          v = entry[1];
          skipping && (skipping = predicate.call(context, v, k, this$0));
        } while (skipping);
        return type === ITERATE_ENTRIES ? step :
          iteratorValue(type, k, v, step);
      });
    };
    return skipSequence;
  }


  function concatFactory(iterable, values) {
    var isKeyedIterable = isKeyed(iterable);
    var iters = [iterable].concat(values).map(function(v ) {
      if (!isIterable(v)) {
        v = isKeyedIterable ?
          keyedSeqFromValue(v) :
          indexedSeqFromValue(Array.isArray(v) ? v : [v]);
      } else if (isKeyedIterable) {
        v = KeyedIterable(v);
      }
      return v;
    }).filter(function(v ) {return v.size !== 0});

    if (iters.length === 0) {
      return iterable;
    }

    if (iters.length === 1) {
      var singleton = iters[0];
      if (singleton === iterable ||
          isKeyedIterable && isKeyed(singleton) ||
          isIndexed(iterable) && isIndexed(singleton)) {
        return singleton;
      }
    }

    var concatSeq = new ArraySeq(iters);
    if (isKeyedIterable) {
      concatSeq = concatSeq.toKeyedSeq();
    } else if (!isIndexed(iterable)) {
      concatSeq = concatSeq.toSetSeq();
    }
    concatSeq = concatSeq.flatten(true);
    concatSeq.size = iters.reduce(
      function(sum, seq)  {
        if (sum !== undefined) {
          var size = seq.size;
          if (size !== undefined) {
            return sum + size;
          }
        }
      },
      0
    );
    return concatSeq;
  }


  function flattenFactory(iterable, depth, useKeys) {
    var flatSequence = makeSequence(iterable);
    flatSequence.__iterateUncached = function(fn, reverse) {
      var iterations = 0;
      var stopped = false;
      function flatDeep(iter, currentDepth) {var this$0 = this;
        iter.__iterate(function(v, k)  {
          if ((!depth || currentDepth < depth) && isIterable(v)) {
            flatDeep(v, currentDepth + 1);
          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
            stopped = true;
          }
          return !stopped;
        }, reverse);
      }
      flatDeep(iterable, 0);
      return iterations;
    }
    flatSequence.__iteratorUncached = function(type, reverse) {
      var iterator = iterable.__iterator(type, reverse);
      var stack = [];
      var iterations = 0;
      return new Iterator(function()  {
        while (iterator) {
          var step = iterator.next();
          if (step.done !== false) {
            iterator = stack.pop();
            continue;
          }
          var v = step.value;
          if (type === ITERATE_ENTRIES) {
            v = v[1];
          }
          if ((!depth || stack.length < depth) && isIterable(v)) {
            stack.push(iterator);
            iterator = v.__iterator(type, reverse);
          } else {
            return useKeys ? step : iteratorValue(type, iterations++, v, step);
          }
        }
        return iteratorDone();
      });
    }
    return flatSequence;
  }


  function flatMapFactory(iterable, mapper, context) {
    var coerce = iterableClass(iterable);
    return iterable.toSeq().map(
      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}
    ).flatten(true);
  }


  function interposeFactory(iterable, separator) {
    var interposedSequence = makeSequence(iterable);
    interposedSequence.size = iterable.size && iterable.size * 2 -1;
    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
      var iterations = 0;
      iterable.__iterate(function(v, k) 
        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&
        fn(v, iterations++, this$0) !== false},
        reverse
      );
      return iterations;
    };
    interposedSequence.__iteratorUncached = function(type, reverse) {
      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
      var iterations = 0;
      var step;
      return new Iterator(function()  {
        if (!step || iterations % 2) {
          step = iterator.next();
          if (step.done) {
            return step;
          }
        }
        return iterations % 2 ?
          iteratorValue(type, iterations++, separator) :
          iteratorValue(type, iterations++, step.value, step);
      });
    };
    return interposedSequence;
  }


  function sortFactory(iterable, comparator, mapper) {
    if (!comparator) {
      comparator = defaultComparator;
    }
    var isKeyedIterable = isKeyed(iterable);
    var index = 0;
    var entries = iterable.toSeq().map(
      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}
    ).toArray();
    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(
      isKeyedIterable ?
      function(v, i)  { entries[i].length = 2; } :
      function(v, i)  { entries[i] = v[1]; }
    );
    return isKeyedIterable ? KeyedSeq(entries) :
      isIndexed(iterable) ? IndexedSeq(entries) :
      SetSeq(entries);
  }


  function maxFactory(iterable, comparator, mapper) {
    if (!comparator) {
      comparator = defaultComparator;
    }
    if (mapper) {
      var entry = iterable.toSeq()
        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})
        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});
      return entry && entry[0];
    } else {
      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});
    }
  }

  function maxCompare(comparator, a, b) {
    var comp = comparator(b, a);
    // b is considered the new max if the comparator declares them equal, but
    // they are not equal and b is in fact a nullish value.
    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;
  }


  function zipWithFactory(keyIter, zipper, iters) {
    var zipSequence = makeSequence(keyIter);
    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();
    // Note: this a generic base implementation of __iterate in terms of
    // __iterator which may be more generically useful in the future.
    zipSequence.__iterate = function(fn, reverse) {
      /* generic:
      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
      var step;
      var iterations = 0;
      while (!(step = iterator.next()).done) {
        iterations++;
        if (fn(step.value[1], step.value[0], this) === false) {
          break;
        }
      }
      return iterations;
      */
      // indexed:
      var iterator = this.__iterator(ITERATE_VALUES, reverse);
      var step;
      var iterations = 0;
      while (!(step = iterator.next()).done) {
        if (fn(step.value, iterations++, this) === false) {
          break;
        }
      }
      return iterations;
    };
    zipSequence.__iteratorUncached = function(type, reverse) {
      var iterators = iters.map(function(i )
        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}
      );
      var iterations = 0;
      var isDone = false;
      return new Iterator(function()  {
        var steps;
        if (!isDone) {
          steps = iterators.map(function(i ) {return i.next()});
          isDone = steps.some(function(s ) {return s.done});
        }
        if (isDone) {
          return iteratorDone();
        }
        return iteratorValue(
          type,
          iterations++,
          zipper.apply(null, steps.map(function(s ) {return s.value}))
        );
      });
    };
    return zipSequence
  }


  // #pragma Helper Functions

  function reify(iter, seq) {
    return isSeq(iter) ? seq : iter.constructor(seq);
  }

  function validateEntry(entry) {
    if (entry !== Object(entry)) {
      throw new TypeError('Expected [K, V] tuple: ' + entry);
    }
  }

  function resolveSize(iter) {
    assertNotInfinite(iter.size);
    return ensureSize(iter);
  }

  function iterableClass(iterable) {
    return isKeyed(iterable) ? KeyedIterable :
      isIndexed(iterable) ? IndexedIterable :
      SetIterable;
  }

  function makeSequence(iterable) {
    return Object.create(
      (
        isKeyed(iterable) ? KeyedSeq :
        isIndexed(iterable) ? IndexedSeq :
        SetSeq
      ).prototype
    );
  }

  function cacheResultThrough() {
    if (this._iter.cacheResult) {
      this._iter.cacheResult();
      this.size = this._iter.size;
      return this;
    } else {
      return Seq.prototype.cacheResult.call(this);
    }
  }

  function defaultComparator(a, b) {
    return a > b ? 1 : a < b ? -1 : 0;
  }

  function forceIterator(keyPath) {
    var iter = getIterator(keyPath);
    if (!iter) {
      // Array might not be iterable in this environment, so we need a fallback
      // to our wrapped type.
      if (!isArrayLike(keyPath)) {
        throw new TypeError('Expected iterable or array-like: ' + keyPath);
      }
      iter = getIterator(Iterable(keyPath));
    }
    return iter;
  }

  createClass(Record, KeyedCollection);

    function Record(defaultValues, name) {
      var hasInitialized;

      var RecordType = function Record(values) {
        if (values instanceof RecordType) {
          return values;
        }
        if (!(this instanceof RecordType)) {
          return new RecordType(values);
        }
        if (!hasInitialized) {
          hasInitialized = true;
          var keys = Object.keys(defaultValues);
          setProps(RecordTypePrototype, keys);
          RecordTypePrototype.size = keys.length;
          RecordTypePrototype._name = name;
          RecordTypePrototype._keys = keys;
          RecordTypePrototype._defaultValues = defaultValues;
        }
        this._map = Map(values);
      };

      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
      RecordTypePrototype.constructor = RecordType;

      return RecordType;
    }

    Record.prototype.toString = function() {
      return this.__toString(recordName(this) + ' {', '}');
    };

    // @pragma Access

    Record.prototype.has = function(k) {
      return this._defaultValues.hasOwnProperty(k);
    };

    Record.prototype.get = function(k, notSetValue) {
      if (!this.has(k)) {
        return notSetValue;
      }
      var defaultVal = this._defaultValues[k];
      return this._map ? this._map.get(k, defaultVal) : defaultVal;
    };

    // @pragma Modification

    Record.prototype.clear = function() {
      if (this.__ownerID) {
        this._map && this._map.clear();
        return this;
      }
      var RecordType = this.constructor;
      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
    };

    Record.prototype.set = function(k, v) {
      if (!this.has(k)) {
        throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
      }
      if (this._map && !this._map.has(k)) {
        var defaultVal = this._defaultValues[k];
        if (v === defaultVal) {
          return this;
        }
      }
      var newMap = this._map && this._map.set(k, v);
      if (this.__ownerID || newMap === this._map) {
        return this;
      }
      return makeRecord(this, newMap);
    };

    Record.prototype.remove = function(k) {
      if (!this.has(k)) {
        return this;
      }
      var newMap = this._map && this._map.remove(k);
      if (this.__ownerID || newMap === this._map) {
        return this;
      }
      return makeRecord(this, newMap);
    };

    Record.prototype.wasAltered = function() {
      return this._map.wasAltered();
    };

    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;
      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);
    };

    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);
    };

    Record.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map && this._map.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        return this;
      }
      return makeRecord(this, newMap, ownerID);
    };


  var RecordPrototype = Record.prototype;
  RecordPrototype[DELETE] = RecordPrototype.remove;
  RecordPrototype.deleteIn =
  RecordPrototype.removeIn = MapPrototype.removeIn;
  RecordPrototype.merge = MapPrototype.merge;
  RecordPrototype.mergeWith = MapPrototype.mergeWith;
  RecordPrototype.mergeIn = MapPrototype.mergeIn;
  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
  RecordPrototype.setIn = MapPrototype.setIn;
  RecordPrototype.update = MapPrototype.update;
  RecordPrototype.updateIn = MapPrototype.updateIn;
  RecordPrototype.withMutations = MapPrototype.withMutations;
  RecordPrototype.asMutable = MapPrototype.asMutable;
  RecordPrototype.asImmutable = MapPrototype.asImmutable;


  function makeRecord(likeRecord, map, ownerID) {
    var record = Object.create(Object.getPrototypeOf(likeRecord));
    record._map = map;
    record.__ownerID = ownerID;
    return record;
  }

  function recordName(record) {
    return record._name || record.constructor.name || 'Record';
  }

  function setProps(prototype, names) {
    try {
      names.forEach(setProp.bind(undefined, prototype));
    } catch (error) {
      // Object.defineProperty failed. Probably IE8.
    }
  }

  function setProp(prototype, name) {
    Object.defineProperty(prototype, name, {
      get: function() {
        return this.get(name);
      },
      set: function(value) {
        invariant(this.__ownerID, 'Cannot set on an immutable record.');
        this.set(name, value);
      }
    });
  }

  createClass(Set, SetCollection);

    // @pragma Construction

    function Set(value) {
      return value === null || value === undefined ? emptySet() :
        isSet(value) && !isOrdered(value) ? value :
        emptySet().withMutations(function(set ) {
          var iter = SetIterable(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v ) {return set.add(v)});
        });
    }

    Set.of = function(/*...values*/) {
      return this(arguments);
    };

    Set.fromKeys = function(value) {
      return this(KeyedIterable(value).keySeq());
    };

    Set.prototype.toString = function() {
      return this.__toString('Set {', '}');
    };

    // @pragma Access

    Set.prototype.has = function(value) {
      return this._map.has(value);
    };

    // @pragma Modification

    Set.prototype.add = function(value) {
      return updateSet(this, this._map.set(value, true));
    };

    Set.prototype.remove = function(value) {
      return updateSet(this, this._map.remove(value));
    };

    Set.prototype.clear = function() {
      return updateSet(this, this._map.clear());
    };

    // @pragma Composition

    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);
      iters = iters.filter(function(x ) {return x.size !== 0});
      if (iters.length === 0) {
        return this;
      }
      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
        return this.constructor(iters[0]);
      }
      return this.withMutations(function(set ) {
        for (var ii = 0; ii < iters.length; ii++) {
          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});
        }
      });
    };

    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);
      if (iters.length === 0) {
        return this;
      }
      iters = iters.map(function(iter ) {return SetIterable(iter)});
      var originalSet = this;
      return this.withMutations(function(set ) {
        originalSet.forEach(function(value ) {
          if (!iters.every(function(iter ) {return iter.includes(value)})) {
            set.remove(value);
          }
        });
      });
    };

    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);
      if (iters.length === 0) {
        return this;
      }
      iters = iters.map(function(iter ) {return SetIterable(iter)});
      var originalSet = this;
      return this.withMutations(function(set ) {
        originalSet.forEach(function(value ) {
          if (iters.some(function(iter ) {return iter.includes(value)})) {
            set.remove(value);
          }
        });
      });
    };

    Set.prototype.merge = function() {
      return this.union.apply(this, arguments);
    };

    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return this.union.apply(this, iters);
    };

    Set.prototype.sort = function(comparator) {
      // Late binding
      return OrderedSet(sortFactory(this, comparator));
    };

    Set.prototype.sortBy = function(mapper, comparator) {
      // Late binding
      return OrderedSet(sortFactory(this, comparator, mapper));
    };

    Set.prototype.wasAltered = function() {
      return this._map.wasAltered();
    };

    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);
    };

    Set.prototype.__iterator = function(type, reverse) {
      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);
    };

    Set.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        return this;
      }
      return this.__make(newMap, ownerID);
    };


  function isSet(maybeSet) {
    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
  }

  Set.isSet = isSet;

  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';

  var SetPrototype = Set.prototype;
  SetPrototype[IS_SET_SENTINEL] = true;
  SetPrototype[DELETE] = SetPrototype.remove;
  SetPrototype.mergeDeep = SetPrototype.merge;
  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
  SetPrototype.withMutations = MapPrototype.withMutations;
  SetPrototype.asMutable = MapPrototype.asMutable;
  SetPrototype.asImmutable = MapPrototype.asImmutable;

  SetPrototype.__empty = emptySet;
  SetPrototype.__make = makeSet;

  function updateSet(set, newMap) {
    if (set.__ownerID) {
      set.size = newMap.size;
      set._map = newMap;
      return set;
    }
    return newMap === set._map ? set :
      newMap.size === 0 ? set.__empty() :
      set.__make(newMap);
  }

  function makeSet(map, ownerID) {
    var set = Object.create(SetPrototype);
    set.size = map ? map.size : 0;
    set._map = map;
    set.__ownerID = ownerID;
    return set;
  }

  var EMPTY_SET;
  function emptySet() {
    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
  }

  createClass(OrderedSet, Set);

    // @pragma Construction

    function OrderedSet(value) {
      return value === null || value === undefined ? emptyOrderedSet() :
        isOrderedSet(value) ? value :
        emptyOrderedSet().withMutations(function(set ) {
          var iter = SetIterable(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v ) {return set.add(v)});
        });
    }

    OrderedSet.of = function(/*...values*/) {
      return this(arguments);
    };

    OrderedSet.fromKeys = function(value) {
      return this(KeyedIterable(value).keySeq());
    };

    OrderedSet.prototype.toString = function() {
      return this.__toString('OrderedSet {', '}');
    };


  function isOrderedSet(maybeOrderedSet) {
    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
  }

  OrderedSet.isOrderedSet = isOrderedSet;

  var OrderedSetPrototype = OrderedSet.prototype;
  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;

  OrderedSetPrototype.__empty = emptyOrderedSet;
  OrderedSetPrototype.__make = makeOrderedSet;

  function makeOrderedSet(map, ownerID) {
    var set = Object.create(OrderedSetPrototype);
    set.size = map ? map.size : 0;
    set._map = map;
    set.__ownerID = ownerID;
    return set;
  }

  var EMPTY_ORDERED_SET;
  function emptyOrderedSet() {
    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
  }

  createClass(Stack, IndexedCollection);

    // @pragma Construction

    function Stack(value) {
      return value === null || value === undefined ? emptyStack() :
        isStack(value) ? value :
        emptyStack().unshiftAll(value);
    }

    Stack.of = function(/*...values*/) {
      return this(arguments);
    };

    Stack.prototype.toString = function() {
      return this.__toString('Stack [', ']');
    };

    // @pragma Access

    Stack.prototype.get = function(index, notSetValue) {
      var head = this._head;
      index = wrapIndex(this, index);
      while (head && index--) {
        head = head.next;
      }
      return head ? head.value : notSetValue;
    };

    Stack.prototype.peek = function() {
      return this._head && this._head.value;
    };

    // @pragma Modification

    Stack.prototype.push = function(/*...values*/) {
      if (arguments.length === 0) {
        return this;
      }
      var newSize = this.size + arguments.length;
      var head = this._head;
      for (var ii = arguments.length - 1; ii >= 0; ii--) {
        head = {
          value: arguments[ii],
          next: head
        };
      }
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };

    Stack.prototype.pushAll = function(iter) {
      iter = IndexedIterable(iter);
      if (iter.size === 0) {
        return this;
      }
      assertNotInfinite(iter.size);
      var newSize = this.size;
      var head = this._head;
      iter.reverse().forEach(function(value ) {
        newSize++;
        head = {
          value: value,
          next: head
        };
      });
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };

    Stack.prototype.pop = function() {
      return this.slice(1);
    };

    Stack.prototype.unshift = function(/*...values*/) {
      return this.push.apply(this, arguments);
    };

    Stack.prototype.unshiftAll = function(iter) {
      return this.pushAll(iter);
    };

    Stack.prototype.shift = function() {
      return this.pop.apply(this, arguments);
    };

    Stack.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._head = undefined;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyStack();
    };

    Stack.prototype.slice = function(begin, end) {
      if (wholeSlice(begin, end, this.size)) {
        return this;
      }
      var resolvedBegin = resolveBegin(begin, this.size);
      var resolvedEnd = resolveEnd(end, this.size);
      if (resolvedEnd !== this.size) {
        // super.slice(begin, end);
        return IndexedCollection.prototype.slice.call(this, begin, end);
      }
      var newSize = this.size - resolvedBegin;
      var head = this._head;
      while (resolvedBegin--) {
        head = head.next;
      }
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };

    // @pragma Mutability

    Stack.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        this.__altered = false;
        return this;
      }
      return makeStack(this.size, this._head, ownerID, this.__hash);
    };

    // @pragma Iteration

    Stack.prototype.__iterate = function(fn, reverse) {
      if (reverse) {
        return this.reverse().__iterate(fn);
      }
      var iterations = 0;
      var node = this._head;
      while (node) {
        if (fn(node.value, iterations++, this) === false) {
          break;
        }
        node = node.next;
      }
      return iterations;
    };

    Stack.prototype.__iterator = function(type, reverse) {
      if (reverse) {
        return this.reverse().__iterator(type);
      }
      var iterations = 0;
      var node = this._head;
      return new Iterator(function()  {
        if (node) {
          var value = node.value;
          node = node.next;
          return iteratorValue(type, iterations++, value);
        }
        return iteratorDone();
      });
    };


  function isStack(maybeStack) {
    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
  }

  Stack.isStack = isStack;

  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';

  var StackPrototype = Stack.prototype;
  StackPrototype[IS_STACK_SENTINEL] = true;
  StackPrototype.withMutations = MapPrototype.withMutations;
  StackPrototype.asMutable = MapPrototype.asMutable;
  StackPrototype.asImmutable = MapPrototype.asImmutable;
  StackPrototype.wasAltered = MapPrototype.wasAltered;


  function makeStack(size, head, ownerID, hash) {
    var map = Object.create(StackPrototype);
    map.size = size;
    map._head = head;
    map.__ownerID = ownerID;
    map.__hash = hash;
    map.__altered = false;
    return map;
  }

  var EMPTY_STACK;
  function emptyStack() {
    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
  }

  /**
   * Contributes additional methods to a constructor
   */
  function mixin(ctor, methods) {
    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };
    Object.keys(methods).forEach(keyCopier);
    Object.getOwnPropertySymbols &&
      Object.getOwnPropertySymbols(methods).forEach(keyCopier);
    return ctor;
  }

  Iterable.Iterator = Iterator;

  mixin(Iterable, {

    // ### Conversion to other types

    toArray: function() {
      assertNotInfinite(this.size);
      var array = new Array(this.size || 0);
      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });
      return array;
    },

    toIndexedSeq: function() {
      return new ToIndexedSequence(this);
    },

    toJS: function() {
      return this.toSeq().map(
        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}
      ).__toJS();
    },

    toJSON: function() {
      return this.toSeq().map(
        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}
      ).__toJS();
    },

    toKeyedSeq: function() {
      return new ToKeyedSequence(this, true);
    },

    toMap: function() {
      // Use Late Binding here to solve the circular dependency.
      return Map(this.toKeyedSeq());
    },

    toObject: function() {
      assertNotInfinite(this.size);
      var object = {};
      this.__iterate(function(v, k)  { object[k] = v; });
      return object;
    },

    toOrderedMap: function() {
      // Use Late Binding here to solve the circular dependency.
      return OrderedMap(this.toKeyedSeq());
    },

    toOrderedSet: function() {
      // Use Late Binding here to solve the circular dependency.
      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
    },

    toSet: function() {
      // Use Late Binding here to solve the circular dependency.
      return Set(isKeyed(this) ? this.valueSeq() : this);
    },

    toSetSeq: function() {
      return new ToSetSequence(this);
    },

    toSeq: function() {
      return isIndexed(this) ? this.toIndexedSeq() :
        isKeyed(this) ? this.toKeyedSeq() :
        this.toSetSeq();
    },

    toStack: function() {
      // Use Late Binding here to solve the circular dependency.
      return Stack(isKeyed(this) ? this.valueSeq() : this);
    },

    toList: function() {
      // Use Late Binding here to solve the circular dependency.
      return List(isKeyed(this) ? this.valueSeq() : this);
    },


    // ### Common JavaScript methods and properties

    toString: function() {
      return '[Iterable]';
    },

    __toString: function(head, tail) {
      if (this.size === 0) {
        return head + tail;
      }
      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
    },


    // ### ES6 Collection methods (ES6 Array and Map)

    concat: function() {var values = SLICE$0.call(arguments, 0);
      return reify(this, concatFactory(this, values));
    },

    includes: function(searchValue) {
      return this.some(function(value ) {return is(value, searchValue)});
    },

    entries: function() {
      return this.__iterator(ITERATE_ENTRIES);
    },

    every: function(predicate, context) {
      assertNotInfinite(this.size);
      var returnValue = true;
      this.__iterate(function(v, k, c)  {
        if (!predicate.call(context, v, k, c)) {
          returnValue = false;
          return false;
        }
      });
      return returnValue;
    },

    filter: function(predicate, context) {
      return reify(this, filterFactory(this, predicate, context, true));
    },

    find: function(predicate, context, notSetValue) {
      var entry = this.findEntry(predicate, context);
      return entry ? entry[1] : notSetValue;
    },

    forEach: function(sideEffect, context) {
      assertNotInfinite(this.size);
      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
    },

    join: function(separator) {
      assertNotInfinite(this.size);
      separator = separator !== undefined ? '' + separator : ',';
      var joined = '';
      var isFirst = true;
      this.__iterate(function(v ) {
        isFirst ? (isFirst = false) : (joined += separator);
        joined += v !== null && v !== undefined ? v.toString() : '';
      });
      return joined;
    },

    keys: function() {
      return this.__iterator(ITERATE_KEYS);
    },

    map: function(mapper, context) {
      return reify(this, mapFactory(this, mapper, context));
    },

    reduce: function(reducer, initialReduction, context) {
      assertNotInfinite(this.size);
      var reduction;
      var useFirst;
      if (arguments.length < 2) {
        useFirst = true;
      } else {
        reduction = initialReduction;
      }
      this.__iterate(function(v, k, c)  {
        if (useFirst) {
          useFirst = false;
          reduction = v;
        } else {
          reduction = reducer.call(context, reduction, v, k, c);
        }
      });
      return reduction;
    },

    reduceRight: function(reducer, initialReduction, context) {
      var reversed = this.toKeyedSeq().reverse();
      return reversed.reduce.apply(reversed, arguments);
    },

    reverse: function() {
      return reify(this, reverseFactory(this, true));
    },

    slice: function(begin, end) {
      return reify(this, sliceFactory(this, begin, end, true));
    },

    some: function(predicate, context) {
      return !this.every(not(predicate), context);
    },

    sort: function(comparator) {
      return reify(this, sortFactory(this, comparator));
    },

    values: function() {
      return this.__iterator(ITERATE_VALUES);
    },


    // ### More sequential methods

    butLast: function() {
      return this.slice(0, -1);
    },

    isEmpty: function() {
      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});
    },

    count: function(predicate, context) {
      return ensureSize(
        predicate ? this.toSeq().filter(predicate, context) : this
      );
    },

    countBy: function(grouper, context) {
      return countByFactory(this, grouper, context);
    },

    equals: function(other) {
      return deepEqual(this, other);
    },

    entrySeq: function() {
      var iterable = this;
      if (iterable._cache) {
        // We cache as an entries array, so we can just return the cache!
        return new ArraySeq(iterable._cache);
      }
      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};
      return entriesSequence;
    },

    filterNot: function(predicate, context) {
      return this.filter(not(predicate), context);
    },

    findEntry: function(predicate, context, notSetValue) {
      var found = notSetValue;
      this.__iterate(function(v, k, c)  {
        if (predicate.call(context, v, k, c)) {
          found = [k, v];
          return false;
        }
      });
      return found;
    },

    findKey: function(predicate, context) {
      var entry = this.findEntry(predicate, context);
      return entry && entry[0];
    },

    findLast: function(predicate, context, notSetValue) {
      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
    },

    findLastEntry: function(predicate, context, notSetValue) {
      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
    },

    findLastKey: function(predicate, context) {
      return this.toKeyedSeq().reverse().findKey(predicate, context);
    },

    first: function() {
      return this.find(returnTrue);
    },

    flatMap: function(mapper, context) {
      return reify(this, flatMapFactory(this, mapper, context));
    },

    flatten: function(depth) {
      return reify(this, flattenFactory(this, depth, true));
    },

    fromEntrySeq: function() {
      return new FromEntriesSequence(this);
    },

    get: function(searchKey, notSetValue) {
      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);
    },

    getIn: function(searchKeyPath, notSetValue) {
      var nested = this;
      // Note: in an ES6 environment, we would prefer:
      // for (var key of searchKeyPath) {
      var iter = forceIterator(searchKeyPath);
      var step;
      while (!(step = iter.next()).done) {
        var key = step.value;
        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
        if (nested === NOT_SET) {
          return notSetValue;
        }
      }
      return nested;
    },

    groupBy: function(grouper, context) {
      return groupByFactory(this, grouper, context);
    },

    has: function(searchKey) {
      return this.get(searchKey, NOT_SET) !== NOT_SET;
    },

    hasIn: function(searchKeyPath) {
      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
    },

    isSubset: function(iter) {
      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
      return this.every(function(value ) {return iter.includes(value)});
    },

    isSuperset: function(iter) {
      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
      return iter.isSubset(this);
    },

    keyOf: function(searchValue) {
      return this.findKey(function(value ) {return is(value, searchValue)});
    },

    keySeq: function() {
      return this.toSeq().map(keyMapper).toIndexedSeq();
    },

    last: function() {
      return this.toSeq().reverse().first();
    },

    lastKeyOf: function(searchValue) {
      return this.toKeyedSeq().reverse().keyOf(searchValue);
    },

    max: function(comparator) {
      return maxFactory(this, comparator);
    },

    maxBy: function(mapper, comparator) {
      return maxFactory(this, comparator, mapper);
    },

    min: function(comparator) {
      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
    },

    minBy: function(mapper, comparator) {
      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
    },

    rest: function() {
      return this.slice(1);
    },

    skip: function(amount) {
      return this.slice(Math.max(0, amount));
    },

    skipLast: function(amount) {
      return reify(this, this.toSeq().reverse().skip(amount).reverse());
    },

    skipWhile: function(predicate, context) {
      return reify(this, skipWhileFactory(this, predicate, context, true));
    },

    skipUntil: function(predicate, context) {
      return this.skipWhile(not(predicate), context);
    },

    sortBy: function(mapper, comparator) {
      return reify(this, sortFactory(this, comparator, mapper));
    },

    take: function(amount) {
      return this.slice(0, Math.max(0, amount));
    },

    takeLast: function(amount) {
      return reify(this, this.toSeq().reverse().take(amount).reverse());
    },

    takeWhile: function(predicate, context) {
      return reify(this, takeWhileFactory(this, predicate, context));
    },

    takeUntil: function(predicate, context) {
      return this.takeWhile(not(predicate), context);
    },

    valueSeq: function() {
      return this.toIndexedSeq();
    },


    // ### Hashable Object

    hashCode: function() {
      return this.__hash || (this.__hash = hashIterable(this));
    }


    // ### Internal

    // abstract __iterate(fn, reverse)

    // abstract __iterator(type, reverse)
  });

  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

  var IterablePrototype = Iterable.prototype;
  IterablePrototype[IS_ITERABLE_SENTINEL] = true;
  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
  IterablePrototype.__toJS = IterablePrototype.toArray;
  IterablePrototype.__toStringMapper = quoteString;
  IterablePrototype.inspect =
  IterablePrototype.toSource = function() { return this.toString(); };
  IterablePrototype.chain = IterablePrototype.flatMap;
  IterablePrototype.contains = IterablePrototype.includes;

  mixin(KeyedIterable, {

    // ### More sequential methods

    flip: function() {
      return reify(this, flipFactory(this));
    },

    mapEntries: function(mapper, context) {var this$0 = this;
      var iterations = 0;
      return reify(this,
        this.toSeq().map(
          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}
        ).fromEntrySeq()
      );
    },

    mapKeys: function(mapper, context) {var this$0 = this;
      return reify(this,
        this.toSeq().flip().map(
          function(k, v)  {return mapper.call(context, k, v, this$0)}
        ).flip()
      );
    }

  });

  var KeyedIterablePrototype = KeyedIterable.prototype;
  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};



  mixin(IndexedIterable, {

    // ### Conversion to other types

    toKeyedSeq: function() {
      return new ToKeyedSequence(this, false);
    },


    // ### ES6 Collection methods (ES6 Array and Map)

    filter: function(predicate, context) {
      return reify(this, filterFactory(this, predicate, context, false));
    },

    findIndex: function(predicate, context) {
      var entry = this.findEntry(predicate, context);
      return entry ? entry[0] : -1;
    },

    indexOf: function(searchValue) {
      var key = this.keyOf(searchValue);
      return key === undefined ? -1 : key;
    },

    lastIndexOf: function(searchValue) {
      var key = this.lastKeyOf(searchValue);
      return key === undefined ? -1 : key;
    },

    reverse: function() {
      return reify(this, reverseFactory(this, false));
    },

    slice: function(begin, end) {
      return reify(this, sliceFactory(this, begin, end, false));
    },

    splice: function(index, removeNum /*, ...values*/) {
      var numArgs = arguments.length;
      removeNum = Math.max(removeNum | 0, 0);
      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
        return this;
      }
      // If index is negative, it should resolve relative to the size of the
      // collection. However size may be expensive to compute if not cached, so
      // only call count() if the number is in fact negative.
      index = resolveBegin(index, index < 0 ? this.count() : this.size);
      var spliced = this.slice(0, index);
      return reify(
        this,
        numArgs === 1 ?
          spliced :
          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
      );
    },


    // ### More collection methods

    findLastIndex: function(predicate, context) {
      var entry = this.findLastEntry(predicate, context);
      return entry ? entry[0] : -1;
    },

    first: function() {
      return this.get(0);
    },

    flatten: function(depth) {
      return reify(this, flattenFactory(this, depth, false));
    },

    get: function(index, notSetValue) {
      index = wrapIndex(this, index);
      return (index < 0 || (this.size === Infinity ||
          (this.size !== undefined && index > this.size))) ?
        notSetValue :
        this.find(function(_, key)  {return key === index}, undefined, notSetValue);
    },

    has: function(index) {
      index = wrapIndex(this, index);
      return index >= 0 && (this.size !== undefined ?
        this.size === Infinity || index < this.size :
        this.indexOf(index) !== -1
      );
    },

    interpose: function(separator) {
      return reify(this, interposeFactory(this, separator));
    },

    interleave: function(/*...iterables*/) {
      var iterables = [this].concat(arrCopy(arguments));
      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
      var interleaved = zipped.flatten(true);
      if (zipped.size) {
        interleaved.size = zipped.size * iterables.length;
      }
      return reify(this, interleaved);
    },

    keySeq: function() {
      return Range(0, this.size);
    },

    last: function() {
      return this.get(-1);
    },

    skipWhile: function(predicate, context) {
      return reify(this, skipWhileFactory(this, predicate, context, false));
    },

    zip: function(/*, ...iterables */) {
      var iterables = [this].concat(arrCopy(arguments));
      return reify(this, zipWithFactory(this, defaultZipper, iterables));
    },

    zipWith: function(zipper/*, ...iterables */) {
      var iterables = arrCopy(arguments);
      iterables[0] = this;
      return reify(this, zipWithFactory(this, zipper, iterables));
    }

  });

  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;



  mixin(SetIterable, {

    // ### ES6 Collection methods (ES6 Array and Map)

    get: function(value, notSetValue) {
      return this.has(value) ? value : notSetValue;
    },

    includes: function(value) {
      return this.has(value);
    },


    // ### More sequential methods

    keySeq: function() {
      return this.valueSeq();
    }

  });

  SetIterable.prototype.has = IterablePrototype.includes;
  SetIterable.prototype.contains = SetIterable.prototype.includes;


  // Mixin subclasses

  mixin(KeyedSeq, KeyedIterable.prototype);
  mixin(IndexedSeq, IndexedIterable.prototype);
  mixin(SetSeq, SetIterable.prototype);

  mixin(KeyedCollection, KeyedIterable.prototype);
  mixin(IndexedCollection, IndexedIterable.prototype);
  mixin(SetCollection, SetIterable.prototype);


  // #pragma Helper functions

  function keyMapper(v, k) {
    return k;
  }

  function entryMapper(v, k) {
    return [k, v];
  }

  function not(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    }
  }

  function neg(predicate) {
    return function() {
      return -predicate.apply(this, arguments);
    }
  }

  function quoteString(value) {
    return typeof value === 'string' ? JSON.stringify(value) : String(value);
  }

  function defaultZipper() {
    return arrCopy(arguments);
  }

  function defaultNegComparator(a, b) {
    return a < b ? 1 : a > b ? -1 : 0;
  }

  function hashIterable(iterable) {
    if (iterable.size === Infinity) {
      return 0;
    }
    var ordered = isOrdered(iterable);
    var keyed = isKeyed(iterable);
    var h = ordered ? 1 : 0;
    var size = iterable.__iterate(
      keyed ?
        ordered ?
          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :
          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :
        ordered ?
          function(v ) { h = 31 * h + hash(v) | 0; } :
          function(v ) { h = h + hash(v) | 0; }
    );
    return murmurHashOfSize(size, h);
  }

  function murmurHashOfSize(size, h) {
    h = imul(h, 0xCC9E2D51);
    h = imul(h << 15 | h >>> -15, 0x1B873593);
    h = imul(h << 13 | h >>> -13, 5);
    h = (h + 0xE6546B64 | 0) ^ size;
    h = imul(h ^ h >>> 16, 0x85EBCA6B);
    h = imul(h ^ h >>> 13, 0xC2B2AE35);
    h = smi(h ^ h >>> 16);
    return h;
  }

  function hashMerge(a, b) {
    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
  }

  var Immutable = {

    Iterable: Iterable,

    Seq: Seq,
    Collection: Collection,
    Map: Map,
    OrderedMap: OrderedMap,
    List: List,
    Stack: Stack,
    Set: Set,
    OrderedSet: OrderedSet,

    Record: Record,
    Range: Range,
    Repeat: Repeat,

    is: is,
    fromJS: fromJS

  };

  return Immutable;

}));

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(440), __esModule: true };

/***/ }),
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _regenerator = __webpack_require__(3);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _assets = __webpack_require__(367);

var _assets2 = _interopRequireDefault(_assets);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var helper = {
    filterArr: function filterArr(arr, propertyName, propertyValue, type) {
        var index = -1;
        arr.some(function (item, itemIndex) {
            if (item[propertyName] == propertyValue) {
                index = itemIndex;
                return;
            }
        });

        return type == "index" ? index : index == -1 ? null : arr[index];
    },
    formatAmount: function formatAmount(amount, precision) {
        return this.getFullNum(amount / Math.pow(10, precision));
    },

    toOpAmount: function toOpAmount(amount, assetObj) {
        var _assetObj, precision, id;

        return _regenerator2.default.async(function toOpAmount$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        if (!(typeof assetObj == "string")) {
                            _context.next = 9;
                            break;
                        }

                        _context.next = 3;
                        return _regenerator2.default.awrap(_assets2.default.fetch_asset_one(assetObj));

                    case 3:
                        assetObj = _context.sent;

                        if (!(assetObj.code != 1)) {
                            _context.next = 8;
                            break;
                        }

                        return _context.abrupt("return", assetObj);

                    case 8:
                        assetObj = assetObj.data;

                    case 9:
                        _assetObj = assetObj, precision = _assetObj.precision, id = _assetObj.id;

                        if (!(helper.getDecimals(amount) > precision)) {
                            _context.next = 12;
                            break;
                        }

                        return _context.abrupt("return", { success: false, code: 117, error: 'The current asset precision is configured as ' + precision + 'ï¼Œand the decimal cannot exceed ' + precision });

                    case 12:
                        amount = parseInt((amount * Math.pow(10, precision)).toFixed(0));
                        return _context.abrupt("return", { success: true, data: { amount: amount, asset_id: id } });

                    case 14:
                    case "end":
                        return _context.stop();
                }
            }
        }, null, undefined);
    },
    getFullNum: function getFullNum(num, precision) {
        //deal with non-numeric
        if (isNaN(num)) {
            return num;
        };
        if (precision && precision != 0) num = num / Math.pow(10, precision);
        //process numberics that needn't transformation
        var str = '' + num;

        if (!/e/i.test(str)) {
            return num;
        };
        num = Number(num).toFixed(18).replace(/\.?0+$/, "");

        return num;
    },
    getDecimals: function getDecimals(num) {
        var num_str = this.getFullNum(num);
        if (typeof num_str != "string") {
            return 0;
        }
        if (num_str.indexOf(".") != -1) {
            return num_str.split(".")[1].length;
        }

        return 0;
    },

    trimParams: function trimParams(params) {
        var noValidates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        var p_value = void 0;
        var requireParams = true;
        for (var key in params) {
            if (key != "callback") {
                p_value = params[key];
                if (typeof p_value == "string") {
                    if (p_value) {
                        params[key] = p_value.trim();
                    }
                    if (!p_value && !(key in noValidates)) {
                        requireParams = false;
                    }
                }
            }
        }
        return requireParams;
    },
    formatTable: function formatTable(table) {
        var result = {};
        table.forEach(function (item) {
            var key = item[0].key[1].v;
            var value = item[1][1].v;
            switch (item[1][0]) {
                case 4:
                    result[key] = helper.formatTable(value);
                    break;
                case 0:
                case 1:
                    result[key] = Number(value);
                    break;
                default:
                    result[key] = value;
            }
        });
        return result;
    }
};

exports.default = helper;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

var isType = __webpack_require__(37);
var getFunctionName = __webpack_require__(132);

module.exports = function getTypeName(ctor) {
  if (isType(ctor)) {
    return ctor.displayName;
  }
  return getFunctionName(ctor);
};

/***/ }),
/* 36 */
/***/ (function(module, exports) {

module.exports = function isFunction(x) {
  return typeof x === 'function';
};

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(36);
var isObject = __webpack_require__(61);

module.exports = function isType(x) {
  return isFunction(x) && isObject(x.meta);
};

/***/ }),
/* 38 */,
/* 39 */,
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

var assert = __webpack_require__(20);
var isString = __webpack_require__(151);
var isFunction = __webpack_require__(36);
var forbidNewOperator = __webpack_require__(133);

module.exports = function irreducible(name, predicate) {

  if (true) {
    assert(isString(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to irreducible(name, predicate) (expected a string)'; });
    assert(isFunction(predicate), 'Invalid argument predicate ' + assert.stringify(predicate) + ' supplied to irreducible(name, predicate) (expected a function)');
  }

  function Irreducible(value, path) {

    if (true) {
      forbidNewOperator(this, Irreducible);
      path = path || [name];
      assert(predicate(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
    }

    return value;
  }

  Irreducible.meta = {
    kind: 'irreducible',
    name: name,
    predicate: predicate,
    identity: true
  };

  Irreducible.displayName = name;

  Irreducible.is = predicate;

  return Irreducible;
};


/***/ }),
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var objectAssign = __webpack_require__(449);

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:
// NB: The URL to the CommonJS spec is kept just for tradition.
//     node-assert has evolved a lot since then, both in API and behavior.

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = __webpack_require__(450);
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = (function () {
  return function foo() {}.name === 'foo';
}());
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function(err) { if (err) throw err; };

// Expose a strict only variant of assert
function strict(value, message) {
  if (!value) fail(value, true, message, '==', strict);
}
assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

var isNil = __webpack_require__(53);
var isString = __webpack_require__(151);

module.exports = function isTypeName(name) {
  return isNil(name) || isString(name);
};

/***/ }),
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */,
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(433), __esModule: true };

/***/ }),
/* 53 */
/***/ (function(module, exports) {

module.exports = function isNil(x) {
  return x === null || x === void 0;
};

/***/ }),
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

var BigInteger = __webpack_require__(371)

//addons
__webpack_require__(448)

module.exports = BigInteger

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.ripemd160 = exports.HmacSHA256 = exports.sha512 = exports.sha256 = exports.sha1 = undefined;

var _createHash = __webpack_require__(55);

var _createHash2 = _interopRequireDefault(_createHash);

var _createHmac = __webpack_require__(139);

var _createHmac2 = _interopRequireDefault(_createHmac);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @arg {string|Buffer} data
    @arg {string} [digest = null] - 'hex', 'binary' or 'base64'
    @return {string|Buffer} - Buffer when digest is null, or string
*/
function sha1(data, encoding) {
    return (0, _createHash2.default)('sha1').update(data).digest(encoding);
}

/** @arg {string|Buffer} data
    @arg {string} [digest = null] - 'hex', 'binary' or 'base64'
    @return {string|Buffer} - Buffer when digest is null, or string
*/
function sha256(data, encoding) {
    return (0, _createHash2.default)('sha256').update(data).digest(encoding);
}

/** @arg {string|Buffer} data
    @arg {string} [digest = null] - 'hex', 'binary' or 'base64'
    @return {string|Buffer} - Buffer when digest is null, or string
*/
function sha512(data, encoding) {
    return (0, _createHash2.default)('sha512').update(data).digest(encoding);
}

function HmacSHA256(buffer, secret) {
    return (0, _createHmac2.default)('sha256', secret).update(buffer).digest();
}

function ripemd160(data) {
    return (0, _createHash2.default)('rmd160').update(data).digest();
}

// function hash160(buffer) {
//   return ripemd160(sha256(buffer))
// }
//
// function hash256(buffer) {
//   return sha256(sha256(buffer))
// }

//
// function HmacSHA512(buffer, secret) {
//   return crypto.createHmac('sha512', secret).update(buffer).digest()
// }

exports.sha1 = sha1;
exports.sha256 = sha256;
exports.sha512 = sha512;
exports.HmacSHA256 = HmacSHA256;
exports.ripemd160 = ripemd160;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _getIterator2 = __webpack_require__(52);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _parseInt = __webpack_require__(496);

var _parseInt2 = _interopRequireDefault(_parseInt);

var _numeral = __webpack_require__(501);

var _numeral2 = _interopRequireDefault(_numeral);

var _MarketClasses = __webpack_require__(148);

var _bcxjsCores = __webpack_require__(7);

var _immutable = __webpack_require__(23);

var _immutable2 = _interopRequireDefault(_immutable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var id_regex = /\b\d+\.\d+\.(\d+)\b/;
var object_type = _bcxjsCores.ChainTypes.object_type,
    operations = _bcxjsCores.ChainTypes.operations;


var Utils = {
    get_object_id: function get_object_id(obj_id) {
        var id_regex_res = id_regex.exec(obj_id);
        return id_regex_res ? (0, _parseInt2.default)(id_regex_res[1]) : 0;
    },

    is_object_id: function is_object_id(obj_id) {
        if ('string' != typeof obj_id) return false;
        var match = id_regex.exec(obj_id);
        return match !== null && obj_id.split(".").length === 3;
    },

    is_object_type: function is_object_type(obj_id, type) {
        var prefix = object_type[type];
        if (!prefix || !obj_id) return null;
        prefix = "1." + prefix.toString();
        return obj_id.substring(0, prefix.length) === prefix;
    },

    get_satoshi_amount: function get_satoshi_amount(amount, asset) {
        var precision = asset.toJS ? asset.get("precision") : asset.precision;
        var assetPrecision = this.get_asset_precision(precision);
        amount = typeof amount === "string" ? amount : amount.toString();

        var decimalPosition = amount.indexOf(".");
        if (decimalPosition === -1) {
            return parseInt(amount, 10) * assetPrecision;
        } else {
            var amountLength = amount.length,
                i = void 0;
            amount = amount.replace(".", "");
            amount = amount.substr(0, decimalPosition + precision);
            for (i = 0; i < precision; i++) {
                decimalPosition += 1;
                if (decimalPosition > amount.length) {
                    amount += "0";
                }
            }
            ;

            return parseInt(amount, 10);
        }
    },


    get_asset_precision: function get_asset_precision(precision) {
        precision = precision.toJS ? precision.get("precision") : precision;
        return Math.pow(10, precision);
    },

    get_asset_amount: function get_asset_amount(amount, asset) {
        if (amount === 0) return amount;
        if (!amount) return null;
        return amount / this.get_asset_precision(asset.toJS ? asset.get("precision") : asset.precision);
    },

    get_asset_price: function get_asset_price(quoteAmount, quoteAsset, baseAmount, baseAsset) {
        var inverted = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

        if (!quoteAsset || !baseAsset) {
            return 1;
        }
        var price = this.get_asset_amount(quoteAmount, quoteAsset) / this.get_asset_amount(baseAmount, baseAsset);
        // if(isNaN(price)) price=0;
        if (price == Infinity || isNaN(price)) return 0;
        return inverted ? 1 / price : price;
    },

    round_number: function round_number(number, asset) {
        var assetPrecision = asset.toJS ? asset.get("precision") : asset.precision;
        var precision = this.get_asset_precision(assetPrecision);
        return Math.round(number * precision) / precision;
    },

    format_volume: function format_volume(amount) {

        if (amount < 10000) {
            return this.format_number(amount, 3);
        } else if (amount < 1000000) {
            return (Math.round(amount / 10) / 100).toFixed(2) + "k";
        } else {
            return (Math.round(amount / 10000) / 100).toFixed(2) + "M";
        }
    },
    format_volume_s: function format_volume_s(amount) {

        if (amount < 1000) {
            return this.format_number(amount, 3);
        } else if (amount < 100000) {
            return (Math.round(amount / 10) / 100).toFixed(2) + "k";
        } else {
            return (Math.round(amount / 10000) / 100).toFixed(2) + "M";
        }
    },


    format_number: function format_number(number, decimals) {
        var trailing_zeros = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

        if (isNaN(number) || !isFinite(number) || number === undefined || number === null) return "" || 0;
        var zeros = ".";
        for (var i = 0; i < decimals; i++) {
            zeros += "0";
        }
        var num = (0, _numeral2.default)(number).format("0,0" + zeros);
        if (num.indexOf('.') > 0 && !trailing_zeros) {
            num = num.replace(/0+$/, "").replace(/\.$/, "");
            return num || 0;
        }
        num = num.replace(/,/g, "") || 0;
        return num;
    },
    formatNumber: function formatNumber(num, s) {
        var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        num = num.replace(',', "");
        if (isNaN(num)) return num;
        var zeros = ".";
        for (var i = 0; i < s; i++) {
            zeros += "0";
        }
        var x = parseFloat(num);
        var m = (0, _numeral2.default)(x.toFixed(s)).format("0,0" + zeros);
        if (m.indexOf('.') > 0 && !z) m = m.replace(/0+$/, "").replace(/\.$/, "");
        return m;
    },

    format_asset: function format_asset(amount, asset, noSymbol) {
        var trailing_zeros = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

        var symbol = void 0;
        var digits = 0;
        if (asset === undefined) return undefined;
        if ('symbol' in asset) {
            // console.log( "asset: ", asset )
            symbol = asset.symbol;
            digits = asset.precision;
        } else {
            // console.log( "asset: ", asset.toJS() )
            symbol = asset.get('symbol');
            digits = asset.get('precision');
        }
        var precision = this.get_asset_precision(digits);
        // console.log( "precision: ", precision )

        return "" + this.format_number(amount / precision, digits, trailing_zeros) + (!noSymbol ? " " + symbol : "");
    },

    format_price: function format_price(quoteAmount, quoteAsset, baseAmount, baseAsset, noSymbol) {
        var inverted = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
        var trailing_zeros = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : true;

        if (quoteAsset.size) quoteAsset = quoteAsset.toJS();
        if (baseAsset.size) baseAsset = baseAsset.toJS();

        var precision = this.get_asset_precision(quoteAsset.precision);
        var basePrecision = this.get_asset_precision(baseAsset.precision);

        if (inverted) {
            if (parseInt(quoteAsset.id.split(".")[2], 10) < parseInt(baseAsset.id.split(".")[2], 10)) {
                return "" + this.format_number(quoteAmount / precision / (baseAmount / basePrecision), Math.max(5, quoteAsset.precision), trailing_zeros) + (!noSymbol ? " " + quoteAsset.symbol + "/" + baseAsset.symbol : "");
            } else {
                return "" + this.format_number(baseAmount / basePrecision / (quoteAmount / precision), Math.max(5, baseAsset.precision), trailing_zeros) + (!noSymbol ? " " + baseAsset.symbol + "/" + quoteAsset.symbol : "");
            }
        } else {
            if (parseInt(quoteAsset.id.split(".")[2], 10) > parseInt(baseAsset.id.split(".")[2], 10)) {
                return "" + this.format_number(quoteAmount / precision / (baseAmount / basePrecision), Math.max(5, quoteAsset.precision), trailing_zeros) + (!noSymbol ? " " + quoteAsset.symbol + "/" + baseAsset.symbol : "");
            } else {
                return "" + this.format_number(baseAmount / basePrecision / (quoteAmount / precision), Math.max(5, baseAsset.precision), trailing_zeros) + (!noSymbol ? " " + baseAsset.symbol + "/" + quoteAsset.symbol : "");
            }
        }
    },

    price_text: function price_text(price, base, quote) {
        var maxDecimals = 8;
        var priceText = void 0;
        var quoteID = quote.toJS ? quote.get("id") : quote.id;
        var quotePrecision = quote.toJS ? quote.get("precision") : quote.precision;
        var baseID = base.toJS ? base.get("id") : base.id;
        var basePrecision = base.toJS ? base.get("precision") : base.precision;
        if (quoteID === "1.3.0") {
            priceText = this.format_number(price, quotePrecision);
        } else if (baseID === "1.3.0") {
            priceText = this.format_number(price, Math.min(maxDecimals, quotePrecision + 2));
        } else {
            priceText = this.format_number(price, Math.min(maxDecimals, quotePrecision + basePrecision));
        }
        return priceText;
    },

    price_to_text: function price_to_text(price, base, quote) {
        var forcePrecision = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

        if (typeof price !== "number" || !base || !quote) {
            return;
        }

        if (price === Infinity) {
            price = 0;
        }
        var precision = void 0;
        var priceText = void 0;

        if (forcePrecision) {
            priceText = this.format_number(price, forcePrecision);
        } else {
            priceText = this.price_text(price, base, quote);
        }
        var price_split = priceText.split(".");
        var int = price_split[0];
        var dec = price_split[1];
        var i = void 0;

        var zeros = 0;
        if (dec) {
            if (price > 1) {
                var l = dec.length;
                for (i = l - 1; i >= 0; i--) {
                    if (dec[i] !== "0") {
                        break;
                    }
                    zeros++;
                }
                ;
            } else {
                var _l = dec.length;
                for (i = 0; i < _l; i++) {
                    if (dec[i] !== "0") {
                        i--;
                        break;
                    }
                    zeros++;
                }
                ;
            }
        }

        var trailing = zeros ? dec.substr(Math.max(0, i + 1), dec.length) : null;

        if (trailing) {
            if (trailing.length === dec.length) {
                dec = null;
            } else if (trailing.length) {
                dec = dec.substr(0, i + 1);
            }
        }

        return {
            text: priceText,
            int: int,
            dec: dec,
            trailing: trailing,
            full: price
        };
    },

    get_op_type: function get_op_type(object) {
        var type = parseInt(object.split(".")[1], 10);

        for (var id in object_type) {
            if (object_type[id] === type) {
                return id;
            }
        }
    },

    add_comma: function add_comma(value) {
        if (typeof value === "number") {
            value = value.toString();
        }
        value = value.trim();
        value = value.replace(/,/g, "");
        if (value == "." || value == "") {
            return value;
        } else if (value.length) {
            // console.log( "before: ",value )
            var n = Number(value);
            if (isNaN(n)) return;
            var parts = value.split('.');
            // console.log( "split: ", parts )
            n = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");
            if (parts.length > 1) n += "." + parts[1];
            // console.log( "after: ",transfer.amount )
            return n;
        }
    },

    parse_float_with_comma: function parse_float_with_comma(value) {
        // let value = new_state.transfer.amount
        // United Labs of BCTech.
        value = value.replace(/,/g, "");
        var fvalue = parseFloat(value);
        if (value.length && isNaN(fvalue) && value != ".") throw "parse_float_with_comma: must be a number";else if (fvalue < 0) return 0;

        return fvalue;
    },

    are_equal_shallow: function are_equal_shallow(a, b) {
        if (Array.isArray(a) && Array.isArray(b)) {
            if (a.length > b.length) {
                return false;
            }
        }
        for (var key in a) {
            if (!(key in b) || a[key] !== b[key]) {
                return false;
            }
        }
        for (var key in b) {
            if (!(key in a) || a[key] !== b[key]) {
                return false;
            }
        }
        return true;
    },

    format_date: function format_date(date_str) {
        var date = new Date(date_str);
        return date.toLocaleDateString();
    },

    format_time: function format_time(time_str) {
        var date = new Date(time_str);
        return date.toLocaleString();
    },

    limitByPrecision: function limitByPrecision(value, assetPrecision) {
        var valueString = value.toString();
        var splitString = valueString.split(".");
        if (splitString.length === 1 || splitString.length === 2 && splitString[1].length <= assetPrecision) {
            return valueString;
        } else {
            return splitString[0] + "." + splitString[1].substr(0, assetPrecision);
        }
        // let precision = this.get_asset_precision(assetPrecision);
        // value = Math.floor(value * precision) / precision;
        // if (isNaN(value) || !isFinite(value)) {
        //     return 0;
        // }
        // return value;
    },

    estimateFee: function estimateFee(op_type, options, globalObject) {
        if (!globalObject) return 0;
        globalObject = _immutable2.default.fromJS(globalObject);
        var op_code = operations[op_type];
        var currentFees = globalObject.getIn(["parameters", "current_fees", "parameters", op_code, 1]); //.toJS();
        if (currentFees) {
            currentFees = currentFees.toJS();
        } else {
            return 0;
        }
        var fee = 0;
        if (currentFees.fee) {
            fee += currentFees.fee;
        }

        if (options) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = (0, _getIterator3.default)(options), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var option = _step.value;

                    fee += currentFees[option];
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }

        return fee * globalObject.getIn(["parameters", "current_fees", "scale"]) / 10000;
    },
    getFee: function getFee(op_type, asset, coreAsset, globalObject) {
        asset = _immutable2.default.fromJS(asset);
        var fee = this.estimateFee(op_type, [], globalObject || _bcxjsCores.ChainStore.getObject("2.0.0")) || 0;
        var coreFee = new _MarketClasses.Asset({
            amount: fee,
            precision: coreAsset ? coreAsset.precision : 8
        });
        if (!asset || asset.get("id") === "1.3.0") return coreFee;

        var cer = asset.getIn(["options", "core_exchange_rate"]).toJS();

        // if(cer.base.amount==cer.quote.amount) return 0
        if (cer.base.asset_id === cer.quote.asset_id) {
            coreFee._real_amount = 0;
            return coreFee;
        }

        var cerBase = new _MarketClasses.Asset({
            asset_id: cer.base.asset_id,
            amount: cer.base.amount,
            precision: coreAsset ? coreAsset.precision : 5
        });

        var cerQuote = new _MarketClasses.Asset({
            asset_id: cer.quote.asset_id,
            amount: cer.quote.amount,
            precision: asset.get("precision")
        });

        try {
            var cerPrice = new _MarketClasses.Price({
                base: cerBase, quote: cerQuote
            });
            var convertedFee = coreFee.times(cerPrice);

            return convertedFee;
        } catch (err) {
            return coreFee;
        }
    },
    convertPrice: function convertPrice(fromRate, toRate, fromID, toID) {

        if (!fromRate || !toRate) {
            return null;
        }

        // Handle case of input simply being a fromAsset and toAsset
        if (fromRate.toJS && this.is_object_type(fromRate.get("id"), "asset")) {
            fromID = fromRate.get("id");
            fromRate = fromRate.get("bitasset") ? fromRate.getIn(["bitasset", "current_feed", "settlement_price"]).toJS() : fromID == "1.3.1" ? fromRate.getIn(["options", "core_exchange_rate"]).toJS() : fromRate.toJS(); //fromRate.getIn(["options", "core_exchange_rate"]).toJS();
        }

        if (toRate.toJS) {
            toID = toRate.get("id");
            toRate = toRate.get("bitasset") ? toRate.getIn(["bitasset", "current_feed", "settlement_price"]).toJS() : toID == "1.3.1" ? toRate.getIn(["options", "core_exchange_rate"]).toJS() : toRate.toJS(); //toRate.getIn(["options", "core_exchange_rate"]).toJS();
        }

        var fromRateQuoteID = fromRate.quote ? fromRate.quote.asset_id : fromRate.asset_id;
        var toRateQuoteID = toRate.quote ? toRate.quote.asset_id : toRate.asset_id;
        // console.info("fromRate",fromRate,toRate);

        var fromRateQuoteAmount = void 0,
            fromRateBaseAmount = void 0,
            finalQuoteID = void 0,
            finalBaseID = void 0;

        if (fromRateQuoteID === fromID) {

            fromRateQuoteAmount = fromRate.quote ? fromRate.quote.amount : 0;
            fromRateBaseAmount = fromRate.base ? fromRate.base.amount : 0;
        } else {

            fromRateQuoteAmount = fromRate.base ? fromRate.base.amount : 0;
            fromRateBaseAmount = fromRate.quote ? fromRate.quote.amount : 0;
        }

        var toRateQuoteAmount = void 0,
            toRateBaseAmount = void 0;
        if (toRateQuoteID === toID) {
            toRateQuoteAmount = toRate.quote ? toRate.quote.amount : 1;
            toRateBaseAmount = toRate.base ? toRate.base.amount : 1;
        } else {
            toRateQuoteAmount = toRate.base ? toRate.base.amount : 1;
            toRateBaseAmount = toRate.quote ? toRate.quote.amount : 1;
        }

        var baseRatio = void 0,
            finalQuoteAmount = void 0,
            finalBaseAmount = void 0;
        if (toRateBaseAmount > fromRateBaseAmount) {
            baseRatio = toRateBaseAmount / fromRateBaseAmount;
            finalQuoteAmount = fromRateQuoteAmount * baseRatio;
            finalBaseAmount = toRateQuoteAmount;
        } else {
            if (toRateBaseAmount) baseRatio = fromRateBaseAmount / toRateBaseAmount;else baseRatio = 0;
            finalQuoteAmount = fromRateQuoteAmount;
            finalBaseAmount = toRateQuoteAmount * baseRatio;
            // console.info("fromRateQuoteAmount",fromRateQuoteAmount);
        }
        // console.info("finalQuoteAmount",finalQuoteAmount,finalBaseAmount);
        // console.info("toRateBaseAmount",toRateBaseAmount,fromRateBaseAmount,finalBaseAmount);

        return {
            quote: {
                amount: finalQuoteAmount,
                asset_id: toID
            },
            base: {
                amount: finalBaseAmount,
                asset_id: fromID
            }
        };
    },

    convertValue: function convertValue(priceObject, amount, fromAsset, toAsset) {
        priceObject = priceObject.toJS ? priceObject.toJS() : priceObject;
        var quotePrecision = this.get_asset_precision(fromAsset.get("precision"));
        var basePrecision = this.get_asset_precision(toAsset.get("precision"));
        var assetPrice = this.get_asset_price(priceObject.quote.amount, fromAsset, priceObject.base.amount, toAsset);
        var eqValue = fromAsset.get("id") !== toAsset.get("id") ? basePrecision * (amount / quotePrecision) / assetPrice : amount;
        if (isNaN(eqValue) || !isFinite(eqValue)) {
            return null;
        }
        return eqValue;
    },

    isValidPrice: function isValidPrice(rate) {
        if (!rate || !rate.toJS) {
            return false;
        }
        var base = rate.get("base").toJS();
        var quote = rate.get("quote").toJS();
        if (base.amount > 0 && quote.amount > 0 && base.asset_id !== quote.asset_id) {
            return true;
        } else {
            return false;
        }
    },
    sortText: function sortText(a, b) {
        var inverse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        if (a > b) {
            return inverse ? 1 : -1;
        } else if (a < b) {
            return inverse ? -1 : 1;
        } else {
            return 0;
        }
    },
    sortID: function sortID(a, b) {
        var inverse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        // inverse = false => low to high
        var intA = parseInt(a.split(".")[2], 10);
        var intB = parseInt(b.split(".")[2], 10);

        return inverse ? intB - intA : intA - intB;
    },
    calc_block_time: function calc_block_time(block_number, globalObject, dynGlobalObject) {
        if (!globalObject || !dynGlobalObject) return null;
        var block_interval = globalObject.get("parameters").get("block_interval");
        var head_block = dynGlobalObject.get("head_block_number");
        var head_block_time = new Date(dynGlobalObject.get("time") + "+00:00");
        var seconds_below = (head_block - block_number) * block_interval;
        return new Date(head_block_time - seconds_below * 1000);
    },
    get_translation_parts: function get_translation_parts(str) {
        var result = [];
        var toReplace = {};
        var re = /\((.*?)\)/g;
        var interpolators = str.split(re);
        // console.log("split:", str.split(re)); 
        return str.split(re);
        // var str = '{{azazdaz}} {{azdazd}}';
        // var m;
        // United Labs of BCTech.
        // while ((m = re.exec(str)) !== null) {
        //     if (m.index === re.lastIndex) {
        //         re.lastIndex++;
        //     }
        //     console.log("m:", m);
        //     // View your result using the m-variable.
        //     // eg m[0] etc.
        //     // 
        //     toReplace[m[1]] = m[0]
        //     result.push(m[1])
        // }

        // return result;
    },
    get_percentage: function get_percentage(a, b) {
        return Math.round(a / b * 100) + "%";
    },
    replaceName: function replaceName(name) {
        var isBitAsset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        var toReplace = ["TRADE.", "OPEN.", "METAEX."];
        var suffix = "";
        var i = void 0;
        for (i = 0; i < toReplace.length; i++) {
            if (name.indexOf(toReplace[i]) !== -1) {
                name = name.replace(toReplace[i], "") + suffix;
                break;
            }
        }

        return {
            name: name,
            prefix: isBitAsset ? "bit" : toReplace[i] ? toReplace[i].toLowerCase() : null
        };
    },
    getAssetName: function getAssetName(asset) {
        var noPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var replace = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

        var name = asset.get("symbol");
        var isBitAsset = asset.has("bitasset");
        var isPredMarket = isBitAsset && asset.getIn(["bitasset", "is_prediction_market"]);

        var _replaceName = this.replaceName(name, isBitAsset && !isPredMarket && asset.get("issuer") === "1.2.0"),
            replacedName = _replaceName.name,
            prefix = _replaceName.prefix;

        if (prefix == null) {
            prefix = '';
        }
        if (replace && replacedName !== name) {

            return "" + (!noPrefix ? prefix : '') + replacedName;
        } else {
            return "" + (!noPrefix ? prefix : '') + name;
        }
    }
};

exports.default = Utils;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _keys = __webpack_require__(24);

var _keys2 = _interopRequireDefault(_keys);

var _getIterator2 = __webpack_require__(52);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _promise = __webpack_require__(4);

var _promise2 = _interopRequireDefault(_promise);

var _bcxjsWs = __webpack_require__(8);

var _idbHelper = __webpack_require__(149);

var _idbHelper2 = _interopRequireDefault(_idbHelper);

var _idbRoot = __webpack_require__(527);

var _idbRoot2 = _interopRequireDefault(_idbRoot);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DB_VERSION = 2; // Initial value was 1
var DB_PREFIX = "gph_v2";
var WALLET_BACKUP_STORES = ["wallet", "private_keys", "linked_accounts"];

var current_wallet_name = "default";

var upgrade = function upgrade(db, oldVersion) {
    // DEBUG console.log('... upgrade oldVersion',oldVersion)
    if (oldVersion === 0) {
        db.createObjectStore("wallet", { keyPath: "public_name" });
        _idbHelper2.default.autoIncrement_unique(db, "private_keys", "pubkey");
        db.createObjectStore("linked_accounts", { keyPath: "name" });
    }
    if (oldVersion < 2) {
        // Cache only, do not backup...
        db.createObjectStore("cached_properties", { keyPath: "name" });
    }
};

/**
    Everything in this class is scopped by the database name.  This separates
    data per-wallet and per-chain. United Labs of BCTech.
*/
var getDatabaseName = function getDatabaseName() {
    var current_wallet = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : current_wallet_name;
    var chain_id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _bcxjsWs.Apis.instance().chain_id;

    return [DB_PREFIX, chain_id ? chain_id.substring(0, 6) : "", current_wallet].join("_");
};

var openDatabase = function openDatabase() {
    var database_name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getDatabaseName();

    return new _promise2.default(function (resolve, reject) {
        var openRequest = iDB.impl.open(database_name, DB_VERSION);

        openRequest.onupgradeneeded = function (e) {
            //  console.log('... openRequest.onupgradeneeded ' + database_name)1
            // Don't resolve here, indexedDb will call onsuccess or onerror next
            upgrade(e.target.result, e.oldVersion);
        };

        openRequest.onsuccess = function (e) {
            // console.log('... openRequest.onsuccess ' + database_name, e.target.result)
            var db = e.target.result;
            iDB.database_name = database_name;
            _idbHelper2.default.set_graphene_db(db);
            resolve(db);
        };

        openRequest.onerror = function (e) {
            // console.log("... openRequest.onerror " + database_name,e.target.error, e)
            reject(e.target.error);
        };
    });
};

var iDB = function () {

    var _instance;
    var idb;

    /** Be carefull not to call twice especially for a new database
       needing an upgrade...
    */
    function openIndexedDB(chain_id) {
        return iDB.root.getProperty("current_wallet", "default").then(function (current_wallet) {
            current_wallet_name = current_wallet;
            var database_name = getDatabaseName(current_wallet, chain_id);
            return openDatabase(database_name);
        });
    }

    function init(chain_id) {
        var instance = void 0;
        var promise = openIndexedDB(chain_id);
        promise.then(function (db) {
            idb = db;
        });
        return {
            init_promise: promise,
            db: function db() {
                return idb;
            }
        };
    }

    return {
        WALLET_BACKUP_STORES: WALLET_BACKUP_STORES,
        getDatabaseName: getDatabaseName,
        getCurrentWalletName: function getCurrentWalletName() {
            return current_wallet_name;
        },
        deleteDatabase: function deleteDatabase() {
            var are_you_sure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

            // if( ! are_you_sure) return "Are you sure?"
            console.log("deleting", this.database_name);
            var req = iDB.impl.deleteDatabase(this.database_name);
            return req.result;
        },

        set_impl: function set_impl(impl) {
            this.impl = impl;
            this.root = new _idbRoot2.default(this.impl);
        },

        set_chain_id: function set_chain_id(chain_id) {
            this.chain_id = chain_id;
            var chain_substring = chain_id ? chain_id.substring(0, 6) : "";
            //this.root.setDbSuffix("_" + chain_substring)
            this.root.setDbSuffix("_" + chain_substring + "_" + current_wallet_name);
        },

        init_instance: function init_instance(indexedDBimpl) {
            var chain_id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _bcxjsWs.Apis.instance().chain_id;

            if (!_instance) {
                if (indexedDBimpl) {
                    this.set_impl(indexedDBimpl);
                    if ("__useShim" in indexedDBimpl) {
                        this.impl.__useShim(); //always use shim
                    }
                }
                this.set_chain_id(chain_id);
                _instance = init(chain_id);
            }
            return _instance;
        },

        instance: function instance() {
            // if (!_instance) {
            //     throw new Error("Internal Database instance is not initialized");
            // }
            return _instance;
        },

        close: function close() {
            if (_instance) {
                _instance.db().close();
            };
            _idbHelper2.default.set_graphene_db(null);
            _instance = undefined;
            // idb=null;
        },

        add_to_store: function add_to_store(store_name, value) {
            var _this = this;

            return new _promise2.default(function (resolve, reject) {
                var transaction = _this.instance().db().transaction([store_name], "readwrite");
                var store = transaction.objectStore(store_name);
                var request = store.add(value);
                request.onsuccess = function () {
                    resolve(value);
                };
                request.onerror = function (e) {
                    console.log("ERROR!!! add_to_store - can't store value in db. ", e.target.error.message, value);
                    reject(e.target.error.message);
                };
            });
        },
        remove_from_store: function remove_from_store(store_name, value) {
            var _this2 = this;

            return new _promise2.default(function (resolve, reject) {
                var transaction = _this2.instance().db().transaction([store_name], "readwrite");
                var store = transaction.objectStore(store_name);
                var request = store.delete(value);
                request.onsuccess = function () {
                    resolve();
                };
                request.onerror = function (e) {
                    console.log("ERROR!!! remove_from_store - can't remove value from db. ", e.target.error.message, value);
                    reject(e.target.error.message);
                };
            });
        },
        load_data: function load_data(store_name) {
            var _this3 = this;

            return new _promise2.default(function (resolve, reject) {
                var data = [];
                var transaction = _this3.instance().db().transaction([store_name], "readonly");
                var store = transaction.objectStore(store_name);
                var request = store.openCursor();
                //request.oncomplete = () => { resolve(data); };
                request.onsuccess = function (e) {
                    var cursor = e.target.result;
                    if (cursor) {
                        data.push(cursor.value);
                        cursor.continue();
                    } else {
                        resolve(data);
                    }
                };
                request.onerror = function (e) {
                    console.log("ERROR!!! open_store - can't get '`${store_name}`' cursor. ", e.target.error.message);
                    reject(e.target.error.message);
                };
            });
        },

        /** Persisted to disk but not backed up.
            @return promise
        */
        getCachedProperty: function getCachedProperty(name, default_value) {
            var db = this.instance().db();
            var transaction = db.transaction(["cached_properties"], "readonly");
            var store = transaction.objectStore("cached_properties");
            return _idbHelper2.default.on_request_end(store.get(name)).then(function (event) {
                var result = event.target.result;
                return result ? result.value : default_value;
            }).catch(function (error) {
                console.error(error);throw error;
            });
        },

        /** Persisted to disk but not backed up. */
        setCachedProperty: function setCachedProperty(name, value) {
            var db = this.instance().db();
            var transaction = db.transaction(["cached_properties"], "readwrite");
            var store = transaction.objectStore("cached_properties");
            if (value && value["toJS"]) value = value.toJS(); //Immutable-js
            return _idbHelper2.default.on_request_end(store.put({ name: name, value: value })).catch(function (error) {
                console.error(error);throw error;
            });
        },

        backup: function backup() {
            var store_names = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : WALLET_BACKUP_STORES;

            var promises = [];
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = (0, _getIterator3.default)(store_names), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var store_name = _step.value;

                    promises.push(this.load_data(store_name));
                }
                //Add each store name
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            return _promise2.default.all(promises).then(function (results) {
                var obj = {};
                for (var i = 0; i < store_names.length; i++) {
                    var store_name = store_names[i];
                    if (store_name === "wallet") {
                        var wallet_array = results[i];
                        // their should be only 1 wallet per database
                        var _iteratorNormalCompletion2 = true;
                        var _didIteratorError2 = false;
                        var _iteratorError2 = undefined;

                        try {
                            for (var _iterator2 = (0, _getIterator3.default)(wallet_array), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                var wallet = _step2.value;

                                wallet.backup_date = new Date().toISOString();
                            }
                        } catch (err) {
                            _didIteratorError2 = true;
                            _iteratorError2 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                                    _iterator2.return();
                                }
                            } finally {
                                if (_didIteratorError2) {
                                    throw _iteratorError2;
                                }
                            }
                        }
                    }
                    obj[store_name] = results[i];
                }
                return obj;
            });
        },
        restore: function restore(wallet_name, object) {
            var database_name = getDatabaseName(wallet_name);
            return openDatabase(database_name).then(function (db) {
                var store_names = (0, _keys2.default)(object);
                var trx = db.transaction(store_names, "readwrite");
                var _iteratorNormalCompletion3 = true;
                var _didIteratorError3 = false;
                var _iteratorError3 = undefined;

                try {
                    for (var _iterator3 = (0, _getIterator3.default)(store_names), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                        var store_name = _step3.value;

                        var store = trx.objectStore(store_name);

                        var records = object[store_name];
                        var _iteratorNormalCompletion4 = true;
                        var _didIteratorError4 = false;
                        var _iteratorError4 = undefined;

                        try {
                            for (var _iterator4 = (0, _getIterator3.default)(records), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                                var record = _step4.value;

                                store.put(record);
                            }
                        } catch (err) {
                            _didIteratorError4 = true;
                            _iteratorError4 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion4 && _iterator4.return) {
                                    _iterator4.return();
                                }
                            } finally {
                                if (_didIteratorError4) {
                                    throw _iteratorError4;
                                }
                            }
                        }
                    }
                } catch (err) {
                    _didIteratorError3 = true;
                    _iteratorError3 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion3 && _iterator3.return) {
                            _iterator3.return();
                        }
                    } finally {
                        if (_didIteratorError3) {
                            throw _iteratorError3;
                        }
                    }
                }

                return _idbHelper2.default.on_transaction_end(trx);
            });
        }
    };
}();

exports.default = iDB;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

var isNil = __webpack_require__(53);
var isArray = __webpack_require__(62);

module.exports = function isObject(x) {
  return !isNil(x) && typeof x === 'object' && !isArray(x);
};

/***/ }),
/* 62 */
/***/ (function(module, exports) {

module.exports = function isArray(x) {
  return Array.isArray ? Array.isArray(x) : x instanceof Array;
};

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

var assert = __webpack_require__(20);
var Boolean = __webpack_require__(398);
var isType = __webpack_require__(37);
var getTypeName = __webpack_require__(35);

// return true if the type constructor behaves like the identity function
module.exports = function isIdentity(type) {
  if (isType(type)) {
    if (true) {
      assert(Boolean.is(type.meta.identity), function () { return 'Invalid meta identity ' + assert.stringify(type.meta.identity) + ' supplied to type ' + getTypeName(type); });
    }
    return type.meta.identity;
  }
  // for tcomb the other constructors, like ES6 classes, are identity-like
  return true;
};

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

var isType = __webpack_require__(37);
var getFunctionName = __webpack_require__(132);
var assert = __webpack_require__(20);
var stringify = __webpack_require__(397);

// creates an instance of a type, handling the optional new operator
module.exports = function create(type, value, path) {
  if (isType(type)) {
    return !type.meta.identity && typeof value === 'object' && value !== null ? new type(value, path): type(value, path);
  }

  if (true) {
    // here type should be a class constructor and value some instance, just check membership and return the value
    path = path || [getFunctionName(type)];
    assert(value instanceof type, function () { return 'Invalid value ' + stringify(value) + ' supplied to ' + path.join('/'); });
  }

  return value;
};

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

var isType = __webpack_require__(37);

// returns true if x is an instance of type
module.exports = function is(x, type) {
  if (isType(type)) {
    return type.is(x);
  }
  return x instanceof type; // type should be a class constructor
};


/***/ }),
/* 66 */,
/* 67 */,
/* 68 */,
/* 69 */,
/* 70 */,
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */,
/* 77 */,
/* 78 */,
/* 79 */,
/* 80 */,
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory();
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define([], factory);
	}
	else {
		// Global (browser)
		root.CryptoJS = factory();
	}
}(this, function () {

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {
	    /*
	     * Local polyfil of Object.create
	     */
	    var create = Object.create || (function () {
	        function F() {};

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }())

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var i = 0; i < thatSigBytes; i += 4) {
	                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            var r = (function (m_w) {
	                var m_w = m_w;
	                var m_z = 0x3ade68b1;
	                var mask = 0xffffffff;

	                return function () {
	                    m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;
	                    m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;
	                    var result = ((m_z << 0x10) + m_w) & mask;
	                    result /= 0x100000000;
	                    result += 0.5;
	                    return result * (Math.random() > .5 ? 1 : -1);
	                }
	            });

	            for (var i = 0, rcache; i < nBytes; i += 4) {
	                var _r = r((rcache || Math.random()) * 0x100000000);

	                rcache = _r() * 0x3ade67b7;
	                words.push((_r() * 0x100000000) | 0);
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                var processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));

/***/ }),
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _isIterable2 = __webpack_require__(435);

var _isIterable3 = _interopRequireDefault(_isIterable2);

var _getIterator2 = __webpack_require__(52);

var _getIterator3 = _interopRequireDefault(_getIterator2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if ((0, _isIterable3.default)(Object(arr))) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

/***/ }),
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.get_translation_parts = exports.getRandomKey = exports.balancesToObject = exports.decryptMemo = exports.encryptMemo = exports.calcPortfolioData = exports.calcPercentChange = exports.formatPrices = exports.getPrices = exports.myTrim = exports.arrayToObject = exports.testNodesPings = undefined;

var _regenerator = __webpack_require__(3);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _bcxjsCores = __webpack_require__(7);

var _nodesManager = __webpack_require__(387);

var _nodesManager2 = _interopRequireDefault(_nodesManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var testNodesPings = exports.testNodesPings = function _callee(nodes) {
  var ws_node_list, testNodes;
  return _regenerator2.default.async(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:

          // return new Promise(resolve=>{
          //     var pingWorker = require("bcl-worker-loader?name=pingWorker.js!../services/workers/pingWorker.js")
          //     var worker = new pingWorker;
          //     worker.postMessage({
          //       nodes
          //     });

          //     worker.onmessage = event => {
          //       var res = event.data;
          //       console.info("res",res);
          //       resolve(res);
          //     }
          // })
          // nodes=nodes.filter(item=>item.url!=selectedNode.url)
          ws_node_list = {};

          nodes.forEach(function (node) {
            ws_node_list[node.url] = { location: node.name };
          });

          _context.next = 4;
          return _regenerator2.default.awrap(new _nodesManager2.default({
            nodes: ws_node_list,
            defaultNode: ""
          }).testNodesPings());

        case 4:
          testNodes = _context.sent;
          return _context.abrupt('return', testNodes);

        case 6:
        case 'end':
          return _context.stop();
      }
    }
  }, null, undefined);
};
/**
 * Return object with keys = id of each element of array (element.id)
 * @param {Array} array - array of data elements
 */
var arrayToObject = exports.arrayToObject = function arrayToObject(array) {
  var obj = {};
  array.forEach(function (item) {
    obj[item.id] = item;
    obj[item.symbol] = item;
  });
  return obj;
};

var myTrim = exports.myTrim = function myTrim(str) {
  return x.replace(/^\s+|\s+$/gm, '');
};

/**
 * Returns array containing first and last history prices of asset.
 * @param {Array} history - array with asset's history data
 */
var getPrices = exports.getPrices = function getPrices(history) {
  if (!history.length) return { first: 0, last: 0 };
  var startElem = history[0];
  var endElem = history[history.length - 1];
  var startPrice = startElem.open_base / startElem.open_quote;
  var endPrice = endElem.close_base / endElem.close_quote;
  return { first: startPrice, last: endPrice };
};

/**
 * Returns formatted prices for array calculated taking precision of assets into account
 * @param {Object} prices - object with asset's history prices
 * @param {number} prices.first - first price of asset history
 * @param {number} prices.last - last price of asset history (current)
 * @param {Object} base - base asset object
 * @param {Object} quote - quote asset object
 */
var formatPrices = exports.formatPrices = function formatPrices(prices, base, quote) {
  var precisionDiff = base.precision - quote.precision;
  if (precisionDiff > 0) {
    // prices.first /= (precisionDiff * 10);
    // prices.last /= (precisionDiff * 10);
    prices.first /= Math.pow(10, precisionDiff);
    prices.last /= Math.pow(10, precisionDiff);

    // prices.last /= (precisionDiff * 10);
  } else if (precisionDiff < 0) {
    // prices.first = prices.first * 10 * precisionDiff;
    // prices.last = prices.last * 10 * precisionDiff;
    prices.first = prices.first * Math.pow(10, precisionDiff);
    prices.last = prices.last * Math.pow(10, precisionDiff);
  }

  prices.change = Math.floor(prices.last / prices.first * 100 - 100);
  prices.first = Math.abs(prices.first);
  prices.last = Math.abs(prices.last);
  return prices;
};

/**
 * Returns amount of change by percent, calculated by prices history and exchange multiplier
 * @param {Object} object.prices - object with asset's history prices
 * @param {number} object.prices.first - first price of asset history
 * @param {number} object.prices.last - last price of asset history (current)
 * @param {Object} object.multiplier - object with base -> fiat exchange rates
 * @param {number} object.multiplier.first - multiplier for first history price
 * @param {number} object.multiplier.last - multiplier for last history price (current)
 */
var calcPercentChange = exports.calcPercentChange = function calcPercentChange(prices, multiplier) {
  return prices.first * multiplier.first / (prices.last * multiplier.last) * 100 - 100;
};

/**
 * Returns object with balance in base currency, balance in fiat currency
  and change by percent
 * @param {Object} object - object containing data for calculation
 * @param {number} object.balance - balance of asset
 * @param {Object} object.assetPrices - object with asset's history prices
 * @param {number} object.assetPrices.first - first price of asset history
 * @param {number} object.assetPrices.last - last price of asset history (current)
 * @param {Object} object.fiatMultiplier - object with base -> fiat exchange rates
 * @param {number} object.fiatMultiplier.first - multiplier for first history price
 * @param {number} object.fiatMultiplier.last - multiplier for last history price (current)
 * @param {Boolean} object.isBase - the asset for calculation is base asset
 * @param {Boolean} object.isFiat - the asset for calculation is fiat asset
 */
var calcPortfolioData = exports.calcPortfolioData = function calcPortfolioData(_ref) {
  var balance = _ref.balance,
      assetPrices = _ref.assetPrices,
      fiatMultiplier = _ref.fiatMultiplier,
      isBase = _ref.isBase,
      isFiat = _ref.isFiat;

  var multiplier = fiatMultiplier;
  var prices = assetPrices;
  if (isFiat) multiplier = { first: 1, last: 1 };
  if (isBase) prices = { first: 1, last: 1 };
  var balanceBase = balance * prices.last;
  var balanceFiat = balanceBase * multiplier.last;
  var change = calcPercentChange(prices, multiplier);
  if (prices.last === prices.first && !isBase) change = 0;
  return { balanceBase: balanceBase, balanceFiat: balanceFiat, change: change };
};

var encryptMemo = exports.encryptMemo = function encryptMemo(memo, fromKey, toPubkey) {
  var nonce = _bcxjsCores.TransactionHelper.unique_nonce_uint64();
  var activePubkey = fromKey.toPublicKey().toPublicKeyString();

  var message = _bcxjsCores.Aes.encrypt_with_checksum(fromKey, toPubkey, nonce, memo);

  return {
    from: activePubkey,
    to: toPubkey,
    nonce: nonce,
    message: message
  };
};

var decryptMemo = exports.decryptMemo = function decryptMemo(memo, privateKey) {
  return _bcxjsCores.Aes.decrypt_with_checksum(privateKey, memo.from, memo.nonce, memo.message).toString('utf-8');
};

var balancesToObject = exports.balancesToObject = function balancesToObject(balancesArr) {
  var obj = {};
  balancesArr.forEach(function (item) {
    obj[item.asset_type] = item;
  });
  return obj;
};

var getRandomKey = exports.getRandomKey = function getRandomKey() {
  return _bcxjsCores.key.get_random_key();
};

var get_translation_parts = exports.get_translation_parts = function get_translation_parts(str) {
  var result = [];
  var toReplace = {};
  var re = /\((.*?)\)/g;
  var interpolators = str.split(re);
  return str.split(re);
};

Date.prototype.format = function (format) {
  if (!format) return "";
  var o = {
    "M+": this.getMonth() + 1, // month
    "d+": this.getDate(), // day
    "H+": this.getHours(), // hour
    "m+": this.getMinutes(), // minute
    "s+": this.getSeconds(), // second
    "q+": Math.floor((this.getMonth() + 3) / 3), // quarter
    "S": this.getMilliseconds()
    // millisecond
  };
  if (/(y+)/.test(format)) format = format.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
  for (var k in o) {
    if (new RegExp("(" + k + ")").test(format)) format = format.replace(RegExp.$1, RegExp.$1.length == 1 ? o[k] : ("00" + o[k]).substr(("" + o[k]).length));
  }return format;
};

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

exports.__esModule = true;

var _bigi = __webpack_require__(57);

var _bigi2 = _interopRequireDefault(_bigi);

var _ecurve = __webpack_require__(215);

var _bs = __webpack_require__(216);

var _hash = __webpack_require__(58);

var _bcxjsWs = __webpack_require__(8);

var _assert = __webpack_require__(45);

var _assert2 = _interopRequireDefault(_assert);

var _deepEqual = __webpack_require__(217);

var _deepEqual2 = _interopRequireDefault(_deepEqual);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var secp256k1 = (0, _ecurve.getCurveByName)("secp256k1");
var G = secp256k1.G,
    n = secp256k1.n;

var PublicKey = function () {
    /** @param {Point} public key */
    function PublicKey(Q) {
        _classCallCheck(this, PublicKey);

        this.Q = Q;
    }

    PublicKey.fromBinary = function fromBinary(bin) {
        return PublicKey.fromBuffer(new Buffer(bin, "binary"));
    };

    PublicKey.fromBuffer = function fromBuffer(buffer) {
        if (buffer.toString("hex") === "000000000000000000000000000000000000000000000000000000000000000000") return new PublicKey(null);
        return new PublicKey(_ecurve.Point.decodeFrom(secp256k1, buffer));
    };

    PublicKey.prototype.toBuffer = function toBuffer() {
        var compressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.Q ? this.Q.compressed : null;

        if (this.Q === null) return new Buffer("000000000000000000000000000000000000000000000000000000000000000000", "hex");
        return this.Q.getEncoded(compressed);
    };

    PublicKey.fromPoint = function fromPoint(point) {
        return new PublicKey(point);
    };

    PublicKey.prototype.toUncompressed = function toUncompressed() {
        var buf = this.Q.getEncoded(false);
        var point = _ecurve.Point.decodeFrom(secp256k1, buf);
        return PublicKey.fromPoint(point);
    };

    /** gph::blockchain::address (unique but not a full public key) */


    PublicKey.prototype.toBlockchainAddress = function toBlockchainAddress() {
        var pub_buf = this.toBuffer();
        var pub_sha = (0, _hash.sha512)(pub_buf);
        return (0, _hash.ripemd160)(pub_sha);
    };

    /** Alias for {@link toPublicKeyString} */


    PublicKey.prototype.toString = function toString() {
        var address_prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _bcxjsWs.ChainConfig.address_prefix;

        return this.toPublicKeyString(address_prefix);
    };

    /**
        Full public key
        {return} string
    */


    PublicKey.prototype.toPublicKeyString = function toPublicKeyString() {
        var address_prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _bcxjsWs.ChainConfig.address_prefix;

        var pub_buf = this.toBuffer();
        var checksum = (0, _hash.ripemd160)(pub_buf);
        var addy = Buffer.concat([pub_buf, checksum.slice(0, 4)]);
        return address_prefix + (0, _bs.encode)(addy);
    };

    /**
        @arg {string} public_key - like GPHXyz...
        @arg {string} address_prefix - like GPH
        @return PublicKey or `null` (if the public_key string is invalid)
    */


    PublicKey.fromPublicKeyString = function fromPublicKeyString(public_key) {
        var address_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _bcxjsWs.ChainConfig.address_prefix;

        try {
            return PublicKey.fromStringOrThrow(public_key, address_prefix);
        } catch (e) {
            return null;
        }
    };

    /**
        @arg {string} public_key - like GPHXyz...
        @arg {string} address_prefix - like GPH
        @throws {Error} if public key is invalid
        @return PublicKey
    */


    PublicKey.fromStringOrThrow = function fromStringOrThrow(public_key) {
        var address_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _bcxjsWs.ChainConfig.address_prefix;

        if (public_key.Q === null) public_key = address_prefix + "1111111111111111111111111111111114T1Anm"; // null key
        var prefix = public_key.slice(0, address_prefix.length);
        _assert2.default.equal(address_prefix, prefix, "Expecting key to begin with " + address_prefix + ", instead got " + prefix);
        public_key = public_key.slice(address_prefix.length);

        public_key = new Buffer((0, _bs.decode)(public_key), "binary");
        var checksum = public_key.slice(-4);
        public_key = public_key.slice(0, -4);
        var new_checksum = (0, _hash.ripemd160)(public_key);
        new_checksum = new_checksum.slice(0, 4);
        var isEqual = (0, _deepEqual2.default)(checksum, new_checksum); //, 'Invalid checksum'
        if (!isEqual) {
            throw new Error("Checksum did not match");
        }
        return PublicKey.fromBuffer(public_key);
    };

    PublicKey.prototype.toAddressString = function toAddressString() {
        var address_prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _bcxjsWs.ChainConfig.address_prefix;

        var pub_buf = this.toBuffer();
        var pub_sha = (0, _hash.sha512)(pub_buf);
        var addy = (0, _hash.ripemd160)(pub_sha);
        var checksum = (0, _hash.ripemd160)(addy);
        addy = Buffer.concat([addy, checksum.slice(0, 4)]);
        return address_prefix + (0, _bs.encode)(addy);
    };

    PublicKey.prototype.toPtsAddy = function toPtsAddy() {
        var pub_buf = this.toBuffer();
        var pub_sha = (0, _hash.sha256)(pub_buf);
        var addy = (0, _hash.ripemd160)(pub_sha);
        addy = Buffer.concat([new Buffer([0x38]), addy]); //version 56(decimal)

        var checksum = (0, _hash.sha256)(addy);
        checksum = (0, _hash.sha256)(checksum);

        addy = Buffer.concat([addy, checksum.slice(0, 4)]);
        return (0, _bs.encode)(addy);
    };

    PublicKey.prototype.child = function child(offset) {
        (0, _assert2.default)(Buffer.isBuffer(offset), "Buffer required: offset");
        _assert2.default.equal(offset.length, 32, "offset length");

        offset = Buffer.concat([this.toBuffer(), offset]);
        offset = (0, _hash.sha256)(offset);

        var c = _bigi2.default.fromBuffer(offset);

        if (c.compareTo(n) >= 0) throw new Error("Child offset went out of bounds, try again");

        var cG = G.multiply(c);
        var Qprime = this.Q.add(cG);

        if (secp256k1.isInfinity(Qprime)) throw new Error("Child offset derived to an invalid key, try again");

        return PublicKey.fromPoint(Qprime);
    };

    /* <HEX> */

    PublicKey.prototype.toByteBuffer = function toByteBuffer() {
        var b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);
        this.appendByteBuffer(b);
        return b.copy(0, b.offset);
    };

    PublicKey.fromHex = function fromHex(hex) {
        return PublicKey.fromBuffer(new Buffer(hex, "hex"));
    };

    PublicKey.prototype.toHex = function toHex() {
        return this.toBuffer().toString("hex");
    };

    PublicKey.fromPublicKeyStringHex = function fromPublicKeyStringHex(hex) {
        return PublicKey.fromPublicKeyString(new Buffer(hex, "hex"));
    };

    /* </HEX> */


    return PublicKey;
}();

exports.default = PublicKey;
module.exports = exports["default"];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */,
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 Copyright 2013-2014 Daniel Wirtz <dcode@dcode.io>

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**
 * @license bytebuffer.js (c) 2015 Daniel Wirtz <dcode@dcode.io>
 * Backing buffer: ArrayBuffer, Accessor: Uint8Array
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/bytebuffer.js for details
 */
(function(global, factory) {

    /* AMD */ if (true)
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(445)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    /* CommonJS */ else if (typeof require === 'function' && typeof module === "object" && module && module["exports"])
        module['exports'] = (function() {
            var Long; try { Long = require("long"); } catch (e) {}
            return factory(Long);
        })();
    /* Global */ else
        (global["dcodeIO"] = global["dcodeIO"] || {})["ByteBuffer"] = factory(global["dcodeIO"]["Long"]);

})(this, function(Long) {
    "use strict";

    /**
     * Constructs a new ByteBuffer.
     * @class The swiss army knife for binary data in JavaScript.
     * @exports ByteBuffer
     * @constructor
     * @param {number=} capacity Initial capacity. Defaults to {@link ByteBuffer.DEFAULT_CAPACITY}.
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @expose
     */
    var ByteBuffer = function(capacity, littleEndian, noAssert) {
        if (typeof capacity === 'undefined')
            capacity = ByteBuffer.DEFAULT_CAPACITY;
        if (typeof littleEndian === 'undefined')
            littleEndian = ByteBuffer.DEFAULT_ENDIAN;
        if (typeof noAssert === 'undefined')
            noAssert = ByteBuffer.DEFAULT_NOASSERT;
        if (!noAssert) {
            capacity = capacity | 0;
            if (capacity < 0)
                throw RangeError("Illegal capacity");
            littleEndian = !!littleEndian;
            noAssert = !!noAssert;
        }

        /**
         * Backing ArrayBuffer.
         * @type {!ArrayBuffer}
         * @expose
         */
        this.buffer = capacity === 0 ? EMPTY_BUFFER : new ArrayBuffer(capacity);

        /**
         * Uint8Array utilized to manipulate the backing buffer. Becomes `null` if the backing buffer has a capacity of `0`.
         * @type {?Uint8Array}
         * @expose
         */
        this.view = capacity === 0 ? null : new Uint8Array(this.buffer);

        /**
         * Absolute read/write offset.
         * @type {number}
         * @expose
         * @see ByteBuffer#flip
         * @see ByteBuffer#clear
         */
        this.offset = 0;

        /**
         * Marked offset.
         * @type {number}
         * @expose
         * @see ByteBuffer#mark
         * @see ByteBuffer#reset
         */
        this.markedOffset = -1;

        /**
         * Absolute limit of the contained data. Set to the backing buffer's capacity upon allocation.
         * @type {number}
         * @expose
         * @see ByteBuffer#flip
         * @see ByteBuffer#clear
         */
        this.limit = capacity;

        /**
         * Whether to use little endian byte order, defaults to `false` for big endian.
         * @type {boolean}
         * @expose
         */
        this.littleEndian = littleEndian;

        /**
         * Whether to skip assertions of offsets and values, defaults to `false`.
         * @type {boolean}
         * @expose
         */
        this.noAssert = noAssert;
    };

    /**
     * ByteBuffer version.
     * @type {string}
     * @const
     * @expose
     */
    ByteBuffer.VERSION = "5.0.1";

    /**
     * Little endian constant that can be used instead of its boolean value. Evaluates to `true`.
     * @type {boolean}
     * @const
     * @expose
     */
    ByteBuffer.LITTLE_ENDIAN = true;

    /**
     * Big endian constant that can be used instead of its boolean value. Evaluates to `false`.
     * @type {boolean}
     * @const
     * @expose
     */
    ByteBuffer.BIG_ENDIAN = false;

    /**
     * Default initial capacity of `16`.
     * @type {number}
     * @expose
     */
    ByteBuffer.DEFAULT_CAPACITY = 16;

    /**
     * Default endianess of `false` for big endian.
     * @type {boolean}
     * @expose
     */
    ByteBuffer.DEFAULT_ENDIAN = ByteBuffer.BIG_ENDIAN;

    /**
     * Default no assertions flag of `false`.
     * @type {boolean}
     * @expose
     */
    ByteBuffer.DEFAULT_NOASSERT = false;

    /**
     * A `Long` class for representing a 64-bit two's-complement integer value. May be `null` if Long.js has not been loaded
     *  and int64 support is not available.
     * @type {?Long}
     * @const
     * @see https://github.com/dcodeIO/long.js
     * @expose
     */
    ByteBuffer.Long = Long || null;

    /**
     * @alias ByteBuffer.prototype
     * @inner
     */
    var ByteBufferPrototype = ByteBuffer.prototype;

    /**
     * An indicator used to reliably determine if an object is a ByteBuffer or not.
     * @type {boolean}
     * @const
     * @expose
     * @private
     */
    ByteBufferPrototype.__isByteBuffer__;

    Object.defineProperty(ByteBufferPrototype, "__isByteBuffer__", {
        value: true,
        enumerable: false,
        configurable: false
    });

    // helpers

    /**
     * @type {!ArrayBuffer}
     * @inner
     */
    var EMPTY_BUFFER = new ArrayBuffer(0);

    /**
     * String.fromCharCode reference for compile-time renaming.
     * @type {function(...number):string}
     * @inner
     */
    var stringFromCharCode = String.fromCharCode;

    /**
     * Creates a source function for a string.
     * @param {string} s String to read from
     * @returns {function():number|null} Source function returning the next char code respectively `null` if there are
     *  no more characters left.
     * @throws {TypeError} If the argument is invalid
     * @inner
     */
    function stringSource(s) {
        var i=0; return function() {
            return i < s.length ? s.charCodeAt(i++) : null;
        };
    }

    /**
     * Creates a destination function for a string.
     * @returns {function(number=):undefined|string} Destination function successively called with the next char code.
     *  Returns the final string when called without arguments.
     * @inner
     */
    function stringDestination() {
        var cs = [], ps = []; return function() {
            if (arguments.length === 0)
                return ps.join('')+stringFromCharCode.apply(String, cs);
            if (cs.length + arguments.length > 1024)
                ps.push(stringFromCharCode.apply(String, cs)),
                    cs.length = 0;
            Array.prototype.push.apply(cs, arguments);
        };
    }

    /**
     * Gets the accessor type.
     * @returns {Function} `Buffer` under node.js, `Uint8Array` respectively `DataView` in the browser (classes)
     * @expose
     */
    ByteBuffer.accessor = function() {
        return Uint8Array;
    };
    /**
     * Allocates a new ByteBuffer backed by a buffer of the specified capacity.
     * @param {number=} capacity Initial capacity. Defaults to {@link ByteBuffer.DEFAULT_CAPACITY}.
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer}
     * @expose
     */
    ByteBuffer.allocate = function(capacity, littleEndian, noAssert) {
        return new ByteBuffer(capacity, littleEndian, noAssert);
    };

    /**
     * Concatenates multiple ByteBuffers into one.
     * @param {!Array.<!ByteBuffer|!ArrayBuffer|!Uint8Array|string>} buffers Buffers to concatenate
     * @param {(string|boolean)=} encoding String encoding if `buffers` contains a string ("base64", "hex", "binary",
     *  defaults to "utf8")
     * @param {boolean=} littleEndian Whether to use little or big endian byte order for the resulting ByteBuffer. Defaults
     *  to {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values for the resulting ByteBuffer. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} Concatenated ByteBuffer
     * @expose
     */
    ByteBuffer.concat = function(buffers, encoding, littleEndian, noAssert) {
        if (typeof encoding === 'boolean' || typeof encoding !== 'string') {
            noAssert = littleEndian;
            littleEndian = encoding;
            encoding = undefined;
        }
        var capacity = 0;
        for (var i=0, k=buffers.length, length; i<k; ++i) {
            if (!ByteBuffer.isByteBuffer(buffers[i]))
                buffers[i] = ByteBuffer.wrap(buffers[i], encoding);
            length = buffers[i].limit - buffers[i].offset;
            if (length > 0) capacity += length;
        }
        if (capacity === 0)
            return new ByteBuffer(0, littleEndian, noAssert);
        var bb = new ByteBuffer(capacity, littleEndian, noAssert),
            bi;
        i=0; while (i<k) {
            bi = buffers[i++];
            length = bi.limit - bi.offset;
            if (length <= 0) continue;
            bb.view.set(bi.view.subarray(bi.offset, bi.limit), bb.offset);
            bb.offset += length;
        }
        bb.limit = bb.offset;
        bb.offset = 0;
        return bb;
    };

    /**
     * Tests if the specified type is a ByteBuffer.
     * @param {*} bb ByteBuffer to test
     * @returns {boolean} `true` if it is a ByteBuffer, otherwise `false`
     * @expose
     */
    ByteBuffer.isByteBuffer = function(bb) {
        return (bb && bb["__isByteBuffer__"]) === true;
    };
    /**
     * Gets the backing buffer type.
     * @returns {Function} `Buffer` under node.js, `ArrayBuffer` in the browser (classes)
     * @expose
     */
    ByteBuffer.type = function() {
        return ArrayBuffer;
    };
    /**
     * Wraps a buffer or a string. Sets the allocated ByteBuffer's {@link ByteBuffer#offset} to `0` and its
     *  {@link ByteBuffer#limit} to the length of the wrapped data.
     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string|!Array.<number>} buffer Anything that can be wrapped
     * @param {(string|boolean)=} encoding String encoding if `buffer` is a string ("base64", "hex", "binary", defaults to
     *  "utf8")
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} A ByteBuffer wrapping `buffer`
     * @expose
     */
    ByteBuffer.wrap = function(buffer, encoding, littleEndian, noAssert) {
        if (typeof encoding !== 'string') {
            noAssert = littleEndian;
            littleEndian = encoding;
            encoding = undefined;
        }
        if (typeof buffer === 'string') {
            if (typeof encoding === 'undefined')
                encoding = "utf8";
            switch (encoding) {
                case "base64":
                    return ByteBuffer.fromBase64(buffer, littleEndian);
                case "hex":
                    return ByteBuffer.fromHex(buffer, littleEndian);
                case "binary":
                    return ByteBuffer.fromBinary(buffer, littleEndian);
                case "utf8":
                    return ByteBuffer.fromUTF8(buffer, littleEndian);
                case "debug":
                    return ByteBuffer.fromDebug(buffer, littleEndian);
                default:
                    throw Error("Unsupported encoding: "+encoding);
            }
        }
        if (buffer === null || typeof buffer !== 'object')
            throw TypeError("Illegal buffer");
        var bb;
        if (ByteBuffer.isByteBuffer(buffer)) {
            bb = ByteBufferPrototype.clone.call(buffer);
            bb.markedOffset = -1;
            return bb;
        }
        if (buffer instanceof Uint8Array) { // Extract ArrayBuffer from Uint8Array
            bb = new ByteBuffer(0, littleEndian, noAssert);
            if (buffer.length > 0) { // Avoid references to more than one EMPTY_BUFFER
                bb.buffer = buffer.buffer;
                bb.offset = buffer.byteOffset;
                bb.limit = buffer.byteOffset + buffer.byteLength;
                bb.view = new Uint8Array(buffer.buffer);
            }
        } else if (buffer instanceof ArrayBuffer) { // Reuse ArrayBuffer
            bb = new ByteBuffer(0, littleEndian, noAssert);
            if (buffer.byteLength > 0) {
                bb.buffer = buffer;
                bb.offset = 0;
                bb.limit = buffer.byteLength;
                bb.view = buffer.byteLength > 0 ? new Uint8Array(buffer) : null;
            }
        } else if (Object.prototype.toString.call(buffer) === "[object Array]") { // Create from octets
            bb = new ByteBuffer(buffer.length, littleEndian, noAssert);
            bb.limit = buffer.length;
            for (var i=0; i<buffer.length; ++i)
                bb.view[i] = buffer[i];
        } else
            throw TypeError("Illegal buffer"); // Otherwise fail
        return bb;
    };

    /**
     * Writes the array as a bitset.
     * @param {Array<boolean>} value Array of booleans to write
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
     * @returns {!ByteBuffer}
     * @expose
     */
    ByteBufferPrototype.writeBitSet = function(value, offset) {
      var relative = typeof offset === 'undefined';
      if (relative) offset = this.offset;
      if (!this.noAssert) {
        if (!(value instanceof Array))
          throw TypeError("Illegal BitSet: Not an array");
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset >>>= 0;
        if (offset < 0 || offset + 0 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
      }

      var start = offset,
          bits = value.length,
          bytes = (bits >> 3),
          bit = 0,
          k;

      offset += this.writeVarint32(bits,offset);

      while(bytes--) {
        k = (!!value[bit++] & 1) |
            ((!!value[bit++] & 1) << 1) |
            ((!!value[bit++] & 1) << 2) |
            ((!!value[bit++] & 1) << 3) |
            ((!!value[bit++] & 1) << 4) |
            ((!!value[bit++] & 1) << 5) |
            ((!!value[bit++] & 1) << 6) |
            ((!!value[bit++] & 1) << 7);
        this.writeByte(k,offset++);
      }

      if(bit < bits) {
        var m = 0; k = 0;
        while(bit < bits) k = k | ((!!value[bit++] & 1) << (m++));
        this.writeByte(k,offset++);
      }

      if (relative) {
        this.offset = offset;
        return this;
      }
      return offset - start;
    }

    /**
     * Reads a BitSet as an array of booleans.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
     * @returns {Array<boolean>
     * @expose
     */
    ByteBufferPrototype.readBitSet = function(offset) {
      var relative = typeof offset === 'undefined';
      if (relative) offset = this.offset;

      var ret = this.readVarint32(offset),
          bits = ret.value,
          bytes = (bits >> 3),
          bit = 0,
          value = [],
          k;

      offset += ret.length;

      while(bytes--) {
        k = this.readByte(offset++);
        value[bit++] = !!(k & 0x01);
        value[bit++] = !!(k & 0x02);
        value[bit++] = !!(k & 0x04);
        value[bit++] = !!(k & 0x08);
        value[bit++] = !!(k & 0x10);
        value[bit++] = !!(k & 0x20);
        value[bit++] = !!(k & 0x40);
        value[bit++] = !!(k & 0x80);
      }

      if(bit < bits) {
        var m = 0;
        k = this.readByte(offset++);
        while(bit < bits) value[bit++] = !!((k >> (m++)) & 1);
      }

      if (relative) {
        this.offset = offset;
      }
      return value;
    }
    /**
     * Reads the specified number of bytes.
     * @param {number} length Number of bytes to read
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
     * @returns {!ByteBuffer}
     * @expose
     */
    ByteBufferPrototype.readBytes = function(length, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + length > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+length+") <= "+this.buffer.byteLength);
        }
        var slice = this.slice(offset, offset + length);
        if (relative) this.offset += length;
        return slice;
    };

    /**
     * Writes a payload of bytes. This is an alias of {@link ByteBuffer#append}.
     * @function
     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string} source Data to write. If `source` is a ByteBuffer, its offsets
     *  will be modified according to the performed read operation.
     * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeBytes = ByteBufferPrototype.append;

    // types/ints/int8

    /**
     * Writes an 8bit signed integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeInt8 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 1;
        var capacity0 = this.buffer.byteLength;
        if (offset > capacity0)
            this.resize((capacity0 *= 2) > offset ? capacity0 : offset);
        offset -= 1;
        this.view[offset] = value;
        if (relative) this.offset += 1;
        return this;
    };

    /**
     * Writes an 8bit signed integer. This is an alias of {@link ByteBuffer#writeInt8}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeByte = ByteBufferPrototype.writeInt8;

    /**
     * Reads an 8bit signed integer.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readInt8 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var value = this.view[offset];
        if ((value & 0x80) === 0x80) value = -(0xFF - value + 1); // Cast to signed
        if (relative) this.offset += 1;
        return value;
    };

    /**
     * Reads an 8bit signed integer. This is an alias of {@link ByteBuffer#readInt8}.
     * @function
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readByte = ByteBufferPrototype.readInt8;

    /**
     * Writes an 8bit unsigned integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeUint8 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value >>>= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 1;
        var capacity1 = this.buffer.byteLength;
        if (offset > capacity1)
            this.resize((capacity1 *= 2) > offset ? capacity1 : offset);
        offset -= 1;
        this.view[offset] = value;
        if (relative) this.offset += 1;
        return this;
    };

    /**
     * Writes an 8bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint8}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeUInt8 = ByteBufferPrototype.writeUint8;

    /**
     * Reads an 8bit unsigned integer.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readUint8 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var value = this.view[offset];
        if (relative) this.offset += 1;
        return value;
    };

    /**
     * Reads an 8bit unsigned integer. This is an alias of {@link ByteBuffer#readUint8}.
     * @function
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readUInt8 = ByteBufferPrototype.readUint8;

    // types/ints/int16

    /**
     * Writes a 16bit signed integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @throws {TypeError} If `offset` or `value` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.writeInt16 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 2;
        var capacity2 = this.buffer.byteLength;
        if (offset > capacity2)
            this.resize((capacity2 *= 2) > offset ? capacity2 : offset);
        offset -= 2;
        if (this.littleEndian) {
            this.view[offset+1] = (value & 0xFF00) >>> 8;
            this.view[offset  ] =  value & 0x00FF;
        } else {
            this.view[offset]   = (value & 0xFF00) >>> 8;
            this.view[offset+1] =  value & 0x00FF;
        }
        if (relative) this.offset += 2;
        return this;
    };

    /**
     * Writes a 16bit signed integer. This is an alias of {@link ByteBuffer#writeInt16}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @throws {TypeError} If `offset` or `value` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.writeShort = ByteBufferPrototype.writeInt16;

    /**
     * Reads a 16bit signed integer.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @returns {number} Value read
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.readInt16 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 2 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+2+") <= "+this.buffer.byteLength);
        }
        var value = 0;
        if (this.littleEndian) {
            value  = this.view[offset  ];
            value |= this.view[offset+1] << 8;
        } else {
            value  = this.view[offset  ] << 8;
            value |= this.view[offset+1];
        }
        if ((value & 0x8000) === 0x8000) value = -(0xFFFF - value + 1); // Cast to signed
        if (relative) this.offset += 2;
        return value;
    };

    /**
     * Reads a 16bit signed integer. This is an alias of {@link ByteBuffer#readInt16}.
     * @function
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @returns {number} Value read
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.readShort = ByteBufferPrototype.readInt16;

    /**
     * Writes a 16bit unsigned integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @throws {TypeError} If `offset` or `value` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.writeUint16 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value >>>= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 2;
        var capacity3 = this.buffer.byteLength;
        if (offset > capacity3)
            this.resize((capacity3 *= 2) > offset ? capacity3 : offset);
        offset -= 2;
        if (this.littleEndian) {
            this.view[offset+1] = (value & 0xFF00) >>> 8;
            this.view[offset  ] =  value & 0x00FF;
        } else {
            this.view[offset]   = (value & 0xFF00) >>> 8;
            this.view[offset+1] =  value & 0x00FF;
        }
        if (relative) this.offset += 2;
        return this;
    };

    /**
     * Writes a 16bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint16}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @throws {TypeError} If `offset` or `value` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.writeUInt16 = ByteBufferPrototype.writeUint16;

    /**
     * Reads a 16bit unsigned integer.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @returns {number} Value read
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.readUint16 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 2 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+2+") <= "+this.buffer.byteLength);
        }
        var value = 0;
        if (this.littleEndian) {
            value  = this.view[offset  ];
            value |= this.view[offset+1] << 8;
        } else {
            value  = this.view[offset  ] << 8;
            value |= this.view[offset+1];
        }
        if (relative) this.offset += 2;
        return value;
    };

    /**
     * Reads a 16bit unsigned integer. This is an alias of {@link ByteBuffer#readUint16}.
     * @function
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @returns {number} Value read
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.readUInt16 = ByteBufferPrototype.readUint16;

    // types/ints/int32

    /**
     * Writes a 32bit signed integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @expose
     */
    ByteBufferPrototype.writeInt32 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 4;
        var capacity4 = this.buffer.byteLength;
        if (offset > capacity4)
            this.resize((capacity4 *= 2) > offset ? capacity4 : offset);
        offset -= 4;
        if (this.littleEndian) {
            this.view[offset+3] = (value >>> 24) & 0xFF;
            this.view[offset+2] = (value >>> 16) & 0xFF;
            this.view[offset+1] = (value >>>  8) & 0xFF;
            this.view[offset  ] =  value         & 0xFF;
        } else {
            this.view[offset  ] = (value >>> 24) & 0xFF;
            this.view[offset+1] = (value >>> 16) & 0xFF;
            this.view[offset+2] = (value >>>  8) & 0xFF;
            this.view[offset+3] =  value         & 0xFF;
        }
        if (relative) this.offset += 4;
        return this;
    };

    /**
     * Writes a 32bit signed integer. This is an alias of {@link ByteBuffer#writeInt32}.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @expose
     */
    ByteBufferPrototype.writeInt = ByteBufferPrototype.writeInt32;

    /**
     * Reads a 32bit signed integer.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readInt32 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 4 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
        }
        var value = 0;
        if (this.littleEndian) {
            value  = this.view[offset+2] << 16;
            value |= this.view[offset+1] <<  8;
            value |= this.view[offset  ];
            value += this.view[offset+3] << 24 >>> 0;
        } else {
            value  = this.view[offset+1] << 16;
            value |= this.view[offset+2] <<  8;
            value |= this.view[offset+3];
            value += this.view[offset  ] << 24 >>> 0;
        }
        value |= 0; // Cast to signed
        if (relative) this.offset += 4;
        return value;
    };

    /**
     * Reads a 32bit signed integer. This is an alias of {@link ByteBuffer#readInt32}.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readInt = ByteBufferPrototype.readInt32;

    /**
     * Writes a 32bit unsigned integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @expose
     */
    ByteBufferPrototype.writeUint32 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value >>>= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 4;
        var capacity5 = this.buffer.byteLength;
        if (offset > capacity5)
            this.resize((capacity5 *= 2) > offset ? capacity5 : offset);
        offset -= 4;
        if (this.littleEndian) {
            this.view[offset+3] = (value >>> 24) & 0xFF;
            this.view[offset+2] = (value >>> 16) & 0xFF;
            this.view[offset+1] = (value >>>  8) & 0xFF;
            this.view[offset  ] =  value         & 0xFF;
        } else {
            this.view[offset  ] = (value >>> 24) & 0xFF;
            this.view[offset+1] = (value >>> 16) & 0xFF;
            this.view[offset+2] = (value >>>  8) & 0xFF;
            this.view[offset+3] =  value         & 0xFF;
        }
        if (relative) this.offset += 4;
        return this;
    };

    /**
     * Writes a 32bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint32}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @expose
     */
    ByteBufferPrototype.writeUInt32 = ByteBufferPrototype.writeUint32;

    /**
     * Reads a 32bit unsigned integer.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readUint32 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 4 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
        }
        var value = 0;
        if (this.littleEndian) {
            value  = this.view[offset+2] << 16;
            value |= this.view[offset+1] <<  8;
            value |= this.view[offset  ];
            value += this.view[offset+3] << 24 >>> 0;
        } else {
            value  = this.view[offset+1] << 16;
            value |= this.view[offset+2] <<  8;
            value |= this.view[offset+3];
            value += this.view[offset  ] << 24 >>> 0;
        }
        if (relative) this.offset += 4;
        return value;
    };

    /**
     * Reads a 32bit unsigned integer. This is an alias of {@link ByteBuffer#readUint32}.
     * @function
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readUInt32 = ByteBufferPrototype.readUint32;

    // types/ints/int64

    if (Long) {

        /**
         * Writes a 64bit signed integer.
         * @param {number|!Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeInt64 = function(value, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof value === 'number')
                    value = Long.fromNumber(value);
                else if (typeof value === 'string')
                    value = Long.fromString(value);
                else if (!(value && value instanceof Long))
                    throw TypeError("Illegal value: "+value+" (not an integer or Long)");
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            if (typeof value === 'number')
                value = Long.fromNumber(value);
            else if (typeof value === 'string')
                value = Long.fromString(value);
            offset += 8;
            var capacity6 = this.buffer.byteLength;
            if (offset > capacity6)
                this.resize((capacity6 *= 2) > offset ? capacity6 : offset);
            offset -= 8;
            var lo = value.low,
                hi = value.high;
            if (this.littleEndian) {
                this.view[offset+3] = (lo >>> 24) & 0xFF;
                this.view[offset+2] = (lo >>> 16) & 0xFF;
                this.view[offset+1] = (lo >>>  8) & 0xFF;
                this.view[offset  ] =  lo         & 0xFF;
                offset += 4;
                this.view[offset+3] = (hi >>> 24) & 0xFF;
                this.view[offset+2] = (hi >>> 16) & 0xFF;
                this.view[offset+1] = (hi >>>  8) & 0xFF;
                this.view[offset  ] =  hi         & 0xFF;
            } else {
                this.view[offset  ] = (hi >>> 24) & 0xFF;
                this.view[offset+1] = (hi >>> 16) & 0xFF;
                this.view[offset+2] = (hi >>>  8) & 0xFF;
                this.view[offset+3] =  hi         & 0xFF;
                offset += 4;
                this.view[offset  ] = (lo >>> 24) & 0xFF;
                this.view[offset+1] = (lo >>> 16) & 0xFF;
                this.view[offset+2] = (lo >>>  8) & 0xFF;
                this.view[offset+3] =  lo         & 0xFF;
            }
            if (relative) this.offset += 8;
            return this;
        };

        /**
         * Writes a 64bit signed integer. This is an alias of {@link ByteBuffer#writeInt64}.
         * @param {number|!Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeLong = ByteBufferPrototype.writeInt64;

        /**
         * Reads a 64bit signed integer.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}
         * @expose
         */
        ByteBufferPrototype.readInt64 = function(offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 8 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+8+") <= "+this.buffer.byteLength);
            }
            var lo = 0,
                hi = 0;
            if (this.littleEndian) {
                lo  = this.view[offset+2] << 16;
                lo |= this.view[offset+1] <<  8;
                lo |= this.view[offset  ];
                lo += this.view[offset+3] << 24 >>> 0;
                offset += 4;
                hi  = this.view[offset+2] << 16;
                hi |= this.view[offset+1] <<  8;
                hi |= this.view[offset  ];
                hi += this.view[offset+3] << 24 >>> 0;
            } else {
                hi  = this.view[offset+1] << 16;
                hi |= this.view[offset+2] <<  8;
                hi |= this.view[offset+3];
                hi += this.view[offset  ] << 24 >>> 0;
                offset += 4;
                lo  = this.view[offset+1] << 16;
                lo |= this.view[offset+2] <<  8;
                lo |= this.view[offset+3];
                lo += this.view[offset  ] << 24 >>> 0;
            }
            var value = new Long(lo, hi, false);
            if (relative) this.offset += 8;
            return value;
        };

        /**
         * Reads a 64bit signed integer. This is an alias of {@link ByteBuffer#readInt64}.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}
         * @expose
         */
        ByteBufferPrototype.readLong = ByteBufferPrototype.readInt64;

        /**
         * Writes a 64bit unsigned integer.
         * @param {number|!Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeUint64 = function(value, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof value === 'number')
                    value = Long.fromNumber(value);
                else if (typeof value === 'string')
                    value = Long.fromString(value);
                else if (!(value && value instanceof Long))
                    throw TypeError("Illegal value: "+value+" (not an integer or Long)");
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            if (typeof value === 'number')
                value = Long.fromNumber(value);
            else if (typeof value === 'string')
                value = Long.fromString(value);
            offset += 8;
            var capacity7 = this.buffer.byteLength;
            if (offset > capacity7)
                this.resize((capacity7 *= 2) > offset ? capacity7 : offset);
            offset -= 8;
            var lo = value.low,
                hi = value.high;
            if (this.littleEndian) {
                this.view[offset+3] = (lo >>> 24) & 0xFF;
                this.view[offset+2] = (lo >>> 16) & 0xFF;
                this.view[offset+1] = (lo >>>  8) & 0xFF;
                this.view[offset  ] =  lo         & 0xFF;
                offset += 4;
                this.view[offset+3] = (hi >>> 24) & 0xFF;
                this.view[offset+2] = (hi >>> 16) & 0xFF;
                this.view[offset+1] = (hi >>>  8) & 0xFF;
                this.view[offset  ] =  hi         & 0xFF;
            } else {
                this.view[offset  ] = (hi >>> 24) & 0xFF;
                this.view[offset+1] = (hi >>> 16) & 0xFF;
                this.view[offset+2] = (hi >>>  8) & 0xFF;
                this.view[offset+3] =  hi         & 0xFF;
                offset += 4;
                this.view[offset  ] = (lo >>> 24) & 0xFF;
                this.view[offset+1] = (lo >>> 16) & 0xFF;
                this.view[offset+2] = (lo >>>  8) & 0xFF;
                this.view[offset+3] =  lo         & 0xFF;
            }
            if (relative) this.offset += 8;
            return this;
        };

        /**
         * Writes a 64bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint64}.
         * @function
         * @param {number|!Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeUInt64 = ByteBufferPrototype.writeUint64;

        /**
         * Reads a 64bit unsigned integer.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}
         * @expose
         */
        ByteBufferPrototype.readUint64 = function(offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 8 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+8+") <= "+this.buffer.byteLength);
            }
            var lo = 0,
                hi = 0;
            if (this.littleEndian) {
                lo  = this.view[offset+2] << 16;
                lo |= this.view[offset+1] <<  8;
                lo |= this.view[offset  ];
                lo += this.view[offset+3] << 24 >>> 0;
                offset += 4;
                hi  = this.view[offset+2] << 16;
                hi |= this.view[offset+1] <<  8;
                hi |= this.view[offset  ];
                hi += this.view[offset+3] << 24 >>> 0;
            } else {
                hi  = this.view[offset+1] << 16;
                hi |= this.view[offset+2] <<  8;
                hi |= this.view[offset+3];
                hi += this.view[offset  ] << 24 >>> 0;
                offset += 4;
                lo  = this.view[offset+1] << 16;
                lo |= this.view[offset+2] <<  8;
                lo |= this.view[offset+3];
                lo += this.view[offset  ] << 24 >>> 0;
            }
            var value = new Long(lo, hi, true);
            if (relative) this.offset += 8;
            return value;
        };

        /**
         * Reads a 64bit unsigned integer. This is an alias of {@link ByteBuffer#readUint64}.
         * @function
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}
         * @expose
         */
        ByteBufferPrototype.readUInt64 = ByteBufferPrototype.readUint64;

    } // Long


    // types/floats/float32

    /*
     ieee754 - https://github.com/feross/ieee754

     The MIT License (MIT)

     Copyright (c) Feross Aboukhadijeh

     Permission is hereby granted, free of charge, to any person obtaining a copy
     of this software and associated documentation files (the "Software"), to deal
     in the Software without restriction, including without limitation the rights
     to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     copies of the Software, and to permit persons to whom the Software is
     furnished to do so, subject to the following conditions:

     The above copyright notice and this permission notice shall be included in
     all copies or substantial portions of the Software.

     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     THE SOFTWARE.
    */

    /**
     * Reads an IEEE754 float from a byte array.
     * @param {!Array} buffer
     * @param {number} offset
     * @param {boolean} isLE
     * @param {number} mLen
     * @param {number} nBytes
     * @returns {number}
     * @inner
     */
    function ieee754_read(buffer, offset, isLE, mLen, nBytes) {
        var e, m,
            eLen = nBytes * 8 - mLen - 1,
            eMax = (1 << eLen) - 1,
            eBias = eMax >> 1,
            nBits = -7,
            i = isLE ? (nBytes - 1) : 0,
            d = isLE ? -1 : 1,
            s = buffer[offset + i];

        i += d;

        e = s & ((1 << (-nBits)) - 1);
        s >>= (-nBits);
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

        m = e & ((1 << (-nBits)) - 1);
        e >>= (-nBits);
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

        if (e === 0) {
            e = 1 - eBias;
        } else if (e === eMax) {
            return m ? NaN : ((s ? -1 : 1) * Infinity);
        } else {
            m = m + Math.pow(2, mLen);
            e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    }

    /**
     * Writes an IEEE754 float to a byte array.
     * @param {!Array} buffer
     * @param {number} value
     * @param {number} offset
     * @param {boolean} isLE
     * @param {number} mLen
     * @param {number} nBytes
     * @inner
     */
    function ieee754_write(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c,
            eLen = nBytes * 8 - mLen - 1,
            eMax = (1 << eLen) - 1,
            eBias = eMax >> 1,
            rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
            i = isLE ? 0 : (nBytes - 1),
            d = isLE ? 1 : -1,
            s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

        value = Math.abs(value);

        if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0;
            e = eMax;
        } else {
            e = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c = Math.pow(2, -e)) < 1) {
                e--;
                c *= 2;
            }
            if (e + eBias >= 1) {
                value += rt / c;
            } else {
                value += rt * Math.pow(2, 1 - eBias);
            }
            if (value * c >= 2) {
                e++;
                c /= 2;
            }

            if (e + eBias >= eMax) {
                m = 0;
                e = eMax;
            } else if (e + eBias >= 1) {
                m = (value * c - 1) * Math.pow(2, mLen);
                e = e + eBias;
            } else {
                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                e = 0;
            }
        }

        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

        e = (e << mLen) | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

        buffer[offset + i - d] |= s * 128;
    }

    /**
     * Writes a 32bit float.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeFloat32 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number')
                throw TypeError("Illegal value: "+value+" (not a number)");
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 4;
        var capacity8 = this.buffer.byteLength;
        if (offset > capacity8)
            this.resize((capacity8 *= 2) > offset ? capacity8 : offset);
        offset -= 4;
        ieee754_write(this.view, value, offset, this.littleEndian, 23, 4);
        if (relative) this.offset += 4;
        return this;
    };

    /**
     * Writes a 32bit float. This is an alias of {@link ByteBuffer#writeFloat32}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeFloat = ByteBufferPrototype.writeFloat32;

    /**
     * Reads a 32bit float.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number}
     * @expose
     */
    ByteBufferPrototype.readFloat32 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 4 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
        }
        var value = ieee754_read(this.view, offset, this.littleEndian, 23, 4);
        if (relative) this.offset += 4;
        return value;
    };

    /**
     * Reads a 32bit float. This is an alias of {@link ByteBuffer#readFloat32}.
     * @function
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number}
     * @expose
     */
    ByteBufferPrototype.readFloat = ByteBufferPrototype.readFloat32;

    // types/floats/float64

    /**
     * Writes a 64bit float.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeFloat64 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number')
                throw TypeError("Illegal value: "+value+" (not a number)");
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 8;
        var capacity9 = this.buffer.byteLength;
        if (offset > capacity9)
            this.resize((capacity9 *= 2) > offset ? capacity9 : offset);
        offset -= 8;
        ieee754_write(this.view, value, offset, this.littleEndian, 52, 8);
        if (relative) this.offset += 8;
        return this;
    };

    /**
     * Writes a 64bit float. This is an alias of {@link ByteBuffer#writeFloat64}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeDouble = ByteBufferPrototype.writeFloat64;

    /**
     * Reads a 64bit float.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
     * @returns {number}
     * @expose
     */
    ByteBufferPrototype.readFloat64 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 8 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+8+") <= "+this.buffer.byteLength);
        }
        var value = ieee754_read(this.view, offset, this.littleEndian, 52, 8);
        if (relative) this.offset += 8;
        return value;
    };

    /**
     * Reads a 64bit float. This is an alias of {@link ByteBuffer#readFloat64}.
     * @function
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
     * @returns {number}
     * @expose
     */
    ByteBufferPrototype.readDouble = ByteBufferPrototype.readFloat64;


    // types/varints/varint32

    /**
     * Maximum number of bytes required to store a 32bit base 128 variable-length integer.
     * @type {number}
     * @const
     * @expose
     */
    ByteBuffer.MAX_VARINT32_BYTES = 5;

    /**
     * Calculates the actual number of bytes required to store a 32bit base 128 variable-length integer.
     * @param {number} value Value to encode
     * @returns {number} Number of bytes required. Capped to {@link ByteBuffer.MAX_VARINT32_BYTES}
     * @expose
     */
    ByteBuffer.calculateVarint32 = function(value) {
        // ref: src/google/protobuf/io/coded_stream.cc
        value = value >>> 0;
             if (value < 1 << 7 ) return 1;
        else if (value < 1 << 14) return 2;
        else if (value < 1 << 21) return 3;
        else if (value < 1 << 28) return 4;
        else                      return 5;
    };

    /**
     * Zigzag encodes a signed 32bit integer so that it can be effectively used with varint encoding.
     * @param {number} n Signed 32bit integer
     * @returns {number} Unsigned zigzag encoded 32bit integer
     * @expose
     */
    ByteBuffer.zigZagEncode32 = function(n) {
        return (((n |= 0) << 1) ^ (n >> 31)) >>> 0; // ref: src/google/protobuf/wire_format_lite.h
    };

    /**
     * Decodes a zigzag encoded signed 32bit integer.
     * @param {number} n Unsigned zigzag encoded 32bit integer
     * @returns {number} Signed 32bit integer
     * @expose
     */
    ByteBuffer.zigZagDecode32 = function(n) {
        return ((n >>> 1) ^ -(n & 1)) | 0; // // ref: src/google/protobuf/wire_format_lite.h
    };

    /**
     * Writes a 32bit base 128 variable-length integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer|number} this if `offset` is omitted, else the actual number of bytes written
     * @expose
     */
    ByteBufferPrototype.writeVarint32 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var size = ByteBuffer.calculateVarint32(value),
            b;
        offset += size;
        var capacity10 = this.buffer.byteLength;
        if (offset > capacity10)
            this.resize((capacity10 *= 2) > offset ? capacity10 : offset);
        offset -= size;
        value >>>= 0;
        while (value >= 0x80) {
            b = (value & 0x7f) | 0x80;
            this.view[offset++] = b;
            value >>>= 7;
        }
        this.view[offset++] = value;
        if (relative) {
            this.offset = offset;
            return this;
        }
        return size;
    };

    /**
     * Writes a zig-zag encoded (signed) 32bit base 128 variable-length integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer|number} this if `offset` is omitted, else the actual number of bytes written
     * @expose
     */
    ByteBufferPrototype.writeVarint32ZigZag = function(value, offset) {
        return this.writeVarint32(ByteBuffer.zigZagEncode32(value), offset);
    };

    /**
     * Reads a 32bit base 128 variable-length integer.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {number|!{value: number, length: number}} The value read if offset is omitted, else the value read
     *  and the actual number of bytes read.
     * @throws {Error} If it's not a valid varint. Has a property `truncated = true` if there is not enough data available
     *  to fully decode the varint.
     * @expose
     */
    ByteBufferPrototype.readVarint32 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var c = 0,
            value = 0 >>> 0,
            b;
        do {
            if (!this.noAssert && offset > this.limit) {
                var err = Error("Truncated");
                err['truncated'] = true;
                throw err;
            }
            b = this.view[offset++];
            if (c < 5)
                value |= (b & 0x7f) << (7*c);
            ++c;
        } while ((b & 0x80) !== 0);
        value |= 0;
        if (relative) {
            this.offset = offset;
            return value;
        }
        return {
            "value": value,
            "length": c
        };
    };

    /**
     * Reads a zig-zag encoded (signed) 32bit base 128 variable-length integer.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {number|!{value: number, length: number}} The value read if offset is omitted, else the value read
     *  and the actual number of bytes read.
     * @throws {Error} If it's not a valid varint
     * @expose
     */
    ByteBufferPrototype.readVarint32ZigZag = function(offset) {
        var val = this.readVarint32(offset);
        if (typeof val === 'object')
            val["value"] = ByteBuffer.zigZagDecode32(val["value"]);
        else
            val = ByteBuffer.zigZagDecode32(val);
        return val;
    };

    // types/varints/varint64

    if (Long) {

        /**
         * Maximum number of bytes required to store a 64bit base 128 variable-length integer.
         * @type {number}
         * @const
         * @expose
         */
        ByteBuffer.MAX_VARINT64_BYTES = 10;

        /**
         * Calculates the actual number of bytes required to store a 64bit base 128 variable-length integer.
         * @param {number|!Long} value Value to encode
         * @returns {number} Number of bytes required. Capped to {@link ByteBuffer.MAX_VARINT64_BYTES}
         * @expose
         */
        ByteBuffer.calculateVarint64 = function(value) {
            if (typeof value === 'number')
                value = Long.fromNumber(value);
            else if (typeof value === 'string')
                value = Long.fromString(value);
            // ref: src/google/protobuf/io/coded_stream.cc
            var part0 = value.toInt() >>> 0,
                part1 = value.shiftRightUnsigned(28).toInt() >>> 0,
                part2 = value.shiftRightUnsigned(56).toInt() >>> 0;
            if (part2 == 0) {
                if (part1 == 0) {
                    if (part0 < 1 << 14)
                        return part0 < 1 << 7 ? 1 : 2;
                    else
                        return part0 < 1 << 21 ? 3 : 4;
                } else {
                    if (part1 < 1 << 14)
                        return part1 < 1 << 7 ? 5 : 6;
                    else
                        return part1 < 1 << 21 ? 7 : 8;
                }
            } else
                return part2 < 1 << 7 ? 9 : 10;
        };

        /**
         * Zigzag encodes a signed 64bit integer so that it can be effectively used with varint encoding.
         * @param {number|!Long} value Signed long
         * @returns {!Long} Unsigned zigzag encoded long
         * @expose
         */
        ByteBuffer.zigZagEncode64 = function(value) {
            if (typeof value === 'number')
                value = Long.fromNumber(value, false);
            else if (typeof value === 'string')
                value = Long.fromString(value, false);
            else if (value.unsigned !== false) value = value.toSigned();
            // ref: src/google/protobuf/wire_format_lite.h
            return value.shiftLeft(1).xor(value.shiftRight(63)).toUnsigned();
        };

        /**
         * Decodes a zigzag encoded signed 64bit integer.
         * @param {!Long|number} value Unsigned zigzag encoded long or JavaScript number
         * @returns {!Long} Signed long
         * @expose
         */
        ByteBuffer.zigZagDecode64 = function(value) {
            if (typeof value === 'number')
                value = Long.fromNumber(value, false);
            else if (typeof value === 'string')
                value = Long.fromString(value, false);
            else if (value.unsigned !== false) value = value.toSigned();
            // ref: src/google/protobuf/wire_format_lite.h
            return value.shiftRightUnsigned(1).xor(value.and(Long.ONE).toSigned().negate()).toSigned();
        };

        /**
         * Writes a 64bit base 128 variable-length integer.
         * @param {number|Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  written if omitted.
         * @returns {!ByteBuffer|number} `this` if offset is omitted, else the actual number of bytes written.
         * @expose
         */
        ByteBufferPrototype.writeVarint64 = function(value, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof value === 'number')
                    value = Long.fromNumber(value);
                else if (typeof value === 'string')
                    value = Long.fromString(value);
                else if (!(value && value instanceof Long))
                    throw TypeError("Illegal value: "+value+" (not an integer or Long)");
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            if (typeof value === 'number')
                value = Long.fromNumber(value, false);
            else if (typeof value === 'string')
                value = Long.fromString(value, false);
            else if (value.unsigned !== false) value = value.toSigned();
            var size = ByteBuffer.calculateVarint64(value),
                part0 = value.toInt() >>> 0,
                part1 = value.shiftRightUnsigned(28).toInt() >>> 0,
                part2 = value.shiftRightUnsigned(56).toInt() >>> 0;
            offset += size;
            var capacity11 = this.buffer.byteLength;
            if (offset > capacity11)
                this.resize((capacity11 *= 2) > offset ? capacity11 : offset);
            offset -= size;
            switch (size) {
                case 10: this.view[offset+9] = (part2 >>>  7) & 0x01;
                case 9 : this.view[offset+8] = size !== 9 ? (part2       ) | 0x80 : (part2       ) & 0x7F;
                case 8 : this.view[offset+7] = size !== 8 ? (part1 >>> 21) | 0x80 : (part1 >>> 21) & 0x7F;
                case 7 : this.view[offset+6] = size !== 7 ? (part1 >>> 14) | 0x80 : (part1 >>> 14) & 0x7F;
                case 6 : this.view[offset+5] = size !== 6 ? (part1 >>>  7) | 0x80 : (part1 >>>  7) & 0x7F;
                case 5 : this.view[offset+4] = size !== 5 ? (part1       ) | 0x80 : (part1       ) & 0x7F;
                case 4 : this.view[offset+3] = size !== 4 ? (part0 >>> 21) | 0x80 : (part0 >>> 21) & 0x7F;
                case 3 : this.view[offset+2] = size !== 3 ? (part0 >>> 14) | 0x80 : (part0 >>> 14) & 0x7F;
                case 2 : this.view[offset+1] = size !== 2 ? (part0 >>>  7) | 0x80 : (part0 >>>  7) & 0x7F;
                case 1 : this.view[offset  ] = size !== 1 ? (part0       ) | 0x80 : (part0       ) & 0x7F;
            }
            if (relative) {
                this.offset += size;
                return this;
            } else {
                return size;
            }
        };

        /**
         * Writes a zig-zag encoded 64bit base 128 variable-length integer.
         * @param {number|Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  written if omitted.
         * @returns {!ByteBuffer|number} `this` if offset is omitted, else the actual number of bytes written.
         * @expose
         */
        ByteBufferPrototype.writeVarint64ZigZag = function(value, offset) {
            return this.writeVarint64(ByteBuffer.zigZagEncode64(value), offset);
        };

        /**
         * Reads a 64bit base 128 variable-length integer. Requires Long.js.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  read if omitted.
         * @returns {!Long|!{value: Long, length: number}} The value read if offset is omitted, else the value read and
         *  the actual number of bytes read.
         * @throws {Error} If it's not a valid varint
         * @expose
         */
        ByteBufferPrototype.readVarint64 = function(offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 1 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
            }
            // ref: src/google/protobuf/io/coded_stream.cc
            var start = offset,
                part0 = 0,
                part1 = 0,
                part2 = 0,
                b  = 0;
            b = this.view[offset++]; part0  = (b & 0x7F)      ; if ( b & 0x80                                                   ) {
            b = this.view[offset++]; part0 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part0 |= (b & 0x7F) << 14; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part0 |= (b & 0x7F) << 21; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part1  = (b & 0x7F)      ; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part1 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part1 |= (b & 0x7F) << 14; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part1 |= (b & 0x7F) << 21; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part2  = (b & 0x7F)      ; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part2 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            throw Error("Buffer overrun"); }}}}}}}}}}
            var value = Long.fromBits(part0 | (part1 << 28), (part1 >>> 4) | (part2) << 24, false);
            if (relative) {
                this.offset = offset;
                return value;
            } else {
                return {
                    'value': value,
                    'length': offset-start
                };
            }
        };

        /**
         * Reads a zig-zag encoded 64bit base 128 variable-length integer. Requires Long.js.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  read if omitted.
         * @returns {!Long|!{value: Long, length: number}} The value read if offset is omitted, else the value read and
         *  the actual number of bytes read.
         * @throws {Error} If it's not a valid varint
         * @expose
         */
        ByteBufferPrototype.readVarint64ZigZag = function(offset) {
            var val = this.readVarint64(offset);
            if (val && val['value'] instanceof Long)
                val["value"] = ByteBuffer.zigZagDecode64(val["value"]);
            else
                val = ByteBuffer.zigZagDecode64(val);
            return val;
        };

    } // Long


    // types/strings/cstring

    /**
     * Writes a NULL-terminated UTF8 encoded string. For this to work the specified string must not contain any NULL
     *  characters itself.
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  contained in `str` + 1 if omitted.
     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written
     * @expose
     */
    ByteBufferPrototype.writeCString = function(str, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        var i,
            k = str.length;
        if (!this.noAssert) {
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
            for (i=0; i<k; ++i) {
                if (str.charCodeAt(i) === 0)
                    throw RangeError("Illegal str: Contains NULL-characters");
            }
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        // UTF8 strings do not contain zero bytes in between except for the zero character, so:
        k = utfx.calculateUTF16asUTF8(stringSource(str))[1];
        offset += k+1;
        var capacity12 = this.buffer.byteLength;
        if (offset > capacity12)
            this.resize((capacity12 *= 2) > offset ? capacity12 : offset);
        offset -= k+1;
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            this.view[offset++] = b;
        }.bind(this));
        this.view[offset++] = 0;
        if (relative) {
            this.offset = offset;
            return this;
        }
        return k;
    };

    /**
     * Reads a NULL-terminated UTF8 encoded string. For this to work the string read must not contain any NULL characters
     *  itself.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     */
    ByteBufferPrototype.readCString = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var start = offset,
            temp;
        // UTF8 strings do not contain zero bytes in between except for the zero character itself, so:
        var sd, b = -1;
        utfx.decodeUTF8toUTF16(function() {
            if (b === 0) return null;
            if (offset >= this.limit)
                throw RangeError("Illegal range: Truncated data, "+offset+" < "+this.limit);
            b = this.view[offset++];
            return b === 0 ? null : b;
        }.bind(this), sd = stringDestination(), true);
        if (relative) {
            this.offset = offset;
            return sd();
        } else {
            return {
                "string": sd(),
                "length": offset - start
            };
        }
    };

    // types/strings/istring

    /**
     * Writes a length as uint32 prefixed UTF8 encoded string.
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer|number} `this` if `offset` is omitted, else the actual number of bytes written
     * @expose
     * @see ByteBuffer#writeVarint32
     */
    ByteBufferPrototype.writeIString = function(str, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var start = offset,
            k;
        k = utfx.calculateUTF16asUTF8(stringSource(str), this.noAssert)[1];
        offset += 4+k;
        var capacity13 = this.buffer.byteLength;
        if (offset > capacity13)
            this.resize((capacity13 *= 2) > offset ? capacity13 : offset);
        offset -= 4+k;
        if (this.littleEndian) {
            this.view[offset+3] = (k >>> 24) & 0xFF;
            this.view[offset+2] = (k >>> 16) & 0xFF;
            this.view[offset+1] = (k >>>  8) & 0xFF;
            this.view[offset  ] =  k         & 0xFF;
        } else {
            this.view[offset  ] = (k >>> 24) & 0xFF;
            this.view[offset+1] = (k >>> 16) & 0xFF;
            this.view[offset+2] = (k >>>  8) & 0xFF;
            this.view[offset+3] =  k         & 0xFF;
        }
        offset += 4;
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            this.view[offset++] = b;
        }.bind(this));
        if (offset !== start + 4 + k)
            throw RangeError("Illegal range: Truncated data, "+offset+" == "+(offset+4+k));
        if (relative) {
            this.offset = offset;
            return this;
        }
        return offset - start;
    };

    /**
     * Reads a length as uint32 prefixed UTF8 encoded string.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     * @see ByteBuffer#readVarint32
     */
    ByteBufferPrototype.readIString = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 4 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
        }
        var start = offset;
        var len = this.readUint32(offset);
        var str = this.readUTF8String(len, ByteBuffer.METRICS_BYTES, offset += 4);
        offset += str['length'];
        if (relative) {
            this.offset = offset;
            return str['string'];
        } else {
            return {
                'string': str['string'],
                'length': offset - start
            };
        }
    };

    // types/strings/utf8string

    /**
     * Metrics representing number of UTF8 characters. Evaluates to `c`.
     * @type {string}
     * @const
     * @expose
     */
    ByteBuffer.METRICS_CHARS = 'c';

    /**
     * Metrics representing number of bytes. Evaluates to `b`.
     * @type {string}
     * @const
     * @expose
     */
    ByteBuffer.METRICS_BYTES = 'b';

    /**
     * Writes an UTF8 encoded string.
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} if omitted.
     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written.
     * @expose
     */
    ByteBufferPrototype.writeUTF8String = function(str, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var k;
        var start = offset;
        k = utfx.calculateUTF16asUTF8(stringSource(str))[1];
        offset += k;
        var capacity14 = this.buffer.byteLength;
        if (offset > capacity14)
            this.resize((capacity14 *= 2) > offset ? capacity14 : offset);
        offset -= k;
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            this.view[offset++] = b;
        }.bind(this));
        if (relative) {
            this.offset = offset;
            return this;
        }
        return offset - start;
    };

    /**
     * Writes an UTF8 encoded string. This is an alias of {@link ByteBuffer#writeUTF8String}.
     * @function
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} if omitted.
     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written.
     * @expose
     */
    ByteBufferPrototype.writeString = ByteBufferPrototype.writeUTF8String;

    /**
     * Calculates the number of UTF8 characters of a string. JavaScript itself uses UTF-16, so that a string's
     *  `length` property does not reflect its actual UTF8 size if it contains code points larger than 0xFFFF.
     * @param {string} str String to calculate
     * @returns {number} Number of UTF8 characters
     * @expose
     */
    ByteBuffer.calculateUTF8Chars = function(str) {
        return utfx.calculateUTF16asUTF8(stringSource(str))[0];
    };

    /**
     * Calculates the number of UTF8 bytes of a string.
     * @param {string} str String to calculate
     * @returns {number} Number of UTF8 bytes
     * @expose
     */
    ByteBuffer.calculateUTF8Bytes = function(str) {
        return utfx.calculateUTF16asUTF8(stringSource(str))[1];
    };

    /**
     * Calculates the number of UTF8 bytes of a string. This is an alias of {@link ByteBuffer.calculateUTF8Bytes}.
     * @function
     * @param {string} str String to calculate
     * @returns {number} Number of UTF8 bytes
     * @expose
     */
    ByteBuffer.calculateString = ByteBuffer.calculateUTF8Bytes;

    /**
     * Reads an UTF8 encoded string.
     * @param {number} length Number of characters or bytes to read.
     * @param {string=} metrics Metrics specifying what `length` is meant to count. Defaults to
     *  {@link ByteBuffer.METRICS_CHARS}.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     */
    ByteBufferPrototype.readUTF8String = function(length, metrics, offset) {
        if (typeof metrics === 'number') {
            offset = metrics;
            metrics = undefined;
        }
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (typeof metrics === 'undefined') metrics = ByteBuffer.METRICS_CHARS;
        if (!this.noAssert) {
            if (typeof length !== 'number' || length % 1 !== 0)
                throw TypeError("Illegal length: "+length+" (not an integer)");
            length |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var i = 0,
            start = offset,
            sd;
        if (metrics === ByteBuffer.METRICS_CHARS) { // The same for node and the browser
            sd = stringDestination();
            utfx.decodeUTF8(function() {
                return i < length && offset < this.limit ? this.view[offset++] : null;
            }.bind(this), function(cp) {
                ++i; utfx.UTF8toUTF16(cp, sd);
            });
            if (i !== length)
                throw RangeError("Illegal range: Truncated data, "+i+" == "+length);
            if (relative) {
                this.offset = offset;
                return sd();
            } else {
                return {
                    "string": sd(),
                    "length": offset - start
                };
            }
        } else if (metrics === ByteBuffer.METRICS_BYTES) {
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + length > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+length+") <= "+this.buffer.byteLength);
            }
            var k = offset + length;
            utfx.decodeUTF8toUTF16(function() {
                return offset < k ? this.view[offset++] : null;
            }.bind(this), sd = stringDestination(), this.noAssert);
            if (offset !== k)
                throw RangeError("Illegal range: Truncated data, "+offset+" == "+k);
            if (relative) {
                this.offset = offset;
                return sd();
            } else {
                return {
                    'string': sd(),
                    'length': offset - start
                };
            }
        } else
            throw TypeError("Unsupported metrics: "+metrics);
    };

    /**
     * Reads an UTF8 encoded string. This is an alias of {@link ByteBuffer#readUTF8String}.
     * @function
     * @param {number} length Number of characters or bytes to read
     * @param {number=} metrics Metrics specifying what `n` is meant to count. Defaults to
     *  {@link ByteBuffer.METRICS_CHARS}.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     */
    ByteBufferPrototype.readString = ByteBufferPrototype.readUTF8String;

    // types/strings/vstring

    /**
     * Writes a length as varint32 prefixed UTF8 encoded string.
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer|number} `this` if `offset` is omitted, else the actual number of bytes written
     * @expose
     * @see ByteBuffer#writeVarint32
     */
    ByteBufferPrototype.writeVString = function(str, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var start = offset,
            k, l;
        k = utfx.calculateUTF16asUTF8(stringSource(str), this.noAssert)[1];
        l = ByteBuffer.calculateVarint32(k);
        offset += l+k;
        var capacity15 = this.buffer.byteLength;
        if (offset > capacity15)
            this.resize((capacity15 *= 2) > offset ? capacity15 : offset);
        offset -= l+k;
        offset += this.writeVarint32(k, offset);
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            this.view[offset++] = b;
        }.bind(this));
        if (offset !== start+k+l)
            throw RangeError("Illegal range: Truncated data, "+offset+" == "+(offset+k+l));
        if (relative) {
            this.offset = offset;
            return this;
        }
        return offset - start;
    };

    /**
     * Reads a length as varint32 prefixed UTF8 encoded string.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     * @see ByteBuffer#readVarint32
     */
    ByteBufferPrototype.readVString = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var start = offset;
        var len = this.readVarint32(offset);
        var str = this.readUTF8String(len['value'], ByteBuffer.METRICS_BYTES, offset += len['length']);
        offset += str['length'];
        if (relative) {
            this.offset = offset;
            return str['string'];
        } else {
            return {
                'string': str['string'],
                'length': offset - start
            };
        }
    };


    /**
     * Appends some data to this ByteBuffer. This will overwrite any contents behind the specified offset up to the appended
     *  data's length.
     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string} source Data to append. If `source` is a ByteBuffer, its offsets
     *  will be modified according to the performed read operation.
     * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
     * @param {number=} offset Offset to append at. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     * @example A relative `<01 02>03.append(<04 05>)` will result in `<01 02 04 05>, 04 05|`
     * @example An absolute `<01 02>03.append(04 05>, 1)` will result in `<01 04>05, 04 05|`
     */
    ByteBufferPrototype.append = function(source, encoding, offset) {
        if (typeof encoding === 'number' || typeof encoding !== 'string') {
            offset = encoding;
            encoding = undefined;
        }
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        if (!(source instanceof ByteBuffer))
            source = ByteBuffer.wrap(source, encoding);
        var length = source.limit - source.offset;
        if (length <= 0) return this; // Nothing to append
        offset += length;
        var capacity16 = this.buffer.byteLength;
        if (offset > capacity16)
            this.resize((capacity16 *= 2) > offset ? capacity16 : offset);
        offset -= length;
        this.view.set(source.view.subarray(source.offset, source.limit), offset);
        source.offset += length;
        if (relative) this.offset += length;
        return this;
    };

    /**
     * Appends this ByteBuffer's contents to another ByteBuffer. This will overwrite any contents at and after the
        specified offset up to the length of this ByteBuffer's data.
     * @param {!ByteBuffer} target Target ByteBuffer
     * @param {number=} offset Offset to append to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     * @see ByteBuffer#append
     */
    ByteBufferPrototype.appendTo = function(target, offset) {
        target.append(this, offset);
        return this;
    };

    /**
     * Enables or disables assertions of argument types and offsets. Assertions are enabled by default but you can opt to
     *  disable them if your code already makes sure that everything is valid.
     * @param {boolean} assert `true` to enable assertions, otherwise `false`
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.assert = function(assert) {
        this.noAssert = !assert;
        return this;
    };

    /**
     * Gets the capacity of this ByteBuffer's backing buffer.
     * @returns {number} Capacity of the backing buffer
     * @expose
     */
    ByteBufferPrototype.capacity = function() {
        return this.buffer.byteLength;
    };
    /**
     * Clears this ByteBuffer's offsets by setting {@link ByteBuffer#offset} to `0` and {@link ByteBuffer#limit} to the
     *  backing buffer's capacity. Discards {@link ByteBuffer#markedOffset}.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.clear = function() {
        this.offset = 0;
        this.limit = this.buffer.byteLength;
        this.markedOffset = -1;
        return this;
    };

    /**
     * Creates a cloned instance of this ByteBuffer, preset with this ByteBuffer's values for {@link ByteBuffer#offset},
     *  {@link ByteBuffer#markedOffset} and {@link ByteBuffer#limit}.
     * @param {boolean=} copy Whether to copy the backing buffer or to return another view on the same, defaults to `false`
     * @returns {!ByteBuffer} Cloned instance
     * @expose
     */
    ByteBufferPrototype.clone = function(copy) {
        var bb = new ByteBuffer(0, this.littleEndian, this.noAssert);
        if (copy) {
            bb.buffer = new ArrayBuffer(this.buffer.byteLength);
            bb.view = new Uint8Array(bb.buffer);
        } else {
            bb.buffer = this.buffer;
            bb.view = this.view;
        }
        bb.offset = this.offset;
        bb.markedOffset = this.markedOffset;
        bb.limit = this.limit;
        return bb;
    };

    /**
     * Compacts this ByteBuffer to be backed by a {@link ByteBuffer#buffer} of its contents' length. Contents are the bytes
     *  between {@link ByteBuffer#offset} and {@link ByteBuffer#limit}. Will set `offset = 0` and `limit = capacity` and
     *  adapt {@link ByteBuffer#markedOffset} to the same relative position if set.
     * @param {number=} begin Offset to start at, defaults to {@link ByteBuffer#offset}
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.compact = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        if (begin === 0 && end === this.buffer.byteLength)
            return this; // Already compacted
        var len = end - begin;
        if (len === 0) {
            this.buffer = EMPTY_BUFFER;
            this.view = null;
            if (this.markedOffset >= 0) this.markedOffset -= begin;
            this.offset = 0;
            this.limit = 0;
            return this;
        }
        var buffer = new ArrayBuffer(len);
        var view = new Uint8Array(buffer);
        view.set(this.view.subarray(begin, end));
        this.buffer = buffer;
        this.view = view;
        if (this.markedOffset >= 0) this.markedOffset -= begin;
        this.offset = 0;
        this.limit = len;
        return this;
    };

    /**
     * Creates a copy of this ByteBuffer's contents. Contents are the bytes between {@link ByteBuffer#offset} and
     *  {@link ByteBuffer#limit}.
     * @param {number=} begin Begin offset, defaults to {@link ByteBuffer#offset}.
     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
     * @returns {!ByteBuffer} Copy
     * @expose
     */
    ByteBufferPrototype.copy = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        if (begin === end)
            return new ByteBuffer(0, this.littleEndian, this.noAssert);
        var capacity = end - begin,
            bb = new ByteBuffer(capacity, this.littleEndian, this.noAssert);
        bb.offset = 0;
        bb.limit = capacity;
        if (bb.markedOffset >= 0) bb.markedOffset -= begin;
        this.copyTo(bb, 0, begin, end);
        return bb;
    };

    /**
     * Copies this ByteBuffer's contents to another ByteBuffer. Contents are the bytes between {@link ByteBuffer#offset} and
     *  {@link ByteBuffer#limit}.
     * @param {!ByteBuffer} target Target ByteBuffer
     * @param {number=} targetOffset Offset to copy to. Will use and increase the target's {@link ByteBuffer#offset}
     *  by the number of bytes copied if omitted.
     * @param {number=} sourceOffset Offset to start copying from. Will use and increase {@link ByteBuffer#offset} by the
     *  number of bytes copied if omitted.
     * @param {number=} sourceLimit Offset to end copying from, defaults to {@link ByteBuffer#limit}
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.copyTo = function(target, targetOffset, sourceOffset, sourceLimit) {
        var relative,
            targetRelative;
        if (!this.noAssert) {
            if (!ByteBuffer.isByteBuffer(target))
                throw TypeError("Illegal target: Not a ByteBuffer");
        }
        targetOffset = (targetRelative = typeof targetOffset === 'undefined') ? target.offset : targetOffset | 0;
        sourceOffset = (relative = typeof sourceOffset === 'undefined') ? this.offset : sourceOffset | 0;
        sourceLimit = typeof sourceLimit === 'undefined' ? this.limit : sourceLimit | 0;

        if (targetOffset < 0 || targetOffset > target.buffer.byteLength)
            throw RangeError("Illegal target range: 0 <= "+targetOffset+" <= "+target.buffer.byteLength);
        if (sourceOffset < 0 || sourceLimit > this.buffer.byteLength)
            throw RangeError("Illegal source range: 0 <= "+sourceOffset+" <= "+this.buffer.byteLength);

        var len = sourceLimit - sourceOffset;
        if (len === 0)
            return target; // Nothing to copy

        target.ensureCapacity(targetOffset + len);

        target.view.set(this.view.subarray(sourceOffset, sourceLimit), targetOffset);

        if (relative) this.offset += len;
        if (targetRelative) target.offset += len;

        return this;
    };

    /**
     * Makes sure that this ByteBuffer is backed by a {@link ByteBuffer#buffer} of at least the specified capacity. If the
     *  current capacity is exceeded, it will be doubled. If double the current capacity is less than the required capacity,
     *  the required capacity will be used instead.
     * @param {number} capacity Required capacity
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.ensureCapacity = function(capacity) {
        var current = this.buffer.byteLength;
        if (current < capacity)
            return this.resize((current *= 2) > capacity ? current : capacity);
        return this;
    };

    /**
     * Overwrites this ByteBuffer's contents with the specified value. Contents are the bytes between
     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}.
     * @param {number|string} value Byte value to fill with. If given as a string, the first character is used.
     * @param {number=} begin Begin offset. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted. defaults to {@link ByteBuffer#offset}.
     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
     * @returns {!ByteBuffer} this
     * @expose
     * @example `someByteBuffer.clear().fill(0)` fills the entire backing buffer with zeroes
     */
    ByteBufferPrototype.fill = function(value, begin, end) {
        var relative = typeof begin === 'undefined';
        if (relative) begin = this.offset;
        if (typeof value === 'string' && value.length > 0)
            value = value.charCodeAt(0);
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        if (begin >= end)
            return this; // Nothing to fill
        while (begin < end) this.view[begin++] = value;
        if (relative) this.offset = begin;
        return this;
    };

    /**
     * Makes this ByteBuffer ready for a new sequence of write or relative read operations. Sets `limit = offset` and
     *  `offset = 0`. Make sure always to flip a ByteBuffer when all relative read or write operations are complete.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.flip = function() {
        this.limit = this.offset;
        this.offset = 0;
        return this;
    };
    /**
     * Marks an offset on this ByteBuffer to be used later.
     * @param {number=} offset Offset to mark. Defaults to {@link ByteBuffer#offset}.
     * @returns {!ByteBuffer} this
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @see ByteBuffer#reset
     * @expose
     */
    ByteBufferPrototype.mark = function(offset) {
        offset = typeof offset === 'undefined' ? this.offset : offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        this.markedOffset = offset;
        return this;
    };
    /**
     * Sets the byte order.
     * @param {boolean} littleEndian `true` for little endian byte order, `false` for big endian
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.order = function(littleEndian) {
        if (!this.noAssert) {
            if (typeof littleEndian !== 'boolean')
                throw TypeError("Illegal littleEndian: Not a boolean");
        }
        this.littleEndian = !!littleEndian;
        return this;
    };

    /**
     * Switches (to) little endian byte order.
     * @param {boolean=} littleEndian Defaults to `true`, otherwise uses big endian
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.LE = function(littleEndian) {
        this.littleEndian = typeof littleEndian !== 'undefined' ? !!littleEndian : true;
        return this;
    };

    /**
     * Switches (to) big endian byte order.
     * @param {boolean=} bigEndian Defaults to `true`, otherwise uses little endian
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.BE = function(bigEndian) {
        this.littleEndian = typeof bigEndian !== 'undefined' ? !bigEndian : false;
        return this;
    };
    /**
     * Prepends some data to this ByteBuffer. This will overwrite any contents before the specified offset up to the
     *  prepended data's length. If there is not enough space available before the specified `offset`, the backing buffer
     *  will be resized and its contents moved accordingly.
     * @param {!ByteBuffer|string|!ArrayBuffer} source Data to prepend. If `source` is a ByteBuffer, its offset will be
     *  modified according to the performed read operation.
     * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
     * @param {number=} offset Offset to prepend at. Will use and decrease {@link ByteBuffer#offset} by the number of bytes
     *  prepended if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     * @example A relative `00<01 02 03>.prepend(<04 05>)` results in `<04 05 01 02 03>, 04 05|`
     * @example An absolute `00<01 02 03>.prepend(<04 05>, 2)` results in `04<05 02 03>, 04 05|`
     */
    ByteBufferPrototype.prepend = function(source, encoding, offset) {
        if (typeof encoding === 'number' || typeof encoding !== 'string') {
            offset = encoding;
            encoding = undefined;
        }
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        if (!(source instanceof ByteBuffer))
            source = ByteBuffer.wrap(source, encoding);
        var len = source.limit - source.offset;
        if (len <= 0) return this; // Nothing to prepend
        var diff = len - offset;
        if (diff > 0) { // Not enough space before offset, so resize + move
            var buffer = new ArrayBuffer(this.buffer.byteLength + diff);
            var view = new Uint8Array(buffer);
            view.set(this.view.subarray(offset, this.buffer.byteLength), len);
            this.buffer = buffer;
            this.view = view;
            this.offset += diff;
            if (this.markedOffset >= 0) this.markedOffset += diff;
            this.limit += diff;
            offset += diff;
        } else {
            var arrayView = new Uint8Array(this.buffer);
        }
        this.view.set(source.view.subarray(source.offset, source.limit), offset - len);

        source.offset = source.limit;
        if (relative)
            this.offset -= len;
        return this;
    };

    /**
     * Prepends this ByteBuffer to another ByteBuffer. This will overwrite any contents before the specified offset up to the
     *  prepended data's length. If there is not enough space available before the specified `offset`, the backing buffer
     *  will be resized and its contents moved accordingly.
     * @param {!ByteBuffer} target Target ByteBuffer
     * @param {number=} offset Offset to prepend at. Will use and decrease {@link ByteBuffer#offset} by the number of bytes
     *  prepended if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     * @see ByteBuffer#prepend
     */
    ByteBufferPrototype.prependTo = function(target, offset) {
        target.prepend(this, offset);
        return this;
    };
    /**
     * Prints debug information about this ByteBuffer's contents.
     * @param {function(string)=} out Output function to call, defaults to console.log
     * @expose
     */
    ByteBufferPrototype.printDebug = function(out) {
        if (typeof out !== 'function') out = console.log.bind(console);
        out(
            this.toString()+"\n"+
            "-------------------------------------------------------------------\n"+
            this.toDebug(/* columns */ true)
        );
    };

    /**
     * Gets the number of remaining readable bytes. Contents are the bytes between {@link ByteBuffer#offset} and
     *  {@link ByteBuffer#limit}, so this returns `limit - offset`.
     * @returns {number} Remaining readable bytes. May be negative if `offset > limit`.
     * @expose
     */
    ByteBufferPrototype.remaining = function() {
        return this.limit - this.offset;
    };
    /**
     * Resets this ByteBuffer's {@link ByteBuffer#offset}. If an offset has been marked through {@link ByteBuffer#mark}
     *  before, `offset` will be set to {@link ByteBuffer#markedOffset}, which will then be discarded. If no offset has been
     *  marked, sets `offset = 0`.
     * @returns {!ByteBuffer} this
     * @see ByteBuffer#mark
     * @expose
     */
    ByteBufferPrototype.reset = function() {
        if (this.markedOffset >= 0) {
            this.offset = this.markedOffset;
            this.markedOffset = -1;
        } else {
            this.offset = 0;
        }
        return this;
    };
    /**
     * Resizes this ByteBuffer to be backed by a buffer of at least the given capacity. Will do nothing if already that
     *  large or larger.
     * @param {number} capacity Capacity required
     * @returns {!ByteBuffer} this
     * @throws {TypeError} If `capacity` is not a number
     * @throws {RangeError} If `capacity < 0`
     * @expose
     */
    ByteBufferPrototype.resize = function(capacity) {
        if (!this.noAssert) {
            if (typeof capacity !== 'number' || capacity % 1 !== 0)
                throw TypeError("Illegal capacity: "+capacity+" (not an integer)");
            capacity |= 0;
            if (capacity < 0)
                throw RangeError("Illegal capacity: 0 <= "+capacity);
        }
        if (this.buffer.byteLength < capacity) {
            var buffer = new ArrayBuffer(capacity);
            var view = new Uint8Array(buffer);
            view.set(this.view);
            this.buffer = buffer;
            this.view = view;
        }
        return this;
    };
    /**
     * Reverses this ByteBuffer's contents.
     * @param {number=} begin Offset to start at, defaults to {@link ByteBuffer#offset}
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.reverse = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        if (begin === end)
            return this; // Nothing to reverse
        Array.prototype.reverse.call(this.view.subarray(begin, end));
        return this;
    };
    /**
     * Skips the next `length` bytes. This will just advance
     * @param {number} length Number of bytes to skip. May also be negative to move the offset back.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.skip = function(length) {
        if (!this.noAssert) {
            if (typeof length !== 'number' || length % 1 !== 0)
                throw TypeError("Illegal length: "+length+" (not an integer)");
            length |= 0;
        }
        var offset = this.offset + length;
        if (!this.noAssert) {
            if (offset < 0 || offset > this.buffer.byteLength)
                throw RangeError("Illegal length: 0 <= "+this.offset+" + "+length+" <= "+this.buffer.byteLength);
        }
        this.offset = offset;
        return this;
    };

    /**
     * Slices this ByteBuffer by creating a cloned instance with `offset = begin` and `limit = end`.
     * @param {number=} begin Begin offset, defaults to {@link ByteBuffer#offset}.
     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
     * @returns {!ByteBuffer} Clone of this ByteBuffer with slicing applied, backed by the same {@link ByteBuffer#buffer}
     * @expose
     */
    ByteBufferPrototype.slice = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        var bb = this.clone();
        bb.offset = begin;
        bb.limit = end;
        return bb;
    };
    /**
     * Returns a copy of the backing buffer that contains this ByteBuffer's contents. Contents are the bytes between
     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}.
     * @param {boolean=} forceCopy If `true` returns a copy, otherwise returns a view referencing the same memory if
     *  possible. Defaults to `false`
     * @returns {!ArrayBuffer} Contents as an ArrayBuffer
     * @expose
     */
    ByteBufferPrototype.toBuffer = function(forceCopy) {
        var offset = this.offset,
            limit = this.limit;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: Not an integer");
            offset >>>= 0;
            if (typeof limit !== 'number' || limit % 1 !== 0)
                throw TypeError("Illegal limit: Not an integer");
            limit >>>= 0;
            if (offset < 0 || offset > limit || limit > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+offset+" <= "+limit+" <= "+this.buffer.byteLength);
        }
        // NOTE: It's not possible to have another ArrayBuffer reference the same memory as the backing buffer. This is
        // possible with Uint8Array#subarray only, but we have to return an ArrayBuffer by contract. So:
        if (!forceCopy && offset === 0 && limit === this.buffer.byteLength)
            return this.buffer;
        if (offset === limit)
            return EMPTY_BUFFER;
        var buffer = new ArrayBuffer(limit - offset);
        new Uint8Array(buffer).set(new Uint8Array(this.buffer).subarray(offset, limit), 0);
        return buffer;
    };

    /**
     * Returns a raw buffer compacted to contain this ByteBuffer's contents. Contents are the bytes between
     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}. This is an alias of {@link ByteBuffer#toBuffer}.
     * @function
     * @param {boolean=} forceCopy If `true` returns a copy, otherwise returns a view referencing the same memory.
     *  Defaults to `false`
     * @returns {!ArrayBuffer} Contents as an ArrayBuffer
     * @expose
     */
    ByteBufferPrototype.toArrayBuffer = ByteBufferPrototype.toBuffer;

    /**
     * Converts the ByteBuffer's contents to a string.
     * @param {string=} encoding Output encoding. Returns an informative string representation if omitted but also allows
     *  direct conversion to "utf8", "hex", "base64" and "binary" encoding. "debug" returns a hex representation with
     *  highlighted offsets.
     * @param {number=} begin Offset to begin at, defaults to {@link ByteBuffer#offset}
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
     * @returns {string} String representation
     * @throws {Error} If `encoding` is invalid
     * @expose
     */
    ByteBufferPrototype.toString = function(encoding, begin, end) {
        if (typeof encoding === 'undefined')
            return "ByteBufferAB(offset="+this.offset+",markedOffset="+this.markedOffset+",limit="+this.limit+",capacity="+this.capacity()+")";
        if (typeof encoding === 'number')
            encoding = "utf8",
            begin = encoding,
            end = begin;
        switch (encoding) {
            case "utf8":
                return this.toUTF8(begin, end);
            case "base64":
                return this.toBase64(begin, end);
            case "hex":
                return this.toHex(begin, end);
            case "binary":
                return this.toBinary(begin, end);
            case "debug":
                return this.toDebug();
            case "columns":
                return this.toColumns();
            default:
                throw Error("Unsupported encoding: "+encoding);
        }
    };

    // lxiv-embeddable

    /**
     * lxiv-embeddable (c) 2014 Daniel Wirtz <dcode@dcode.io>
     * Released under the Apache License, Version 2.0
     * see: https://github.com/dcodeIO/lxiv for details
     */
    var lxiv = function() {
        "use strict";

        /**
         * lxiv namespace.
         * @type {!Object.<string,*>}
         * @exports lxiv
         */
        var lxiv = {};

        /**
         * Character codes for output.
         * @type {!Array.<number>}
         * @inner
         */
        var aout = [
            65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,
            81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102,
            103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118,
            119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47
        ];

        /**
         * Character codes for input.
         * @type {!Array.<number>}
         * @inner
         */
        var ain = [];
        for (var i=0, k=aout.length; i<k; ++i)
            ain[aout[i]] = i;

        /**
         * Encodes bytes to base64 char codes.
         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if
         *  there are no more bytes left.
         * @param {!function(number)} dst Characters destination as a function successively called with each encoded char
         *  code.
         */
        lxiv.encode = function(src, dst) {
            var b, t;
            while ((b = src()) !== null) {
                dst(aout[(b>>2)&0x3f]);
                t = (b&0x3)<<4;
                if ((b = src()) !== null) {
                    t |= (b>>4)&0xf;
                    dst(aout[(t|((b>>4)&0xf))&0x3f]);
                    t = (b&0xf)<<2;
                    if ((b = src()) !== null)
                        dst(aout[(t|((b>>6)&0x3))&0x3f]),
                        dst(aout[b&0x3f]);
                    else
                        dst(aout[t&0x3f]),
                        dst(61);
                } else
                    dst(aout[t&0x3f]),
                    dst(61),
                    dst(61);
            }
        };

        /**
         * Decodes base64 char codes to bytes.
         * @param {!function():number|null} src Characters source as a function returning the next char code respectively
         *  `null` if there are no more characters left.
         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte.
         * @throws {Error} If a character code is invalid
         */
        lxiv.decode = function(src, dst) {
            var c, t1, t2;
            function fail(c) {
                throw Error("Illegal character code: "+c);
            }
            while ((c = src()) !== null) {
                t1 = ain[c];
                if (typeof t1 === 'undefined') fail(c);
                if ((c = src()) !== null) {
                    t2 = ain[c];
                    if (typeof t2 === 'undefined') fail(c);
                    dst((t1<<2)>>>0|(t2&0x30)>>4);
                    if ((c = src()) !== null) {
                        t1 = ain[c];
                        if (typeof t1 === 'undefined')
                            if (c === 61) break; else fail(c);
                        dst(((t2&0xf)<<4)>>>0|(t1&0x3c)>>2);
                        if ((c = src()) !== null) {
                            t2 = ain[c];
                            if (typeof t2 === 'undefined')
                                if (c === 61) break; else fail(c);
                            dst(((t1&0x3)<<6)>>>0|t2);
                        }
                    }
                }
            }
        };

        /**
         * Tests if a string is valid base64.
         * @param {string} str String to test
         * @returns {boolean} `true` if valid, otherwise `false`
         */
        lxiv.test = function(str) {
            return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(str);
        };

        return lxiv;
    }();

    // encodings/base64

    /**
     * Encodes this ByteBuffer's contents to a base64 encoded string.
     * @param {number=} begin Offset to begin at, defaults to {@link ByteBuffer#offset}.
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}.
     * @returns {string} Base64 encoded string
     * @throws {RangeError} If `begin` or `end` is out of bounds
     * @expose
     */
    ByteBufferPrototype.toBase64 = function(begin, end) {
        if (typeof begin === 'undefined')
            begin = this.offset;
        if (typeof end === 'undefined')
            end = this.limit;
        begin = begin | 0; end = end | 0;
        if (begin < 0 || end > this.capacity || begin > end)
            throw RangeError("begin, end");
        var sd; lxiv.encode(function() {
            return begin < end ? this.view[begin++] : null;
        }.bind(this), sd = stringDestination());
        return sd();
    };

    /**
     * Decodes a base64 encoded string to a ByteBuffer.
     * @param {string} str String to decode
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     */
    ByteBuffer.fromBase64 = function(str, littleEndian) {
        if (typeof str !== 'string')
            throw TypeError("str");
        var bb = new ByteBuffer(str.length/4*3, littleEndian),
            i = 0;
        lxiv.decode(stringSource(str), function(b) {
            bb.view[i++] = b;
        });
        bb.limit = i;
        return bb;
    };

    /**
     * Encodes a binary string to base64 like `window.btoa` does.
     * @param {string} str Binary string
     * @returns {string} Base64 encoded string
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.btoa
     * @expose
     */
    ByteBuffer.btoa = function(str) {
        return ByteBuffer.fromBinary(str).toBase64();
    };

    /**
     * Decodes a base64 encoded string to binary like `window.atob` does.
     * @param {string} b64 Base64 encoded string
     * @returns {string} Binary string
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.atob
     * @expose
     */
    ByteBuffer.atob = function(b64) {
        return ByteBuffer.fromBase64(b64).toBinary();
    };

    // encodings/binary

    /**
     * Encodes this ByteBuffer to a binary encoded string, that is using only characters 0x00-0xFF as bytes.
     * @param {number=} begin Offset to begin at. Defaults to {@link ByteBuffer#offset}.
     * @param {number=} end Offset to end at. Defaults to {@link ByteBuffer#limit}.
     * @returns {string} Binary encoded string
     * @throws {RangeError} If `offset > limit`
     * @expose
     */
    ByteBufferPrototype.toBinary = function(begin, end) {
        if (typeof begin === 'undefined')
            begin = this.offset;
        if (typeof end === 'undefined')
            end = this.limit;
        begin |= 0; end |= 0;
        if (begin < 0 || end > this.capacity() || begin > end)
            throw RangeError("begin, end");
        if (begin === end)
            return "";
        var chars = [],
            parts = [];
        while (begin < end) {
            chars.push(this.view[begin++]);
            if (chars.length >= 1024)
                parts.push(String.fromCharCode.apply(String, chars)),
                chars = [];
        }
        return parts.join('') + String.fromCharCode.apply(String, chars);
    };

    /**
     * Decodes a binary encoded string, that is using only characters 0x00-0xFF as bytes, to a ByteBuffer.
     * @param {string} str String to decode
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     */
    ByteBuffer.fromBinary = function(str, littleEndian) {
        if (typeof str !== 'string')
            throw TypeError("str");
        var i = 0,
            k = str.length,
            charCode,
            bb = new ByteBuffer(k, littleEndian);
        while (i<k) {
            charCode = str.charCodeAt(i);
            if (charCode > 0xff)
                throw RangeError("illegal char code: "+charCode);
            bb.view[i++] = charCode;
        }
        bb.limit = k;
        return bb;
    };

    // encodings/debug

    /**
     * Encodes this ByteBuffer to a hex encoded string with marked offsets. Offset symbols are:
     * * `<` : offset,
     * * `'` : markedOffset,
     * * `>` : limit,
     * * `|` : offset and limit,
     * * `[` : offset and markedOffset,
     * * `]` : markedOffset and limit,
     * * `!` : offset, markedOffset and limit
     * @param {boolean=} columns If `true` returns two columns hex + ascii, defaults to `false`
     * @returns {string|!Array.<string>} Debug string or array of lines if `asArray = true`
     * @expose
     * @example `>00'01 02<03` contains four bytes with `limit=0, markedOffset=1, offset=3`
     * @example `00[01 02 03>` contains four bytes with `offset=markedOffset=1, limit=4`
     * @example `00|01 02 03` contains four bytes with `offset=limit=1, markedOffset=-1`
     * @example `|` contains zero bytes with `offset=limit=0, markedOffset=-1`
     */
    ByteBufferPrototype.toDebug = function(columns) {
        var i = -1,
            k = this.buffer.byteLength,
            b,
            hex = "",
            asc = "",
            out = "";
        while (i<k) {
            if (i !== -1) {
                b = this.view[i];
                if (b < 0x10) hex += "0"+b.toString(16).toUpperCase();
                else hex += b.toString(16).toUpperCase();
                if (columns)
                    asc += b > 32 && b < 127 ? String.fromCharCode(b) : '.';
            }
            ++i;
            if (columns) {
                if (i > 0 && i % 16 === 0 && i !== k) {
                    while (hex.length < 3*16+3) hex += " ";
                    out += hex+asc+"\n";
                    hex = asc = "";
                }
            }
            if (i === this.offset && i === this.limit)
                hex += i === this.markedOffset ? "!" : "|";
            else if (i === this.offset)
                hex += i === this.markedOffset ? "[" : "<";
            else if (i === this.limit)
                hex += i === this.markedOffset ? "]" : ">";
            else
                hex += i === this.markedOffset ? "'" : (columns || (i !== 0 && i !== k) ? " " : "");
        }
        if (columns && hex !== " ") {
            while (hex.length < 3*16+3)
                hex += " ";
            out += hex + asc + "\n";
        }
        return columns ? out : hex;
    };

    /**
     * Decodes a hex encoded string with marked offsets to a ByteBuffer.
     * @param {string} str Debug string to decode (not be generated with `columns = true`)
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     * @see ByteBuffer#toDebug
     */
    ByteBuffer.fromDebug = function(str, littleEndian, noAssert) {
        var k = str.length,
            bb = new ByteBuffer(((k+1)/3)|0, littleEndian, noAssert);
        var i = 0, j = 0, ch, b,
            rs = false, // Require symbol next
            ho = false, hm = false, hl = false, // Already has offset (ho), markedOffset (hm), limit (hl)?
            fail = false;
        while (i<k) {
            switch (ch = str.charAt(i++)) {
                case '!':
                    if (!noAssert) {
                        if (ho || hm || hl) {
                            fail = true;
                            break;
                        }
                        ho = hm = hl = true;
                    }
                    bb.offset = bb.markedOffset = bb.limit = j;
                    rs = false;
                    break;
                case '|':
                    if (!noAssert) {
                        if (ho || hl) {
                            fail = true;
                            break;
                        }
                        ho = hl = true;
                    }
                    bb.offset = bb.limit = j;
                    rs = false;
                    break;
                case '[':
                    if (!noAssert) {
                        if (ho || hm) {
                            fail = true;
                            break;
                        }
                        ho = hm = true;
                    }
                    bb.offset = bb.markedOffset = j;
                    rs = false;
                    break;
                case '<':
                    if (!noAssert) {
                        if (ho) {
                            fail = true;
                            break;
                        }
                        ho = true;
                    }
                    bb.offset = j;
                    rs = false;
                    break;
                case ']':
                    if (!noAssert) {
                        if (hl || hm) {
                            fail = true;
                            break;
                        }
                        hl = hm = true;
                    }
                    bb.limit = bb.markedOffset = j;
                    rs = false;
                    break;
                case '>':
                    if (!noAssert) {
                        if (hl) {
                            fail = true;
                            break;
                        }
                        hl = true;
                    }
                    bb.limit = j;
                    rs = false;
                    break;
                case "'":
                    if (!noAssert) {
                        if (hm) {
                            fail = true;
                            break;
                        }
                        hm = true;
                    }
                    bb.markedOffset = j;
                    rs = false;
                    break;
                case ' ':
                    rs = false;
                    break;
                default:
                    if (!noAssert) {
                        if (rs) {
                            fail = true;
                            break;
                        }
                    }
                    b = parseInt(ch+str.charAt(i++), 16);
                    if (!noAssert) {
                        if (isNaN(b) || b < 0 || b > 255)
                            throw TypeError("Illegal str: Not a debug encoded string");
                    }
                    bb.view[j++] = b;
                    rs = true;
            }
            if (fail)
                throw TypeError("Illegal str: Invalid symbol at "+i);
        }
        if (!noAssert) {
            if (!ho || !hl)
                throw TypeError("Illegal str: Missing offset or limit");
            if (j<bb.buffer.byteLength)
                throw TypeError("Illegal str: Not a debug encoded string (is it hex?) "+j+" < "+k);
        }
        return bb;
    };

    // encodings/hex

    /**
     * Encodes this ByteBuffer's contents to a hex encoded string.
     * @param {number=} begin Offset to begin at. Defaults to {@link ByteBuffer#offset}.
     * @param {number=} end Offset to end at. Defaults to {@link ByteBuffer#limit}.
     * @returns {string} Hex encoded string
     * @expose
     */
    ByteBufferPrototype.toHex = function(begin, end) {
        begin = typeof begin === 'undefined' ? this.offset : begin;
        end = typeof end === 'undefined' ? this.limit : end;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        var out = new Array(end - begin),
            b;
        while (begin < end) {
            b = this.view[begin++];
            if (b < 0x10)
                out.push("0", b.toString(16));
            else out.push(b.toString(16));
        }
        return out.join('');
    };

    /**
     * Decodes a hex encoded string to a ByteBuffer.
     * @param {string} str String to decode
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     */
    ByteBuffer.fromHex = function(str, littleEndian, noAssert) {
        if (!noAssert) {
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
            if (str.length % 2 !== 0)
                throw TypeError("Illegal str: Length not a multiple of 2");
        }
        var k = str.length,
            bb = new ByteBuffer((k / 2) | 0, littleEndian),
            b;
        for (var i=0, j=0; i<k; i+=2) {
            b = parseInt(str.substring(i, i+2), 16);
            if (!noAssert)
                if (!isFinite(b) || b < 0 || b > 255)
                    throw TypeError("Illegal str: Contains non-hex characters");
            bb.view[j++] = b;
        }
        bb.limit = j;
        return bb;
    };

    // utfx-embeddable

    /**
     * utfx-embeddable (c) 2014 Daniel Wirtz <dcode@dcode.io>
     * Released under the Apache License, Version 2.0
     * see: https://github.com/dcodeIO/utfx for details
     */
    var utfx = function() {
        "use strict";

        /**
         * utfx namespace.
         * @inner
         * @type {!Object.<string,*>}
         */
        var utfx = {};

        /**
         * Maximum valid code point.
         * @type {number}
         * @const
         */
        utfx.MAX_CODEPOINT = 0x10FFFF;

        /**
         * Encodes UTF8 code points to UTF8 bytes.
         * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point
         *  respectively `null` if there are no more code points left or a single numeric code point.
         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte
         */
        utfx.encodeUTF8 = function(src, dst) {
            var cp = null;
            if (typeof src === 'number')
                cp = src,
                src = function() { return null; };
            while (cp !== null || (cp = src()) !== null) {
                if (cp < 0x80)
                    dst(cp&0x7F);
                else if (cp < 0x800)
                    dst(((cp>>6)&0x1F)|0xC0),
                    dst((cp&0x3F)|0x80);
                else if (cp < 0x10000)
                    dst(((cp>>12)&0x0F)|0xE0),
                    dst(((cp>>6)&0x3F)|0x80),
                    dst((cp&0x3F)|0x80);
                else
                    dst(((cp>>18)&0x07)|0xF0),
                    dst(((cp>>12)&0x3F)|0x80),
                    dst(((cp>>6)&0x3F)|0x80),
                    dst((cp&0x3F)|0x80);
                cp = null;
            }
        };

        /**
         * Decodes UTF8 bytes to UTF8 code points.
         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there
         *  are no more bytes left.
         * @param {!function(number)} dst Code points destination as a function successively called with each decoded code point.
         * @throws {RangeError} If a starting byte is invalid in UTF8
         * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the
         *  remaining bytes.
         */
        utfx.decodeUTF8 = function(src, dst) {
            var a, b, c, d, fail = function(b) {
                b = b.slice(0, b.indexOf(null));
                var err = Error(b.toString());
                err.name = "TruncatedError";
                err['bytes'] = b;
                throw err;
            };
            while ((a = src()) !== null) {
                if ((a&0x80) === 0)
                    dst(a);
                else if ((a&0xE0) === 0xC0)
                    ((b = src()) === null) && fail([a, b]),
                    dst(((a&0x1F)<<6) | (b&0x3F));
                else if ((a&0xF0) === 0xE0)
                    ((b=src()) === null || (c=src()) === null) && fail([a, b, c]),
                    dst(((a&0x0F)<<12) | ((b&0x3F)<<6) | (c&0x3F));
                else if ((a&0xF8) === 0xF0)
                    ((b=src()) === null || (c=src()) === null || (d=src()) === null) && fail([a, b, c ,d]),
                    dst(((a&0x07)<<18) | ((b&0x3F)<<12) | ((c&0x3F)<<6) | (d&0x3F));
                else throw RangeError("Illegal starting byte: "+a);
            }
        };

        /**
         * Converts UTF16 characters to UTF8 code points.
         * @param {!function():number|null} src Characters source as a function returning the next char code respectively
         *  `null` if there are no more characters left.
         * @param {!function(number)} dst Code points destination as a function successively called with each converted code
         *  point.
         */
        utfx.UTF16toUTF8 = function(src, dst) {
            var c1, c2 = null;
            while (true) {
                if ((c1 = c2 !== null ? c2 : src()) === null)
                    break;
                if (c1 >= 0xD800 && c1 <= 0xDFFF) {
                    if ((c2 = src()) !== null) {
                        if (c2 >= 0xDC00 && c2 <= 0xDFFF) {
                            dst((c1-0xD800)*0x400+c2-0xDC00+0x10000);
                            c2 = null; continue;
                        }
                    }
                }
                dst(c1);
            }
            if (c2 !== null) dst(c2);
        };

        /**
         * Converts UTF8 code points to UTF16 characters.
         * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point
         *  respectively `null` if there are no more code points left or a single numeric code point.
         * @param {!function(number)} dst Characters destination as a function successively called with each converted char code.
         * @throws {RangeError} If a code point is out of range
         */
        utfx.UTF8toUTF16 = function(src, dst) {
            var cp = null;
            if (typeof src === 'number')
                cp = src, src = function() { return null; };
            while (cp !== null || (cp = src()) !== null) {
                if (cp <= 0xFFFF)
                    dst(cp);
                else
                    cp -= 0x10000,
                    dst((cp>>10)+0xD800),
                    dst((cp%0x400)+0xDC00);
                cp = null;
            }
        };

        /**
         * Converts and encodes UTF16 characters to UTF8 bytes.
         * @param {!function():number|null} src Characters source as a function returning the next char code respectively `null`
         *  if there are no more characters left.
         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte.
         */
        utfx.encodeUTF16toUTF8 = function(src, dst) {
            utfx.UTF16toUTF8(src, function(cp) {
                utfx.encodeUTF8(cp, dst);
            });
        };

        /**
         * Decodes and converts UTF8 bytes to UTF16 characters.
         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there
         *  are no more bytes left.
         * @param {!function(number)} dst Characters destination as a function successively called with each converted char code.
         * @throws {RangeError} If a starting byte is invalid in UTF8
         * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the remaining bytes.
         */
        utfx.decodeUTF8toUTF16 = function(src, dst) {
            utfx.decodeUTF8(src, function(cp) {
                utfx.UTF8toUTF16(cp, dst);
            });
        };

        /**
         * Calculates the byte length of an UTF8 code point.
         * @param {number} cp UTF8 code point
         * @returns {number} Byte length
         */
        utfx.calculateCodePoint = function(cp) {
            return (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;
        };

        /**
         * Calculates the number of UTF8 bytes required to store UTF8 code points.
         * @param {(!function():number|null)} src Code points source as a function returning the next code point respectively
         *  `null` if there are no more code points left.
         * @returns {number} The number of UTF8 bytes required
         */
        utfx.calculateUTF8 = function(src) {
            var cp, l=0;
            while ((cp = src()) !== null)
                l += (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;
            return l;
        };

        /**
         * Calculates the number of UTF8 code points respectively UTF8 bytes required to store UTF16 char codes.
         * @param {(!function():number|null)} src Characters source as a function returning the next char code respectively
         *  `null` if there are no more characters left.
         * @returns {!Array.<number>} The number of UTF8 code points at index 0 and the number of UTF8 bytes required at index 1.
         */
        utfx.calculateUTF16asUTF8 = function(src) {
            var n=0, l=0;
            utfx.UTF16toUTF8(src, function(cp) {
                ++n; l += (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;
            });
            return [n,l];
        };

        return utfx;
    }();

    // encodings/utf8

    /**
     * Encodes this ByteBuffer's contents between {@link ByteBuffer#offset} and {@link ByteBuffer#limit} to an UTF8 encoded
     *  string.
     * @returns {string} Hex encoded string
     * @throws {RangeError} If `offset > limit`
     * @expose
     */
    ByteBufferPrototype.toUTF8 = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        var sd; try {
            utfx.decodeUTF8toUTF16(function() {
                return begin < end ? this.view[begin++] : null;
            }.bind(this), sd = stringDestination());
        } catch (e) {
            if (begin !== end)
                throw RangeError("Illegal range: Truncated data, "+begin+" != "+end);
        }
        return sd();
    };

    /**
     * Decodes an UTF8 encoded string to a ByteBuffer.
     * @param {string} str String to decode
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     */
    ByteBuffer.fromUTF8 = function(str, littleEndian, noAssert) {
        if (!noAssert)
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
        var bb = new ByteBuffer(utfx.calculateUTF16asUTF8(stringSource(str), true)[1], littleEndian, noAssert),
            i = 0;
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            bb.view[i++] = b;
        });
        bb.limit = i;
        return bb;
    };

    return ByteBuffer;
});


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var ChainTypes = {};

ChainTypes.reserved_spaces = {
    relative_protocol_ids: 0,
    protocol_ids: 1,
    implementation_ids: 2,
    nh_protocol_ids:4
};

ChainTypes.object_type = {
    "null": 0,
    base: 1,
    account: 2,
    asset: 3,
    force_settlement: 4,
    committee_member: 5,
    witness: 6,
    limit_order: 7,
    call_order: 8,
    custom: 9,
    proposal: 10,
    operation_history: 11,
    withdraw_permission: 12,
    vesting_balance: 13,
    worker: 14,
    balance: 15,
    contract_id_type: 16,
    crontab_id_type:19
};

ChainTypes.lua_type = {
    int:0,
    number:1,
    string:2,
    boolean:3,
    table:4,
    function:5,
    memo_data:6,
    asset:7
};

ChainTypes.impl_object_type = {
    global_property: 0,
    dynamic_global_property: 1,
    index_meta: 2,
    asset_dynamic_data: 3,
    asset_bitasset_data: 4,
    account_balance: 5,
    account_statistics: 6,
    transaction: 7,
    block_summary: 8,
    account_transaction_history: 9,
    blinded_balance: 10,
    chain_property: 11,
    witness_schedule: 12,
    budget_record: 13
};

ChainTypes.nh_object_type = {
    nh_developer_object_type: 0,
    nh_version_object_type:1,
    nh_item_object_type:2,
    nh_item_order_object_type:3
};

ChainTypes.vote_type = {
    committee: 0,
    witness: 1,
    worker: 2
};

ChainTypes.operations = {
    transfer: 0,
    limit_order_create: 1,
    limit_order_cancel: 2,
    call_order_update: 3,
    fill_order: 4,
    account_create: 5,
    account_update: 6,
    account_upgrade: 7,
    asset_create: 8,
    asset_update: 9,
    asset_update_restricted:10,
    asset_update_bitasset: 11,
    asset_update_feed_producers: 12,
    asset_issue: 13,
    asset_reserve: 14,
    asset_settle: 15,
    asset_global_settle: 16,
    asset_publish_feed: 17,
    witness_create: 18,
    // asset_publish_feed: 18,

    witness_update: 19,
    proposal_create:20,
    proposal_update: 21,
    proposal_delete: 22,
    committee_member_create: 23,
    committee_member_update: 24,
    committee_member_update_global_parameters: 25,
    vesting_balance_create: 26,
    vesting_balance_withdraw: 27,
    worker_create: 28,
    balance_claim: 29,
    asset_settle_cancel: 30,
    asset_claim_fees: 31,
    bid_collateral:32,
    execute_bid:33,
    contract_create:34,
    call_contract_function:35,
    temporary_authority_chang:36,
    register_nh_asset_creator:37,
    create_world_view:38,
    relate_world_view:39,
    create_nh_asset:40,
    delete_nh_asset:41,
    transfer_nh_asset:42,
    create_nh_asset_order:43,
    cancel_nh_asset_order:44,
    fill_nh_asset_order:45,
    create_file:46,
    add_file_relate_account:47,
    file_signature:48,
    relate_parent_file:49,
    revise_contract:50,
    crontab_create:51, 
    crontab_cancel:52,
    crontab_recover:53,
    update_collateral_for_gas:54    
};

exports.default = ChainTypes;
module.exports = exports["default"];

/***/ }),
/* 132 */
/***/ (function(module, exports) {

module.exports = function getFunctionName(f) {
  return f.displayName || f.name || '<function' + f.length + '>';
};

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

var assert = __webpack_require__(20);
var getTypeName = __webpack_require__(35);

module.exports = function forbidNewOperator(x, type) {
  assert(!(x instanceof type), function () { return 'Cannot use the new operator to instantiate the type ' + getTypeName(type); });
};

/***/ }),
/* 134 */,
/* 135 */,
/* 136 */,
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _bytebuffer = __webpack_require__(130);

var _ChainTypes = __webpack_require__(131);

var _ChainTypes2 = _interopRequireDefault(_ChainTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MAX_SAFE_INT =100000000000*1000000; //9007199254740991;
var MIN_SAFE_INT =-100000000000*1000000;//-9007199254740991;

/**
    Most validations are skipped and the value returned unchanged when an empty string, null, or undefined is encountered (except "required").

    Validations support a string format for dealing with large numbers.
*/
var _my = {
    is_empty: function is_empty(value) {
        return value === null || value === undefined;
    },

    required: function required(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
        if (this.is_empty(value)) {
            throw new Error("value required " + field_name + " " + value);
        }
        return value;
    },
    require_long: function require_long(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
        if (!_bytebuffer.Long.isLong(value)) {
            throw new Error("Long value required " + field_name + " " + value);
        }
        return value;
    },
    string: function string(value) {
        if (this.is_empty(value)) {
            return value;
        }
        if (typeof value !== "string") {
            throw new Error("string required: " + value);
        }
        return value;
    },
    number: function number(value) {
        if (this.is_empty(value)) {
            return value;
        }
        if (typeof value !== "number") {
            throw new Error("number required: " + value);
        }
        return value;
    },
    whole_number: function whole_number(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

        if (this.is_empty(value)) {
            return value;
        }
        if (/\./.test(value)) {
            throw new Error("whole number required " + field_name + " " + value);
        }
        return value;
    },
    unsigned: function unsigned(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

        if (this.is_empty(value)) {
            return value;
        }
        if (/-/.test(value)) {
            throw new Error("unsigned required " + field_name + " " + value);
        }
        return value;
    },


    is_digits: function is_digits(value) {
        if (typeof value === "numeric") {
            return true;
        }
        return (/^[0-9]+$/.test(value)
        );
    },

    to_number: function to_number(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

        if (this.is_empty(value)) {
            return value;
        }
        this.no_overflow53(value, field_name);
        var int_value = function () {
            if (typeof value === "number") {
                return value;
            } else {
                return parseInt(value);
            }
        }();
        return int_value;
    },

    to_long: function to_long(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
        var unsigned = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        if (this.is_empty(value)) {
            return value;
        }
        if (_bytebuffer.Long.isLong(value)) {
            return value;
        }

        this.no_overflow64(value, field_name, unsigned);
        if (typeof value === "number") {
            value = "" + value;
        }
        return _bytebuffer.Long.fromString(value, unsigned);
    },
    to_string: function to_string(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

        if (this.is_empty(value)) {
            return value;
        }
        if (typeof value === "string") {
            return value;
        }
        if (typeof value === "number") {
            this.no_overflow53(value, field_name);
            return "" + value;
        }
        if (_bytebuffer.Long.isLong(value)) {
            return value.toString();
        }
        throw "unsupported type " + field_name + ": (" + (typeof value === "undefined" ? "undefined" : _typeof(value)) + ") " + value;
    },
    require_test: function require_test(regex, value) {
        var field_name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";

        if (this.is_empty(value)) {
            return value;
        }
        if (!regex.test(value)) {
            throw new Error("unmatched " + regex + " " + field_name + " " + value);
        }
        return value;
    },


    require_match: function require_match(regex, value) {
        var field_name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";

        if (this.is_empty(value)) {
            return value;
        }
        var match = value.match(regex);
        if (match === null) {
            throw new Error("unmatched " + regex + " " + field_name + " " + value);
        }
        return match;
    },

    require_object_id: function require_object_id(value, field_name) {
        return require_match(/^([0-9]+)\.([0-9]+)\.([0-9]+)$/, value, field_name);
    },

    // Does not support over 53 bits
    require_range: function require_range(min, max, value) {
        var field_name = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";

        if (this.is_empty(value)) {
            return value;
        }
        var number = this.to_number(value);
        if (value < min || value > max) {
            throw new Error("out of range " + value + " " + field_name + " " + value);
        }
        return value;
    },


    require_object_type: function require_object_type() {
        var reserved_spaces = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
        var type = arguments[1];
        var value = arguments[2];
        var field_name = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";

        if (this.is_empty(value)) {
            return value;
        }
        var object_type = _ChainTypes2.default.object_type[type];
         if(value.split(".")[0]=="4"){
            object_type= _ChainTypes2.default.nh_object_type[type];
         }
        if (!object_type) {
            throw new Error("Unknown object type " + type + " " + field_name + " " + value);
        }
        var re = new RegExp(reserved_spaces + "." + object_type + ".[0-9]+$");
        if (!re.test(value)) {
            throw new Error("Expecting " + type + " in format " + (reserved_spaces + "." + object_type + ".[0-9]+ ") + ("instead of " + value + " " + field_name + " " + value));
        }
        return value;
    },

    get_instance: function get_instance(reserve_spaces, type, value, field_name) {
        if (this.is_empty(value)) {
            return value;
        }
        this.require_object_type(reserve_spaces, type, value, field_name);
        // if(value.split(".")[1]=="16"){
        //     return value;
        // }
        return this.to_number(value.split(".")[2]);
    },

    require_relative_type: function require_relative_type(type, value, field_name) {
        this.require_object_type(0, type, value, field_name);
        return value;
    },

    get_relative_instance: function get_relative_instance(type, value, field_name) {
        if (this.is_empty(value)) {
            return value;
        }
        this.require_object_type(0, type, value, field_name);
        return this.to_number(value.split(".")[2]);
    },

    require_protocol_type: function require_protocol_type(type, value, field_name) {
        this.require_object_type(1, type, value, field_name);
        return value;
    },

    get_protocol_instance: function get_protocol_instance(type, value, field_name) {
        if (this.is_empty(value)) {
            return value;
        }
        this.require_object_type(1, type, value, field_name);
        return this.to_number(value.split(".")[2]);
    },

    get_protocol_type: function get_protocol_type(value, field_name) {
        if (this.is_empty(value)) {
            return value;
        }
        this.require_object_id(value, field_name);
        var values = value.split(".");
        return this.to_number(values[1]);
    },

    get_protocol_type_name: function get_protocol_type_name(value, field_name) {
        if (this.is_empty(value)) {
            return value;
        }
        var type_id = this.get_protocol_type(value, field_name);
        return Object.keys(_ChainTypes2.default.object_type)[type_id];
    },


    require_implementation_type: function require_implementation_type(type, value, field_name) {
        this.require_object_type(2, type, value, field_name);
        return value;
    },

    get_implementation_instance: function get_implementation_instance(type, value, field_name) {
        if (this.is_empty(value)) {
            return value;
        }
        this.require_object_type(2, type, value, field_name);
        return this.to_number(value.split(".")[2]);
    },

    // signed / unsigned decimal
    no_overflow53: function no_overflow53(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

        if (typeof value === "number") {
            if (value > MAX_SAFE_INT || value < MIN_SAFE_INT) {
                throw new Error("overflow " + field_name + " " + value);
            }
            return;
        }
        if (typeof value === "string") {
            var int = parseInt(value);
            if (value > MAX_SAFE_INT || value < MIN_SAFE_INT) {
                throw new Error("overflow " + field_name + " " + value);
            }
            return;
        }
        if (_bytebuffer.Long.isLong(value)) {
            // typeof value.toInt() is 'number'
            this.no_overflow53(value.toInt(), field_name);
            return;
        }
        throw "unsupported type " + field_name + ": (" + (typeof value === "undefined" ? "undefined" : _typeof(value)) + ") " + value;
    },


    // signed / unsigned whole numbers only
    no_overflow64: function no_overflow64(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
        var unsigned = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        // https://github.com/dcodeIO/Long.js/issues/20
        if (_bytebuffer.Long.isLong(value)) {
            return;
        }

        // BigInteger#isBigInteger https://github.com/cryptocoinjs/bigi/issues/20
        if (value.t !== undefined && value.s !== undefined) {
            this.no_overflow64(value.toString(), field_name, unsigned);
            return;
        }
        if (typeof value === "string") {
            // remove leading zeros, will cause a false positive
            value = value.replace(/^0+/, "");
            // remove trailing zeros
            while (/0$/.test(value)) {
                value = value.substring(0, value.length - 1);
            }
            if (/\.$/.test(value)) {
                // remove trailing dot
                value = value.substring(0, value.length - 1);
            }
            if (value === "") {
                value = "0";
            }
            var long_string = _bytebuffer.Long.fromString(value, unsigned).toString();
            if (long_string !== value.trim()) {
                throw new Error("overflow " + field_name + " " + value);
            }
            return;
        }
        if (typeof value === "number") {
            if (value > MAX_SAFE_INT || value < MIN_SAFE_INT) {
                throw new Error("overflow " + field_name + " " + value);
            }
            return;
        }

        throw "unsupported type " + field_name + ": (" + (typeof value === "undefined" ? "undefined" : _typeof(value)) + ") " + value;
    }
};

exports.default = _my;
module.exports = exports["default"];

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

exports.__esModule = true;

var _ecurve = __webpack_require__(215);

var _ecurve2 = _interopRequireDefault(_ecurve);

var _bigi = __webpack_require__(57);

var _bigi2 = _interopRequireDefault(_bigi);

var _bs = __webpack_require__(216);

var _hash = __webpack_require__(58);

var _PublicKey = __webpack_require__(97);

var _PublicKey2 = _interopRequireDefault(_PublicKey);

var _deepEqual = __webpack_require__(217);

var _deepEqual2 = _interopRequireDefault(_deepEqual);

var _assert = __webpack_require__(45);

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var secp256k1 = (0, _ecurve.getCurveByName)('secp256k1');
var G = secp256k1.G,
    n = secp256k1.n;

var PrivateKey = function () {

    /**
        @private see static functions
        @param {BigInteger}
    */
    function PrivateKey(d) {
        _classCallCheck(this, PrivateKey);

        this.d = d;
    }

    PrivateKey.fromBuffer = function fromBuffer(buf) {
        if (!Buffer.isBuffer(buf)) {
            throw new Error("Expecting paramter to be a Buffer type");
        }
        if (32 !== buf.length) {
            console.log('WARN: Expecting 32 bytes, instead got ' + buf.length + ', stack trace:', new Error().stack);
        }
        if (buf.length === 0) {
            throw new Error("Empty buffer");
        }
        return new PrivateKey(_bigi2.default.fromBuffer(buf));
    };

    /** @arg {string} seed - any length string.  This is private, the same seed produces the same private key every time.  */


    PrivateKey.fromSeed = function fromSeed(seed) {
        // generate_private_key
        if (!(typeof seed === 'string')) {
            throw new Error('seed must be of type string');
        }
        return PrivateKey.fromBuffer((0, _hash.sha256)(seed));
    };

    /** @return {string} Wallet Import Format (still a secret, Not encrypted) */


    PrivateKey.fromWif = function fromWif(_private_wif) {
        var private_wif = new Buffer((0, _bs.decode)(_private_wif));
        var version = private_wif.readUInt8(0);
        _assert2.default.equal(0x80, version, 'Expected version ' + 0x80 + ', instead got ' + version);
        // checksum includes the version
        var private_key = private_wif.slice(0, -4);
        var checksum = private_wif.slice(-4);
        var new_checksum = (0, _hash.sha256)(private_key);
        new_checksum = (0, _hash.sha256)(new_checksum);
        new_checksum = new_checksum.slice(0, 4);
        var isEqual = (0, _deepEqual2.default)(checksum, new_checksum); //, 'Invalid checksum'
        if (!isEqual) {
            throw new Error("Checksum did not match");
        }
        private_key = private_key.slice(1);
        return PrivateKey.fromBuffer(private_key);
    };

    PrivateKey.prototype.toWif = function toWif() {
        var private_key = this.toBuffer();
        // checksum includes the version
        private_key = Buffer.concat([new Buffer([0x80]), private_key]);
        var checksum = (0, _hash.sha256)(private_key);
        checksum = (0, _hash.sha256)(checksum);
        checksum = checksum.slice(0, 4);
        var private_wif = Buffer.concat([private_key, checksum]);
        return (0, _bs.encode)(private_wif);
    };

    /**
        @return {Point}
    */


    PrivateKey.prototype.toPublicKeyPoint = function toPublicKeyPoint() {
        var Q;
        return Q = secp256k1.G.multiply(this.d);
    };

    PrivateKey.prototype.toPublicKey = function toPublicKey() {
        if (this.public_key) {
            return this.public_key;
        }
        return this.public_key = _PublicKey2.default.fromPoint(this.toPublicKeyPoint());
    };

    PrivateKey.prototype.toBuffer = function toBuffer() {
        return this.d.toBuffer(32);
    };

    /** ECIES */


    PrivateKey.prototype.get_shared_secret = function get_shared_secret(public_key) {
        var legacy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        public_key = toPublic(public_key);
        var KB = public_key.toUncompressed().toBuffer();
        var KBP = _ecurve.Point.fromAffine(secp256k1, _bigi2.default.fromBuffer(KB.slice(1, 33)), // x
        _bigi2.default.fromBuffer(KB.slice(33, 65)) // y
        );
        var r = this.toBuffer();
        var P = KBP.multiply(_bigi2.default.fromBuffer(r));
        var S = P.affineX.toBuffer({ size: 32 });
        /*
        the input to sha512 must be exactly 32-bytes, to match the c++ implementation
        of get_shared_secret.  Right now S will be shorter if the most significant
        byte(s) is zero.  Pad it back to the full 32-bytes
        */
        if (!legacy && S.length < 32) {
            var pad = new Buffer(32 - S.length).fill(0);
            S = Buffer.concat([pad, S]);
        }

        // SHA512 used in ECIES
        return (0, _hash.sha512)(S);
    };

    // /** ECIES (does not always match the Point.fromAffine version above) */
    // get_shared_secret(public_key){
    //     public_key = toPublic(public_key)
    //     var P = public_key.Q.multiply( this.d );
    //     var S = P.affineX.toBuffer({size: 32});
    //     // ECIES, adds an extra sha512
    //     return sha512(S);
    // }

    /** @throws {Error} - overflow of the key could not be derived */


    PrivateKey.prototype.child = function child(offset) {
        offset = Buffer.concat([this.toPublicKey().toBuffer(), offset]);
        offset = (0, _hash.sha256)(offset);
        var c = _bigi2.default.fromBuffer(offset);

        if (c.compareTo(n) >= 0) throw new Error("Child offset went out of bounds, try again");

        var derived = this.d.add(c); //.mod(n)

        if (derived.signum() === 0) throw new Error("Child offset derived to an invalid key, try again");

        return new PrivateKey(derived);
    };

    /* <helper_functions> */

    PrivateKey.prototype.toByteBuffer = function toByteBuffer() {
        var b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);
        this.appendByteBuffer(b);
        return b.copy(0, b.offset);
    };

    PrivateKey.fromHex = function fromHex(hex) {
        return PrivateKey.fromBuffer(new Buffer(hex, 'hex'));
    };

    PrivateKey.prototype.toHex = function toHex() {
        return this.toBuffer().toString('hex');
    };

    /* </helper_functions> */


    return PrivateKey;
}();

exports.default = PrivateKey;


var toPublic = function toPublic(data) {
    return data == null ? data : data.Q ? data : _PublicKey2.default.fromStringOrThrow(data);
};
module.exports = exports['default'];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = __webpack_require__(18);

var _stringify2 = _interopRequireDefault(_stringify);

var _typeof2 = __webpack_require__(26);

var _typeof3 = _interopRequireDefault(_typeof2);

var _jsCookie = __webpack_require__(492);

var _jsCookie2 = _interopRequireDefault(_jsCookie);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _host = (process.browser || true ? window.location.host : "GPH") + "_" + "1.4";
// Persistent Storage for data cache management
var PersistentStorage = {
  saveUserData: function saveUserData(_ref) {
    var id = _ref.id,
        encrypted_key = _ref.encrypted_key,
        encryptionKey = _ref.encryptionKey,
        passwordPubkey = _ref.passwordPubkey,
        activePubkey = _ref.activePubkey;

    _jsCookie2.default.set(_host + 'GPH_USER_ID', id, { expires: 365 });
    _jsCookie2.default.set(_host + 'GPH_USER_ENCRYPTED_KEY', encrypted_key, { expires: 365 });
    _jsCookie2.default.set(_host + 'GPH_ENCRYPTION_KEY', encryptionKey, { expires: 365 });
    _jsCookie2.default.set(_host + 'GPH_PASSWORD_PUBKEY', passwordPubkey, { expires: 365 });
    _jsCookie2.default.set(_host + 'GPH_ACTIVE_PUBKEY', activePubkey, { expires: 365 });
  },
  getSavedUserData: function getSavedUserData() {
    var userId = _jsCookie2.default.get(_host + 'GPH_USER_ID');
    var encrypted_key = _jsCookie2.default.get(_host + 'GPH_USER_ENCRYPTED_KEY');
    var encryptionKey = _jsCookie2.default.get(_host + 'GPH_ENCRYPTION_KEY');
    var backupDate = _jsCookie2.default.get(_host + 'BACKUP_DATE');
    var passwordPubkey = _jsCookie2.default.get(_host + 'GPH_PASSWORD_PUBKEY');
    var activePubkey = _jsCookie2.default.get(_host + 'GPH_ACTIVE_PUBKEY');
    if (!userId || !encrypted_key || !encryptionKey || !passwordPubkey) return null;
    if (typeof userId !== 'string') return null;
    return {
      userId: userId,
      encrypted_key: encrypted_key,
      encryptionKey: encryptionKey,
      backupDate: backupDate,
      passwordPubkey: passwordPubkey,
      activePubkey: activePubkey
    };
  },
  clearUserData: function clearUserData() {
    _jsCookie2.default.remove(_host + 'GPH_USER_ID');
    _jsCookie2.default.remove(_host + 'GPH_USER_ENCRYPTED_KEY');
    _jsCookie2.default.remove(_host + 'GPH_ENCRYPTION_KEY');
    _jsCookie2.default.remove(_host + 'BACKUP_DATE');
    _jsCookie2.default.remove(_host + 'GPH_PASSWORD_PUBKEY');
    _jsCookie2.default.remove(_host + 'GPH_ACTIVE_PUBKEY');
  },
  clearNodesData: function clearNodesData() {
    _jsCookie2.default.remove(_host + 'GPH_NODES');
  },
  saveNodesData: function saveNodesData(_ref2) {
    var data = _ref2.data;

    _jsCookie2.default.set(_host + 'GPH_NODES', data);
  },
  getSavedNodesData: function getSavedNodesData() {
    var cachedData = _jsCookie2.default.getJSON(_host + 'GPH_NODES');
    if ((typeof cachedData === "undefined" ? "undefined" : (0, _typeof3.default)(cachedData)) === 'object' && cachedData !== null) {
      return cachedData;
    }
    return {};
  },
  saveBackupDate: function saveBackupDate(_ref3) {
    var date = _ref3.date,
        userId = _ref3.userId;

    var backupDateArray = _jsCookie2.default.get(_host + 'BACKUP_DATE');
    if (backupDateArray === undefined) {
      backupDateArray = [{ userId: userId, date: date }];
    } else {
      try {
        var backupDateFromString = JSON.parse(backupDateArray);
        var foundObj = backupDateFromString.some(function (item) {
          return item.userId === userId;
        });
        if (!foundObj) {
          backupDateFromString.push({ userId: userId, date: date });
          backupDateArray = (0, _stringify2.default)(backupDateFromString);
        }
      } catch (ex) {
        backupDateArray = [{ userId: userId, date: date }];
      }
    }
    _jsCookie2.default.set(_host + 'BACKUP_DATE', backupDateArray, { expires: 365 });
  }
};

exports.default = PersistentStorage;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9)))

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.didOrdersChange = exports.SettleOrder = exports.CallOrder = exports.LimitOrder = exports.precisionToRatio = exports.limitByPrecision = exports.LimitOrderCreate = exports.FeedPrice = exports.Price = exports.Asset = undefined;

var _getPrototypeOf = __webpack_require__(390);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _typeof2 = __webpack_require__(26);

var _typeof3 = _interopRequireDefault(_typeof2);

var _possibleConstructorReturn2 = __webpack_require__(391);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(392);

var _inherits3 = _interopRequireDefault(_inherits2);

var _classCallCheck2 = __webpack_require__(11);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(15);

var _createClass3 = _interopRequireDefault(_createClass2);

var _fractional = __webpack_require__(511);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var GRAPHENE_100_PERCENT = 10000;

function limitByPrecision(value) {
    var p = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;

    if (typeof p !== "number") throw new Error("Input must be a number");
    var valueString = value.toString();
    var splitString = valueString.split(".");
    if (splitString.length === 1 || splitString.length === 2 && splitString[1].length <= p) {
        return parseFloat(valueString);
    } else {
        return parseFloat(splitString[0] + "." + splitString[1].substr(0, p));
    }
}

function precisionToRatio(p) {
    if (typeof p !== "number") throw new Error("Input must be a number");
    return Math.pow(10, p);
}

function didOrdersChange(newOrders, oldOrders) {
    var changed = oldOrders && oldOrders.size !== newOrders.size;
    if (changed) return changed;

    newOrders.forEach(function (a, key) {
        var oldOrder = oldOrders.get(key);
        if (!oldOrder) {
            changed = true;
        } else {
            if (a.market_base === oldOrder.market_base) {
                changed = changed || a.ne(oldOrder);
            }
        }
    });
    return changed;
}

var Asset = function () {
    function Asset() {
        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            _ref$asset_id = _ref.asset_id,
            asset_id = _ref$asset_id === undefined ? "1.3.0" : _ref$asset_id,
            _ref$amount = _ref.amount,
            amount = _ref$amount === undefined ? 0 : _ref$amount,
            _ref$precision = _ref.precision,
            precision = _ref$precision === undefined ? 5 : _ref$precision,
            _ref$real = _ref.real,
            real = _ref$real === undefined ? null : _ref$real;

        (0, _classCallCheck3.default)(this, Asset);

        this.satoshi = precisionToRatio(precision);
        this.asset_id = asset_id;
        this.setAmount({ sats: amount, real: real });
        this.precision = precision;
    }

    (0, _createClass3.default)(Asset, [{
        key: "hasAmount",
        value: function hasAmount() {
            return this.amount > 0;
        }
    }, {
        key: "toSats",
        value: function toSats() {
            var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

            // Return the full integer amount in 'satoshis'
            // Round to prevent floating point math errors
            return Math.round(amount * this.satoshi);
        }
    }, {
        key: "setAmount",
        value: function setAmount(_ref2) {
            var sats = _ref2.sats,
                real = _ref2.real;

            if (typeof sats === "string") sats = parseInt(sats, 10);
            if (typeof real === "string") real = parseFloat(real);

            if (typeof sats !== "number" && typeof real !== "number") {
                throw new Error("Invalid arguments for setAmount");
            }
            if (typeof real === "number") {
                this.amount = this.toSats(real);
                this._clearCache();
            } else if (typeof sats === "number") {
                this.amount = Math.floor(sats);
                this._clearCache();
            } else {
                throw new Error("Invalid setAmount input");
            }
        }
    }, {
        key: "_clearCache",
        value: function _clearCache() {
            this._real_amount = null;
        }
    }, {
        key: "getAmount",
        value: function getAmount() {
            var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                _ref3$real = _ref3.real,
                real = _ref3$real === undefined ? false : _ref3$real;

            if (real) {
                if (this._real_amount != null) return this._real_amount;
                return this._real_amount = limitByPrecision(this.amount / this.toSats(), this.precision);
            } else {
                return Math.floor(this.amount);
            }
        }
    }, {
        key: "plus",
        value: function plus(asset) {
            if (asset.asset_id !== this.asset_id) throw new Error("Assets are not the same type");
            this.amount += asset.amount;
            this._clearCache();
        }
    }, {
        key: "minus",
        value: function minus(asset) {
            if (asset.asset_id !== this.asset_id) throw new Error("Assets are not the same type");
            this.amount -= asset.amount;
            this.amount = Math.max(0, this.amount);
            this._clearCache();
        }
    }, {
        key: "equals",
        value: function equals(asset) {
            return this.asset_id === asset.asset_id && this.getAmount() === asset.getAmount();
        }
    }, {
        key: "ne",
        value: function ne(asset) {
            return !this.equals(asset);
        }
    }, {
        key: "gt",
        value: function gt(asset) {
            return this.getAmount() > asset.getAmount();
        }
    }, {
        key: "lt",
        value: function lt(asset) {
            return this.getAmount() < asset.getAmount();
        }
    }, {
        key: "times",
        value: function times(p) {
            var isBid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

            // asset amount times a price p
            var temp = void 0,
                amount = void 0;
            if (this.asset_id === p.base.asset_id) {
                temp = this.amount * p.quote.amount / p.base.amount;
                amount = Math.floor(temp);
                /*
                * Sometimes prices are inexact for the relevant amounts, in the case
                * of bids this means we need to round up in order to pay 1 sat more
                * than the floored price, if we don't do this the orders don't match
                */
                if (isBid && temp !== amount) {
                    amount += 1;
                }
                if (amount === 0) amount = 1;
                return new Asset({
                    asset_id: p.quote.asset_id,
                    amount: amount,
                    precision: p.quote.precision
                });
            } else if (this.asset_id === p.quote.asset_id) {
                temp = this.amount * p.base.amount / p.quote.amount;
                amount = Math.floor(temp);
                /*
                * Sometimes prices are inexact for the relevant amounts, in the case
                * of bids this means we need to round up in order to pay 1 sat more
                * than the floored price, if we don't do this the orders don't match
                */
                if (isBid && temp !== amount) {
                    amount += 1;
                }
                if (amount === 0) amount = 1;
                return new Asset({
                    asset_id: p.base.asset_id,
                    amount: amount,
                    precision: p.base.precision
                });
            }
            throw new Error("Invalid asset types for price multiplication");
        }
    }, {
        key: "divide",
        value: function divide(quote) {
            var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;

            return new Price({ base: base, quote: quote });
        }
    }, {
        key: "toObject",
        value: function toObject() {
            return {
                asset_id: this.asset_id,
                amount: this.amount
            };
        }
    }, {
        key: "clone",
        value: function clone() {
            var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.amount;

            return new Asset({
                amount: amount,
                asset_id: this.asset_id,
                precision: this.precision
            });
        }
    }]);
    return Asset;
}();

/**
 * @brief The price struct stores asset prices in the Graphene system.
 *
 * A price is defined as a ratio between two assets, and represents a possible exchange rate between those two
 * assets. prices are generally not stored in any simplified form, i.e. a price of (1000 CORE)/(20 USD) is perfectly
 * normal.
 *
 * The assets within a price are labeled base and quote. Throughout the Graphene code base, the convention used is
 * that the base asset is the asset being sold, and the quote asset is the asset being purchased, where the price is
 * represented as base/quote, so in the example price above the seller is looking to sell CORE asset and get USD in
 * return.
 */

var Price = function () {
    function Price() {
        var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            base = _ref4.base,
            quote = _ref4.quote,
            _ref4$real = _ref4.real,
            real = _ref4$real === undefined ? false : _ref4$real;

        (0, _classCallCheck3.default)(this, Price);

        if (!base || !quote) {
            throw new Error("Base and Quote assets must be defined");
        }
        if (base.asset_id === quote.asset_id) {
            throw new Error("Base and Quote assets must be different");
        }

        base = base.clone();
        quote = quote.clone();
        if (real && typeof real === "number") {
            /*
            * In order to make large numbers work properly, we assume numbers
            * larger than 100k do not need more than 5 decimals. Without this we
            * quickly encounter JavaScript floating point errors for large numbers.
            */
            if (real > 100000) {
                real = limitByPrecision(real, 5);
            }
            var frac = new _fractional.Fraction(real);
            var baseSats = base.toSats(),
                quoteSats = quote.toSats();
            var numRatio = baseSats / quoteSats,
                denRatio = quoteSats / baseSats;

            if (baseSats >= quoteSats) {
                denRatio = 1;
            } else {
                numRatio = 1;
            }

            base.amount = frac.numerator * numRatio;
            quote.amount = frac.denominator * denRatio;
        } else if (real === 0) {
            base.amount = 0;
            quote.amount = 0;
        }

        if (!base.asset_id || !("amount" in base) || !quote.asset_id || !("amount" in quote)) throw new Error("Invalid Price inputs");
        this.base = base;
        this.quote = quote;
    }

    (0, _createClass3.default)(Price, [{
        key: "getUnits",
        value: function getUnits() {
            return this.base.asset_id + "_" + this.quote.asset_id;
        }
    }, {
        key: "isValid",
        value: function isValid() {
            return this.base.amount !== 0 && this.quote.amount !== 0 && !isNaN(this.toReal()) && isFinite(this.toReal());
        }
    }, {
        key: "toReal",
        value: function toReal() {
            var sameBase = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

            var key = sameBase ? "_samebase_real" : "_not_samebase_real";
            if (this[key]) {
                return this[key];
            }
            var real = sameBase ? this.quote.amount * this.base.toSats() / (this.base.amount * this.quote.toSats()) : this.base.amount * this.quote.toSats() / (this.quote.amount * this.base.toSats());
            return this[key] = parseFloat(real.toFixed(8)); // toFixed and parseFloat helps avoid floating point errors for really big or small numbers
        }
    }, {
        key: "invert",
        value: function invert() {
            return new Price({
                base: this.quote,
                quote: this.base
            });
        }
    }, {
        key: "clone",
        value: function clone() {
            var real = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

            return new Price({
                base: this.base,
                quote: this.quote,
                real: real
            });
        }
    }, {
        key: "equals",
        value: function equals(b) {
            if (this.base.asset_id !== b.base.asset_id || this.quote.asset_id !== b.quote.asset_id) {
                // console.error("Cannot compare prices for different assets");
                return false;
            }
            var amult = b.quote.amount * this.base.amount;
            var bmult = this.quote.amount * b.base.amount;

            return amult === bmult;
        }
    }, {
        key: "lt",
        value: function lt(b) {
            if (this.base.asset_id !== b.base.asset_id || this.quote.asset_id !== b.quote.asset_id) {
                throw new Error("Cannot compare prices for different assets");
            }
            var amult = b.quote.amount * this.base.amount;
            var bmult = this.quote.amount * b.base.amount;

            return amult < bmult;
        }
    }, {
        key: "lte",
        value: function lte(b) {
            return this.equals(b) || this.lt(b);
        }
    }, {
        key: "ne",
        value: function ne(b) {
            return !this.equals(b);
        }
    }, {
        key: "gt",
        value: function gt(b) {
            return !this.lte(b);
        }
    }, {
        key: "gte",
        value: function gte(b) {
            return !this.lt(b);
        }
    }, {
        key: "toObject",
        value: function toObject() {
            return {
                base: this.base.toObject(),
                quote: this.quote.toObject()
            };
        }
    }, {
        key: "times",
        value: function times(p) {
            var common = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "1.3.0";

            var p2 = p.base.asset_id === common && this.quote.asset_id === common || p.quote.asset_id === common && this.base.asset_id === common ? p.clone() : p.invert();

            var np = p2.toReal() * this.toReal();
            return new Price({
                base: p2.base,
                quote: this.quote,
                real: np
            });
        }
    }]);
    return Price;
}();

var FeedPrice = function (_Price) {
    (0, _inherits3.default)(FeedPrice, _Price);

    function FeedPrice(_ref5) {
        var priceObject = _ref5.priceObject,
            assets = _ref5.assets,
            market_base = _ref5.market_base,
            sqr = _ref5.sqr,
            _ref5$real = _ref5.real,
            real = _ref5$real === undefined ? false : _ref5$real;
        (0, _classCallCheck3.default)(this, FeedPrice);

        if (!priceObject || (typeof priceObject === "undefined" ? "undefined" : (0, _typeof3.default)(priceObject)) !== "object" || !market_base || !assets || !sqr) {
            throw new Error("Invalid FeedPrice inputs");
        }

        if (priceObject.toJS) {
            priceObject = priceObject.toJS();
        }

        var inverted = market_base === priceObject.base.asset_id;

        var base = new Asset({
            asset_id: priceObject.base.asset_id,
            amount: priceObject.base.amount,
            precision: assets[priceObject.base.asset_id].precision
        });

        var quote = new Asset({
            asset_id: priceObject.quote.asset_id,
            amount: priceObject.quote.amount,
            precision: assets[priceObject.quote.asset_id].precision
        });

        var _this = (0, _possibleConstructorReturn3.default)(this, (FeedPrice.__proto__ || (0, _getPrototypeOf2.default)(FeedPrice)).call(this, {
            base: inverted ? quote : base,
            quote: inverted ? base : quote,
            real: real
        }));

        _this.sqr = parseInt(sqr, 10) / 1000;
        _this.inverted = inverted;
        return _this;
    }

    (0, _createClass3.default)(FeedPrice, [{
        key: "getSqueezePrice",
        value: function getSqueezePrice() {
            var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                _ref6$real = _ref6.real,
                real = _ref6$real === undefined ? false : _ref6$real;

            if (!this._squeeze_price) {
                this._squeeze_price = this.clone();
                if (this.inverted) this._squeeze_price.base.amount = Math.floor(this._squeeze_price.base.amount * this.sqr);
                if (!this.inverted) this._squeeze_price.quote.amount = Math.floor(this._squeeze_price.quote.amount * this.sqr);
            }

            if (real) {
                return this._squeeze_price.toReal();
            }
            return this._squeeze_price;
        }
    }]);
    return FeedPrice;
}(Price);

var LimitOrderCreate = function () {
    function LimitOrderCreate() {
        var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            for_sale = _ref7.for_sale,
            to_receive = _ref7.to_receive,
            _ref7$seller = _ref7.seller,
            seller = _ref7$seller === undefined ? "" : _ref7$seller,
            _ref7$expiration = _ref7.expiration,
            expiration = _ref7$expiration === undefined ? new Date() : _ref7$expiration,
            _ref7$fill_or_kill = _ref7.fill_or_kill,
            fill_or_kill = _ref7$fill_or_kill === undefined ? false : _ref7$fill_or_kill,
            _ref7$fee = _ref7.fee,
            fee = _ref7$fee === undefined ? { amount: 0, asset_id: "1.3.0" } : _ref7$fee;

        (0, _classCallCheck3.default)(this, LimitOrderCreate);

        if (!for_sale || !to_receive) {
            throw new Error("Missing order amounts");
        }

        if (for_sale.asset_id === to_receive.asset_id) {
            throw new Error("Order assets cannot be the same");
        }

        this.amount_for_sale = for_sale;
        this.min_to_receive = to_receive;
        this.setExpiration(expiration);
        this.fill_or_kill = fill_or_kill;
        this.seller = seller;
        this.fee = fee;
    }

    (0, _createClass3.default)(LimitOrderCreate, [{
        key: "setExpiration",
        value: function setExpiration() {
            var expiration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

            if (!expiration) {
                expiration = new Date();
                expiration.setYear(expiration.getFullYear() + 5);
            }
            this.expiration = expiration;
        }
    }, {
        key: "getExpiration",
        value: function getExpiration() {
            return this.expiration;
        }
    }, {
        key: "toObject",
        value: function toObject() {
            return {
                seller: this.seller,
                min_to_receive: this.min_to_receive.toObject(),
                amount_to_sell: this.amount_for_sale.toObject(),
                expiration: this.expiration,
                fill_or_kill: this.fill_or_kill,
                fee: this.fee
            };
        }
    }]);
    return LimitOrderCreate;
}();

var LimitOrder = function () {
    function LimitOrder(order, assets, market_base) {
        (0, _classCallCheck3.default)(this, LimitOrder);

        if (!market_base) {
            throw new Error("LimitOrder requires a market_base id");
        }
        this.assets = assets;
        this.market_base = market_base;
        this.id = order.id;
        this.expiration = order.expiration && new Date(order.expiration);
        this.seller = order.seller;
        this.for_sale = parseInt(order.for_sale, 10); // asset id is sell_price.base.asset_id

        var base = new Asset({
            asset_id: order.sell_price.base.asset_id,
            amount: parseInt(order.sell_price.base.amount, 10),
            precision: assets[order.sell_price.base.asset_id].precision
        });
        var quote = new Asset({
            asset_id: order.sell_price.quote.asset_id,
            amount: parseInt(order.sell_price.quote.amount, 10),
            precision: assets[order.sell_price.quote.asset_id].precision
        });

        this.sell_price = new Price({
            base: base, quote: quote
        });

        this.fee = order.deferred_fee;
    }

    (0, _createClass3.default)(LimitOrder, [{
        key: "getPrice",
        value: function getPrice() {
            var p = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.sell_price;

            if (this._real_price) {
                return this._real_price;
            }
            return this._real_price = p.toReal(p.base.asset_id === this.market_base);
        }
    }, {
        key: "isBid",
        value: function isBid() {
            return !(this.sell_price.base.asset_id === this.market_base);
        }
    }, {
        key: "isCall",
        value: function isCall() {
            return false;
        }
    }, {
        key: "sellPrice",
        value: function sellPrice() {
            return this.sell_price;
        }
    }, {
        key: "amountForSale",
        value: function amountForSale() {
            if (this._for_sale) return this._for_sale;
            return this._for_sale = new Asset({
                asset_id: this.sell_price.base.asset_id,
                amount: this.for_sale,
                precision: this.assets[this.sell_price.base.asset_id].precision
            });
        }
    }, {
        key: "amountToReceive",
        value: function amountToReceive() {
            var isBid = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.isBid();

            if (this._to_receive) return this._to_receive;
            this._to_receive = this.amountForSale().times(this.sell_price, isBid);
            return this._to_receive;
        }
    }, {
        key: "sum",
        value: function sum(order) {
            this.for_sale += order.for_sale;
            this._for_sale = null;
            this._total_to_receive = null;
            this._total_for_sale = null;
        }
    }, {
        key: "ne",
        value: function ne(order) {
            return this.sell_price.ne(order.sell_price) || this.for_sale !== order.for_sale;
        }
    }, {
        key: "equals",
        value: function equals(order) {
            return !this.ne(order);
        }
    }, {
        key: "setTotalToReceive",
        value: function setTotalToReceive(total) {
            this.total_to_receive = total;
        }
    }, {
        key: "setTotalForSale",
        value: function setTotalForSale(total) {
            this.total_for_sale = total;
            this._total_to_receive = null;
        }
    }, {
        key: "totalToReceive",
        value: function totalToReceive() {
            var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                _ref8$noCache = _ref8.noCache,
                noCache = _ref8$noCache === undefined ? false : _ref8$noCache;

            if (!noCache && this._total_to_receive) return this._total_to_receive;
            this._total_to_receive = (this.total_to_receive || this.amountToReceive()).clone();
            return this._total_to_receive;
        }
    }, {
        key: "totalForSale",
        value: function totalForSale() {
            var _ref9 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                _ref9$noCache = _ref9.noCache,
                noCache = _ref9$noCache === undefined ? false : _ref9$noCache;

            if (!noCache && this._total_for_sale) return this._total_for_sale;
            return this._total_for_sale = (this.total_for_sale || this.amountForSale()).clone();
        }
    }]);
    return LimitOrder;
}();
// class LimitOrder {
//     constructor(order, assets, market_base) {
//         if (!market_base) {
//             throw new Error("LimitOrder requires a market_base id");
//         }
//         this.order = order;
//         this.assets = assets;
//         this.market_base = market_base;
//         this.id = order.id;
//         this.sellers = [order.seller];
//         this.expiration = order.expiration && new Date(order.expiration);
//         this.seller = order.seller;
//         this.for_sale = parseInt(order.for_sale, 10); // asset id is sell_price.base.asset_id

//         let base = new Asset({
//             asset_id: order.sell_price.base.asset_id,
//             amount: parseInt(order.sell_price.base.amount, 10),
//             precision: assets[order.sell_price.base.asset_id].precision
//         });
//         let quote = new Asset({
//             asset_id: order.sell_price.quote.asset_id,
//             amount: parseInt(order.sell_price.quote.amount, 10),
//             precision: assets[order.sell_price.quote.asset_id].precision
//         });

//         this.sell_price = new Price({
//             base,
//             quote
//         });

//         this.fee = order.deferred_fee;
//     }

//     getPrice(p = this.sell_price) {
//         if (this._real_price) {
//             return this._real_price;
//         }
//         return (this._real_price = p.toReal(
//             p.base.asset_id === this.market_base
//         ));
//     }

//     isBid() {
//         return !(this.sell_price.base.asset_id === this.market_base);
//     }

//     isCall() {
//         return false;
//     }

//     sellPrice() {
//         return this.sell_price;
//     }

//     amountForSale() {
//         if (this._for_sale) return this._for_sale;
//         return (this._for_sale = new Asset({
//             asset_id: this.sell_price.base.asset_id,
//             amount: this.for_sale,
//             precision: this.assets[this.sell_price.base.asset_id].precision
//         }));
//     }

//     amountToReceive(isBid = this.isBid()) {
//         if (this._to_receive) return this._to_receive;
//         this._to_receive = this.amountForSale().times(this.sell_price, isBid);
//         return this._to_receive;
//     }

//     sum(order) {
//         let newOrder = this.clone();
//         if (newOrder.sellers.indexOf(order.seller) === -1) {
//             newOrder.sellers.push(order.seller);
//         }
//         newOrder.for_sale += order.for_sale;
//         console.info("newOrder.for_sale",newOrder.for_sale);
//         return newOrder;
//     }

//     isMine(id) {
//         return this.sellers.indexOf(id) !== -1;
//     }

//     clone() {
//         return new LimitOrder(this.order, this.assets, this.market_base);
//     }

//     ne(order) {
//         return (
//             this.sell_price.ne(order.sell_price) ||
//             this.for_sale !== order.for_sale
//         );
//     }

//     equals(order) {
//         return !this.ne(order);
//     }

//     setTotalToReceive(total) {
//         this.total_to_receive = total;
//     }

//     setTotalForSale(total) {
//         this.total_for_sale = total;
//         this._total_to_receive = null;
//     }

//     totalToReceive({noCache = false} = {}) {
//         if (!noCache && this._total_to_receive) return this._total_to_receive;
//         this._total_to_receive = (
//             this.total_to_receive || this.amountToReceive()
//         ).clone();
//         return this._total_to_receive;
//     }

//     totalForSale({noCache = false} = {}) {
//         if (!noCache && this._total_for_sale) return this._total_for_sale;
//         return (this._total_for_sale = (
//             this.total_for_sale || this.amountForSale()
//         ).clone());
//     }
// }

var CallOrder = function () {
    function CallOrder(order, assets, market_base, feed) {
        var is_prediction_market = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
        (0, _classCallCheck3.default)(this, CallOrder);

        if (!order || !assets || !market_base || !feed) {
            throw new Error("CallOrder missing inputs");
        }

        this.order = order;
        this.assets = assets;
        this.market_base = market_base;
        this.is_prediction_market = is_prediction_market;
        this.inverted = market_base === order.call_price.base.asset_id;
        this.id = order.id;
        this.borrower = order.borrower;
        this.borrowers = [order.borrower];
        /* Collateral asset type is call_price.base.asset_id */
        this.for_sale = parseInt(order.collateral, 10);
        this.for_sale_id = order.call_price.base.asset_id;
        /* Debt asset type is call_price.quote.asset_id */
        this.to_receive = parseInt(order.debt, 10);
        this.to_receive_id = order.call_price.quote.asset_id;

        var base = new Asset({
            asset_id: order.call_price.base.asset_id,
            amount: parseInt(order.call_price.base.amount, 10),
            precision: assets[order.call_price.base.asset_id].precision
        });
        var quote = new Asset({
            asset_id: order.call_price.quote.asset_id,
            amount: parseInt(order.call_price.quote.amount, 10),
            precision: assets[order.call_price.quote.asset_id].precision
        });

        /*
        * The call price is DEBT * MCR / COLLATERAL. This calculation is already
        * done by the witness_node before returning the orders so it is not necessary
        * to deal with the MCR (maintenance collateral ratio) here.
        */
        this.call_price = new Price({
            base: this.inverted ? quote : base,
            quote: this.inverted ? base : quote
        });

        if (feed.base.asset_id !== this.call_price.base.asset_id) {
            throw new Error("Feed price assets and call price assets must be the same");
        }

        this.feed_price = feed;
    }

    (0, _createClass3.default)(CallOrder, [{
        key: "clone",
        value: function clone() {
            var f = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.feed_price;

            return new CallOrder(this.order, this.assets, this.market_base, f);
        }
    }, {
        key: "setFeed",
        value: function setFeed(f) {
            this.feed_price = f;
            this._clearCache();
        }
    }, {
        key: "getPrice",
        value: function getPrice() {
            var squeeze = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
            var p = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.call_price;

            if (squeeze) {
                return this.getSqueezePrice();
            }
            if (this._real_price) {
                return this._real_price;
            }
            return this._real_price = p.toReal(p.base.asset_id === this.market_base);
        }
    }, {
        key: "getFeedPrice",
        value: function getFeedPrice() {
            var f = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.feed_price;

            if (this._feed_price) {
                return this._feed_price;
            }
            return this._feed_price = f.toReal(f.base.asset_id === this.market_base);
        }
    }, {
        key: "getSqueezePrice",
        value: function getSqueezePrice() {
            var f = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.feed_price;

            if (this._squeeze_price) {
                return this._squeeze_price;
            }
            return this._squeeze_price = f.getSqueezePrice().toReal();
        }
    }, {
        key: "isMarginCalled",
        value: function isMarginCalled() {
            if (this.is_prediction_market) return false;
            return this.isBid() ? this.call_price.lt(this.feed_price) : this.call_price.gt(this.feed_price);
        }
    }, {
        key: "isBid",
        value: function isBid() {
            return !this.inverted;
        }
    }, {
        key: "isCall",
        value: function isCall() {
            return true;
        }
    }, {
        key: "sellPrice",
        value: function sellPrice() {
            var squeeze = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

            if (squeeze) {
                return this.isBid() ? this.feed_price.getSqueezePrice() : this.feed_price.getSqueezePrice().invert();
            }
            return this.call_price;
        }
    }, {
        key: "getCollateral",
        value: function getCollateral() {
            if (this._collateral) return this._collateral;
            return this._collateral = new Asset({
                amount: this.for_sale,
                asset_id: this.for_sale_id,
                precision: this.assets[this.for_sale_id].precision
            });
        }
    }, {
        key: "amountForSale",
        value: function amountForSale() {
            var isBid = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.isBid();

            if (this._for_sale) return this._for_sale;
            return this._for_sale = this.amountToReceive().times(this.feed_price.getSqueezePrice(), isBid);
        }
    }, {
        key: "amountToReceive",
        value: function amountToReceive() {
            if (this._to_receive) return this._to_receive;
            // return this._to_receive = this.amountForSale().times(this.feed_price.getSqueezePrice(), isBid);
            return this._to_receive = new Asset({
                asset_id: this.to_receive_id,
                amount: this.to_receive,
                precision: this.assets[this.to_receive_id].precision
            });
        }
    }, {
        key: "sum",
        value: function sum(order) {
            var newOrder = this.clone();
            if (newOrder.borrowers.indexOf(order.borrower) === -1) {
                newOrder.borrowers.push(order.borrower);
            }
            newOrder.to_receive += order.to_receive;
            newOrder.for_sale += order.for_sale;
            newOrder._clearCache();
            return newOrder;
        }
    }, {
        key: "_clearCache",
        value: function _clearCache() {
            this._for_sale = null;
            this._to_receive = null;
            this._feed_price = null;
            this._squeeze_price = null;
            this._total_to_receive = null;
            this._total_for_sale = null;
        }
    }, {
        key: "ne",
        value: function ne(order) {
            return this.call_price.ne(order.call_price) || this.feed_price.ne(order.feed_price) || this.to_receive !== order.to_receive || this.for_sale !== order.for_sale;
        }
    }, {
        key: "equals",
        value: function equals(order) {
            return !this.ne(order);
        }
    }, {
        key: "setTotalToReceive",
        value: function setTotalToReceive(total) {
            this.total_to_receive = total;
        }
    }, {
        key: "setTotalForSale",
        value: function setTotalForSale(total) {
            this.total_for_sale = total;
        }
    }, {
        key: "totalToReceive",
        value: function totalToReceive() {
            var _ref10 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                _ref10$noCache = _ref10.noCache,
                noCache = _ref10$noCache === undefined ? false : _ref10$noCache;

            if (!noCache && this._total_to_receive) return this._total_to_receive;
            this._total_to_receive = (this.total_to_receive || this.amountToReceive()).clone();
            return this._total_to_receive;
        }
    }, {
        key: "totalForSale",
        value: function totalForSale() {
            var _ref11 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                _ref11$noCache = _ref11.noCache,
                noCache = _ref11$noCache === undefined ? false : _ref11$noCache;

            if (!noCache && this._total_for_sale) return this._total_for_sale;
            return this._total_for_sale = (this.total_for_sale || this.amountForSale()).clone();
        }
    }, {
        key: "getRatio",
        value: function getRatio() {
            return this.getCollateral().getAmount({ real: true }) / this.amountToReceive().getAmount({ real: true }) / this.getFeedPrice();
        }
    }, {
        key: "getStatus",
        value: function getStatus() {
            var mr = this.assets[this.to_receive_id].bitasset.current_feed.maintenance_collateral_ratio / 1000;
            var cr = this.getRatio();

            if (isNaN(cr)) return null;
            if (cr < mr) {
                return "danger";
            } else if (cr < mr + 0.5) {
                return "warning";
            } else {
                return "";
            }
        }
    }, {
        key: "isMine",
        value: function isMine(id) {
            return this.borrowers.indexOf(id) !== -1;
        }
    }]);
    return CallOrder;
}();

var SettleOrder = function (_LimitOrder) {
    (0, _inherits3.default)(SettleOrder, _LimitOrder);

    function SettleOrder(order, assets, market_base, feed_price, bitasset_options) {
        (0, _classCallCheck3.default)(this, SettleOrder);

        if (!feed_price || !bitasset_options) {
            throw new Error("SettleOrder needs feed_price and bitasset_options inputs");
        }

        order.sell_price = feed_price.toObject();
        order.seller = order.owner;

        var _this2 = (0, _possibleConstructorReturn3.default)(this, (SettleOrder.__proto__ || (0, _getPrototypeOf2.default)(SettleOrder)).call(this, order, assets, market_base));

        _this2.offset_percent = bitasset_options.force_settlement_offset_percent;
        _this2.settlement_date = new Date(order.settlement_date);

        _this2.for_sale = new Asset({
            amount: order.balance.amount,
            asset_id: order.balance.asset_id,
            precision: assets[order.balance.asset_id].precision
        });

        _this2.inverted = _this2.for_sale.asset_id === market_base;
        _this2.feed_price = feed_price[_this2.inverted ? "invert" : "clone"]();
        return _this2;
    }

    (0, _createClass3.default)(SettleOrder, [{
        key: "isBefore",
        value: function isBefore(order) {
            return this.settlement_date < order.settlement_date;
        }
    }, {
        key: "amountForSale",
        value: function amountForSale() {
            return this.for_sale;
        }
    }, {
        key: "amountToReceive",
        value: function amountToReceive() {
            var to_receive = this.for_sale.times(this.feed_price, this.isBid());
            to_receive.setAmount({
                sats: to_receive.getAmount() * ((GRAPHENE_100_PERCENT - this.offset_percent) / GRAPHENE_100_PERCENT)
            });
            return this._to_receive = to_receive;
        }
    }, {
        key: "isBid",
        value: function isBid() {
            return !this.inverted;
        }
    }]);
    return SettleOrder;
}(LimitOrder);

exports.Asset = Asset;
exports.Price = Price;
exports.FeedPrice = FeedPrice;
exports.LimitOrderCreate = LimitOrderCreate;
exports.limitByPrecision = limitByPrecision;
exports.precisionToRatio = precisionToRatio;
exports.LimitOrder = LimitOrder;
exports.CallOrder = CallOrder;
exports.SettleOrder = SettleOrder;
exports.didOrdersChange = didOrdersChange;

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _classCallCheck2 = __webpack_require__(11);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _promise = __webpack_require__(4);

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var db;
var idb_helper;

module.exports = idb_helper = {

    set_graphene_db: function set_graphene_db(database) {
        db = database;
    },

    trx_readwrite: function trx_readwrite(object_stores) {
        return db.transaction([object_stores], "readwrite");
    },

    on_request_end: function on_request_end(request) {
        //return request => {
        return new _promise2.default(function (resolve, reject) {
            request.onsuccess = new ChainEvent(request.onsuccess, resolve, request).event;
            request.onerror = new ChainEvent(request.onerror, reject, request).event;
        });
        //}(request)
    },

    on_transaction_end: function on_transaction_end(transaction) {
        return new _promise2.default(function (resolve, reject) {
            transaction.oncomplete = new ChainEvent(transaction.oncomplete, resolve).event;
            transaction.onabort = new ChainEvent(transaction.onabort, reject).event;
        });
    },

    /** Chain an add event.  Provide the @param store and @param object and
        this method gives you convenient hooks into the database events.
        United Labs of BCTech.
        @param event_callback (within active transaction)
        @return Promise (resolves or rejects outside of the transaction)
    */
    add: function add(store, object, event_callback) {
        return function (object, event_callback) {
            var request = store.add(object);
            var event_promise = null;
            if (event_callback) request.onsuccess = new ChainEvent(request.onsuccess, function (event) {
                event_promise = event_callback(event);
            }).event;

            var request_promise = idb_helper.on_request_end(request).then(function (event) {
                //DEBUG console.log('... object',object,'result',event.target.result,'event',event)
                if (event.target.result != void 0) {
                    //todo does event provide the keyPath name? (instead of id)
                    object.id = event.target.result;
                }
                return [object, event];
            });

            if (event_promise) return _promise2.default.all([event_promise, request_promise]);
            return request_promise;
        }(object, event_callback); //copy var references for callbacks
    },

    /** callback may return <b>false</b> to indicate that iteration should stop */
    cursor: function cursor(store_name, callback, transaction) {
        return new _promise2.default(function (resolve, reject) {
            if (!transaction) {
                transaction = db.transaction([store_name], "readonly");
                transaction.onerror = function (error) {
                    console.error("ERROR idb_helper.cursor transaction", error);
                    reject(error);
                };
            }
            var store = transaction.objectStore(store_name);
            var request = store.openCursor();
            request.onsuccess = function (e) {
                var cursor = e.target.result;
                var ret = callback(cursor, e);
                if (ret === false) resolve();
                if (!cursor) resolve(ret);
            };
            request.onerror = function (e) {
                var error = {
                    error: e.target.error.message,
                    data: e
                };
                console.log("ERROR idb_helper.cursor request", error);
                reject(error);
            };
        }).then();
    },

    autoIncrement_unique: function autoIncrement_unique(db, table_name, unique_index) {
        return db.createObjectStore(table_name, { keyPath: "id", autoIncrement: true }).createIndex("by_" + unique_index, unique_index, { unique: true });
    }

};

var ChainEvent = function ChainEvent(existing_on_event, callback, request) {
    (0, _classCallCheck3.default)(this, ChainEvent);

    this.event = function (event) {
        if (event.target.error) console.error("---- transaction error ---->", event.target.error);
        //event.request = request
        callback(event);
        if (existing_on_event) existing_on_event(event);
    };
};

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _defineProperty2 = __webpack_require__(27);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _promise = __webpack_require__(4);

var _promise2 = _interopRequireDefault(_promise);

var _regenerator = __webpack_require__(3);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _getIterator2 = __webpack_require__(52);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _mutations;

var _vue = __webpack_require__(19);

var _vue2 = _interopRequireDefault(_vue);

var _mutations2 = __webpack_require__(14);

var types = _interopRequireWildcard(_mutations2);

var _bcxjsCores = __webpack_require__(7);

var _idbHelper = __webpack_require__(149);

var _idbHelper2 = _interopRequireDefault(_idbHelper);

var _tcomb_structs = __webpack_require__(396);

var _WalletDb = __webpack_require__(227);

var WalletDbS = _interopRequireWildcard(_WalletDb);

var _immutable = __webpack_require__(23);

var _immutable2 = _interopRequireDefault(_immutable);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var initialState = {
    keys: {},
    app_keys: [],

    privateKeyStorage_error: false,
    pending_operation_count: 0,
    privateKeyStorage_error_add_key: null,
    privateKeyStorage_error_loading: null
};

var getters = {
    keys: function keys(state) {
        return state.keys;
    },
    app_keys: function app_keys(state) {
        return state.app_keys;
    },
    getTcomb_byPubkey: function getTcomb_byPubkey(state) {
        return function (public_key) {
            if (!public_key) return null;
            if (public_key.Q) public_key = public_key.toPublicKeyString();
            return state.keys[public_key];
        };
    },
    getPubkeys_having_PrivateKey: function getPubkeys_having_PrivateKey(state) {
        return function (pubkeys) {
            var addys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

            var _pubkeys = [];
            if (pubkeys) {
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = (0, _getIterator3.default)(pubkeys), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var pubkey = _step.value;

                        if (state.keys[pubkey]) {
                            _pubkeys.push(pubkey);
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
            return _pubkeys;
        };
    },

    psdDecodeMemo: function psdDecodeMemo(state) {
        var errorMessege = "";
        return function (memo_con, store, account, password) {
            var memo = memo_con;
            var lockedWallet = false;
            var memo_text = void 0,
                isMine = false;
            var from_private_key = state.keys[memo.from];
            var to_private_key = state.keys[memo.to];
            var private_key = from_private_key ? from_private_key : to_private_key;
            var public_key = from_private_key ? memo.to : memo.from;
            public_key = _bcxjsCores.PublicKey.fromPublicKeyString(public_key);
            try {
                // private_key =store.getters["WalletDb/decryptTcomb_PrivateKey"](private_key);//WalletDb.decryptTcomb_PrivateKey(private_key);
                private_key = WalletDbS.generateKeyFromPassword(account, "active", password).privKey;
            } catch (e) {
                // Failed because wallet is locked
                lockedWallet = true;
                private_key = null;
                isMine = true;
            }

            var tryLegacy = false;
            if (private_key) {
                try {
                    memo_text = private_key ? _bcxjsCores.Aes.decrypt_with_checksum(private_key, public_key, memo.nonce, memo.message).toString("utf-8") : null;
                    if (private_key && !memo_text) {
                        // debugger
                    }
                } catch (e) {
                    console.log("transfer memo exception ...", e);
                    memo_text = "*";
                    tryLegacy = true;
                    errorMessege = e;
                }

                // Apply legacy method if new, correct method fails to decode
                if (private_key && tryLegacy) {
                    // debugger;
                    try {
                        memo_text = _bcxjsCores.Aes.decrypt_with_checksum(private_key, public_key, memo.nonce, memo.message, true).toString("utf-8");
                        tryLegacy = false;
                    } catch (e) {
                        console.log("transfer memo exception ...", e);
                        memo_text = "**";
                        tryLegacy = true;
                        errorMessege = e;
                    }
                }
            }
            // Error: Invalid key, could not decrypt message(1)
            var reqData = {};
            if (tryLegacy) {
                reqData = {
                    code: 0,
                    message: errorMessege
                };
            } else {
                reqData = {
                    code: 1,
                    data: {
                        text: memo_text,
                        isMine: isMine
                    }
                };
            }
            return reqData;
        };
    },
    decodeMemo: function decodeMemo(state) {
        return function (memo, store) {
            var lockedWallet = false;
            var memo_text = void 0,
                isMine = false;
            var from_private_key = state.keys[memo.from];
            var to_private_key = state.keys[memo.to];
            var private_key = from_private_key ? from_private_key : to_private_key;
            var public_key = from_private_key ? memo.to : memo.from;
            public_key = _bcxjsCores.PublicKey.fromPublicKeyString(public_key);
            try {
                private_key = store.getters["WalletDb/decryptTcomb_PrivateKey"](private_key); //WalletDb.decryptTcomb_PrivateKey(private_key);
            } catch (e) {
                // Failed because wallet is locked
                lockedWallet = true;
                private_key = null;
                isMine = true;
            }
            if (private_key) {
                var tryLegacy = false;
                try {
                    memo_text = private_key ? _bcxjsCores.Aes.decrypt_with_checksum(private_key, public_key, memo.nonce, memo.message).toString("utf-8") : null;
                    if (private_key && !memo_text) {
                        // debugger
                    }
                } catch (e) {
                    console.log("transfer memo exception ...", e);
                    memo_text = "*";
                    tryLegacy = true;
                }

                // Apply legacy method if new, correct method fails to decode
                if (private_key && tryLegacy) {
                    // debugger;
                    try {
                        memo_text = _bcxjsCores.Aes.decrypt_with_checksum(private_key, public_key, memo.nonce, memo.message, true).toString("utf-8");
                    } catch (e) {
                        console.log("transfer memo exception ...", e);
                        memo_text = "**";
                    }
                }
            }
            return {
                text: memo_text,
                isMine: isMine
            };
        };
    }
};

var actions = {
    setKeys: function setKeys(_ref, key) {
        var commit = _ref.commit;

        commit(types.SET_KEYS, key);
    },
    clearKeys: function clearKeys(_ref2) {
        var commit = _ref2.commit;

        commit(types.CLEAR_KEYS);
    },
    setAppkeys: function setAppkeys(_ref3, keys) {
        var commit = _ref3.commit;

        commit(types.SET_APP_KEYS, keys);
    },
    decodeMemo: function decodeMemo(_ref4, memo) {
        var commit = _ref4.commit,
            state = _ref4.state,
            dispatch = _ref4.dispatch;
        var lockedWallet, memo_text, isMine, from_private_key, to_private_key, private_key, public_key, tryLegacy;
        return _regenerator2.default.async(function decodeMemo$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        lockedWallet = false;
                        memo_text = void 0, isMine = false;
                        from_private_key = state.keys[memo.from];
                        to_private_key = state.keys[memo.to];
                        private_key = from_private_key ? from_private_key : to_private_key;
                        public_key = from_private_key ? memo.to : memo.from;

                        public_key = _bcxjsCores.PublicKey.fromPublicKeyString(public_key);

                        _context.prev = 7;
                        _context.next = 10;
                        return _regenerator2.default.awrap(dispatch("WalletDb/decryptTcomb_PrivateKey", private_key, { root: true }));

                    case 10:
                        private_key = _context.sent;
                        _context.next = 18;
                        break;

                    case 13:
                        _context.prev = 13;
                        _context.t0 = _context['catch'](7);

                        // Failed because wallet is locked
                        lockedWallet = true;
                        private_key = null;
                        isMine = true;

                    case 18:
                        if (private_key) {
                            tryLegacy = false;

                            try {
                                memo_text = private_key ? _bcxjsCores.Aes.decrypt_with_checksum(private_key, public_key, memo.nonce, memo.message).toString("utf-8") : null;
                                if (private_key && !memo_text) {
                                    // debugger
                                }
                            } catch (e) {
                                console.log("transfer memo exception ...", e);
                                memo_text = "*";
                                tryLegacy = true;
                            }

                            // Apply legacy method if new, correct method fails to decode
                            if (private_key && tryLegacy) {
                                // debugger;
                                try {
                                    memo_text = _bcxjsCores.Aes.decrypt_with_checksum(private_key, public_key, memo.nonce, memo.message, true).toString("utf-8");
                                } catch (e) {
                                    console.log("transfer memo exception ...", e);
                                    memo_text = "**";
                                }
                            }
                        }

                        return _context.abrupt('return', {
                            text: memo_text,
                            isMine: isMine
                        });

                    case 20:
                    case 'end':
                        return _context.stop();
                }
            }
        }, null, undefined, [[7, 13]]);
    },
    loadDbData: function loadDbData(_ref5) {
        var commit = _ref5.commit,
            state = _ref5.state,
            dispatch = _ref5.dispatch;

        commit("_getInitialState");
        commit("pendingOperation");
        var p = _idbHelper2.default.cursor("private_keys", function (cursor) {
            if (!cursor) {
                //state.keys={};
                return;
            }
            var private_key_tcomb = (0, _tcomb_structs.PrivateKeyTcomb)(cursor.value);
            commit(types.SET_KEYS, (0, _tcomb_structs.PrivateKeyTcomb)(private_key_tcomb));
            dispatch("AddressIndex/add", private_key_tcomb.pubkey, { root: true });
            cursor.continue();
        }).then(function () {
            setTimeout(function () {
                dispatch("pendingOperationDone");
            }, 2000);
        }).catch(function (error) {
            commit("_getInitialState");
            throw error;
        });
        return p;
    },
    pendingOperationDone: function pendingOperationDone(_ref6) {
        var state = _ref6.state;

        // console.info("state.pending_operation_count11111111",state.pending_operation_count);

        if (state.pending_operation_count == 0) {}
        // console.log("Pending operation done called too many times")

        // throw new Error("Pending operation done called too many times")
        state.pending_operation_count--;
    },

    addKey: function addKey(_ref7, _ref8) {
        var state = _ref7.state,
            dispatch = _ref7.dispatch,
            commit = _ref7.commit;
        var private_key_object = _ref8.private_key_object,
            transaction = _ref8.transaction,
            resolve = _ref8.resolve;
        // resolve is deprecated
        if (state.keys[private_key_object.pubkey]) {
            resolve({ result: "duplicate", id: null });
            return;
        }
        commit("pendingOperation");
        //console.log("... onAddKey private_key_object.pubkey", private_key_object.pubkey)
        //console.info("state.keys",state.keys);
        // state.keys = state.keys.set(
        //     private_key_object.pubkey,
        //     PrivateKeyTcomb(private_key_object)
        // );
        commit(types.SET_KEYS, (0, _tcomb_structs.PrivateKeyTcomb)(private_key_object));
        // Vue.set(state.keys,private_key_object.pubkey, PrivateKeyTcomb(private_key_object));

        dispatch("AddressIndex/add", private_key_object.pubkey, { root: true });

        var p = new _promise2.default(function (resolve, reject) {
            (0, _tcomb_structs.PrivateKeyTcomb)(private_key_object);
            var duplicate = false;
            var p = _idbHelper2.default.add(transaction.objectStore("private_keys"), private_key_object);

            //console.log("p:", p);
            p.catch(function (event) {
                // ignore_duplicates
                var error = event.target.error;
                console.log("... error", error, event);
                if (error.name != "ConstraintError" || error.message.indexOf("by_encrypted_key") == -1) {
                    //this.privateKeyStorageError("add_key", error);
                    throw event;
                }
                duplicate = true;
                event.preventDefault();
            }).then(function () {
                dispatch("pendingOperationDone");
                if (duplicate) return { result: "duplicate", id: null };
                if (private_key_object.brainkey_sequence == null)
                    //this.binaryBackupRecommended(); // non-deterministic
                    disconnect("CachedPropertyStore/set", { name: "backup_recommended", value: true });
                _idbHelper2.default.on_transaction_end(transaction).then(function () {

                    //this.setState({ keys: this.state.keys }); 
                });
                return {
                    result: "added",
                    id: private_key_object.id
                };
            });
            resolve(p);
        });
        return p;
    },
    addPrivateKeys_noindex: function addPrivateKeys_noindex(_ref9, _ref10) {
        var state = _ref9.state,
            dispatch = _ref9.dispatch;
        var private_key_objects = _ref10.private_key_objects,
            transaction = _ref10.transaction;

        var store = transaction.objectStore("private_keys");
        var duplicate_count = 0;

        var keys = _immutable2.default.fromJS(state.keys).withMutations(function (keys) {
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = (0, _getIterator3.default)(private_key_objects), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var private_key_object = _step2.value;

                    if (state.keys[private_key_object.pubkey]) {
                        duplicate_count++;
                        continue;
                    }
                    var private_tcomb = (0, _tcomb_structs.PrivateKeyTcomb)(private_key_object);
                    store.add(private_key_object);
                    keys.set(private_key_object.pubkey, private_tcomb);
                    _bcxjsCores.ChainStore.getAccountRefsOfKey(private_key_object.pubkey);
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }
        });
        state.keys = keys.toJS();
        binaryBackupRecommended(dispatch);
        return duplicate_count;
    }
};

function binaryBackupRecommended(dispatch) {
    dispatch("CachedPropertyStore/Set", { name: "backup_recommended", value: true }, { root: true });
}

var mutations = (_mutations = {}, (0, _defineProperty3.default)(_mutations, types.SET_KEYS, function (state, key) {
    _vue2.default.set(state.keys, key.pubkey, key);
}), (0, _defineProperty3.default)(_mutations, types.SET_APP_KEYS, function (state, keys) {
    state.app_keys = keys;
}), (0, _defineProperty3.default)(_mutations, types.CLEAR_KEYS, function (state) {
    state.keys = {};
    //state.app_keys=[];
}), (0, _defineProperty3.default)(_mutations, 'pendingOperation', function pendingOperation(state) {
    state.pending_operation_count++;
}), (0, _defineProperty3.default)(_mutations, '_getInitialState', function _getInitialState(state) {
    state.privateKeyStorage_error = false;
    state.pending_operation_count = 0;
    state.privateKeyStorage_error_add_key = null;
    state.privateKeyStorage_error_loading = null;
}), _mutations);

exports.default = {
    state: initialState,
    mutations: mutations,
    actions: actions,
    getters: getters,
    namespaced: true
};

/***/ }),
/* 151 */
/***/ (function(module, exports) {

module.exports = function isString(x) {
  return typeof x === 'string';
};

/***/ }),
/* 152 */
/***/ (function(module, exports) {

module.exports = function isBoolean(x) {
  return x === true || x === false;
};

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

var irreducible = __webpack_require__(40);
var isFunction = __webpack_require__(36);

module.exports = irreducible('Function', isFunction);


/***/ }),
/* 154 */,
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(25);
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};


/***/ }),
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */,
/* 162 */,
/* 163 */,
/* 164 */,
/* 165 */,
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */,
/* 178 */,
/* 179 */,
/* 180 */,
/* 181 */,
/* 182 */,
/* 183 */,
/* 184 */,
/* 185 */,
/* 186 */,
/* 187 */,
/* 188 */,
/* 189 */,
/* 190 */,
/* 191 */,
/* 192 */,
/* 193 */,
/* 194 */,
/* 195 */,
/* 196 */,
/* 197 */,
/* 198 */,
/* 199 */,
/* 200 */,
/* 201 */,
/* 202 */,
/* 203 */,
/* 204 */,
/* 205 */,
/* 206 */,
/* 207 */,
/* 208 */,
/* 209 */,
/* 210 */,
/* 211 */,
/* 212 */,
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, Buffer) {

exports.__esModule = true;

var _bytebuffer = __webpack_require__(130);

var _bytebuffer2 = _interopRequireDefault(_bytebuffer);

var _error_with_cause = __webpack_require__(446);

var _error_with_cause2 = _interopRequireDefault(_error_with_cause);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var HEX_DUMP = process.env.npm_config__graphene_serializer_hex_dump;

var Serializer = function () {
    function Serializer(operation_name, types) {
        _classCallCheck(this, Serializer);

        this.operation_name = operation_name;
        this.types = types;
        if (this.types) this.keys = Object.keys(this.types);

        Serializer.printDebug = true;
    }

    Serializer.prototype.fromByteBuffer = function fromByteBuffer(b) {
        var object = {};
        var field = null;
        try {
            var iterable = this.keys;
            for (var i = 0, field; i < iterable.length; i++) {
                field = iterable[i];
                var type = this.types[field];
                try {
                    if (HEX_DUMP) {
                        if (type.operation_name) {
                            console.error(type.operation_name);
                        } else {
                            var o1 = b.offset;
                            type.fromByteBuffer(b);
                            var o2 = b.offset;
                            b.offset = o1;
                            //b.reset()
                            var _b = b.copy(o1, o2);
                            console.error(this.operation_name + '.' + field + '\t', _b.toHex());
                        }
                    }
                    object[field] = type.fromByteBuffer(b);
                } catch (e) {
                    if (Serializer.printDebug) {
                        console.error('Error reading ' + this.operation_name + '.' + field + ' in data:');
                        b.printDebug();
                    }
                    throw e;
                }
            }
        } catch (error) {
            _error_with_cause2.default.throw(this.operation_name + '.' + field, error);
        }

        return object;
    };

    Serializer.prototype.appendByteBuffer = function appendByteBuffer(b, object) {
        var field = null;
        try {
            var iterable = this.keys;
            for (var i = 0, field; i < iterable.length; i++) {
                field = iterable[i];
                var type = this.types[field];
                //  console.info(' Serializer.prototype.appendByteBuffer',"1",field,"2",this.types,"3",type,"4",object[field],object);
                 type.appendByteBuffer(b, object[field]);
            }
        } catch (error) {
            try {
                _error_with_cause2.default.throw(this.operation_name + '.' + field + " = " + JSON.stringify(object[field]), error);
            } catch (e) {
                // circular ref
                _error_with_cause2.default.throw(this.operation_name + '.' + field + " = " + object[field], error);
            }
        }
        return;
    };

    Serializer.prototype.fromObject = function fromObject(serialized_object) {
        var result = {};
        var field = null;
        try {
            var iterable = this.keys;
            for (var i = 0, field; i < iterable.length; i++) {
                field = iterable[i];
                var type = this.types[field];
                var value = serialized_object[field];
            

                //DEBUG value = value.resolve if value.resolve
                //DEBUG console.log('... value',field,value)
                // console.info("serialized_object fromObject 1111111",'0',value,"1",serialized_object,"2", field,"3", value,"4",type,"5",this.types)
                var object = type.fromObject(value);
                // if((object instanceof Array&&!object.length)||field=="contract_id"){
                //     object=value;
                // }
                // object=object.length?object:value;
                // console.info('fromObject object',field,value,type,object);
                result[field] = object;
            }
        } catch (error) {
            console.info("error",error);
            _error_with_cause2.default.throw(this.operation_name + '.' + field, error);
        }
        return result;
    };

    /**
        @arg {boolean} [debug.use_default = false] - more template friendly
        @arg {boolean} [debug.annotate = false] - add user-friendly information
    */


    Serializer.prototype.toObject = function toObject() {
        var serialized_object = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { use_default: false, annotate: false };
        var result = {};
        var field = null;
        try {
            if (!this.types) return result;

            var iterable = this.keys;
            for (var i = 0, field; i < iterable.length; i++) {
                field = iterable[i];
                var type = this.types[field];
                var object = type.toObject(typeof serialized_object !== "undefined" && serialized_object !== null ? serialized_object[field] : undefined, debug);

                result[field] = object;
                if (HEX_DUMP) {
                    var b = new _bytebuffer2.default(_bytebuffer2.default.DEFAULT_CAPACITY, _bytebuffer2.default.LITTLE_ENDIAN);
                    type.appendByteBuffer(b, typeof serialized_object !== "undefined" && serialized_object !== null ? serialized_object[field] : undefined);
                    b = b.copy(0, b.offset);
                    console.error(this.operation_name + '.' + field, b.toHex());
                }
            }
        } catch (error) {
            _error_with_cause2.default.throw(this.operation_name + '.' + field, error);
        }
        return result;
    };

    /** Sort by the first element in a operation */


    Serializer.prototype.compare = function compare(a, b) {

        var first_key = this.keys[0];
        var first_type = this.types[first_key];

        var valA = a[first_key];
        var valB = b[first_key];

        if (first_type.compare) return first_type.compare(valA, valB);

        if (typeof valA === "number" && typeof valB === "number") return valA - valB;

        var encoding = void 0;
        if (Buffer.isBuffer(valA) && Buffer.isBuffer(valB)) {
            // A binary string compare does not work.  If localeCompare is well supported that could replace HEX.  Performanance is very good so comparing HEX works.
            encoding = "hex";
        }

        var strA = valA.toString(encoding);
        var strB = valB.toString(encoding);
        return strA > strB ? 1 : strA < strB ? -1 : 0;
    };

    // <helper_functions>

    Serializer.prototype.fromHex = function fromHex(hex) {
        var b = _bytebuffer2.default.fromHex(hex, _bytebuffer2.default.LITTLE_ENDIAN);
        return this.fromByteBuffer(b);
    };

    Serializer.prototype.fromBuffer = function fromBuffer(buffer) {
        var b = _bytebuffer2.default.fromBinary(buffer.toString("binary"), _bytebuffer2.default.LITTLE_ENDIAN);
        return this.fromByteBuffer(b);
    };

    Serializer.prototype.toHex = function toHex(object) {
        // return this.toBuffer(object).toString("hex")
        var b = this.toByteBuffer(object);
        return b.toHex();
    };

    Serializer.prototype.toByteBuffer = function toByteBuffer(object) {
        var b = new _bytebuffer2.default(_bytebuffer2.default.DEFAULT_CAPACITY, _bytebuffer2.default.LITTLE_ENDIAN);
        this.appendByteBuffer(b, object);
        return b.copy(0, b.offset);
    };

    Serializer.prototype.toBuffer = function toBuffer(object) {
        return new Buffer(this.toByteBuffer(object).toBinary(), 'binary');
    };

    return Serializer;
}();

exports.default = Serializer;
module.exports = exports['default'];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9), __webpack_require__(2).Buffer))

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

exports.__esModule = true;

var _PublicKey = __webpack_require__(97);

var _PublicKey2 = _interopRequireDefault(_PublicKey);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FastParser = function () {
    function FastParser() {
        _classCallCheck(this, FastParser);
    }

    FastParser.fixed_data = function fixed_data(b, len, buffer) {
        if (!b) {
            return;
        }
        if (buffer) {
            var data = buffer.slice(0, len).toString('binary');
            b.append(data, 'binary');
            while (len-- > data.length) {
                b.writeUint8(0);
            }
        } else {
            var b_copy = b.copy(b.offset, b.offset + len);
            b.skip(len);
            return new Buffer(b_copy.toBinary(), 'binary');
        }
    };

    FastParser.public_key = function public_key(b, _public_key) {
        if (!b) {
            return;
        }
        if (_public_key) {
            var buffer = _public_key.toBuffer();
            b.append(buffer.toString('binary'), 'binary');
            return;
        } else {
            buffer = FastParser.fixed_data(b, 33);
            return _PublicKey2.default.fromBuffer(buffer);
        }
    };

    FastParser.ripemd160 = function ripemd160(b, _ripemd) {
        if (!b) {
            return;
        }
        if (_ripemd) {
            FastParser.fixed_data(b, 20, _ripemd);
            return;
        } else {
            return FastParser.fixed_data(b, 20);
        }
    };

    FastParser.time_point_sec = function time_point_sec(b, epoch) {
        if (epoch) {
            epoch = Math.ceil(epoch / 1000);
            b.writeInt32(epoch);
            return;
        } else {
            epoch = b.readInt32(); // fc::time_point_sec
            return new Date(epoch * 1000);
        }
    };

    return FastParser;
}();

exports.default = FastParser;
module.exports = exports['default'];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

var Point = __webpack_require__(372)
var Curve = __webpack_require__(373)

var getCurveByName = __webpack_require__(453)

module.exports = {
  Curve: Curve,
  Point: Point,
  getCurveByName: getCurveByName
}


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

var basex = __webpack_require__(455)
var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'

module.exports = basex(ALPHABET)


/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

var pSlice = Array.prototype.slice;
var objectKeys = __webpack_require__(456);
var isArguments = __webpack_require__(457);

var deepEqual = module.exports = function (actual, expected, opts) {
  if (!opts) opts = {};
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
    return opts.strict ? actual === expected : actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected, opts);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isBuffer (x) {
  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== 'number') return false;
  return true;
}

function objEquiv(a, b, opts) {
  var i, key;
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b, opts);
  }
  if (isBuffer(a)) {
    if (!isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) return false;
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b);
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], opts)) return false;
  }
  return typeof a === typeof b;
}


/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, Buffer) {

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; // Low-level types that make up operations

var _SerializerValidation = __webpack_require__(145);

var _SerializerValidation2 = _interopRequireDefault(_SerializerValidation);

var _FastParser = __webpack_require__(214);

var _FastParser2 = _interopRequireDefault(_FastParser);

var _ChainTypes = __webpack_require__(131);

var _ChainTypes2 = _interopRequireDefault(_ChainTypes);

var _ObjectId = __webpack_require__(374);

var _ObjectId2 = _interopRequireDefault(_ObjectId);

var _ecc = __webpack_require__(219);

var _bcxjsWs = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Types = {};

var HEX_DUMP = process.env.npm_config__graphene_serializer_hex_dump;

Types.uint8 = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readUint8();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        _SerializerValidation2.default.require_range(0, 0xff, object, "uint8 " + object);
        b.writeUint8(object);
        return;
    },
    fromObject: function fromObject(object) {
        _SerializerValidation2.default.require_range(0, 0xff, object, "uint8 " + object);
        return object;
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return 0;
        }
        _SerializerValidation2.default.require_range(0, 0xff, object, "uint8 " + object);
        return parseInt(object);
    }
};

Types.uint16 = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readUint16();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        _SerializerValidation2.default.require_range(0, 0xffff, object, "uint16 " + object);
        b.writeUint16(object);
        return;
    },
    fromObject: function fromObject(object) {
        _SerializerValidation2.default.require_range(0, 0xffff, object, "uint16 " + object);
        return object;
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return 0;
        }
        _SerializerValidation2.default.require_range(0, 0xffff, object, "uint16 " + object);
        return parseInt(object);
    }
};

Types.uint32 = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readUint32();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        _SerializerValidation2.default.require_range(0, 0xffffffff, object, "uint32 " + object);
        b.writeUint32(object);
        return;
    },
    fromObject: function fromObject(object) {
        _SerializerValidation2.default.require_range(0, 0xffffffff, object, "uint32 " + object);
        return object;
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return 0;
        }
        _SerializerValidation2.default.require_range(0, 0xffffffff, object, "uint32 " + object);
        return parseInt(object);
    }
};

var MIN_SIGNED_32 = -1 * Math.pow(2, 31);
var MAX_SIGNED_32 = Math.pow(2, 31) - 1;

Types.varint32 = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readVarint32();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        _SerializerValidation2.default.require_range(MIN_SIGNED_32, MAX_SIGNED_32, object, "uint32 " + object);
        b.writeVarint32(object);
        return;
    },
    fromObject: function fromObject(object) {
        _SerializerValidation2.default.require_range(MIN_SIGNED_32, MAX_SIGNED_32, object, "uint32 " + object);
        return object;
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return 0;
        }
        _SerializerValidation2.default.require_range(MIN_SIGNED_32, MAX_SIGNED_32, object, "uint32 " + object);
        return parseInt(object);
    }
};
Types.double={
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readFloat64();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        _SerializerValidation2.default.required(object);
        b.writeFloat64(object);
        return;
    },
    fromObject: function fromObject(object) {
        _SerializerValidation2.default.required(object);
        return object;
        return _SerializerValidation2.default.to_long(object);
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return "0";
        }
        _SerializerValidation2.default.required(object);
        return object;
        return _SerializerValidation2.default.to_long(object).toString();
    }
}
Types.int64 = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readInt64();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        _SerializerValidation2.default.required(object);
        b.writeInt64(_SerializerValidation2.default.to_long(object));
        return;
    },
    fromObject: function fromObject(object) {
        _SerializerValidation2.default.required(object);
        return _SerializerValidation2.default.to_long(object);
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return "0";
        }
        _SerializerValidation2.default.required(object);
        return _SerializerValidation2.default.to_long(object).toString();
    }
};

Types.int32 = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readInt32();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        _SerializerValidation2.default.required(object);
        b.writeInt32(object);
        return;
    },
    fromObject: function fromObject(object) {
        _SerializerValidation2.default.required(object);
        return object;
        return _SerializerValidation2.default.to_long(object);
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return "0";
        }
        _SerializerValidation2.default.required(object);
        return _SerializerValidation2.default.to_long(object).toString();
    }
};


Types.uint64 = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readUint64();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        b.writeUint64(_SerializerValidation2.default.to_long(_SerializerValidation2.default.unsigned(object), undefined, true));
        return;
    },
    fromObject: function fromObject(object) {
        return _SerializerValidation2.default.to_long(_SerializerValidation2.default.unsigned(object), undefined, true);
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return "0";
        }
        return _SerializerValidation2.default.to_long(object, undefined, true).toString();
    }
};

Types.string = {
    fromByteBuffer: function fromByteBuffer(b) {
        var b_copy;
        var len = b.readVarint32();
        b_copy = b.copy(b.offset, b.offset + len), b.skip(len);
        return new Buffer(b_copy.toBinary(), "binary");
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        _SerializerValidation2.default.required(object);
        b.writeVarint32(object.length);
        b.append(object.toString("binary"), "binary");
        return;
    },
    fromObject: function fromObject(object) {
        _SerializerValidation2.default.required(object);
        return new Buffer(object);
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return "";
        }
        return object.toString();
    }
};

Types.bytes = function (size) {
    return {
        fromByteBuffer: function fromByteBuffer(b) {
            if (size === undefined) {
                var b_copy;
                var len = b.readVarint32();
                b_copy = b.copy(b.offset, b.offset + len), b.skip(len);
                return new Buffer(b_copy.toBinary(), "binary");
            } else {
                b_copy = b.copy(b.offset, b.offset + size), b.skip(size);
                return new Buffer(b_copy.toBinary(), "binary");
            }
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            _SerializerValidation2.default.required(object);
            if (typeof object === "string") object = new Buffer(object, "hex");

            if (size === undefined) {
                b.writeVarint32(object.length);
            }
            b.append(object.toString("binary"), "binary");
            return;
        },
        fromObject: function fromObject(object) {
            _SerializerValidation2.default.required(object);
            if (Buffer.isBuffer(object)) return object;

            return new Buffer(object, "hex");
        },
        toObject: function toObject(object) {
            var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            if (debug.use_default && object === undefined) {
                var zeros = function zeros(num) {
                    return new Array(num).join("00");
                };
                return zeros(size);
            }
            _SerializerValidation2.default.required(object);
            return object.toString("hex");
        }
    };
};

Types.bool = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readUint8() === 1;
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        // supports boolean or integer
        b.writeUint8(JSON.parse(object) ? 1 : 0);
        return;
    },
    fromObject: function fromObject(object) {
        return JSON.parse(object) ? true : false;
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return false;
        }
        return JSON.parse(object) ? true : false;
    }
};

Types.void = {
    fromByteBuffer: function fromByteBuffer(b) {
        throw new Error("(void) undefined type");
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        throw new Error("(void) undefined type");
    },
    fromObject: function fromObject(object) {
        throw new Error("(void) undefined type");
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return undefined;
        }
        throw new Error("(void) undefined type");
    }
};

Types.array = function (st_operation,b) {
    return {
        fromByteBuffer: function fromByteBuffer(b) {
            var size = b.readVarint32();
            if (HEX_DUMP) {
                console.log("varint32 size = " + size.toString(16));
            }
            var result = [];
            for (var i = 0; 0 < size ? i < size : i > size; 0 < size ? i++ : i++) {
                result.push(st_operation.fromByteBuffer(b));
            }
            return sortOperation(result, st_operation);
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            _SerializerValidation2.default.required(object);
            object = sortOperation(object, st_operation);
            b.writeVarint32(object.length);
            for (var i = 0, o; i < object.length; i++) {
                o = object[i];
                st_operation.appendByteBuffer(b, o);
            }
        },
        fromObject: function fromObject(object) {
            _SerializerValidation2.default.required(object);
            object = sortOperation(object, st_operation);
            var result = [];
            for (var i = 0, o; i < object.length; i++) {
                o = object[i];
                result.push(st_operation.fromObject(o));
            }
            return result;
        },
        toObject: function toObject(object) {
            var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            if (debug.use_default && object === undefined) {
                return [st_operation.toObject(object, debug)];
            }
            _SerializerValidation2.default.required(object);
            object = sortOperation(object, st_operation);
            var result = [];
            for (var i = 0, o; i < object.length; i++) {
                o = object[i];

                result.push(st_operation.toObject(o, debug));
            }
            return result;
        }
    };
};


Types.table = function (st_operation) {
    return {
        validate: function validate(array) {
            if (!Array.isArray(array)) {
                throw new Error("expecting array");
            }
            var dup_map = {};
            for (var i = 0, o; i < array.length; i++) {
                o = array[i];
                var ref;
                if (!(o.length === 2)) {
                    throw new Error("expecting two elements");
                }
                if (ref = _typeof(o[0]), ["number", "string"].indexOf(ref) >= 0) {
                    if (dup_map[o[0]] !== undefined) {
                        throw new Error("duplicate (map)");
                    }
                    dup_map[o[0]] = true;
                }
            }
            //return sortOperation(array, st_operation);
            return array;
            //return this.sortOperation(array);
        },
        fromByteBuffer: function fromByteBuffer(b) {
            var result = [];
            var end = b.readVarint32();
            for (var i = 0; 0 < end ? i < end : i > end; 0 < end ? i++ : i++) {
                result.push([st_operation.fromByteBuffer(b), st_operation.fromByteBuffer(b)]);
            }
            return this.validate(result);
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            this.validate(object);
            b.writeVarint32(object.length);
            for (var i = 0, o; i < object.length; i++) {
                o = object[i];
                st_operation.appendByteBuffer(b, o[0].key);
                st_operation.appendByteBuffer(b, o[1]);
            }
            return;
        },
        fromObject: function fromObject(object) {
            _SerializerValidation2.default.required(object);
            // object = sortOperation(object, st_operation);
            object = this.sortOperation(object);
            var result = [];
            for (var i = 0, o; i < object.length; i++) {
                o = object[i];
                result.push([
                    {
                        key:st_operation.fromObject(o[0].key)
                    }, 
                    st_operation.fromObject(o[1])
                ]);
            }
            return this.validate(result);
        },
        toObject: function toObject(object) {
            var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            if (debug.use_default && object === undefined) {
                return [[st_operation.toObject(undefined, debug), st_operation.toObject(undefined, debug)]];
            }
            _SerializerValidation2.default.required(object);
            object = this.validate(object);
            var result = [];
            for (var i = 0, o; i < object.length; i++) {
                o = object[i];
                result.push([
                    {
                        key:st_operation.toObject(o[0].key,debug)
                    }, 
                    st_operation.toObject(o[1],debug)
                ]);
            }
            return result;
        },
        sortOperation:function sortOperation(array){
           return array.sort(function (a, b) {
                 return strCmp((a[0].key.value).toString(), (b[0].key.value).toString());
            });
        }
    };
};


Types.lua_types = {
    nosort:true,
    types: {
        int:0,
        number:1,
        string:2,
        boolean:3,
        table:4,
        memo_data:5,
        asset:6
    },
    fromByteBuffer: function fromByteBuffer(b) {
        var type_id = b.readVarint32();
        var st_operation = this.st_operations[type_id];
        if (HEX_DUMP) {
            console.error("static_variant id 0x" + type_id.toString(16) + " (" + type_id + ")");
        }
        _SerializerValidation2.default.required(st_operation, "operation " + type_id);
        return [type_id, st_operation.fromByteBuffer(b)];
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        _SerializerValidation2.default.required(object);
        var type_id = object[0];
        var st_operation = this.st_operations[type_id];
        _SerializerValidation2.default.required(st_operation, "operation " + type_id);
         b.writeVarint32(type_id);
        if(type_id<5){
            st_operation.appendByteBuffer(b, object[1].v);//
            return
        }
        st_operation.appendByteBuffer(b, object[1]);
        return;
    },
    fromObject: function fromObject(object) {
        _SerializerValidation2.default.required(object);

        var type_id = _ChainTypes2.default.lua_type[object.dataType]; //this.types[object.dataType];
        var st_operation = this.st_operations[type_id];
        _SerializerValidation2.default.required(st_operation, "operation " + type_id);
        if(type_id<5){
            return [type_id, {v:st_operation.fromObject(object.value)}];//
        }
        return [type_id, st_operation.fromObject(object.value)];
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return [0, this.st_operations[0].toObject(undefined, debug)];
        }
        _SerializerValidation2.default.required(object);

        var type_id = object[0];


        var st_operation = this.st_operations[type_id];

        _SerializerValidation2.default.required(st_operation, "operation " + type_id);
        if(type_id<5){
            return [type_id,{v:st_operation.toObject(object[1].v, debug)}];
        }

        return [type_id, st_operation.toObject(object[1], debug)];
    }
};

Types.lua_types.st_operations= [Types.int64,Types.double,Types.string,Types.bool,Types.table(Types.lua_types)],


Types.map = function (key_st_operation, value_st_operation) {
    return {
        validate: function validate(array) {
            if (!Array.isArray(array)) {
                throw new Error("expecting array");
            }
            var dup_map = {};
            for (var i = 0, o; i < array.length; i++) {
                o = array[i];
                var ref;
                if (!(o.length === 2)) {
                    throw new Error("expecting two elements");
                }
                if (ref = _typeof(o[0]), ["number", "string"].indexOf(ref) >= 0) {
                    if (dup_map[o[0]] !== undefined) {
                        throw new Error("duplicate (map)");
                    }
                    dup_map[o[0]] = true;
                }
            }
            return sortOperation(array, key_st_operation);
        },
        fromByteBuffer: function fromByteBuffer(b) {
            var result = [];
            var end = b.readVarint32();
            for (var i = 0; 0 < end ? i < end : i > end; 0 < end ? i++ : i++) {
                result.push([key_st_operation.fromByteBuffer(b), value_st_operation.fromByteBuffer(b)]);
            }
            return this.validate(result);
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            this.validate(object);
            b.writeVarint32(object.length);
            for (var i = 0, o; i < object.length; i++) {
                o = object[i];
                key_st_operation.appendByteBuffer(b, o[0]);
                value_st_operation.appendByteBuffer(b, o[1]);
            }
            return;
        },
        fromObject: function fromObject(object) {
            _SerializerValidation2.default.required(object);
            var result = [];
            for (var i = 0, o; i < object.length; i++) {
                o = object[i];
                result.push([key_st_operation.fromObject(o[0]), value_st_operation.fromObject(o[1])]);
            }
            return this.validate(result);
        },
        toObject: function toObject(object) {
            var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            if (debug.use_default && object === undefined) {
                return [[key_st_operation.toObject(undefined, debug), value_st_operation.toObject(undefined, debug)]];
            }
            _SerializerValidation2.default.required(object);
            object = this.validate(object);
            var result = [];
            for (var i = 0, o; i < object.length; i++) {
                o = object[i];
                result.push([key_st_operation.toObject(o[0], debug), value_st_operation.toObject(o[1], debug)]);
            }
            return result;
        }
    };
};


Types.pair = function (key_st_operation, value_st_operation) {
    return {
        validate: function validate(array) {
            if (!Array.isArray(array)) {
                throw new Error("expecting array");
            }
            return sortOperation(array, key_st_operation);
        },
        fromByteBuffer: function fromByteBuffer(b) {
            var result = [];
            var end = b.readVarint32();
            for (var i = 0; 0 < end ? i < end : i > end; 0 < end ? i++ : i++) {
                result.push([key_st_operation.fromByteBuffer(b), value_st_operation.fromByteBuffer(b)]);
            }
            return this.validate(result);
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            key_st_operation.appendByteBuffer(b, object[0]);
            value_st_operation.appendByteBuffer(b, object[1]);
            return;
        },
        fromObject: function fromObject(object) {
            return [key_st_operation.fromObject(object[0]), value_st_operation.fromObject(object[1])];
        },
        toObject: function toObject(object) {
            var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            if (debug.use_default && object === undefined) {
                return [[key_st_operation.toObject(undefined, debug), value_st_operation.toObject(undefined, debug)]];
            }
            return [key_st_operation.toObject(object[0], debug), value_st_operation.toObject(object[1], debug)];
        }
    };
};

Types.time_point_sec = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readUint32();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        if (typeof object !== "number") object = Types.time_point_sec.fromObject(object);

        b.writeUint32(object);
        return;
    },
    fromObject: function fromObject(object) {
        _SerializerValidation2.default.required(object);

        if (typeof object === "number") return object;

        if (object.getTime) return Math.floor(object.getTime() / 1000);

        if (typeof object !== "string") throw new Error("Unknown date type: " + object);

        if (/T[0-2][0-9]:[0-5][0-9]:[0-5][0-9]$/.test(object)) object = object + "Z";

        return Math.floor(new Date(object).getTime() / 1000);
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) return new Date(0).toISOString().split(".")[0];

        _SerializerValidation2.default.required(object);

        if (typeof object === "string") return object;

        if (object.getTime) return object.toISOString().split(".")[0];

        var int = parseInt(object);
        _SerializerValidation2.default.require_range(0, 0xffffffff, int, "uint32 " + object);
        return new Date(int * 1000).toISOString().split(".")[0];
    }
};

Types.set = function (st_operation) {
    return {
        validate: function validate(array) {
            var dup_map = {};
            for (var i = 0, o; i < array.length; i++) {
                o = array[i];
                var ref;
                if (ref = typeof o === "undefined" ? "undefined" : _typeof(o), ["string", "number"].indexOf(ref) >= 0) {
                    if (dup_map[o] !== undefined) {
                        throw new Error("duplicate (set)");
                    }
                    dup_map[o] = true;
                }
            }
            return sortOperation(array, st_operation);
        },
        fromByteBuffer: function fromByteBuffer(b) {
            var size = b.readVarint32();
            if (HEX_DUMP) {
                console.log("varint32 size = " + size.toString(16));
            }
            return this.validate(function () {
                var result = [];
                for (var i = 0; 0 < size ? i < size : i > size; 0 < size ? i++ : i++) {
                    result.push(st_operation.fromByteBuffer(b));
                }
                return result;
            }());
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            if (!object) {
                object = [];
            }
            b.writeVarint32(object.length);
            var iterable = this.validate(object);
            for (var i = 0, o; i < iterable.length; i++) {
                o = iterable[i];
                st_operation.appendByteBuffer(b, o);
            }
            return;
        },
        fromObject: function fromObject(object) {
            if (!object) {
                object = [];
            }
            return this.validate(function () {
                var result = [];
                for (var i = 0, o; i < object.length; i++) {
                    o = object[i];
                    result.push(st_operation.fromObject(o));
                }
                return result;
            }());
        },
        toObject: function toObject(object) {
            var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            if (debug.use_default && object === undefined) {
                return [st_operation.toObject(object, debug)];
            }
            if (!object) {
                object = [];
            }
            return this.validate(function () {
                var result = [];
                for (var i = 0, o; i < object.length; i++) {
                    o = object[i];
                    result.push(st_operation.toObject(o, debug));
                }
                return result;
            }());
        }
    };
};

// global_parameters_update_operation current_fees
Types.fixed_array = function (count, st_operation) {
    return {
        fromByteBuffer: function fromByteBuffer(b) {
            var i, j, ref, results;
            results = [];
            for (i = j = 0, ref = count; j < ref; i = j += 1) {
                results.push(st_operation.fromByteBuffer(b));
            }
            return sortOperation(results, st_operation);
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            var i, j, ref;
            if (count !== 0) {
                _SerializerValidation2.default.required(object);
                object = sortOperation(object, st_operation);
            }
            for (i = j = 0, ref = count; j < ref; i = j += 1) {
                st_operation.appendByteBuffer(b, object[i]);
            }
        },
        fromObject: function fromObject(object) {
            var i, j, ref, results;
            if (count !== 0) {
                _SerializerValidation2.default.required(object);
            }
            results = [];
            for (i = j = 0, ref = count; j < ref; i = j += 1) {
                results.push(st_operation.fromObject(object[i]));
            }
            return results;
        },
        toObject: function toObject(object, debug) {
            var i, j, k, ref, ref1, results, results1;
            if (debug == null) {
                debug = {};
            }
            if (debug.use_default && object === void 0) {
                results = [];
                for (i = j = 0, ref = count; j < ref; i = j += 1) {
                    results.push(st_operation.toObject(void 0, debug));
                }
                return results;
            }
            if (count !== 0) {
                _SerializerValidation2.default.required(object);
            }
            results1 = [];
            for (i = k = 0, ref1 = count; k < ref1; i = k += 1) {
                results1.push(st_operation.toObject(object[i], debug));
            }
            return results1;
        }
    };
};

/* Supports instance numbers (11) or object types (1.2.11).  Object type
Validation is enforced when an object type is used. */
var id_type = function id_type(reserved_spaces, object_type) {
    _SerializerValidation2.default.required(reserved_spaces, "reserved_spaces");
    _SerializerValidation2.default.required(object_type, "object_type");
    return {
        fromByteBuffer: function fromByteBuffer(b) {
            return b.readVarint32();
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            _SerializerValidation2.default.required(object);
            if (object.resolve !== undefined) {
                object = object.resolve;
            }
            // convert 1.2.n into just n
            if (/^[0-9]+\.[0-9]+\.[0-9]+$/.test(object)) {
                object = _SerializerValidation2.default.get_instance(reserved_spaces, object_type, object);
            }
            //writeInt64 writeVarint32
            b.writeInt64(_SerializerValidation2.default.to_number(object));
            return;
        },
        fromObject: function fromObject(object) {
            _SerializerValidation2.default.required(object);
            if (object.resolve !== undefined) {
                object = object.resolve;
            }
            if (_SerializerValidation2.default.is_digits(object)) {
                return _SerializerValidation2.default.to_number(object);
            }
            return _SerializerValidation2.default.get_instance(reserved_spaces, object_type, object);
        },
        toObject: function toObject(object) {
            var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            var object_type_id = _ChainTypes2.default.object_type[object_type];
            if (debug.use_default && object === undefined) {
                return reserved_spaces + "." + object_type_id + ".0";
            }
            _SerializerValidation2.default.required(object);
            if (object.resolve !== undefined) {
                object = object.resolve;
            }
            if (/^[0-9]+\.[0-9]+\.[0-9]+$/.test(object)) {
                object = _SerializerValidation2.default.get_instance(reserved_spaces, object_type, object);
            }
            return reserved_spaces + "." + object_type_id + "." + object;
        }
    };
};

var item_id_type = function id_type(reserved_spaces, object_type) {
    _SerializerValidation2.default.required(reserved_spaces, "reserved_spaces");
    _SerializerValidation2.default.required(object_type, "object_type");
    return {
        fromByteBuffer: function fromByteBuffer(b) {
            return b.readVarint32();
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            _SerializerValidation2.default.required(object);
            if (object.resolve !== undefined) {
                object = object.resolve;
            }
            // convert 1.2.n into just n
            if (/^[0-9]+\.[0-9]+\.[0-9]+$/.test(object)) {
                object = _SerializerValidation2.default.get_instance(reserved_spaces, object_type, object);
            }
            //writeInt64 writeVarint32
            b.writeInt64(_SerializerValidation2.default.to_number(object));
            return;
        },
        fromObject: function fromObject(object) {
            _SerializerValidation2.default.required(object);
            if (object.resolve !== undefined) {
                object = object.resolve;
            }
            if (_SerializerValidation2.default.is_digits(object)) {
                return _SerializerValidation2.default.to_number(object);
            }
            return _SerializerValidation2.default.get_instance(reserved_spaces, object_type, object);
        },
        toObject: function toObject(object) {
            var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var object_type_id = _ChainTypes2.default.nh_object_type[object_type];
            if (debug.use_default && object === undefined) {
                return reserved_spaces + "." + object_type_id + ".0";
            }
            _SerializerValidation2.default.required(object);
            if (object.resolve !== undefined) {
                object = object.resolve;
            }
            if (/^[0-9]+\.[0-9]+\.[0-9]+$/.test(object)) {
                object = _SerializerValidation2.default.get_instance(reserved_spaces, object_type, object);
            }
            return reserved_spaces + "." + object_type_id + "." + object;
        }
    };
};

Types.protocol_id_type = function (name) {
    _SerializerValidation2.default.required(name, "name");
    return id_type(_ChainTypes2.default.reserved_spaces.protocol_ids, name);
};

Types.nh_protocol_id_type = function (name) {
    _SerializerValidation2.default.required(name, "name");
    return item_id_type(_ChainTypes2.default.reserved_spaces.nh_protocol_ids, name);
};


Types.object_id_type = {
    fromByteBuffer: function fromByteBuffer(b) {
        return _ObjectId2.default.fromByteBuffer(b);
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        _SerializerValidation2.default.required(object);
        if (object.resolve !== undefined) {
            object = object.resolve;
        }
        object = _ObjectId2.default.fromString(object);
        object.appendByteBuffer(b);
        return;
    },
    fromObject: function fromObject(object) {
        _SerializerValidation2.default.required(object);
        if (object.resolve !== undefined) {
            object = object.resolve;
        }
        return _ObjectId2.default.fromString(object);
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return "0.0.0";
        }
        _SerializerValidation2.default.required(object);
        if (object.resolve !== undefined) {
            object = object.resolve;
        }
        object = _ObjectId2.default.fromString(object);
        return object.toString();
    }
};

Types.vote_id = {
    TYPE: 0x000000ff,
    ID: 0xffffff00,
    fromByteBuffer: function fromByteBuffer(b) {
        var value = b.readUint32();
        return {
            type: value & this.TYPE,
            id: value & this.ID
        };
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        _SerializerValidation2.default.required(object);
        if (object === "string") object = Types.vote_id.fromObject(object);

        var value = object.id << 8 | object.type;
        b.writeUint32(value);
        
        return;
    },
    fromObject: function fromObject(object) {
        _SerializerValidation2.default.required(object, "(type vote_id)");
        if ((typeof object === "undefined" ? "undefined" : _typeof(object)) === "object") {
            _SerializerValidation2.default.required(object.type, "type");
            _SerializerValidation2.default.required(object.id, "id");
            return object;
        }
        _SerializerValidation2.default.require_test(/^[0-9]+:[0-9]+$/, object, "vote_id format " + object);

        var _object$split = object.split(":"),
            type = _object$split[0],
            id = _object$split[1];

        _SerializerValidation2.default.require_range(0, 0xff, type, "vote type " + object);
        _SerializerValidation2.default.require_range(0, 0xffffff, id, "vote id " + object);
        return { type: type, id: id };
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return "0:0";
        }
        _SerializerValidation2.default.required(object);
        if (typeof object === "string") object = Types.vote_id.fromObject(object);

        return object.type + ":" + object.id;
    },
    compare: function compare(a, b) {
        if ((typeof a === "undefined" ? "undefined" : _typeof(a)) !== "object") a = Types.vote_id.fromObject(a);
        if ((typeof b === "undefined" ? "undefined" : _typeof(b)) !== "object") b = Types.vote_id.fromObject(b);
        return parseInt(a.id) - parseInt(b.id);
    }
};

Types.optional = function (st_operation) {
    _SerializerValidation2.default.required(st_operation, "st_operation");
    return {
        fromByteBuffer: function fromByteBuffer(b) {
            if (!(b.readUint8() === 1)) {
                return undefined;
            }
            return st_operation.fromByteBuffer(b);
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            if (object !== null && object !== undefined) {
                b.writeUint8(1);
                st_operation.appendByteBuffer(b, object);
            } else {
                b.writeUint8(0);
            }
            return;
        },
        fromObject: function fromObject(object) {
            if (object === undefined) {
                return undefined;
            }
            return st_operation.fromObject(object);
        },
        toObject: function toObject(object) {
            var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            // toObject is only null save if use_default is true
            var result_object = function () {
                if (!debug.use_default && object === undefined) {
                    return undefined;
                } else {
                    return st_operation.toObject(object, debug);
                }
            }();

            if (debug.annotate) {
                if ((typeof result_object === "undefined" ? "undefined" : _typeof(result_object)) === "object") {
                    result_object.__optional = "parent is optional";
                } else {
                    result_object = { __optional: result_object };
                }
            }
            return result_object;
        }
    };
};

Types.static_variant = function (_st_operations) {
    return {
        nosort: true,
        st_operations: _st_operations,
        fromByteBuffer: function fromByteBuffer(b) {
            var type_id = b.readVarint32();
            var st_operation = this.st_operations[type_id];
            if (HEX_DUMP) {
                console.error("static_variant id 0x" + type_id.toString(16) + " (" + type_id + ")");
            }
            _SerializerValidation2.default.required(st_operation, "operation " + type_id);
            return [type_id, st_operation.fromByteBuffer(b)];
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            _SerializerValidation2.default.required(object);
            var type_id = object[0];
            var st_operation = this.st_operations[type_id];
            _SerializerValidation2.default.required(st_operation, "operation " + type_id);
            b.writeVarint32(type_id);
            st_operation.appendByteBuffer(b, object[1]);
            return;
        },
        fromObject: function fromObject(object) {
            _SerializerValidation2.default.required(object);
            var type_id = object[0];
            var st_operation = this.st_operations[type_id];
            _SerializerValidation2.default.required(st_operation, "operation " + type_id);
            return [type_id, st_operation.fromObject(object[1])];
        },
        toObject: function toObject(object) {
            var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            if (debug.use_default && object === undefined) {
                return [0, this.st_operations[0].toObject(undefined, debug)];
            }
            _SerializerValidation2.default.required(object);
            var type_id = object[0];
            var st_operation = this.st_operations[type_id];
            _SerializerValidation2.default.required(st_operation, "operation " + type_id);
            return [type_id, st_operation.toObject(object[1], debug)];
        }
    };
};



Types.public_key = {
    toPublic: function toPublic(object) {
        if (object.resolve !== undefined) {
            object = object.resolve;
        }
        return object == null ? object : object.Q ? object : _ecc.PublicKey.fromStringOrThrow(object);
    },
    fromByteBuffer: function fromByteBuffer(b) {
        return _FastParser2.default.public_key(b);
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        _SerializerValidation2.default.required(object);
        _FastParser2.default.public_key(b, Types.public_key.toPublic(object));
        return;
    },
    fromObject: function fromObject(object) {
        _SerializerValidation2.default.required(object);
        if (object.Q) {
            return object;
        }
        return Types.public_key.toPublic(object);
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return _bcxjsWs.ChainConfig.address_prefix + "859gxfnXyUriMgUeThh1fWv3oqcpLFyHa3TfFYC4PK2HqhToVM";
        }
        _SerializerValidation2.default.required(object);
        return object.toString();
    },
    compare: function compare(a, b) {
        return Types.public_key.fromObject(a).toBlockchainAddress().compare(Types.public_key.fromObject(b).toBlockchainAddress());
    }
};

Types.address = {
    _to_address: function _to_address(object) {
        _SerializerValidation2.default.required(object);
        if (object.addy) {
            return object;
        }
        return _ecc.Address.fromString(object);
    },
    fromByteBuffer: function fromByteBuffer(b) {
        return new _ecc.Address(_FastParser2.default.ripemd160(b));
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        _FastParser2.default.ripemd160(b, Types.address._to_address(object).toBuffer());
        return;
    },
    fromObject: function fromObject(object) {
        return Types.address._to_address(object);
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return _bcxjsWs.ChainConfig.address_prefix + "664KmHxSuQyDsfwo4WEJvWpzg1QKdg67S";
        }
        return Types.address._to_address(object).toString();
    },
    compare: function compare(a, b) {
        return strCmp(a.toString(), b.toString());
    }
};

var strCmp = function strCmp(a, b) {
    return a > b ? 1 : a < b ? -1 : 0;
};
var firstEl = function firstEl(el) {
    return Array.isArray(el) ? el[0] : el;
};
var sortOperation = function sortOperation(array, st_operation) {
    return st_operation.nosort ? array : st_operation.compare ? array.sort(function (a, b) {
        return st_operation.compare(firstEl(a), firstEl(b));
    }) // custom compare operation
    : array.sort(function (a, b) {
        return typeof firstEl(a) === "number" && typeof firstEl(b) === "number" ? firstEl(a) - firstEl(b) : // A binary string compare does not work. Performanance is very good so HEX is used..  localeCompare is another option.
        Buffer.isBuffer(firstEl(a)) && Buffer.isBuffer(firstEl(b)) ? strCmp(firstEl(a).toString("hex"), firstEl(b).toString("hex")) : strCmp(firstEl(a).toString(), firstEl(b).toString());
    });
};

exports.default = Types;
module.exports = exports["default"];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9), __webpack_require__(2).Buffer))

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.key = exports.hash = exports.brainKey = exports.Signature = exports.PublicKey = exports.PrivateKey = exports.Aes = exports.Address = undefined;

var _address = __webpack_require__(220);

var _address2 = _interopRequireDefault(_address);

var _aes = __webpack_require__(221);

var _aes2 = _interopRequireDefault(_aes);

var _PrivateKey = __webpack_require__(146);

var _PrivateKey2 = _interopRequireDefault(_PrivateKey);

var _PublicKey = __webpack_require__(97);

var _PublicKey2 = _interopRequireDefault(_PublicKey);

var _signature = __webpack_require__(377);

var _signature2 = _interopRequireDefault(_signature);

var _BrainKey = __webpack_require__(379);

var _BrainKey2 = _interopRequireDefault(_BrainKey);

var _hash = __webpack_require__(58);

var hash = _interopRequireWildcard(_hash);

var _KeyUtils = __webpack_require__(222);

var _KeyUtils2 = _interopRequireDefault(_KeyUtils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.Address = _address2.default;
exports.Aes = _aes2.default;
exports.PrivateKey = _PrivateKey2.default;
exports.PublicKey = _PublicKey2.default;
exports.Signature = _signature2.default;
exports.brainKey = _BrainKey2.default;
exports.hash = hash;
exports.key = _KeyUtils2.default;

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

exports.__esModule = true;

var _assert = __webpack_require__(45);

var _assert2 = _interopRequireDefault(_assert);

var _bcxjsWs = __webpack_require__(8);

var _hash2 = __webpack_require__(58);

var _bs = __webpack_require__(216);

var _deepEqual = __webpack_require__(217);

var _deepEqual2 = _interopRequireDefault(_deepEqual);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/** Addresses are shortened non-reversable hashes of a public key.  The full PublicKey is preferred.
    @deprecated
*/
var Address = function () {
    function Address(addy) {
        _classCallCheck(this, Address);

        this.addy = addy;
    }

    Address.fromBuffer = function fromBuffer(buffer) {
        var _hash = (0, _hash2.sha512)(buffer);
        var addy = (0, _hash2.ripemd160)(_hash);
        return new Address(addy);
    };

    Address.fromString = function fromString(string) {
        var address_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _bcxjsWs.ChainConfig.address_prefix;

        var prefix = string.slice(0, address_prefix.length);
        _assert2.default.equal(address_prefix, prefix, 'Expecting key to begin with ' + address_prefix + ', instead got ' + prefix);
        var addy = string.slice(address_prefix.length);
        addy = new Buffer((0, _bs.decode)(addy), 'binary');
        var checksum = addy.slice(-4);
        addy = addy.slice(0, -4);
        var new_checksum = (0, _hash2.ripemd160)(addy);
        new_checksum = new_checksum.slice(0, 4);
        var isEqual = (0, _deepEqual2.default)(checksum, new_checksum); //, 'Invalid checksum'
        if (!isEqual) {
            throw new Error("Checksum did not match");
        }
        return new Address(addy);
    };

    /** @return Address - Compressed PTS format (by default) */
    Address.fromPublic = function fromPublic(public_key) {
        var compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var version = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 56;

        var sha2 = (0, _hash2.sha256)(public_key.toBuffer(compressed));
        var rep = (0, _hash2.ripemd160)(sha2);
        var versionBuffer = new Buffer(1);
        versionBuffer.writeUInt8(0xFF & version, 0);
        var addr = Buffer.concat([versionBuffer, rep]);
        var check = (0, _hash2.sha256)(addr);
        check = (0, _hash2.sha256)(check);
        var buffer = Buffer.concat([addr, check.slice(0, 4)]);
        return new Address((0, _hash2.ripemd160)(buffer));
    };

    Address.prototype.toBuffer = function toBuffer() {
        return this.addy;
    };

    Address.prototype.toString = function toString() {
        var address_prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _bcxjsWs.ChainConfig.address_prefix;

        var checksum = (0, _hash2.ripemd160)(this.addy);
        var addy = Buffer.concat([this.addy, checksum.slice(0, 4)]);
        return address_prefix + (0, _bs.encode)(addy);
    };

    return Address;
}();

exports.default = Address;
module.exports = exports['default'];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

exports.__esModule = true;

var _aes = __webpack_require__(458);

var _aes2 = _interopRequireDefault(_aes);

var _encHex = __webpack_require__(463);

var _encHex2 = _interopRequireDefault(_encHex);

var _encBase = __webpack_require__(375);

var _encBase2 = _interopRequireDefault(_encBase);

var _assert = __webpack_require__(45);

var _assert2 = _interopRequireDefault(_assert);

var _bytebuffer = __webpack_require__(130);

var _hash2 = __webpack_require__(58);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } // https://code.google.com/p/crypto-js


/** Provides symetric encrypt and decrypt via AES. */
var Aes = function () {

    /** @private */
    function Aes(iv, key) {
        _classCallCheck(this, Aes);

        this.iv = iv, this.key = key;
    }

    /** This is an excellent way to ensure that all references to Aes can not operate anymore (example: a wallet becomes locked).  An application should ensure there is only one Aes object instance for a given secret `seed`. */


    Aes.prototype.clear = function clear() {
        return this.iv = this.key = undefined;
    };

    /** @arg {string} seed - secret seed may be used to encrypt or decrypt. */


    Aes.fromSeed = function fromSeed(seed) {
        if (seed === undefined) {
            throw new Error("seed is required");
        }
        var _hash = (0, _hash2.sha512)(seed);
        _hash = _hash.toString('hex');
        // DEBUG console.log('... fromSeed _hash',_hash)
        return Aes.fromSha512(_hash);
    };

    /** @arg {string} hash - A 128 byte hex string, typically one would call {@link fromSeed} instead. */
    Aes.fromSha512 = function fromSha512(hash) {
        _assert2.default.equal(hash.length, 128, "A Sha512 in HEX should be 128 characters long, instead got " + hash.length);
        var iv = _encHex2.default.parse(hash.substring(64, 96));
        var key = _encHex2.default.parse(hash.substring(0, 64));
        return new Aes(iv, key);
    };

    Aes.fromBuffer = function fromBuffer(buf) {
        (0, _assert2.default)(Buffer.isBuffer(buf), "Expecting Buffer");
        _assert2.default.equal(buf.length, 64, "A Sha512 Buffer should be 64 characters long, instead got " + buf.length);
        return Aes.fromSha512(buf.toString("hex"));
    };
    /**
        @throws {Error} - "Invalid Key, ..."
        @arg {PrivateKey} private_key - required and used for decryption
        @arg {PublicKey} public_key - required and used to calcualte the shared secret
        @arg {string} [nonce = ""] optional but should always be provided and be unique when re-using the same private/public keys more than once.  This nonce is not a secret.
        @arg {string|Buffer} message - Encrypted message containing a checksum
        @return {Buffer}
    */


    Aes.decrypt_with_checksum = function decrypt_with_checksum(private_key, public_key, nonce, message) {
        var legacy = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;


        // Warning: Do not put `nonce = ""` in the arguments, in es6 this will not convert "null" into an emtpy string
        if (nonce == null) // null or undefined
            nonce = "";

        if (!Buffer.isBuffer(message)) {
            message = new Buffer(message, 'hex');
        }

        var S = private_key.get_shared_secret(public_key, legacy);
        // D E B U G
        // console.log('decrypt_with_checksum', {
        //     priv_to_pub: private_key.toPublicKey().toString(),
        //     pub: public_key.toPublicKeyString(),
        //     nonce: nonce,
        //     message: message.length,
        //     S: S.toString('hex')
        // })

        var aes = Aes.fromSeed(Buffer.concat([
        // A null or empty string nonce will not effect the hash
        new Buffer("" + nonce), new Buffer(S.toString('hex'))]));

        var planebuffer = aes.decrypt(message);
        if (!(planebuffer.length >= 4)) {
            throw new Error("Invalid key, could not decrypt message(1)");
        }

        // DEBUG console.log('... planebuffer',planebuffer)
        var checksum = planebuffer.slice(0, 4);
        var plaintext = planebuffer.slice(4);

        // console.log('... checksum',checksum.toString('hex'))
        // console.log('... plaintext',plaintext.toString())

        var new_checksum = (0, _hash2.sha256)(plaintext);
        new_checksum = new_checksum.slice(0, 4);
        new_checksum = new_checksum.toString('hex');

        if (!(checksum.toString('hex') === new_checksum)) {
            throw new Error("Invalid key, could not decrypt message(2)");
        }

        return plaintext;
    };

    /** Identical to {@link decrypt_with_checksum} but used to encrypt.  Should not throw an error.
        @return {Buffer} message - Encrypted message which includes a checksum
    */
    Aes.encrypt_with_checksum = function encrypt_with_checksum(private_key, public_key, nonce, message) {

        // Warning: Do not put `nonce = ""` in the arguments, in es6 this will not convert "null" into an emtpy string

        if (nonce == null) // null or undefined
            nonce = "";

        if (!Buffer.isBuffer(message)) {
            message = new Buffer(message, 'binary');
        }

        var S = private_key.get_shared_secret(public_key);

        // D E B U G
        // console.log('encrypt_with_checksum', {
        //     priv_to_pub: private_key.toPublicKey().toString()
        //     pub: public_key.toPublicKeyString()
        //     nonce: nonce
        //     message: message.length
        //     S: S.toString('hex')
        // })

        var aes = Aes.fromSeed(Buffer.concat([
        // A null or empty string nonce will not effect the hash
        new Buffer("" + nonce), new Buffer(S.toString('hex'))]));
        // DEBUG console.log('... S',S.toString('hex'))
        var checksum = (0, _hash2.sha256)(message).slice(0, 4);
        var payload = Buffer.concat([checksum, message]);
        // DEBUG console.log('... payload',payload.toString())
        return aes.encrypt(payload);
    };

    /** @private */
    Aes.prototype._decrypt_word_array = function _decrypt_word_array(cipher) {
        // https://code.google.com/p/crypto-js/#Custom_Key_and_IV
        // see wallet_records.cpp master_key::decrypt_key
        return _aes2.default.decrypt({ ciphertext: cipher, salt: null }, this.key, { iv: this.iv });
    };

    /** @private */


    Aes.prototype._encrypt_word_array = function _encrypt_word_array(plaintext) {
        //https://code.google.com/p/crypto-js/issues/detail?id=85
        var cipher = _aes2.default.encrypt(plaintext, this.key, { iv: this.iv });
        return _encBase2.default.parse(cipher.toString());
    };

    /** This method does not use a checksum, the returned data must be validated some other way.
        @arg {string} ciphertext
        @return {Buffer} binary
    */


    Aes.prototype.decrypt = function decrypt(ciphertext) {
        if (typeof ciphertext === "string") {
            ciphertext = new Buffer(ciphertext, 'binary');
        }
        if (!Buffer.isBuffer(ciphertext)) {
            throw new Error("buffer required");
        }
        (0, _assert2.default)(ciphertext, "Missing cipher text");
        // hex is the only common format
        var hex = this.decryptHex(ciphertext.toString('hex'));
        return new Buffer(hex, 'hex');
    };

    /** This method does not use a checksum, the returned data must be validated some other way.
        @arg {string} plaintext
        @return {Buffer} binary
    */


    Aes.prototype.encrypt = function encrypt(plaintext) {
        if (typeof plaintext === "string") {
            plaintext = new Buffer(plaintext, 'binary');
        }
        if (!Buffer.isBuffer(plaintext)) {
            throw new Error("buffer required");
        }
        //assert plaintext, "Missing plain text"
        // hex is the only common format
        var hex = this.encryptHex(plaintext.toString('hex'));
        return new Buffer(hex, 'hex');
    };

    /** This method does not use a checksum, the returned data must be validated some other way.
        @arg {string|Buffer} plaintext
        @return {string} hex
    */


    Aes.prototype.encryptToHex = function encryptToHex(plaintext) {
        if (typeof plaintext === "string") {
            plaintext = new Buffer(plaintext, 'binary');
        }
        if (!Buffer.isBuffer(plaintext)) {
            throw new Error("buffer required");
        }
        //assert plaintext, "Missing plain text"
        // hex is the only common format
        return this.encryptHex(plaintext.toString('hex'));
    };

    /** This method does not use a checksum, the returned data must be validated some other way.
        @arg {string} cipher - hex
        @return {string} binary (could easily be readable text)
    */


    Aes.prototype.decryptHex = function decryptHex(cipher) {
        (0, _assert2.default)(cipher, "Missing cipher text");
        // Convert data into word arrays (used by Crypto)
        var cipher_array = _encHex2.default.parse(cipher);
        var plainwords = this._decrypt_word_array(cipher_array);
        return _encHex2.default.stringify(plainwords);
    };

    /** This method does not use a checksum, the returned data must be validated some other way.
        @arg {string} cipher - hex
        @return {Buffer} encoded as specified by the parameter
    */


    Aes.prototype.decryptHexToBuffer = function decryptHexToBuffer(cipher) {
        (0, _assert2.default)(cipher, "Missing cipher text");
        // Convert data into word arrays (used by Crypto)
        var cipher_array = _encHex2.default.parse(cipher);
        var plainwords = this._decrypt_word_array(cipher_array);
        var plainhex = _encHex2.default.stringify(plainwords);
        return new Buffer(plainhex, 'hex');
    };

    /** This method does not use a checksum, the returned data must be validated some other way.
        @arg {string} cipher - hex
        @arg {string} [encoding = 'binary'] - a valid Buffer encoding
        @return {String} encoded as specified by the parameter
    */


    Aes.prototype.decryptHexToText = function decryptHexToText(cipher) {
        var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'binary';

        return this.decryptHexToBuffer(cipher).toString(encoding);
    };

    /** This method does not use a checksum, the returned data must be validated some other way.
        @arg {string} plainhex - hex format
        @return {String} hex
    */


    Aes.prototype.encryptHex = function encryptHex(plainhex) {
        var plain_array = _encHex2.default.parse(plainhex);
        var cipher_array = this._encrypt_word_array(plain_array);
        return _encHex2.default.stringify(cipher_array);
    };

    return Aes;
}();

exports.default = Aes;
module.exports = exports["default"];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

exports.__esModule = true;

var _PrivateKey = __webpack_require__(146);

var _PrivateKey2 = _interopRequireDefault(_PrivateKey);

var _PublicKey = __webpack_require__(97);

var _PublicKey2 = _interopRequireDefault(_PublicKey);

var _address = __webpack_require__(220);

var _address2 = _interopRequireDefault(_address);

var _aes = __webpack_require__(221);

var _aes2 = _interopRequireDefault(_aes);

var _hash = __webpack_require__(58);

var _secureRandom = __webpack_require__(380);

var _secureRandom2 = _interopRequireDefault(_secureRandom);

var _bcxjsWs = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// hash for .25 second

// import dictionary from './dictionary_en';
var HASH_POWER_MILLS = 250;

var key = {

    /** Uses 1 second of hashing power to create a key/password checksum.  An
    implementation can re-call this method with the same password to re-match
    the strength of the CPU (either after moving from a desktop to a mobile,
    mobile to desktop, or N years from now when CPUs are presumably stronger).
     A salt is used for all the normal reasons...
     @return object {
        aes_private: Aes,
        checksum: "{hash_iteration_count},{salt},{checksum}"
    }
    */
    aes_checksum: function aes_checksum(password) {
        if (!(typeof password === "string")) {
            throw new "password string required"();
        }
        var salt = _secureRandom2.default.randomBuffer(4).toString('hex');
        var iterations = 0;
        var secret = salt + password;
        // hash for .1 second
        var start_t = Date.now();
        while (Date.now() - start_t < HASH_POWER_MILLS) {
            secret = (0, _hash.sha256)(secret);
            iterations += 1;
        }

        var checksum = (0, _hash.sha256)(secret);
        var checksum_string = [iterations, salt.toString('hex'), checksum.slice(0, 4).toString('hex')].join(',');

        return { aes_private: _aes2.default.fromSeed(secret),
            checksum: checksum_string
        };
    },


    /** Provide a matching password and key_checksum.  A "wrong password"
    error is thrown if the password does not match.  If this method takes
    much more or less than 1 second to return, one should consider updating
    all encyrpted fields using a new key.key_checksum.
    */
    aes_private: function aes_private(password, key_checksum) {
        var _key_checksum$split = key_checksum.split(','),
            iterations = _key_checksum$split[0],
            salt = _key_checksum$split[1],
            checksum = _key_checksum$split[2];

        var secret = salt + password;
        for (var i = 0; 0 < iterations ? i < iterations : i > iterations; 0 < iterations ? i++ : i++) {
            secret = (0, _hash.sha256)(secret);
        }
        var new_checksum = (0, _hash.sha256)(secret);
        if (!(new_checksum.slice(0, 4).toString('hex') === checksum)) {
            throw new Error("wrong password");
        }
        return _aes2.default.fromSeed(secret);
    },


    /**
        A week random number generator can run out of entropy.  This should ensure even the worst random number implementation will be reasonably safe.
         @param1 string entropy of at least 32 bytes
    */
    random32ByteBuffer: function random32ByteBuffer() {
        var entropy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.browserEntropy();


        if (!(typeof entropy === 'string')) {
            throw new Error("string required for entropy");
        }

        if (entropy.length < 32) {
            throw new Error("expecting at least 32 bytes of entropy");
        }

        var start_t = Date.now();

        while (Date.now() - start_t < HASH_POWER_MILLS) {
            entropy = (0, _hash.sha256)(entropy);
        }var hash_array = [];
        hash_array.push(entropy);

        // Hashing for 1 second may helps the computer is not low on entropy (this method may be called back-to-back).
        hash_array.push(_secureRandom2.default.randomBuffer(32));

        return (0, _hash.sha256)(Buffer.concat(hash_array));
    },


    suggest_brain_key: function suggest_brain_key() {
        var dictionary = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ",";
        var entropy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.browserEntropy();


        var randomBuffer = this.random32ByteBuffer(entropy);

        var word_count = 16;
        var dictionary_lines = dictionary.split(',');

        if (!(dictionary_lines.length === 49744)) {
            throw new Error('expecting ' + 49744 + ' but got ' + dictionary_lines.length + ' dictionary words');
        }

        var brainkey = [];
        var end = word_count * 2;

        for (var i = 0; i < end; i += 2) {

            // randomBuffer has 256 bits / 16 bits per word == 16 words
            var num = (randomBuffer[i] << 8) + randomBuffer[i + 1];

            // convert into a number between 0 and 1 (inclusive)
            var rndMultiplier = num / Math.pow(2, 16);
            var wordIndex = Math.round(dictionary_lines.length * rndMultiplier);

            brainkey.push(dictionary_lines[wordIndex]);
        }
        return this.normalize_brainKey(brainkey.join(' '));
    },

    get_random_key: function get_random_key(entropy) {
        return _PrivateKey2.default.fromBuffer(this.random32ByteBuffer(entropy));
    },
    get_brainPrivateKey: function get_brainPrivateKey(brainKey) {
        var sequence = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        if (sequence < 0) {
            throw new Error("invalid sequence");
        }
        brainKey = key.normalize_brainKey(brainKey);
        return _PrivateKey2.default.fromBuffer((0, _hash.sha256)((0, _hash.sha512)(brainKey + " " + sequence)));
    },


    // Turn invisible space like characters into a single space
    normalize_brainKey: function normalize_brainKey(brainKey) {
        if (!(typeof brainKey === 'string')) {
            throw new Error("string required for brainKey");
        }

        brainKey = brainKey.trim();
        return brainKey.split(/[\t\n\v\f\r ]+/).join(' ');
    },
    browserEntropy: function browserEntropy() {

        var entropyStr = "";
        try {
            entropyStr = new Date().toString() + " " + window.screen.height + " " + window.screen.width + " " + window.screen.colorDepth + " " + " " + window.screen.availHeight + " " + window.screen.availWidth + " " + window.screen.pixelDepth + navigator.language + " " + window.location + " " + window.history.length;

            for (var i = 0, mimeType; i < navigator.mimeTypes.length; i++) {
                mimeType = navigator.mimeTypes[i];
                entropyStr += mimeType.description + " " + mimeType.type + " " + mimeType.suffixes + " ";
            }
            console.log("INFO\tbrowserEntropy gathered");
        } catch (error) {
            //nodejs:ReferenceError: window is not defined
            entropyStr = (0, _hash.sha256)(new Date().toString());
        }

        var b = new Buffer(entropyStr);
        entropyStr += b.toString('binary') + " " + new Date().toString();
        return entropyStr;
    },


    // @return array of 5 legacy addresses for a pubkey string parameter.
    addresses: function addresses(pubkey) {
        var address_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _bcxjsWs.ChainConfig.address_prefix;

        var public_key = _PublicKey2.default.fromPublicKeyString(pubkey, address_prefix);
        // S L O W
        var address_string = [_address2.default.fromPublic(public_key, false, 0).toString(address_prefix), // btc_uncompressed
        _address2.default.fromPublic(public_key, true, 0).toString(address_prefix), // btc_compressed
        _address2.default.fromPublic(public_key, false, 56).toString(address_prefix), // pts_uncompressed
        _address2.default.fromPublic(public_key, true, 56).toString(address_prefix), // pts_compressed
        public_key.toAddressString(address_prefix) // gph_short, most recent format
        ];
        return address_string;
    }
};

exports.default = key;
module.exports = exports['default'];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _undefined = __webpack_require__(480)(); // Support ES3 engines

module.exports = function (val) { return val !== _undefined && val !== null; };


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = __webpack_require__(18);

var _stringify2 = _interopRequireDefault(_stringify);

var _regenerator = __webpack_require__(3);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _classCallCheck2 = __webpack_require__(11);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(15);

var _createClass3 = _interopRequireDefault(_createClass2);

var _bcxjsWs = __webpack_require__(8);

var _bcxjsCores = __webpack_require__(7);

var _api = __webpack_require__(10);

var _api2 = _interopRequireDefault(_api);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Subscribe to updates from bcxjs-ws
 */

var ChainListener = function () {
  function ChainListener() {
    (0, _classCallCheck3.default)(this, ChainListener);

    this._subscribers = [];
    this._enabled = false;
    this.isCallbackOk = true;
    this.exist_block_num = 0;
    this.sub_max_ops = 13;
    this.real_sub = true;
  }

  (0, _createClass3.default)(ChainListener, [{
    key: 'enable',
    value: function enable(sub_max_ops) {
      return _regenerator2.default.async(function enable$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _bcxjsCores.ChainStore.setCustomSubscribeCallback(this._mainCallback.bind(this));
              this._enabled = true;
              this.sub_max_ops = sub_max_ops || 13;

            case 3:
            case 'end':
              return _context.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: 'disable',
    value: function disable() {
      var _this = this;

      return _bcxjsWs.Apis.instance().db_api().exec('cancel_all_subscriptions', []).then(function () {
        _this._enabled = false;
      });
    }
  }, {
    key: 'addSubscription',
    value: function addSubscription(subscription) {
      var userId = "";
      if (subscription.type == "userOperation") {
        userId = subscription._userId;
      }
      this._deleteSubscription(subscription.type, userId);

      this._subscribers.push(subscription);
      return true;
    }
  }, {
    key: '_deleteSubscription',
    value: function _deleteSubscription(type, userId) {
      if (!type) {
        this._subscribers = [];
        return { code: 1 };
      }
      this._subscribers = this._subscribers.filter(function (item) {
        if (userId) {
          return item._userId != userId;
        } else {
          return item.type != type;
        }
      });
      return { code: 1 };
    }
  }, {
    key: '_mainCallback',
    value: function _mainCallback(data) {
      var _this2 = this;

      if (this.real_sub) {
        data[0].forEach(function (operation) {
          _this2._subscribers.forEach(function (subscriber) {
            if (subscriber.type == "BlocksOp" && operation.id == "2.1.0") {
              // console.info("operation",operation);
              operation.block_num = operation.block_height = operation.head_block_number;
              operation.block_id = operation.head_block_id;
              subscriber.notify(operation, false);
            } else {
              subscriber.notify(operation);
            }
          });
        });
        return;
      }
      if (!this._subscribers.length) return;
      data[0].forEach(function (operation) {
        if (operation && operation.id == "2.1.0") {
          var head_block_number = operation.head_block_number;


          if (head_block_number <= _this2.exist_block_num) return;

          _this2.exist_block_num = head_block_number;
          //If the subscription has only one subscription block and does not request a transaction
          if (_this2._subscribers.length == 1 && _this2._subscribers[0].type == "BlocksOp" && !_this2._subscribers[0].isReqTrx) {
            _this2._subscribers[0].notify(operation, false);
            return;
          }

          _api2.default.Operations.getBlock(head_block_number).then(function (res) {
            if (res.code == 1) {
              res.data.block_num = head_block_number;
              res.data.block_id = operation.head_block_id;
              _this2._subscribers.forEach(function (subscriber) {
                subscriber.notify(JSON.parse((0, _stringify2.default)(res.data)), true);
              });

              var opCount = 0; //op counts
              //Traversing trx
              res.data.transactions.some(function (trx, trx_index) {
                opCount += trx[1].operations.length;
                if (opCount > _this2.sub_max_ops) {
                  trx[1].operations.length = _this2.sub_max_ops;
                }
                //Traversing OP Account record
                trx[1].operations.forEach(function (op, op_index) {
                  _this2._subscribers.forEach(function (subscriber) {
                    subscriber.notify({
                      block_num: head_block_number,
                      id: head_block_number + "." + trx_index + "." + op_index,
                      op: op,
                      result: trx[1].operation_results[op_index]
                    });
                  });
                });
                if (opCount > _this2.sub_max_ops) {
                  return true;
                }
              });
            }
            // subscriber.notify(operation);
          });
        }
      });
      //this.isCallbackOk=true;
    }
  }]);
  return ChainListener;
}();

exports.default = new ChainListener();

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__(24);

var _keys2 = _interopRequireDefault(_keys);

var _slicedToArray2 = __webpack_require__(90);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _getPrototypeOf = __webpack_require__(390);

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _possibleConstructorReturn2 = __webpack_require__(391);

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = __webpack_require__(392);

var _inherits3 = _interopRequireDefault(_inherits2);

var _classCallCheck2 = __webpack_require__(11);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(15);

var _createClass3 = _interopRequireDefault(_createClass2);

var _bcxjsCores = __webpack_require__(7);

var _api = __webpack_require__(10);

var _api2 = _interopRequireDefault(_api);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint no-underscore-dangle: 0 */
/* eslint camelcase: 0 */

var object_type = _bcxjsCores.ChainTypes.object_type;


var limit_order = parseInt(object_type.limit_order, 10);
var history = parseInt(object_type.operation_history, 10);
var order_prefix = '1.' + limit_order + '.';
var history_prefix = '1.' + history + '.';

var Subscription = function () {
  function Subscription(type) {
    (0, _classCallCheck3.default)(this, Subscription);

    this.type = type;
    this._callback = function () {};
  }

  (0, _createClass3.default)(Subscription, [{
    key: 'setCallback',
    value: function setCallback(callback) {
      this._callback = callback;
    }
  }, {
    key: 'getType',
    value: function getType() {
      return this.type;
    }
  }, {
    key: 'notify',
    value: function notify(operation) {
      this._callback(operation);
    }
  }]);
  return Subscription;
}();

var Markets = function (_Subscription) {
  (0, _inherits3.default)(Markets, _Subscription);

  function Markets(_ref) {
    var callback = _ref.callback;
    (0, _classCallCheck3.default)(this, Markets);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Markets.__proto__ || (0, _getPrototypeOf2.default)(Markets)).call(this, 'markets'));

    _this._callback = callback;
    return _this;
  }

  (0, _createClass3.default)(Markets, [{
    key: 'notify',
    value: function notify(obj) {
      if (_bcxjsCores.ChainValidation.is_object_id(obj)) {
        if (obj.search(order_prefix) === 0) {
          this._callback('deleteOrder', obj);
        }
      } else {
        if (obj.id && obj.id.startsWith(history_prefix)) {
          var _obj$op = (0, _slicedToArray3.default)(obj.op, 1),
              type = _obj$op[0];

          if (type === _bcxjsCores.ChainTypes.operations.fill_order) {
            this._callback('fillOrder', obj);
          }
        }

        if (obj.id && obj.id.startsWith(order_prefix)) {
          this._callback('newOrder', obj);
        }
      }
    }
  }]);
  return Markets;
}(Subscription);

var UserOperations = function (_Subscription2) {
  (0, _inherits3.default)(UserOperations, _Subscription2);

  function UserOperations(_ref2) {
    var userId = _ref2.userId,
        callback = _ref2.callback;
    (0, _classCallCheck3.default)(this, UserOperations);

    var _this2 = (0, _possibleConstructorReturn3.default)(this, (UserOperations.__proto__ || (0, _getPrototypeOf2.default)(UserOperations)).call(this, 'userOperation'));

    _this2._userId = userId;
    _this2._callback = callback;

    _this2._operationTypes = {};
    (0, _keys2.default)(_bcxjsCores.ChainTypes.operations).forEach(function (name) {
      var code = _bcxjsCores.ChainTypes.operations[name];
      _this2._operationTypes[code] = name;
    });

    _this2._userFields = {
      transfer: 'from',
      fill_order: 'account_id',
      limit_order_create: 'seller',
      limit_order_cancel: 'fee_paying_account',
      contract_create: 'owner',
      call_contract_function: 'caller',
      transfer_nh_asset: "from",
      create_nh_asset_order: "seller",
      account_update: "account",

      account_create: "registrar",
      vesting_balance_withdraw: "owner",
      asset_create: "issuer",
      asset_update: "issuer",
      asset_issue: "issuer",
      asset_claim_fees: "issuer",
      asset_reserve: "payer",
      asset_fund_fee_pool: "from_account",
      revise_contract: "reviser",
      update_collateral_for_gas: "mortgager"
      //,
      // create_world_view: 'fee_paying_account',
      // register_nh_asset_creator_operation:"fee_paying_account",
      // propose_relate_world_view_operation:"fee_paying_account",
      // create_nh_asset_operation:"fee_paying_account"
    };
    return _this2;
  }

  (0, _createClass3.default)(UserOperations, [{
    key: '_getOperationUserIds',
    value: function _getOperationUserIds(operation) {
      var _operation$op = (0, _slicedToArray3.default)(operation.op, 2),
          typeCode = _operation$op[0],
          payload = _operation$op[1];

      var operationType = this._operationTypes[typeCode];
      var pathToUserId = this._userFields[operationType];
      if (!pathToUserId) pathToUserId = "fee_paying_account";
      var usersIds = [payload[pathToUserId]];
      // if (operationType === 'transfer') usersIds.push(payload.from);
      if (operationType === 'transfer') usersIds.push(payload.to);
      if (operationType === 'transfer_nh_asset') usersIds.push(payload.to);
      if (operationType === 'relate_world_view') usersIds.push(payload.version_owner);
      if (operationType === 'fill_nh_asset_order') usersIds.push(payload.seller);

      if (operationType == "create_nh_asset") usersIds.push(payload.owner);
      if (operationType == "asset_issue") usersIds.push(payload.issue_to_account);
      if (operationType == "proposal_create") usersIds.push(payload.proposed_ops[0].op[1].fee_paying_account);
      if (operationType == "update_collateral_for_gas") usersIds.push(payload.beneficiary);

      return usersIds;
    }
  }, {
    key: 'notify',
    value: function notify(operation) {
      if (operation && operation.op) {
        var _userOperationsCodes = [0, 1, 2, 4, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16, 17, 20, 21, 27, 31, 34, 35, 37, 38, 39, 40, 41, 42, 43, 44, 45, 50, 54, 300, 301, 303, 3010, 3011, 3012];
        var _opCode = operation.op[0];
        if (_userOperationsCodes.indexOf(_opCode) > -1) {
          var usersIds = this._getOperationUserIds(operation);
          if (usersIds.indexOf(this._userId) > -1) {
            this._callback(operation);
          }
        }
      }
    }
  }]);
  return UserOperations;
}(Subscription);

var AllOperations = function (_Subscription3) {
  (0, _inherits3.default)(AllOperations, _Subscription3);

  function AllOperations(_ref3) {
    var callback = _ref3.callback;
    (0, _classCallCheck3.default)(this, AllOperations);

    var _this3 = (0, _possibleConstructorReturn3.default)(this, (AllOperations.__proto__ || (0, _getPrototypeOf2.default)(AllOperations)).call(this, 'allOperation'));

    _this3._callback = callback;
    return _this3;
  }

  (0, _createClass3.default)(AllOperations, [{
    key: 'notify',
    value: function notify(operation) {
      if (operation && operation.op) {
        var _userOperationsCodes = [0, 1, 2, 4, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16, 17, 20, 21, 27, 31, 34, 35, 37, 38, 39, 40, 41, 42, 43, 44, 45, 50, 54, 300, 301, 303, 3010, 3011, 3012];
        var _opCode = operation.op[0];
        if (_userOperationsCodes.indexOf(_opCode) > -1) {
          this._callback(operation);
        }
      }
    }
  }]);
  return AllOperations;
}(Subscription);

var BlocksOp = function (_Subscription4) {
  (0, _inherits3.default)(BlocksOp, _Subscription4);

  function BlocksOp(_ref4) {
    var callback = _ref4.callback,
        isReqTrx = _ref4.isReqTrx;
    (0, _classCallCheck3.default)(this, BlocksOp);

    var _this4 = (0, _possibleConstructorReturn3.default)(this, (BlocksOp.__proto__ || (0, _getPrototypeOf2.default)(BlocksOp)).call(this, 'BlocksOp'));

    _this4._callback = callback;
    _this4.isReqTrx = isReqTrx;
    return _this4;
  }

  (0, _createClass3.default)(BlocksOp, [{
    key: 'notify',
    value: function notify(data) {
      if (arguments.length == 2) {
        this._callback(data, arguments[1]);
      }
    }
  }]);
  return BlocksOp;
}(Subscription);

var Subscriptions = {
  Markets: Markets,
  UserOperations: UserOperations,
  AllOperations: AllOperations,
  BlocksOp: BlocksOp
};

exports.default = Subscriptions;

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _keys = __webpack_require__(24);

var _keys2 = _interopRequireDefault(_keys);

var _utils = __webpack_require__(59);

var _utils2 = _interopRequireDefault(_utils);

var _bcxjsCores = __webpack_require__(7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var object_type = _bcxjsCores.ChainTypes.object_type;

var opTypes = (0, _keys2.default)(object_type);

var MarketUtils = {
    order_type: function order_type(id) {
        if (typeof id !== "string") {
            return false;
        }
        var type = id.split(".")[1];
        return opTypes[type];
    },
    isAsk: function isAsk(order, base) {
        var baseId = base.toJS ? base.get("id") : base.id;
        ;

        if (order.sell_price) {
            return order.sell_price.quote.asset_id === baseId;
        } else if (order.call_price) {
            return order.call_price.quote.asset_id === baseId;
        }
    },
    isAskOp: function isAskOp(op) {
        return op.amount_to_sell.asset_id !== op.fee.asset_id;
    },
    getMarketName: function getMarketName(base, quote) {
        // if (!base || !quote) return {marketName: "_"};
        var baseID = parseInt(base.split(".")[2], 10);
        var quoteID = parseInt(quote.split(".")[2], 10);

        var first = quoteID > baseID ? quote : base;
        var second = quoteID > baseID ? base : quote;

        // const marketName = `${first.get("symbol")}_${second.get("symbol")}`;
        return { baseID: baseID, quoteID: quoteID, first: first, second: second };
    },
    limitByPrecision: function limitByPrecision(value, asset) {
        var floor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

        var assetPrecision = asset.toJS ? asset.get("precision") : asset.precision;
        var valueString = value.toString();
        var splitString = valueString.split(".");
        if (splitString.length === 1 || splitString.length === 2 && splitString[1].length <= assetPrecision) {
            return value;
        }
        var precision = _utils2.default.get_asset_precision(assetPrecision);
        value = floor ? Math.floor(value * precision) / precision : Math.round(value * precision) / precision;
        if (isNaN(value) || !isFinite(value)) {
            return 0;
        }
        return value;
    },
    getFeedPrice: function getFeedPrice(settlement_price) {
        var invert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        var quoteAsset = _bcxjsCores.ChainStore.getAsset(settlement_price.getIn(["quote", "asset_id"]));
        var baseAsset = _bcxjsCores.ChainStore.getAsset(settlement_price.getIn(["base", "asset_id"]));

        var price = _utils2.default.get_asset_price(settlement_price.getIn(["quote", "amount"]), quoteAsset, settlement_price.getIn(["base", "amount"]), baseAsset);

        if (invert) {
            return 1 / price;
        } else {
            return price;
        }
    },
    parseOrder: function parseOrder(order, base, quote) {
        var invert = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

        var ask = this.isAsk(order, base);

        var quotePrecision = _utils2.default.get_asset_precision(quote.toJS ? quote.get("precision") : quote.precision);
        var basePrecision = _utils2.default.get_asset_precision(base.toJS ? base.get("precision") : base.precision);
        var pricePrecision = order.call_price ? quote.toJS ? quote.get("precision") : quote.precision : base.toJS ? base.get("precision") : base.precision;

        var buy = void 0,
            sell = void 0;
        var callPrice = void 0;
        if (order.sell_price) {
            buy = ask ? order.sell_price.base : order.sell_price.quote;
            sell = ask ? order.sell_price.quote : order.sell_price.base;
        } else if (order.call_price) {
            buy = order.call_price.base;
            sell = order.call_price.quote;
            var marginPrice = buy.amount / basePrecision / (sell.amount / quotePrecision);
            if (!invert) {
                callPrice = marginPrice;
            } else {
                callPrice = 1 / marginPrice;
            }
        }

        if (typeof sell.amount !== "number") {
            sell.amount = parseInt(sell.amount, 10);
        }

        if (typeof buy.amount !== "number") {
            buy.amount = parseInt(buy.amount, 10);
        }
        var fullPrice = callPrice ? callPrice : sell.amount / basePrecision / (buy.amount / quotePrecision);
        var price = _utils2.default.price_to_text(fullPrice, order.call_price ? base : quote, order.call_price ? quote : base);

        var amount = void 0,
            value = void 0;

        // We need to figure out a better way to set the number of decimals
        // United Labs of BCTech.
        // let price_split = utils.format_number(price.full, Math.max(5, pricePrecision)).split(".");
        // price.int = price_split[0];
        // price.dec = price_split[1];

        if (order.debt) {
            if (invert) {
                // Price in USD/GPH, amount should be in GPH, value should be in USD, debt is in USD
                // buy is in USD, sell is in GPH
                // quote is USD, base is GPH
                value = order.debt / quotePrecision;
                amount = this.limitByPrecision(value / price.full, base);
            } else {
                // Price in GPH/USD, amount should be in USD, value should be in GPH, debt is in USD
                // buy is in USD, sell is in GPH
                // quote is USD, base is GPH

                amount = this.limitByPrecision(order.debt / quotePrecision, quote);
                value = price.full * amount;
            }
        } else if (!ask) {
            amount = this.limitByPrecision(buy.amount / sell.amount * order.for_sale / quotePrecision, quote);
            value = order.for_sale / basePrecision;
        } else {
            amount = this.limitByPrecision(order.for_sale / quotePrecision, quote);
            value = price.full * amount;
        }

        value = this.limitByPrecision(value, base);

        if (!ask && order.for_sale) {
            value = this.limitByPrecision(price.full * amount, base);
        }

        return {
            value: value,
            price: price,
            amount: amount
        };
    },
    parse_order_history: function parse_order_history(order, paysAsset, receivesAsset, isAsk, flipped) {
        var isCall = order.order_id.split(".")[1] == object_type.limit_order ? false : true;
        var receivePrecision = _utils2.default.get_asset_precision(receivesAsset.get("precision"));
        var payPrecision = _utils2.default.get_asset_precision(paysAsset.get("precision"));

        var receives = order.receives.amount / receivePrecision;
        receives = _utils2.default.format_number(receives, receivesAsset.get("precision"));
        var pays = order.pays.amount / payPrecision;
        pays = _utils2.default.format_number(pays, paysAsset.get("precision"));
        var price_full = _utils2.default.get_asset_price(order.receives.amount, receivesAsset, order.pays.amount, paysAsset, isAsk);
        // price_full = !flipped ? (1 / price_full) : price_full;
        // let {int, dec} = this.split_price(price_full, isAsk ? receivesAsset.get("precision") : paysAsset.get("precision"));

        var _utils$price_to_text = _utils2.default.price_to_text(price_full, isAsk ? receivesAsset : paysAsset, isAsk ? paysAsset : receivesAsset),
            int = _utils$price_to_text.int,
            dec = _utils$price_to_text.dec,
            trailing = _utils$price_to_text.trailing;

        var className = isCall ? "orderHistoryCall" : isAsk ? "orderHistoryBid" : "orderHistoryAsk";

        var time = void 0;
        if (order.time) {
            time = order.time.split("T")[1];
            var now = new Date();
            var offset = now.getTimezoneOffset() / 60;
            var date = _utils2.default.format_date(order.time + "Z").split(/\W/);
            var hour = time.substr(0, 2);
            var hourNumber = parseInt(hour, 10);
            var localHour = hourNumber - offset;
            if (localHour >= 24) {
                localHour -= 24;
            } else if (localHour < 0) {
                localHour += 24;
            }
            var hourString = localHour.toString();
            if (parseInt(hourString, 10) < 10) {
                hourString = "0" + hourString;
            }
            time = date[0] + "/" + date[1] + "/" + date[2] + " " + time.replace(hour, hourString);
        }
        return {
            receives: isAsk ? receives : pays,
            pays: isAsk ? pays : receives,
            full: price_full,
            int: int,
            dec: dec,
            trailing: trailing,
            className: className,
            time: time
        };
    },
    split_price: function split_price(price, pricePrecision) {
        // We need to figure out a better way to set the number of decimals
        var price_split = _utils2.default.format_number(price, Math.max(5, pricePrecision)).split(".");
        var int = price_split[0];
        var dec = price_split[1];
        return { int: int, dec: dec };
    },


    // flatten_orderbookchart(array, sumBoolean, inverse, precision) {
    //     inverse = inverse === undefined ? false : inverse;
    //     let orderBookArray = [];
    //     let maxStep, arrayLength = array.length;
    //     // United Labs of BCTech.
    //     // Sum orders at same price
    //     // if (arrayLength > 1) {
    //     //     for (var i = arrayLength - 2; i >= 0; i--) {
    //     //         if (array[i].x === array[i + 1].x) {
    //     //             console.log("found order to sum");
    //     //             array[i].y += array[i + 1].y;
    //     //             array.splice(i + 1, 1);
    //     //         }
    //     //     }
    //     // }
    //     // arrayLength = array.length;

    //     if (inverse) {

    //         if (array && arrayLength) {
    //             arrayLength = arrayLength - 1;
    //             orderBookArray.unshift({
    //                 x: array[arrayLength].x,
    //                 y: array[arrayLength].y
    //             });
    //             if (array.length > 1) {
    //                 for (let i = array.length - 2; i >= 0; i--) {
    //                     // maxStep = Math.min((array[i + 1].x - array[i].x) / 2, 0.1 / precision);
    //                     orderBookArray.unshift({
    //                         x: array[i].x + maxStep,
    //                         y: array[i + 1].y
    //                     });
    //                     if (sumBoolean) {
    //                         array[i].y += array[i + 1].y;
    //                     }
    //                     orderBookArray.unshift({
    //                         x: array[i].x,
    //                         y: array[i].y
    //                     });
    //                 }
    //             } else {
    //                 orderBookArray.unshift({
    //                     x: 0,
    //                     y: array[arrayLength].y
    //                 });
    //             }
    //         }
    //     } else {
    //         if (array && arrayLength) {
    //             orderBookArray.push({
    //                 x: array[0].x,
    //                 y: array[0].y
    //             });
    //             if (array.length > 1) {
    //                 for (let i = 1; i < array.length; i++) {
    //                     // maxStep = Math.min((array[i].x - array[i - 1].x) / 2, 0.1 / precision);
    //                     orderBookArray.push({
    //                         x: array[i].x - maxStep,
    //                         y: array[i - 1].y
    //                     });
    //                     if (sumBoolean) {
    //                         array[i].y += array[i - 1].y;
    //                     }
    //                     orderBookArray.push({
    //                         x: array[i].x,
    //                         y: array[i].y
    //                     });
    //                 }
    //             } else {
    //                 orderBookArray.push({
    //                     x: array[0].x * 1.5,
    //                     y: array[0].y
    //                 });
    //             }
    //         }
    //     }
    //     return orderBookArray;
    // }

    flatten_orderbookchart_highcharts: function flatten_orderbookchart_highcharts(array, sumBoolean, inverse, precision) {
        inverse = inverse === undefined ? false : inverse;
        var orderBookArray = [];
        var arrayLength = void 0;

        if (inverse) {

            if (array && array.length) {
                arrayLength = array.length - 1;
                orderBookArray.unshift([array[arrayLength][0], array[arrayLength][1]]);
                if (array.length > 1) {
                    for (var _i = array.length - 2; _i >= 0; _i--) {
                        if (sumBoolean) {
                            array[_i][1] += array[_i + 1][1];
                        }
                        orderBookArray.unshift([array[_i][0], array[_i][1]]);
                    }
                } else {
                    orderBookArray.unshift([0, array[arrayLength][1]]);
                }
            }
        } else {
            if (array && array.length) {
                orderBookArray.push([array[0][0], array[0][1]]);
                if (array.length > 1) {
                    for (var i = 1; i < array.length; i++) {
                        if (sumBoolean) {
                            array[i][1] += array[i - 1][1];
                        }
                        orderBookArray.push([array[i][0], array[i][1]]);
                    }
                } else {
                    orderBookArray.push([array[0][0] * 1.5, array[0][1]]);
                }
            }
        }
        return orderBookArray;
    },
    priceToObject: function priceToObject(x, type) {
        var tolerance = 1.0E-8;
        var h1 = 1;
        var h2 = 0;
        var k1 = 0;
        var k2 = 1;
        var b = x;
        do {
            var a = Math.floor(b);
            var aux = h1;
            h1 = a * h1 + h2;
            h2 = aux;
            aux = k1;
            k1 = a * k1 + k2;
            k2 = aux;
            b = 1 / (b - a);
        } while (Math.abs(x - h1 / k1) > x * tolerance);

        if (type === "ask") {
            return { base: h1, quote: k1 };
        } else if (type === "bid") {
            return { quote: h1, base: k1 };
        } else {
            throw "Unknown type";
        }
    },
    isMarketAsset: function isMarketAsset(quote, base) {
        var isMarketAsset = false,
            marketAsset = void 0,
            inverted = false;

        if (quote.get("bitasset") && base.get("id") === quote.getIn(["bitasset", "options", "short_backing_asset"])) {
            isMarketAsset = true;
            marketAsset = { id: quote.get("id") };
        } else if (base.get("bitasset") && quote.get("id") === base.getIn(["bitasset", "options", "short_backing_asset"])) {
            inverted = true;
            isMarketAsset = true;
            marketAsset = { id: base.get("id") };
        }

        return {
            isMarketAsset: isMarketAsset,
            marketAsset: marketAsset,
            inverted: inverted
        };
    }
};

exports.default = MarketUtils;

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.generateKeyFromPassword = undefined;

var _bcxjsCores = __webpack_require__(7);

var generateKeyFromPassword = exports.generateKeyFromPassword = function generateKeyFromPassword(accountName, role, password) {
    var seed = accountName + role + password;
    var privKey = _bcxjsCores.PrivateKey.fromSeed(seed);
    var pubKey = privKey.toPublicKey().toString();

    return { privKey: privKey, pubKey: pubKey };
};

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

var irreducible = __webpack_require__(40);

module.exports = irreducible('Any', function () { return true; });


/***/ }),
/* 229 */
/***/ (function(module, exports) {

module.exports = function isNumber(x) {
  return typeof x === 'number' && isFinite(x) && !isNaN(x);
};

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

var assert = __webpack_require__(20);
var isTypeName = __webpack_require__(46);
var isFunction = __webpack_require__(36);
var forbidNewOperator = __webpack_require__(133);
var isIdentity = __webpack_require__(63);
var create = __webpack_require__(64);
var is = __webpack_require__(65);
var getTypeName = __webpack_require__(35);
var getFunctionName = __webpack_require__(132);

function getDefaultName(type, predicate) {
  return '{' + getTypeName(type) + ' | ' + getFunctionName(predicate) + '}';
}

function refinement(type, predicate, name) {

  if (true) {
    assert(isFunction(type), function () { return 'Invalid argument type ' + assert.stringify(type) + ' supplied to refinement(type, predicate, [name]) combinator (expected a type)'; });
    assert(isFunction(predicate), function () { return 'Invalid argument predicate supplied to refinement(type, predicate, [name]) combinator (expected a function)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to refinement(type, predicate, [name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(type, predicate);
  var identity = isIdentity(type);

  function Refinement(value, path) {

    if (true) {
      if (identity) {
        forbidNewOperator(this, Refinement);
      }
      path = path || [displayName];
    }

    var x = create(type, value, path);

    if (true) {
      assert(predicate(x), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
    }

    return x;
  }

  Refinement.meta = {
    kind: 'subtype',
    type: type,
    predicate: predicate,
    name: name,
    identity: identity
  };

  Refinement.displayName = displayName;

  Refinement.is = function (x) {
    return is(x, type) && predicate(x);
  };

  Refinement.update = function (instance, patch) {
    return Refinement(assert.update(instance, patch));
  };

  return Refinement;
}

refinement.getDefaultName = getDefaultName;
module.exports = refinement;


/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

var irreducible = __webpack_require__(40);
var isString = __webpack_require__(151);

module.exports = irreducible('String', isString);


/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

var assert = __webpack_require__(20);
var isTypeName = __webpack_require__(46);
var isFunction = __webpack_require__(36);
var getTypeName = __webpack_require__(35);
var isIdentity = __webpack_require__(63);
var isObject = __webpack_require__(61);
var create = __webpack_require__(64);
var is = __webpack_require__(65);

function getDefaultName(domain, codomain) {
  return '{[key: ' + getTypeName(domain) + ']: ' + getTypeName(codomain) + '}';
}

function dict(domain, codomain, name) {

  if (true) {
    assert(isFunction(domain), function () { return 'Invalid argument domain ' + assert.stringify(domain) + ' supplied to dict(domain, codomain, [name]) combinator (expected a type)'; });
    assert(isFunction(codomain), function () { return 'Invalid argument codomain ' + assert.stringify(codomain) + ' supplied to dict(domain, codomain, [name]) combinator (expected a type)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to dict(domain, codomain, [name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(domain, codomain);
  var domainNameCache = getTypeName(domain);
  var codomainNameCache = getTypeName(codomain);
  var identity = isIdentity(domain) && isIdentity(codomain);

  function Dict(value, path) {

    if (false) {
      if (identity) {
        return value; // just trust the input if elements must not be hydrated
      }
    }

    if (true) {
      path = path || [displayName];
      assert(isObject(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
    }

    var idempotent = true; // will remain true if I can reutilise the input
    var ret = {}; // make a temporary copy, will be discarded if idempotent remains true
    for (var k in value) {
      if (value.hasOwnProperty(k)) {
        k = create(domain, k, (  true ? path.concat(domainNameCache) : null ));
        var actual = value[k];
        var instance = create(codomain, actual, (  true ? path.concat(k + ': ' + codomainNameCache) : null ));
        idempotent = idempotent && ( actual === instance );
        ret[k] = instance;
      }
    }

    if (idempotent) { // implements idempotency
      ret = value;
    }

    if (true) {
      Object.freeze(ret);
    }

    return ret;
  }

  Dict.meta = {
    kind: 'dict',
    domain: domain,
    codomain: codomain,
    name: name,
    identity: identity
  };

  Dict.displayName = displayName;

  Dict.is = function (x) {
    if (!isObject(x)) {
      return false;
    }
    for (var k in x) {
      if (x.hasOwnProperty(k)) {
        if (!is(k, domain) || !is(x[k], codomain)) {
          return false;
        }
      }
    }
    return true;
  };

  Dict.update = function (instance, patch) {
    return Dict(assert.update(instance, patch));
  };

  return Dict;
}

dict.getDefaultName = getDefaultName;
module.exports = dict;


/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

var isNil = __webpack_require__(53);
var assert = __webpack_require__(20);

// safe mixin, cannot override props unless specified
module.exports = function mixin(target, source, overwrite) {
  if (isNil(source)) { return target; }
  for (var k in source) {
    if (source.hasOwnProperty(k)) {
      if (overwrite !== true) {
        if (true) {
          assert(!target.hasOwnProperty(k) || target[k] === source[k], function () { return 'Invalid call to mixin(target, source, [overwrite]): cannot overwrite property "' + k + '" of target object'; });
        }
      }
      target[k] = source[k];
    }
  }
  return target;
};

/***/ }),
/* 234 */,
/* 235 */,
/* 236 */,
/* 237 */,
/* 238 */,
/* 239 */,
/* 240 */,
/* 241 */,
/* 242 */,
/* 243 */,
/* 244 */,
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(530), __esModule: true };

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__(41);
var IObject = __webpack_require__(137);
var toObject = __webpack_require__(51);
var toLength = __webpack_require__(95);
var asc = __webpack_require__(533);
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};


/***/ }),
/* 247 */,
/* 248 */,
/* 249 */,
/* 250 */,
/* 251 */,
/* 252 */,
/* 253 */,
/* 254 */,
/* 255 */,
/* 256 */,
/* 257 */,
/* 258 */,
/* 259 */,
/* 260 */,
/* 261 */,
/* 262 */,
/* 263 */,
/* 264 */,
/* 265 */,
/* 266 */,
/* 267 */,
/* 268 */,
/* 269 */,
/* 270 */,
/* 271 */,
/* 272 */,
/* 273 */,
/* 274 */,
/* 275 */,
/* 276 */,
/* 277 */,
/* 278 */,
/* 279 */,
/* 280 */,
/* 281 */,
/* 282 */,
/* 283 */,
/* 284 */,
/* 285 */,
/* 286 */,
/* 287 */,
/* 288 */,
/* 289 */,
/* 290 */,
/* 291 */,
/* 292 */,
/* 293 */,
/* 294 */,
/* 295 */,
/* 296 */,
/* 297 */,
/* 298 */,
/* 299 */,
/* 300 */,
/* 301 */,
/* 302 */,
/* 303 */,
/* 304 */,
/* 305 */,
/* 306 */,
/* 307 */,
/* 308 */,
/* 309 */,
/* 310 */,
/* 311 */,
/* 312 */,
/* 313 */,
/* 314 */,
/* 315 */,
/* 316 */,
/* 317 */,
/* 318 */,
/* 319 */,
/* 320 */,
/* 321 */,
/* 322 */,
/* 323 */,
/* 324 */,
/* 325 */,
/* 326 */,
/* 327 */,
/* 328 */,
/* 329 */,
/* 330 */,
/* 331 */,
/* 332 */,
/* 333 */,
/* 334 */,
/* 335 */,
/* 336 */,
/* 337 */,
/* 338 */,
/* 339 */,
/* 340 */,
/* 341 */,
/* 342 */,
/* 343 */,
/* 344 */,
/* 345 */,
/* 346 */,
/* 347 */,
/* 348 */,
/* 349 */,
/* 350 */,
/* 351 */,
/* 352 */,
/* 353 */,
/* 354 */,
/* 355 */,
/* 356 */,
/* 357 */,
/* 358 */,
/* 359 */,
/* 360 */,
/* 361 */,
/* 362 */,
/* 363 */,
/* 364 */,
/* 365 */,
/* 366 */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(16);
var core = __webpack_require__(6);
var fails = __webpack_require__(47);
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),
/* 367 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _promise = __webpack_require__(4);

var _promise2 = _interopRequireDefault(_promise);

var _regenerator = __webpack_require__(3);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _bcxjsWs = __webpack_require__(8);

var _utils = __webpack_require__(96);

var utils = _interopRequireWildcard(_utils);

var _bcxjsCores = __webpack_require__(7);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inProgress = {};
var _assets = {};
/**
 * Fetches array of assets from bcxjs-ws
 */
var fetch = function _callee(assets) {
    var cacheAndOne = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var result;
    return _regenerator2.default.async(function _callee$(_context) {
        while (1) {
            switch (_context.prev = _context.next) {
                case 0:
                    if (!(!assets || !assets[0])) {
                        _context.next = 2;
                        break;
                    }

                    return _context.abrupt('return', null);

                case 2:
                    if (!cacheAndOne) {
                        _context.next = 8;
                        break;
                    }

                    if (!_assets[assets[0]]) {
                        _context.next = 7;
                        break;
                    }

                    return _context.abrupt('return', _assets[assets[0]]);

                case 7:
                    _assets[assets[0]] = { precision: 5, symbol: assets[0] };

                case 8:
                    _context.prev = 8;
                    _context.next = 11;
                    return _regenerator2.default.awrap(_bcxjsWs.Apis.instance().db_api().exec('lookup_asset_symbols', [assets]));

                case 11:
                    result = _context.sent;

                    result = result.filter(function (item) {
                        return item != null;
                    });

                    if (!cacheAndOne) {
                        _context.next = 18;
                        break;
                    }

                    if (!result.length) {
                        _context.next = 17;
                        break;
                    }

                    _assets[result[0].id] = result[0];
                    return _context.abrupt('return', result[0]);

                case 17:
                    return _context.abrupt('return', null);

                case 18:
                    return _context.abrupt('return', result);

                case 21:
                    _context.prev = 21;
                    _context.t0 = _context['catch'](8);

                    console.log(_context.t0);
                    return _context.abrupt('return', null);

                case 25:
                case 'end':
                    return _context.stop();
            }
        }
    }, null, undefined, [[8, 21]]);
};

var fetch_asset_one = function _callee2(asset_id) {
    var result;
    return _regenerator2.default.async(function _callee2$(_context2) {
        while (1) {
            switch (_context2.prev = _context2.next) {
                case 0:
                    if (!_assets[asset_id]) {
                        _context2.next = 2;
                        break;
                    }

                    return _context2.abrupt('return', { code: 1, data: _assets[asset_id] });

                case 2:
                    _context2.prev = 2;
                    _context2.next = 5;
                    return _regenerator2.default.awrap(_bcxjsWs.Apis.instance().db_api().exec('lookup_asset_symbols', [[asset_id]]));

                case 5:
                    result = _context2.sent;

                    if (result[0]) {
                        _context2.next = 8;
                        break;
                    }

                    return _context2.abrupt('return', { code: 115, message: "There is no asset " + asset_id + " on block chain", error: "There is no asset " + asset_id + " on block chain" });

                case 8:
                    _assets[result[0].id] = result[0];
                    return _context2.abrupt('return', { code: 1, data: result[0] });

                case 12:
                    _context2.prev = 12;
                    _context2.t0 = _context2['catch'](2);

                    console.log(_context2.t0);
                    return _context2.abrupt('return', null);

                case 16:
                case 'end':
                    return _context2.stop();
            }
        }
    }, null, undefined, [[2, 12]]);
};

var fetch_asset_by_cache = function fetch_asset_by_cache(asset_id) {
    return _assets[asset_id];
};

var fetch_all_assets = function fetch_all_assets() {
    return _assets;
};
/**
 * Returns prices bistory between base and quote assets from the last specified number of days
 * @param {Object} base - base asset object
 * @param {Object} quote - quote asset object
 * @param {number} days - number of days
 */
var fetchPriceHistory = function _callee3(base, quote, days) {
    var bucketSize, endDate, startDate, endDateISO, startDateISO, history, prices;
    return _regenerator2.default.async(function _callee3$(_context3) {
        while (1) {
            switch (_context3.prev = _context3.next) {
                case 0:
                    _context3.prev = 0;
                    bucketSize = 3600 * 24;
                    endDate = new Date();
                    startDate = new Date(endDate - 1000 * 60 * 60 * 24 * days);
                    endDateISO = endDate.toISOString().slice(0, -5);
                    startDateISO = startDate.toISOString().slice(0, -5);


                    endDate.setDate(endDate.getDate() + 1);
                    _context3.next = 9;
                    return _regenerator2.default.awrap(_bcxjsWs.Apis.instance().history_api().exec('get_market_history', [base.id, quote.id, bucketSize, startDateISO, endDateISO]));

                case 9:
                    history = _context3.sent;
                    prices = utils.formatPrices(utils.getPrices(history), base, quote);
                    _context3.t0 = history;
                    _context3.next = 14;
                    return _regenerator2.default.awrap(_bcxjsWs.Apis.instance().history_api().exec("get_fill_order_history", [base.id, quote.id, 1]));

                case 14:
                    _context3.t1 = _context3.sent;
                    return _context3.abrupt('return', [_context3.t0, _context3.t1]);

                case 18:
                    _context3.prev = 18;
                    _context3.t2 = _context3['catch'](0);

                    console.log(_context3.t2);
                    return _context3.abrupt('return', null);

                case 22:
                case 'end':
                    return _context3.stop();
            }
        }
    }, null, undefined, [[0, 18]]);
};

var getAssetList = function getAssetList(start, count) {
    var id = start + "_" + count;
    if (!inProgress[id]) {
        inProgress[id] = true;
        return _bcxjsWs.Apis.instance().db_api().exec("list_assets", [start, count]).then(function (assets) {
            var bitAssetIDS = [];
            var dynamicIDS = [];

            assets.forEach(function (asset) {
                _bcxjsCores.ChainStore._updateObject(asset, false);
                dynamicIDS.push(asset.dynamic_asset_data_id);

                if (asset.bitasset_data_id) {
                    bitAssetIDS.push(asset.bitasset_data_id);
                }
            });

            var dynamicPromise = _bcxjsWs.Apis.instance().db_api().exec("get_objects", [dynamicIDS]);

            var bitAssetPromise = bitAssetIDS.length > 0 ? _bcxjsWs.Apis.instance().db_api().exec("get_objects", [bitAssetIDS]) : null;

            return _promise2.default.all([dynamicPromise, bitAssetPromise]).then(function (results) {
                delete inProgress[id];
                //   console.info("dispatch assets",{
                //       assets: assets,
                //       dynamic: results[0],
                //       bitasset_data: results[1],
                //       loading: false
                //   })
                return {
                    assets: assets,
                    dynamic: results[0],
                    bitasset_data: results[1]
                    //loading: false

                    //return assets && assets.length;
                };
            });
        }).catch(function (error) {
            console.log("Error in AssetActions.getAssetList: ", error);
            delete inProgress[id];
            return { code: 161, message: "Error in AssetActions.getAssetList", error: error };
        });
    }
};

var list_asset_restricted_objects = function _callee4(asset_id, restricted_type) {
    var response;
    return _regenerator2.default.async(function _callee4$(_context4) {
        while (1) {
            switch (_context4.prev = _context4.next) {
                case 0:
                    _context4.prev = 0;
                    _context4.next = 3;
                    return _regenerator2.default.awrap(_bcxjsWs.Apis.instance().db_api().exec('list_asset_restricted_objects', [asset_id, restricted_type]));

                case 3:
                    response = _context4.sent;

                    if (!response) {
                        _context4.next = 6;
                        break;
                    }

                    return _context4.abrupt('return', { code: 1, data: response });

                case 6:
                    return _context4.abrupt('return', {
                        code: 104,
                        message: 'not found'
                    });

                case 9:
                    _context4.prev = 9;
                    _context4.t0 = _context4['catch'](0);
                    return _context4.abrupt('return', {
                        code: 0,
                        message: _context4.t0.message,
                        error: _context4.t0
                    });

                case 12:
                case 'end':
                    return _context4.stop();
            }
        }
    }, null, undefined, [[0, 9]]);
};

var estimation_gas = function _callee5(amountObj) {
    var response;
    return _regenerator2.default.async(function _callee5$(_context5) {
        while (1) {
            switch (_context5.prev = _context5.next) {
                case 0:
                    _context5.prev = 0;
                    _context5.next = 3;
                    return _regenerator2.default.awrap(_bcxjsWs.Apis.instance().db_api().exec('estimation_gas', [amountObj]));

                case 3:
                    response = _context5.sent;

                    if (!response) {
                        _context5.next = 6;
                        break;
                    }

                    return _context5.abrupt('return', { code: 1, data: response });

                case 6:
                    return _context5.abrupt('return', {
                        code: 104,
                        message: 'not found'
                    });

                case 9:
                    _context5.prev = 9;
                    _context5.t0 = _context5['catch'](0);
                    return _context5.abrupt('return', {
                        code: 0,
                        message: _context5.t0.message,
                        error: _context5.t0
                    });

                case 12:
                case 'end':
                    return _context5.stop();
            }
        }
    }, null, undefined, [[0, 9]]);
};
exports.default = {
    fetch: fetch,
    fetch_asset_one: fetch_asset_one,
    fetch_asset_by_cache: fetch_asset_by_cache,
    fetch_all_assets: fetch_all_assets,
    list_asset_restricted_objects: list_asset_restricted_objects,
    fetchPriceHistory: fetchPriceHistory,
    getAssetList: getAssetList,
    estimation_gas: estimation_gas
};

/***/ }),
/* 368 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _ChainWebSocket = __webpack_require__(369);

var _ChainWebSocket2 = _interopRequireDefault(_ChainWebSocket);

var _GrapheneApi = __webpack_require__(443);

var _GrapheneApi2 = _interopRequireDefault(_GrapheneApi);

var _ChainConfig = __webpack_require__(370);

var _ChainConfig2 = _interopRequireDefault(_ChainConfig);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } // var { List } = require("immutable");


// if (global) {
//      global.inst = "";
// } else {
//     var _inst = void 0;
// };
//let inst="";
var inst="";
var autoReconnect = false; // by default don't use reconnecting-websocket
/**
    Configure: configure as follows `Apis.instance("ws://localhost:8090").init_promise`.  This returns a promise, once resolved the connection is ready.

    Import: import { Apis } from "@graphene/chain"

    Short-hand: Apis.db.method("parm1", 2, 3, ...).  Returns a promise with results.

    Additional usage: Apis.instance().db_api().exec("method", ["method", "parm1", 2, 3, ...]).  Returns a promise with results.
*/

var Apis = function () {
    function Apis() {
        _classCallCheck(this, Apis);
    }

    Apis.setRpcConnectionStatusCallback = function setRpcConnectionStatusCallback(callback) {
        this.statusCb = callback;
        if (inst) inst.setRpcConnectionStatusCallback(callback);
    };

    /**
        @arg {boolean} auto means automatic reconnect if possible( browser case), default true
    */


    Apis.setAutoReconnect = function setAutoReconnect(auto) {
        autoReconnect = auto;
    };

    /**
        @arg {string} cs is only provided in the first call
        @return {Apis} singleton .. Check Apis.instance().init_promise to know when the connection is established
    */


    Apis.reset = function reset() {
        var cs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "ws://localhost:8090";
        var connect = arguments[1];
        var connectTimeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4000;

        var _this = this;

        var optionalApis = arguments[3];
        var closeCb = arguments[4];

        return this.close().then(function () {
            inst = new Apis();
            inst.setRpcConnectionStatusCallback(_this.statusCb);

            if (inst && connect) {
                inst.connect(cs, connectTimeout, optionalApis, closeCb);
            }

            return inst;
        });
    };

    Apis.instance = function instance() {
        var cs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "ws://localhost:8090";
        var connect = arguments[1];
        var connectTimeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4000;
        var optionalApis = arguments[3];
        var closeCb = arguments[4];
        if (!inst) {
            inst = new Apis();
            inst.setRpcConnectionStatusCallback(this.statusCb);
        }

        if (inst && connect) {
            inst.connect(cs, connectTimeout, optionalApis);
        }
        if (closeCb) inst.closeCb = closeCb;

        return inst;
    };

    Apis.chainId = function chainId() {
        return this.instance().chain_id;
    };

    Apis.close = function close() {
        if (inst) {
            return new Promise(function (res) {
                inst.close().then(function () {
                    inst = null;
                    res();
                });
            });
        }

        return Promise.resolve();
    };
    // db: (method, ...args) => Apis.instance().db_api().exec(method, toStrings(args)),
    // network: (method, ...args) => Apis.instance().network_api().exec(method, toStrings(args)),
    // history: (method, ...args) => Apis.instance().history_api().exec(method, toStrings(args)),
    // crypto: (method, ...args) => Apis.instance().crypto_api().exec(method, toStrings(args))
    // orders: (method, ...args) => Apis.instance().orders_api().exec(method, toStrings(args))


    /** @arg {string} connection .. */
    Apis.prototype.connect = function connect(cs, connectTimeout) {
        var _this2 = this;

        var optionalApis = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { enableCrypto: false, enableOrders: false };

        // console.log("INFO\tApiInstances\tconnect\t", cs);
        this.url = cs;
        var rpc_user = "",
            rpc_password = "";
        if (typeof window !== "undefined" && window.location && window.location.protocol === "https:" && cs.indexOf("wss://") < 0) {
            throw new Error("Secure domains require wss connection");
        }

        if (this.ws_rpc) {
            this.ws_rpc.statusCb = null;
            this.ws_rpc.keepAliveCb = null;
            this.ws_rpc.on_close = null;
            this.ws_rpc.on_reconnect = null;
        }
        this.ws_rpc = new _ChainWebSocket2.default(cs, this.statusCb, connectTimeout, autoReconnect, function (closed) {
            if (_this2._db && !closed) {
                _this2._db.exec('get_objects', [['2.1.0']]).catch(function (e) {});
            }
        });

        this.init_promise = this.ws_rpc.login(rpc_user, rpc_password).then(function () {
            //console.log("Connected to API node:", cs);
            _this2._db = new _GrapheneApi2.default(_this2.ws_rpc, "database");
            _this2._net = new _GrapheneApi2.default(_this2.ws_rpc, "network_broadcast");
            _this2._hist = new _GrapheneApi2.default(_this2.ws_rpc, "history");
            if (optionalApis.enableOrders) _this2._orders = new _GrapheneApi2.default(_this2.ws_rpc, "orders");
            if (optionalApis.enableCrypto) _this2._crypt = new _GrapheneApi2.default(_this2.ws_rpc, "crypto");
            var db_promise = _this2._db.init().then(function () {
                //https://github.com/cryptonomex/graphene/wiki/chain-locked-tx
                return _this2._db.exec("get_chain_id", []).then(function (_chain_id) {
                    _this2.chain_id = _chain_id;
                    return _ChainConfig2.default.setChainId(_chain_id);
                    //DEBUG console.log("chain_id1",this.chain_id)
                });
            });
            _this2.ws_rpc.on_reconnect = function () {
                if (!_this2.ws_rpc) return;
                _this2.ws_rpc.login("", "").then(function () {
                    _this2._db.init().then(function () {
                        if (_this2.statusCb) _this2.statusCb("reconnect");
                    });
                    _this2._net.init();
                    _this2._hist.init();
                    if (optionalApis.enableOrders) _this2._orders.init();
                    if (optionalApis.enableCrypto) _this2._crypt.init();
                });
            };
            _this2.ws_rpc.on_close = function () {
                _this2.close().then(function () {
                    if (_this2.closeCb) _this2.closeCb();
                });
            };
            var initPromises = [db_promise, _this2._net.init(), _this2._hist.init()];

            if (optionalApis.enableOrders) initPromises.push(_this2._orders.init());
            if (optionalApis.enableCrypto) initPromises.push(_this2._crypt.init());
            return Promise.all(initPromises);
        }).catch(function (err) {
            console.error(cs, "Failed to initialize with error", err && err.message);
            return _this2.close().then(function () {
                throw err;
            });
        });
    };

    Apis.prototype.close = function close() {
        var _this3 = this;

        if (this.ws_rpc && this.ws_rpc.ws.readyState === 1) {
            return this.ws_rpc.close().then(function () {
                _this3.ws_rpc = null;
            });
        };
        this.ws_rpc = null;
        return Promise.resolve();
    };

    Apis.prototype.db_api = function db_api() {
        return this._db;
    };

    Apis.prototype.network_api = function network_api() {
        return this._net;
    };

    Apis.prototype.history_api = function history_api() {
        return this._hist;
    };

    Apis.prototype.crypto_api = function crypto_api() {
        return this._crypt;
    };

    Apis.prototype.orders_api = function orders_api() {
        return this._orders;
    };

    Apis.prototype.setRpcConnectionStatusCallback = function setRpcConnectionStatusCallback(callback) {
        this.statusCb = callback;
    };
    return Apis;
}();

Apis.db = new Proxy(Apis, {
    get: function get(apis, method) {
        return function () {
            return apis.instance().db_api().exec(method, [].concat(Array.prototype.slice.call(arguments)));
        };
    }
});
Apis.network = new Proxy(Apis, {
    get: function get(apis, method) {
        return function () {
            return apis.instance().network_api().exec(method, [].concat(Array.prototype.slice.call(arguments)));
        };
    }
});
Apis.history = new Proxy(Apis, {
    get: function get(apis, method) {
        return function () {
            return apis.instance().history_api().exec(method, [].concat(Array.prototype.slice.call(arguments)));
        };
    }
});
Apis.crypto = new Proxy(Apis, {
    get: function get(apis, method) {
        return function () {
            return apis.instance().crypto_api().exec(method, [].concat(Array.prototype.slice.call(arguments)));
        };
    }
});
Apis.orders = new Proxy(Apis, {
    get: function get(apis, method) {
        return function () {
            return apis.instance().orders_api().exec(method, [].concat(Array.prototype.slice.call(arguments)));
        };
    }
});


exports.default = Apis;
module.exports = exports["default"];

/***/ }),
/* 369 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var WebSocketClient = void 0;
if (typeof WebSocket === "undefined" && !process.env.browser) {
    WebSocketClient = __webpack_require__(442);
} else {
    WebSocketClient = WebSocket;
}

var SOCKET_DEBUG = false;

function getWebSocketClient(autoReconnect) {
    if (!autoReconnect && typeof WebSocket !== "undefined" && typeof document !== "undefined") {
        return WebSocket;
    }
    return WebSocketClient;
}

var keep_alive_interval = 5000;
var max_send_life = 5;
var max_recv_life = max_send_life * 2;

var ChainWebSocket = function () {
    function ChainWebSocket(ws_server, statusCb) {
        var connectTimeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5000;

        var _this = this;

        var autoReconnect = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var keepAliveCb = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

        _classCallCheck(this, ChainWebSocket);

        this.url = ws_server;
        this.statusCb = statusCb;
        this.connectionTimeout = setTimeout(function () {
            if (_this.current_reject) {
                var reject = _this.current_reject;
                _this.current_reject = null;
                _this.close();
                reject(new Error("Connection attempt timed out after " + connectTimeout / 1000 + "s"));
            }
        }, connectTimeout);

        this.current_reject = null;
        this.on_reconnect = null;
        this.closed = false;
        this.send_life = max_send_life;
        this.recv_life = max_recv_life;
        this.keepAliveCb = keepAliveCb;
        this.connect_promise = new Promise(function (resolve, reject) {
            _this.current_reject = reject;
            var WsClient = getWebSocketClient(autoReconnect);
            try {
                _this.ws = new WsClient(ws_server);
            } catch (error) {
                _this.ws = { readyState: 3, close: function close() {} }; // DISCONNECTED
                reject(new Error("Invalid url", ws_server, " closed"));
                // return this.close().then(() => {
                //     console.log("Invalid url", ws_server, " closed");
                //     // throw new Error("Invalid url", ws_server, " closed")
                //     // return this.current_reject(Error("Invalid websocket url: " + ws_server));
                // })
            }

            _this.ws.onopen = function () {
                clearTimeout(_this.connectionTimeout);
                if (_this.statusCb) _this.statusCb("open");
                if (_this.on_reconnect) _this.on_reconnect();
                _this.keepalive_timer = setInterval(function () {

                    _this.recv_life--;
                    if (_this.recv_life == 0) {
                        console.error(_this.url + ' connection is dead, terminating ws');
                        _this.close();
                        // clearInterval(this.keepalive_timer);
                        // this.keepalive_timer = undefined;
                        return;
                    }
                    _this.send_life--;
                    if (_this.send_life == 0) {
                        // this.ws.ping('', false, true);
                        if (_this.keepAliveCb) {
                            _this.keepAliveCb(_this.closed);
                        }
                        _this.send_life = max_send_life;
                    }
                }, 5000);
                _this.current_reject = null;
                resolve();
            };
            _this.ws.onerror = function (error) {
                if (_this.keepalive_timer) {
                    clearInterval(_this.keepalive_timer);
                    _this.keepalive_timer = undefined;
                }
                clearTimeout(_this.connectionTimeout);
                if (_this.statusCb) _this.statusCb("error");

                if (_this.current_reject) {
                    _this.current_reject(error);
                }
            };
            _this.ws.onmessage = function (message) {
                _this.recv_life = max_recv_life;
                _this.listener(JSON.parse(message.data));
            };
            _this.ws.onclose = function () {
                _this.closed = true;
                if (_this.keepalive_timer) {
                    clearInterval(_this.keepalive_timer);
                    _this.keepalive_timer = undefined;
                }
                var err = new Error('connection closed');
                for (var cbId = _this.responseCbId + 1; cbId <= _this.cbId; cbId += 1) {
                    _this.cbs[cbId].reject(err);
                }
                if (_this.statusCb) _this.statusCb("closed");
                if (_this._closeCb) _this._closeCb();
                if (_this.on_close) _this.on_close();
            };
        });
        this.cbId = 0;
        this.responseCbId = 0;
        this.cbs = {};
        this.subs = {};
        this.unsub = {};
    }

    ChainWebSocket.prototype.call = function call(params) {
        var _this2 = this;

        if (this.ws.readyState !== 1) {
            return Promise.reject(new Error('websocket state error:' + this.ws.readyState));
        }
        var method = params[1];
        if (SOCKET_DEBUG) console.log("[ChainWebSocket] >---- call ----->  \"id\":" + (this.cbId + 1), JSON.stringify(params));

        this.cbId += 1;

        if (method === "set_subscribe_callback" || method === "subscribe_to_market" || method === "broadcast_transaction_with_callback" || method === "set_pending_transaction_callback") {
            // Store callback in subs map
            this.subs[this.cbId] = {
                callback: params[2][0]
            };

            // Replace callback with the callback id
            params[2][0] = this.cbId;
        }

        if (method === "unsubscribe_from_market" || method === "unsubscribe_from_accounts") {
            if (typeof params[2][0] !== "function") {
                throw new Error("First parameter of unsub must be the original callback");
            }

            var unSubCb = params[2].splice(0, 1)[0];

            // Find the corresponding subscription
            for (var id in this.subs) {
                if (this.subs[id].callback === unSubCb) {
                    this.unsub[this.cbId] = id;
                    break;
                }
            }
        }

        var request = {
            method: "call",
            params: params
        };
        request.id = this.cbId;
        this.send_life = max_send_life;

        return new Promise(function (resolve, reject) {
            _this2.cbs[_this2.cbId] = {
                time: new Date(),
                resolve: resolve,
                reject: reject
            };
            _this2.ws.send(JSON.stringify(request));
        });
    };

    ChainWebSocket.prototype.listener = function listener(response) {
        if (SOCKET_DEBUG) console.log("[ChainWebSocket] <---- reply ----<", JSON.stringify(response));

        var sub = false,
            callback = null;

        if (response.method === "notice") {
            sub = true;
            response.id = response.params[0];
        }

        if (!sub) {
            callback = this.cbs[response.id];
            this.responseCbId = response.id;
        } else {
            callback = this.subs[response.id].callback;
        }

        if (callback && !sub) {
            if (response.error) {
                callback.reject(response.error);
            } else {
                callback.resolve(response.result);
            }
            delete this.cbs[response.id];

            if (this.unsub[response.id]) {
                delete this.subs[this.unsub[response.id]];
                delete this.unsub[response.id];
            }
        } else if (callback && sub) {
            callback(response.params[1]);
        } else {
            console.log("Warning: unknown websocket response: ", response);
        }
    };

    ChainWebSocket.prototype.login = function login(user, password) {
        var _this3 = this;

        return this.connect_promise.then(function () {
            return _this3.call([1, "login", [user, password]]);
        });
    };

    ChainWebSocket.prototype.close = function close() {
        var _this4 = this;

        return new Promise(function (res) {
            clearInterval(_this4.keepalive_timer);
            _this4.keepalive_timer = undefined;
            _this4._closeCb = function () {
                res();
                _this4._closeCb = null;
            };
            if (!_this4.ws) {
                console.log("Websocket already cleared", _this4);
                return res();
            }
            if (_this4.ws.terminate) {
                _this4.ws.terminate();
            } else {
                _this4.ws.close();
            }
            if (_this4.ws.readyState === 3) res();
        });
    };

    return ChainWebSocket;
}();

exports.default = ChainWebSocket;
module.exports = exports["default"];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9)))

/***/ }),
/* 370 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

exports.__esModule = true;
var _this = void 0;

var ecc_config = {
    address_prefix: process.env.npm_config__graphene_ecc_default_address_prefix || "COCOS"
};

_this = {
    chain_id:"",
    core_asset: "COCOS",
    address_prefix: "COCOS",
    expire_in_secs: 15,
    expire_in_secs_proposal: 24 * 60 * 60,
    review_in_secs_committee: 24 * 60 * 60,
    networks:[],

    /** Set a few properties for known chain IDs. */
    setChainId: function setChainId(chain_id) {

        var i = void 0,
            len = void 0,
            network = void 0,    
            network_name = void 0,
            ref = void 0;
        for (i = 0, len = _this.networks.length; i < len; i++) {
            network=_this.networks[i];
            network_name = network.core_asset;
            if (network.chain_id === chain_id) {
                _this.network_name = network_name;
                if (network.core_asset) {
                    _this.core_asset = network.core_asset;
                    _this.address_prefix = network.core_asset;
                    ecc_config.address_prefix = network.core_asset;
                }
                _this.chain_id=chain_id;
                // console.log("INFO    Configured for", network_name, ":", network.core_asset, "\n");
                return {
                    network_name: network_name,
                    network: network
                };
            }
        }
        if (!_this.network_name) {
            console.log("Unknown chain id (this may be a testnet)", chain_id);
        }
    },

    reset: function reset() {
        _this.core_asset = "COCOS";
        _this.address_prefix = "COCOS";
        ecc_config.address_prefix = "COCOS";
        _this.expire_in_secs = 15;
        _this.expire_in_secs_proposal = 24 * 60 * 60;

        console.log("Chain config reset");
    },

    setPrefix: function setPrefix() {
        var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "COCOS";

        _this.address_prefix = prefix;
        ecc_config.address_prefix = prefix;
    }
};

exports.default = _this;
module.exports = exports["default"];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9)))

/***/ }),
/* 371 */
/***/ (function(module, exports, __webpack_require__) {

// (public) Constructor
function BigInteger(a, b, c) {
  if (!(this instanceof BigInteger))
    return new BigInteger(a, b, c)

  if (a != null) {
    if ("number" == typeof a) this.fromNumber(a, b, c)
    else if (b == null && "string" != typeof a) this.fromString(a, 256)
    else this.fromString(a, b)
  }
}

var proto = BigInteger.prototype

// duck-typed isBigInteger
proto.__bigi = __webpack_require__(447).version
BigInteger.isBigInteger = function (obj, check_ver) {
  return obj && obj.__bigi && (!check_ver || obj.__bigi === proto.__bigi)
}

// Bits per digit
var dbits

// am: Compute w_j += (x*this_i), propagate carries,
// c is initial carry, returns final carry.
// c < 3*dvalue, x < 2*dvalue, this_i < dvalue
// We need to select the fastest one that works in this environment.

// am1: use a single mult and divide to get the high bits,
// max digit bits should be 26 because
// max internal value = 2*dvalue^2-2*dvalue (< 2^53)
function am1(i, x, w, j, c, n) {
  while (--n >= 0) {
    var v = x * this[i++] + w[j] + c
    c = Math.floor(v / 0x4000000)
    w[j++] = v & 0x3ffffff
  }
  return c
}
// am2 avoids a big mult-and-extract completely.
// Max digit bits should be <= 30 because we do bitwise ops
// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
function am2(i, x, w, j, c, n) {
  var xl = x & 0x7fff,
    xh = x >> 15
  while (--n >= 0) {
    var l = this[i] & 0x7fff
    var h = this[i++] >> 15
    var m = xh * l + h * xl
    l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff)
    c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30)
    w[j++] = l & 0x3fffffff
  }
  return c
}
// Alternately, set max digit bits to 28 since some
// browsers slow down when dealing with 32-bit numbers.
function am3(i, x, w, j, c, n) {
  var xl = x & 0x3fff,
    xh = x >> 14
  while (--n >= 0) {
    var l = this[i] & 0x3fff
    var h = this[i++] >> 14
    var m = xh * l + h * xl
    l = xl * l + ((m & 0x3fff) << 14) + w[j] + c
    c = (l >> 28) + (m >> 14) + xh * h
    w[j++] = l & 0xfffffff
  }
  return c
}

// wtf?
BigInteger.prototype.am = am1
dbits = 26

BigInteger.prototype.DB = dbits
BigInteger.prototype.DM = ((1 << dbits) - 1)
var DV = BigInteger.prototype.DV = (1 << dbits)

var BI_FP = 52
BigInteger.prototype.FV = Math.pow(2, BI_FP)
BigInteger.prototype.F1 = BI_FP - dbits
BigInteger.prototype.F2 = 2 * dbits - BI_FP

// Digit conversions
var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz"
var BI_RC = new Array()
var rr, vv
rr = "0".charCodeAt(0)
for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv
rr = "a".charCodeAt(0)
for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv
rr = "A".charCodeAt(0)
for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv

function int2char(n) {
  return BI_RM.charAt(n)
}

function intAt(s, i) {
  var c = BI_RC[s.charCodeAt(i)]
  return (c == null) ? -1 : c
}

// (protected) copy this to r
function bnpCopyTo(r) {
  for (var i = this.t - 1; i >= 0; --i) r[i] = this[i]
  r.t = this.t
  r.s = this.s
}

// (protected) set from integer value x, -DV <= x < DV
function bnpFromInt(x) {
  this.t = 1
  this.s = (x < 0) ? -1 : 0
  if (x > 0) this[0] = x
  else if (x < -1) this[0] = x + DV
  else this.t = 0
}

// return bigint initialized to value
function nbv(i) {
  var r = new BigInteger()
  r.fromInt(i)
  return r
}

// (protected) set from string and radix
function bnpFromString(s, b) {
  var self = this

  var k
  if (b == 16) k = 4
  else if (b == 8) k = 3
  else if (b == 256) k = 8; // byte array
  else if (b == 2) k = 1
  else if (b == 32) k = 5
  else if (b == 4) k = 2
  else {
    self.fromRadix(s, b)
    return
  }
  self.t = 0
  self.s = 0
  var i = s.length,
    mi = false,
    sh = 0
  while (--i >= 0) {
    var x = (k == 8) ? s[i] & 0xff : intAt(s, i)
    if (x < 0) {
      if (s.charAt(i) == "-") mi = true
      continue
    }
    mi = false
    if (sh == 0)
      self[self.t++] = x
    else if (sh + k > self.DB) {
      self[self.t - 1] |= (x & ((1 << (self.DB - sh)) - 1)) << sh
      self[self.t++] = (x >> (self.DB - sh))
    } else
      self[self.t - 1] |= x << sh
    sh += k
    if (sh >= self.DB) sh -= self.DB
  }
  if (k == 8 && (s[0] & 0x80) != 0) {
    self.s = -1
    if (sh > 0) self[self.t - 1] |= ((1 << (self.DB - sh)) - 1) << sh
  }
  self.clamp()
  if (mi) BigInteger.ZERO.subTo(self, self)
}

// (protected) clamp off excess high words
function bnpClamp() {
  var c = this.s & this.DM
  while (this.t > 0 && this[this.t - 1] == c)--this.t
}

// (public) return string representation in given radix
function bnToString(b) {
  var self = this
  if (self.s < 0) return "-" + self.negate()
    .toString(b)
  var k
  if (b == 16) k = 4
  else if (b == 8) k = 3
  else if (b == 2) k = 1
  else if (b == 32) k = 5
  else if (b == 4) k = 2
  else return self.toRadix(b)
  var km = (1 << k) - 1,
    d, m = false,
    r = "",
    i = self.t
  var p = self.DB - (i * self.DB) % k
  if (i-- > 0) {
    if (p < self.DB && (d = self[i] >> p) > 0) {
      m = true
      r = int2char(d)
    }
    while (i >= 0) {
      if (p < k) {
        d = (self[i] & ((1 << p) - 1)) << (k - p)
        d |= self[--i] >> (p += self.DB - k)
      } else {
        d = (self[i] >> (p -= k)) & km
        if (p <= 0) {
          p += self.DB
          --i
        }
      }
      if (d > 0) m = true
      if (m) r += int2char(d)
    }
  }
  return m ? r : "0"
}

// (public) -this
function bnNegate() {
  var r = new BigInteger()
  BigInteger.ZERO.subTo(this, r)
  return r
}

// (public) |this|
function bnAbs() {
  return (this.s < 0) ? this.negate() : this
}

// (public) return + if this > a, - if this < a, 0 if equal
function bnCompareTo(a) {
  var r = this.s - a.s
  if (r != 0) return r
  var i = this.t
  r = i - a.t
  if (r != 0) return (this.s < 0) ? -r : r
  while (--i >= 0)
    if ((r = this[i] - a[i]) != 0) return r
  return 0
}

// returns bit length of the integer x
function nbits(x) {
  var r = 1,
    t
  if ((t = x >>> 16) != 0) {
    x = t
    r += 16
  }
  if ((t = x >> 8) != 0) {
    x = t
    r += 8
  }
  if ((t = x >> 4) != 0) {
    x = t
    r += 4
  }
  if ((t = x >> 2) != 0) {
    x = t
    r += 2
  }
  if ((t = x >> 1) != 0) {
    x = t
    r += 1
  }
  return r
}

// (public) return the number of bits in "this"
function bnBitLength() {
  if (this.t <= 0) return 0
  return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM))
}

// (public) return the number of bytes in "this"
function bnByteLength() {
  return this.bitLength() >> 3
}

// (protected) r = this << n*DB
function bnpDLShiftTo(n, r) {
  var i
  for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i]
  for (i = n - 1; i >= 0; --i) r[i] = 0
  r.t = this.t + n
  r.s = this.s
}

// (protected) r = this >> n*DB
function bnpDRShiftTo(n, r) {
  for (var i = n; i < this.t; ++i) r[i - n] = this[i]
  r.t = Math.max(this.t - n, 0)
  r.s = this.s
}

// (protected) r = this << n
function bnpLShiftTo(n, r) {
  var self = this
  var bs = n % self.DB
  var cbs = self.DB - bs
  var bm = (1 << cbs) - 1
  var ds = Math.floor(n / self.DB),
    c = (self.s << bs) & self.DM,
    i
  for (i = self.t - 1; i >= 0; --i) {
    r[i + ds + 1] = (self[i] >> cbs) | c
    c = (self[i] & bm) << bs
  }
  for (i = ds - 1; i >= 0; --i) r[i] = 0
  r[ds] = c
  r.t = self.t + ds + 1
  r.s = self.s
  r.clamp()
}

// (protected) r = this >> n
function bnpRShiftTo(n, r) {
  var self = this
  r.s = self.s
  var ds = Math.floor(n / self.DB)
  if (ds >= self.t) {
    r.t = 0
    return
  }
  var bs = n % self.DB
  var cbs = self.DB - bs
  var bm = (1 << bs) - 1
  r[0] = self[ds] >> bs
  for (var i = ds + 1; i < self.t; ++i) {
    r[i - ds - 1] |= (self[i] & bm) << cbs
    r[i - ds] = self[i] >> bs
  }
  if (bs > 0) r[self.t - ds - 1] |= (self.s & bm) << cbs
  r.t = self.t - ds
  r.clamp()
}

// (protected) r = this - a
function bnpSubTo(a, r) {
  var self = this
  var i = 0,
    c = 0,
    m = Math.min(a.t, self.t)
  while (i < m) {
    c += self[i] - a[i]
    r[i++] = c & self.DM
    c >>= self.DB
  }
  if (a.t < self.t) {
    c -= a.s
    while (i < self.t) {
      c += self[i]
      r[i++] = c & self.DM
      c >>= self.DB
    }
    c += self.s
  } else {
    c += self.s
    while (i < a.t) {
      c -= a[i]
      r[i++] = c & self.DM
      c >>= self.DB
    }
    c -= a.s
  }
  r.s = (c < 0) ? -1 : 0
  if (c < -1) r[i++] = self.DV + c
  else if (c > 0) r[i++] = c
  r.t = i
  r.clamp()
}

// (protected) r = this * a, r != this,a (HAC 14.12)
// "this" should be the larger one if appropriate.
function bnpMultiplyTo(a, r) {
  var x = this.abs(),
    y = a.abs()
  var i = x.t
  r.t = i + y.t
  while (--i >= 0) r[i] = 0
  for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t)
  r.s = 0
  r.clamp()
  if (this.s != a.s) BigInteger.ZERO.subTo(r, r)
}

// (protected) r = this^2, r != this (HAC 14.16)
function bnpSquareTo(r) {
  var x = this.abs()
  var i = r.t = 2 * x.t
  while (--i >= 0) r[i] = 0
  for (i = 0; i < x.t - 1; ++i) {
    var c = x.am(i, x[i], r, 2 * i, 0, 1)
    if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
      r[i + x.t] -= x.DV
      r[i + x.t + 1] = 1
    }
  }
  if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1)
  r.s = 0
  r.clamp()
}

// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
// r != q, this != m.  q or r may be null.
function bnpDivRemTo(m, q, r) {
  var self = this
  var pm = m.abs()
  if (pm.t <= 0) return
  var pt = self.abs()
  if (pt.t < pm.t) {
    if (q != null) q.fromInt(0)
    if (r != null) self.copyTo(r)
    return
  }
  if (r == null) r = new BigInteger()
  var y = new BigInteger(),
    ts = self.s,
    ms = m.s
  var nsh = self.DB - nbits(pm[pm.t - 1]); // normalize modulus
  if (nsh > 0) {
    pm.lShiftTo(nsh, y)
    pt.lShiftTo(nsh, r)
  } else {
    pm.copyTo(y)
    pt.copyTo(r)
  }
  var ys = y.t
  var y0 = y[ys - 1]
  if (y0 == 0) return
  var yt = y0 * (1 << self.F1) + ((ys > 1) ? y[ys - 2] >> self.F2 : 0)
  var d1 = self.FV / yt,
    d2 = (1 << self.F1) / yt,
    e = 1 << self.F2
  var i = r.t,
    j = i - ys,
    t = (q == null) ? new BigInteger() : q
  y.dlShiftTo(j, t)
  if (r.compareTo(t) >= 0) {
    r[r.t++] = 1
    r.subTo(t, r)
  }
  BigInteger.ONE.dlShiftTo(ys, t)
  t.subTo(y, y); // "negative" y so we can replace sub with am later
  while (y.t < ys) y[y.t++] = 0
  while (--j >= 0) {
    // Estimate quotient digit
    var qd = (r[--i] == y0) ? self.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2)
    if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) { // Try it out
      y.dlShiftTo(j, t)
      r.subTo(t, r)
      while (r[i] < --qd) r.subTo(t, r)
    }
  }
  if (q != null) {
    r.drShiftTo(ys, q)
    if (ts != ms) BigInteger.ZERO.subTo(q, q)
  }
  r.t = ys
  r.clamp()
  if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder
  if (ts < 0) BigInteger.ZERO.subTo(r, r)
}

// (public) this mod a
function bnMod(a) {
  var r = new BigInteger()
  this.abs()
    .divRemTo(a, null, r)
  if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r)
  return r
}

// Modular reduction using "classic" algorithm
function Classic(m) {
  this.m = m
}

function cConvert(x) {
  if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m)
  else return x
}

function cRevert(x) {
  return x
}

function cReduce(x) {
  x.divRemTo(this.m, null, x)
}

function cMulTo(x, y, r) {
  x.multiplyTo(y, r)
  this.reduce(r)
}

function cSqrTo(x, r) {
  x.squareTo(r)
  this.reduce(r)
}

Classic.prototype.convert = cConvert
Classic.prototype.revert = cRevert
Classic.prototype.reduce = cReduce
Classic.prototype.mulTo = cMulTo
Classic.prototype.sqrTo = cSqrTo

// (protected) return "-1/this % 2^DB"; useful for Mont. reduction
// justification:
//         xy == 1 (mod m)
//         xy =  1+km
//   xy(2-xy) = (1+km)(1-km)
// x[y(2-xy)] = 1-k^2m^2
// x[y(2-xy)] == 1 (mod m^2)
// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
// JS multiply "overflows" differently from C/C++, so care is needed here.
function bnpInvDigit() {
  if (this.t < 1) return 0
  var x = this[0]
  if ((x & 1) == 0) return 0
  var y = x & 3; // y == 1/x mod 2^2
  y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4
  y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8
  y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16
  // last step - calculate inverse mod DV directly
  // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
  y = (y * (2 - x * y % this.DV)) % this.DV; // y == 1/x mod 2^dbits
  // we really want the negative inverse, and -DV < y < DV
  return (y > 0) ? this.DV - y : -y
}

// Montgomery reduction
function Montgomery(m) {
  this.m = m
  this.mp = m.invDigit()
  this.mpl = this.mp & 0x7fff
  this.mph = this.mp >> 15
  this.um = (1 << (m.DB - 15)) - 1
  this.mt2 = 2 * m.t
}

// xR mod m
function montConvert(x) {
  var r = new BigInteger()
  x.abs()
    .dlShiftTo(this.m.t, r)
  r.divRemTo(this.m, null, r)
  if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r)
  return r
}

// x/R mod m
function montRevert(x) {
  var r = new BigInteger()
  x.copyTo(r)
  this.reduce(r)
  return r
}

// x = x/R mod m (HAC 14.32)
function montReduce(x) {
  while (x.t <= this.mt2) // pad x so am has enough room later
    x[x.t++] = 0
  for (var i = 0; i < this.m.t; ++i) {
    // faster way of calculating u0 = x[i]*mp mod DV
    var j = x[i] & 0x7fff
    var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM
    // use am to combine the multiply-shift-add into one call
    j = i + this.m.t
    x[j] += this.m.am(0, u0, x, i, 0, this.m.t)
    // propagate carry
    while (x[j] >= x.DV) {
      x[j] -= x.DV
      x[++j]++
    }
  }
  x.clamp()
  x.drShiftTo(this.m.t, x)
  if (x.compareTo(this.m) >= 0) x.subTo(this.m, x)
}

// r = "x^2/R mod m"; x != r
function montSqrTo(x, r) {
  x.squareTo(r)
  this.reduce(r)
}

// r = "xy/R mod m"; x,y != r
function montMulTo(x, y, r) {
  x.multiplyTo(y, r)
  this.reduce(r)
}

Montgomery.prototype.convert = montConvert
Montgomery.prototype.revert = montRevert
Montgomery.prototype.reduce = montReduce
Montgomery.prototype.mulTo = montMulTo
Montgomery.prototype.sqrTo = montSqrTo

// (protected) true iff this is even
function bnpIsEven() {
  return ((this.t > 0) ? (this[0] & 1) : this.s) == 0
}

// (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
function bnpExp(e, z) {
  if (e > 0xffffffff || e < 1) return BigInteger.ONE
  var r = new BigInteger(),
    r2 = new BigInteger(),
    g = z.convert(this),
    i = nbits(e) - 1
  g.copyTo(r)
  while (--i >= 0) {
    z.sqrTo(r, r2)
    if ((e & (1 << i)) > 0) z.mulTo(r2, g, r)
    else {
      var t = r
      r = r2
      r2 = t
    }
  }
  return z.revert(r)
}

// (public) this^e % m, 0 <= e < 2^32
function bnModPowInt(e, m) {
  var z
  if (e < 256 || m.isEven()) z = new Classic(m)
  else z = new Montgomery(m)
  return this.exp(e, z)
}

// protected
proto.copyTo = bnpCopyTo
proto.fromInt = bnpFromInt
proto.fromString = bnpFromString
proto.clamp = bnpClamp
proto.dlShiftTo = bnpDLShiftTo
proto.drShiftTo = bnpDRShiftTo
proto.lShiftTo = bnpLShiftTo
proto.rShiftTo = bnpRShiftTo
proto.subTo = bnpSubTo
proto.multiplyTo = bnpMultiplyTo
proto.squareTo = bnpSquareTo
proto.divRemTo = bnpDivRemTo
proto.invDigit = bnpInvDigit
proto.isEven = bnpIsEven
proto.exp = bnpExp

// public
proto.toString = bnToString
proto.negate = bnNegate
proto.abs = bnAbs
proto.compareTo = bnCompareTo
proto.bitLength = bnBitLength
proto.byteLength = bnByteLength
proto.mod = bnMod
proto.modPowInt = bnModPowInt

// (public)
function bnClone() {
  var r = new BigInteger()
  this.copyTo(r)
  return r
}

// (public) return value as integer
function bnIntValue() {
  if (this.s < 0) {
    if (this.t == 1) return this[0] - this.DV
    else if (this.t == 0) return -1
  } else if (this.t == 1) return this[0]
  else if (this.t == 0) return 0
  // assumes 16 < DB < 32
  return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0]
}

// (public) return value as byte
function bnByteValue() {
  return (this.t == 0) ? this.s : (this[0] << 24) >> 24
}

// (public) return value as short (assumes DB>=16)
function bnShortValue() {
  return (this.t == 0) ? this.s : (this[0] << 16) >> 16
}

// (protected) return x s.t. r^x < DV
function bnpChunkSize(r) {
  return Math.floor(Math.LN2 * this.DB / Math.log(r))
}

// (public) 0 if this == 0, 1 if this > 0
function bnSigNum() {
  if (this.s < 0) return -1
  else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0
  else return 1
}

// (protected) convert to radix string
function bnpToRadix(b) {
  if (b == null) b = 10
  if (this.signum() == 0 || b < 2 || b > 36) return "0"
  var cs = this.chunkSize(b)
  var a = Math.pow(b, cs)
  var d = nbv(a),
    y = new BigInteger(),
    z = new BigInteger(),
    r = ""
  this.divRemTo(d, y, z)
  while (y.signum() > 0) {
    r = (a + z.intValue())
      .toString(b)
      .substr(1) + r
    y.divRemTo(d, y, z)
  }
  return z.intValue()
    .toString(b) + r
}

// (protected) convert from radix string
function bnpFromRadix(s, b) {
  var self = this
  self.fromInt(0)
  if (b == null) b = 10
  var cs = self.chunkSize(b)
  var d = Math.pow(b, cs),
    mi = false,
    j = 0,
    w = 0
  for (var i = 0; i < s.length; ++i) {
    var x = intAt(s, i)
    if (x < 0) {
      if (s.charAt(i) == "-" && self.signum() == 0) mi = true
      continue
    }
    w = b * w + x
    if (++j >= cs) {
      self.dMultiply(d)
      self.dAddOffset(w, 0)
      j = 0
      w = 0
    }
  }
  if (j > 0) {
    self.dMultiply(Math.pow(b, j))
    self.dAddOffset(w, 0)
  }
  if (mi) BigInteger.ZERO.subTo(self, self)
}

// (protected) alternate constructor
function bnpFromNumber(a, b, c) {
  var self = this
  if ("number" == typeof b) {
    // new BigInteger(int,int,RNG)
    if (a < 2) self.fromInt(1)
    else {
      self.fromNumber(a, c)
      if (!self.testBit(a - 1)) // force MSB set
        self.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, self)
      if (self.isEven()) self.dAddOffset(1, 0); // force odd
      while (!self.isProbablePrime(b)) {
        self.dAddOffset(2, 0)
        if (self.bitLength() > a) self.subTo(BigInteger.ONE.shiftLeft(a - 1), self)
      }
    }
  } else {
    // new BigInteger(int,RNG)
    var x = new Array(),
      t = a & 7
    x.length = (a >> 3) + 1
    b.nextBytes(x)
    if (t > 0) x[0] &= ((1 << t) - 1)
    else x[0] = 0
    self.fromString(x, 256)
  }
}

// (public) convert to bigendian byte array
function bnToByteArray() {
  var self = this
  var i = self.t,
    r = new Array()
  r[0] = self.s
  var p = self.DB - (i * self.DB) % 8,
    d, k = 0
  if (i-- > 0) {
    if (p < self.DB && (d = self[i] >> p) != (self.s & self.DM) >> p)
      r[k++] = d | (self.s << (self.DB - p))
    while (i >= 0) {
      if (p < 8) {
        d = (self[i] & ((1 << p) - 1)) << (8 - p)
        d |= self[--i] >> (p += self.DB - 8)
      } else {
        d = (self[i] >> (p -= 8)) & 0xff
        if (p <= 0) {
          p += self.DB
          --i
        }
      }
      if ((d & 0x80) != 0) d |= -256
      if (k === 0 && (self.s & 0x80) != (d & 0x80))++k
      if (k > 0 || d != self.s) r[k++] = d
    }
  }
  return r
}

function bnEquals(a) {
  return (this.compareTo(a) == 0)
}

function bnMin(a) {
  return (this.compareTo(a) < 0) ? this : a
}

function bnMax(a) {
  return (this.compareTo(a) > 0) ? this : a
}

// (protected) r = this op a (bitwise)
function bnpBitwiseTo(a, op, r) {
  var self = this
  var i, f, m = Math.min(a.t, self.t)
  for (i = 0; i < m; ++i) r[i] = op(self[i], a[i])
  if (a.t < self.t) {
    f = a.s & self.DM
    for (i = m; i < self.t; ++i) r[i] = op(self[i], f)
    r.t = self.t
  } else {
    f = self.s & self.DM
    for (i = m; i < a.t; ++i) r[i] = op(f, a[i])
    r.t = a.t
  }
  r.s = op(self.s, a.s)
  r.clamp()
}

// (public) this & a
function op_and(x, y) {
  return x & y
}

function bnAnd(a) {
  var r = new BigInteger()
  this.bitwiseTo(a, op_and, r)
  return r
}

// (public) this | a
function op_or(x, y) {
  return x | y
}

function bnOr(a) {
  var r = new BigInteger()
  this.bitwiseTo(a, op_or, r)
  return r
}

// (public) this ^ a
function op_xor(x, y) {
  return x ^ y
}

function bnXor(a) {
  var r = new BigInteger()
  this.bitwiseTo(a, op_xor, r)
  return r
}

// (public) this & ~a
function op_andnot(x, y) {
  return x & ~y
}

function bnAndNot(a) {
  var r = new BigInteger()
  this.bitwiseTo(a, op_andnot, r)
  return r
}

// (public) ~this
function bnNot() {
  var r = new BigInteger()
  for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i]
  r.t = this.t
  r.s = ~this.s
  return r
}

// (public) this << n
function bnShiftLeft(n) {
  var r = new BigInteger()
  if (n < 0) this.rShiftTo(-n, r)
  else this.lShiftTo(n, r)
  return r
}

// (public) this >> n
function bnShiftRight(n) {
  var r = new BigInteger()
  if (n < 0) this.lShiftTo(-n, r)
  else this.rShiftTo(n, r)
  return r
}

// return index of lowest 1-bit in x, x < 2^31
function lbit(x) {
  if (x == 0) return -1
  var r = 0
  if ((x & 0xffff) == 0) {
    x >>= 16
    r += 16
  }
  if ((x & 0xff) == 0) {
    x >>= 8
    r += 8
  }
  if ((x & 0xf) == 0) {
    x >>= 4
    r += 4
  }
  if ((x & 3) == 0) {
    x >>= 2
    r += 2
  }
  if ((x & 1) == 0)++r
  return r
}

// (public) returns index of lowest 1-bit (or -1 if none)
function bnGetLowestSetBit() {
  for (var i = 0; i < this.t; ++i)
    if (this[i] != 0) return i * this.DB + lbit(this[i])
  if (this.s < 0) return this.t * this.DB
  return -1
}

// return number of 1 bits in x
function cbit(x) {
  var r = 0
  while (x != 0) {
    x &= x - 1
    ++r
  }
  return r
}

// (public) return number of set bits
function bnBitCount() {
  var r = 0,
    x = this.s & this.DM
  for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x)
  return r
}

// (public) true iff nth bit is set
function bnTestBit(n) {
  var j = Math.floor(n / this.DB)
  if (j >= this.t) return (this.s != 0)
  return ((this[j] & (1 << (n % this.DB))) != 0)
}

// (protected) this op (1<<n)
function bnpChangeBit(n, op) {
  var r = BigInteger.ONE.shiftLeft(n)
  this.bitwiseTo(r, op, r)
  return r
}

// (public) this | (1<<n)
function bnSetBit(n) {
  return this.changeBit(n, op_or)
}

// (public) this & ~(1<<n)
function bnClearBit(n) {
  return this.changeBit(n, op_andnot)
}

// (public) this ^ (1<<n)
function bnFlipBit(n) {
  return this.changeBit(n, op_xor)
}

// (protected) r = this + a
function bnpAddTo(a, r) {
  var self = this

  var i = 0,
    c = 0,
    m = Math.min(a.t, self.t)
  while (i < m) {
    c += self[i] + a[i]
    r[i++] = c & self.DM
    c >>= self.DB
  }
  if (a.t < self.t) {
    c += a.s
    while (i < self.t) {
      c += self[i]
      r[i++] = c & self.DM
      c >>= self.DB
    }
    c += self.s
  } else {
    c += self.s
    while (i < a.t) {
      c += a[i]
      r[i++] = c & self.DM
      c >>= self.DB
    }
    c += a.s
  }
  r.s = (c < 0) ? -1 : 0
  if (c > 0) r[i++] = c
  else if (c < -1) r[i++] = self.DV + c
  r.t = i
  r.clamp()
}

// (public) this + a
function bnAdd(a) {
  var r = new BigInteger()
  this.addTo(a, r)
  return r
}

// (public) this - a
function bnSubtract(a) {
  var r = new BigInteger()
  this.subTo(a, r)
  return r
}

// (public) this * a
function bnMultiply(a) {
  var r = new BigInteger()
  this.multiplyTo(a, r)
  return r
}

// (public) this^2
function bnSquare() {
  var r = new BigInteger()
  this.squareTo(r)
  return r
}

// (public) this / a
function bnDivide(a) {
  var r = new BigInteger()
  this.divRemTo(a, r, null)
  return r
}

// (public) this % a
function bnRemainder(a) {
  var r = new BigInteger()
  this.divRemTo(a, null, r)
  return r
}

// (public) [this/a,this%a]
function bnDivideAndRemainder(a) {
  var q = new BigInteger(),
    r = new BigInteger()
  this.divRemTo(a, q, r)
  return new Array(q, r)
}

// (protected) this *= n, this >= 0, 1 < n < DV
function bnpDMultiply(n) {
  this[this.t] = this.am(0, n - 1, this, 0, 0, this.t)
  ++this.t
  this.clamp()
}

// (protected) this += n << w words, this >= 0
function bnpDAddOffset(n, w) {
  if (n == 0) return
  while (this.t <= w) this[this.t++] = 0
  this[w] += n
  while (this[w] >= this.DV) {
    this[w] -= this.DV
    if (++w >= this.t) this[this.t++] = 0
    ++this[w]
  }
}

// A "null" reducer
function NullExp() {}

function nNop(x) {
  return x
}

function nMulTo(x, y, r) {
  x.multiplyTo(y, r)
}

function nSqrTo(x, r) {
  x.squareTo(r)
}

NullExp.prototype.convert = nNop
NullExp.prototype.revert = nNop
NullExp.prototype.mulTo = nMulTo
NullExp.prototype.sqrTo = nSqrTo

// (public) this^e
function bnPow(e) {
  return this.exp(e, new NullExp())
}

// (protected) r = lower n words of "this * a", a.t <= n
// "this" should be the larger one if appropriate.
function bnpMultiplyLowerTo(a, n, r) {
  var i = Math.min(this.t + a.t, n)
  r.s = 0; // assumes a,this >= 0
  r.t = i
  while (i > 0) r[--i] = 0
  var j
  for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t)
  for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i)
  r.clamp()
}

// (protected) r = "this * a" without lower n words, n > 0
// "this" should be the larger one if appropriate.
function bnpMultiplyUpperTo(a, n, r) {
  --n
  var i = r.t = this.t + a.t - n
  r.s = 0; // assumes a,this >= 0
  while (--i >= 0) r[i] = 0
  for (i = Math.max(n - this.t, 0); i < a.t; ++i)
    r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n)
  r.clamp()
  r.drShiftTo(1, r)
}

// Barrett modular reduction
function Barrett(m) {
  // setup Barrett
  this.r2 = new BigInteger()
  this.q3 = new BigInteger()
  BigInteger.ONE.dlShiftTo(2 * m.t, this.r2)
  this.mu = this.r2.divide(m)
  this.m = m
}

function barrettConvert(x) {
  if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m)
  else if (x.compareTo(this.m) < 0) return x
  else {
    var r = new BigInteger()
    x.copyTo(r)
    this.reduce(r)
    return r
  }
}

function barrettRevert(x) {
  return x
}

// x = x mod m (HAC 14.42)
function barrettReduce(x) {
  var self = this
  x.drShiftTo(self.m.t - 1, self.r2)
  if (x.t > self.m.t + 1) {
    x.t = self.m.t + 1
    x.clamp()
  }
  self.mu.multiplyUpperTo(self.r2, self.m.t + 1, self.q3)
  self.m.multiplyLowerTo(self.q3, self.m.t + 1, self.r2)
  while (x.compareTo(self.r2) < 0) x.dAddOffset(1, self.m.t + 1)
  x.subTo(self.r2, x)
  while (x.compareTo(self.m) >= 0) x.subTo(self.m, x)
}

// r = x^2 mod m; x != r
function barrettSqrTo(x, r) {
  x.squareTo(r)
  this.reduce(r)
}

// r = x*y mod m; x,y != r
function barrettMulTo(x, y, r) {
  x.multiplyTo(y, r)
  this.reduce(r)
}

Barrett.prototype.convert = barrettConvert
Barrett.prototype.revert = barrettRevert
Barrett.prototype.reduce = barrettReduce
Barrett.prototype.mulTo = barrettMulTo
Barrett.prototype.sqrTo = barrettSqrTo

// (public) this^e % m (HAC 14.85)
function bnModPow(e, m) {
  var i = e.bitLength(),
    k, r = nbv(1),
    z
  if (i <= 0) return r
  else if (i < 18) k = 1
  else if (i < 48) k = 3
  else if (i < 144) k = 4
  else if (i < 768) k = 5
  else k = 6
  if (i < 8)
    z = new Classic(m)
  else if (m.isEven())
    z = new Barrett(m)
  else
    z = new Montgomery(m)

  // precomputation
  var g = new Array(),
    n = 3,
    k1 = k - 1,
    km = (1 << k) - 1
  g[1] = z.convert(this)
  if (k > 1) {
    var g2 = new BigInteger()
    z.sqrTo(g[1], g2)
    while (n <= km) {
      g[n] = new BigInteger()
      z.mulTo(g2, g[n - 2], g[n])
      n += 2
    }
  }

  var j = e.t - 1,
    w, is1 = true,
    r2 = new BigInteger(),
    t
  i = nbits(e[j]) - 1
  while (j >= 0) {
    if (i >= k1) w = (e[j] >> (i - k1)) & km
    else {
      w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i)
      if (j > 0) w |= e[j - 1] >> (this.DB + i - k1)
    }

    n = k
    while ((w & 1) == 0) {
      w >>= 1
      --n
    }
    if ((i -= n) < 0) {
      i += this.DB
      --j
    }
    if (is1) { // ret == 1, don't bother squaring or multiplying it
      g[w].copyTo(r)
      is1 = false
    } else {
      while (n > 1) {
        z.sqrTo(r, r2)
        z.sqrTo(r2, r)
        n -= 2
      }
      if (n > 0) z.sqrTo(r, r2)
      else {
        t = r
        r = r2
        r2 = t
      }
      z.mulTo(r2, g[w], r)
    }

    while (j >= 0 && (e[j] & (1 << i)) == 0) {
      z.sqrTo(r, r2)
      t = r
      r = r2
      r2 = t
      if (--i < 0) {
        i = this.DB - 1
        --j
      }
    }
  }
  return z.revert(r)
}

// (public) gcd(this,a) (HAC 14.54)
function bnGCD(a) {
  var x = (this.s < 0) ? this.negate() : this.clone()
  var y = (a.s < 0) ? a.negate() : a.clone()
  if (x.compareTo(y) < 0) {
    var t = x
    x = y
    y = t
  }
  var i = x.getLowestSetBit(),
    g = y.getLowestSetBit()
  if (g < 0) return x
  if (i < g) g = i
  if (g > 0) {
    x.rShiftTo(g, x)
    y.rShiftTo(g, y)
  }
  while (x.signum() > 0) {
    if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x)
    if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y)
    if (x.compareTo(y) >= 0) {
      x.subTo(y, x)
      x.rShiftTo(1, x)
    } else {
      y.subTo(x, y)
      y.rShiftTo(1, y)
    }
  }
  if (g > 0) y.lShiftTo(g, y)
  return y
}

// (protected) this % n, n < 2^26
function bnpModInt(n) {
  if (n <= 0) return 0
  var d = this.DV % n,
    r = (this.s < 0) ? n - 1 : 0
  if (this.t > 0)
    if (d == 0) r = this[0] % n
    else
      for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n
  return r
}

// (public) 1/this % m (HAC 14.61)
function bnModInverse(m) {
  var ac = m.isEven()
  if (this.signum() === 0) throw new Error('division by zero')
  if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO
  var u = m.clone(),
    v = this.clone()
  var a = nbv(1),
    b = nbv(0),
    c = nbv(0),
    d = nbv(1)
  while (u.signum() != 0) {
    while (u.isEven()) {
      u.rShiftTo(1, u)
      if (ac) {
        if (!a.isEven() || !b.isEven()) {
          a.addTo(this, a)
          b.subTo(m, b)
        }
        a.rShiftTo(1, a)
      } else if (!b.isEven()) b.subTo(m, b)
      b.rShiftTo(1, b)
    }
    while (v.isEven()) {
      v.rShiftTo(1, v)
      if (ac) {
        if (!c.isEven() || !d.isEven()) {
          c.addTo(this, c)
          d.subTo(m, d)
        }
        c.rShiftTo(1, c)
      } else if (!d.isEven()) d.subTo(m, d)
      d.rShiftTo(1, d)
    }
    if (u.compareTo(v) >= 0) {
      u.subTo(v, u)
      if (ac) a.subTo(c, a)
      b.subTo(d, b)
    } else {
      v.subTo(u, v)
      if (ac) c.subTo(a, c)
      d.subTo(b, d)
    }
  }
  if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO
  while (d.compareTo(m) >= 0) d.subTo(m, d)
  while (d.signum() < 0) d.addTo(m, d)
  return d
}

var lowprimes = [
  2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,
  73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151,
  157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233,
  239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317,
  331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419,
  421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503,
  509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607,
  613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701,
  709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811,
  821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911,
  919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997
]

var lplim = (1 << 26) / lowprimes[lowprimes.length - 1]

// (public) test primality with certainty >= 1-.5^t
function bnIsProbablePrime(t) {
  var i, x = this.abs()
  if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
    for (i = 0; i < lowprimes.length; ++i)
      if (x[0] == lowprimes[i]) return true
    return false
  }
  if (x.isEven()) return false
  i = 1
  while (i < lowprimes.length) {
    var m = lowprimes[i],
      j = i + 1
    while (j < lowprimes.length && m < lplim) m *= lowprimes[j++]
    m = x.modInt(m)
    while (i < j) if (m % lowprimes[i++] == 0) return false
  }
  return x.millerRabin(t)
}

// (protected) true if probably prime (HAC 4.24, Miller-Rabin)
function bnpMillerRabin(t) {
  var n1 = this.subtract(BigInteger.ONE)
  var k = n1.getLowestSetBit()
  if (k <= 0) return false
  var r = n1.shiftRight(k)
  t = (t + 1) >> 1
  if (t > lowprimes.length) t = lowprimes.length
  var a = new BigInteger(null)
  var j, bases = []
  for (var i = 0; i < t; ++i) {
    for (;;) {
      j = lowprimes[Math.floor(Math.random() * lowprimes.length)]
      if (bases.indexOf(j) == -1) break
    }
    bases.push(j)
    a.fromInt(j)
    var y = a.modPow(r, this)
    if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
      var j = 1
      while (j++ < k && y.compareTo(n1) != 0) {
        y = y.modPowInt(2, this)
        if (y.compareTo(BigInteger.ONE) == 0) return false
      }
      if (y.compareTo(n1) != 0) return false
    }
  }
  return true
}

// protected
proto.chunkSize = bnpChunkSize
proto.toRadix = bnpToRadix
proto.fromRadix = bnpFromRadix
proto.fromNumber = bnpFromNumber
proto.bitwiseTo = bnpBitwiseTo
proto.changeBit = bnpChangeBit
proto.addTo = bnpAddTo
proto.dMultiply = bnpDMultiply
proto.dAddOffset = bnpDAddOffset
proto.multiplyLowerTo = bnpMultiplyLowerTo
proto.multiplyUpperTo = bnpMultiplyUpperTo
proto.modInt = bnpModInt
proto.millerRabin = bnpMillerRabin

// public
proto.clone = bnClone
proto.intValue = bnIntValue
proto.byteValue = bnByteValue
proto.shortValue = bnShortValue
proto.signum = bnSigNum
proto.toByteArray = bnToByteArray
proto.equals = bnEquals
proto.min = bnMin
proto.max = bnMax
proto.and = bnAnd
proto.or = bnOr
proto.xor = bnXor
proto.andNot = bnAndNot
proto.not = bnNot
proto.shiftLeft = bnShiftLeft
proto.shiftRight = bnShiftRight
proto.getLowestSetBit = bnGetLowestSetBit
proto.bitCount = bnBitCount
proto.testBit = bnTestBit
proto.setBit = bnSetBit
proto.clearBit = bnClearBit
proto.flipBit = bnFlipBit
proto.add = bnAdd
proto.subtract = bnSubtract
proto.multiply = bnMultiply
proto.divide = bnDivide
proto.remainder = bnRemainder
proto.divideAndRemainder = bnDivideAndRemainder
proto.modPow = bnModPow
proto.modInverse = bnModInverse
proto.pow = bnPow
proto.gcd = bnGCD
proto.isProbablePrime = bnIsProbablePrime

// JSBN-specific extension
proto.square = bnSquare

// constants
BigInteger.ZERO = nbv(0)
BigInteger.ONE = nbv(1)
BigInteger.valueOf = nbv

module.exports = BigInteger


/***/ }),
/* 372 */
/***/ (function(module, exports, __webpack_require__) {

var assert = __webpack_require__(45)
var Buffer = __webpack_require__(1).Buffer
var BigInteger = __webpack_require__(57)

var THREE = BigInteger.valueOf(3)

function Point (curve, x, y, z) {
  assert.notStrictEqual(z, undefined, 'Missing Z coordinate')

  this.curve = curve
  this.x = x
  this.y = y
  this.z = z
  this._zInv = null

  this.compressed = true
}

Object.defineProperty(Point.prototype, 'zInv', {
  get: function () {
    if (this._zInv === null) {
      this._zInv = this.z.modInverse(this.curve.p)
    }

    return this._zInv
  }
})

Object.defineProperty(Point.prototype, 'affineX', {
  get: function () {
    return this.x.multiply(this.zInv).mod(this.curve.p)
  }
})

Object.defineProperty(Point.prototype, 'affineY', {
  get: function () {
    return this.y.multiply(this.zInv).mod(this.curve.p)
  }
})

Point.fromAffine = function (curve, x, y) {
  return new Point(curve, x, y, BigInteger.ONE)
}

Point.prototype.equals = function (other) {
  if (other === this) return true
  if (this.curve.isInfinity(this)) return this.curve.isInfinity(other)
  if (this.curve.isInfinity(other)) return this.curve.isInfinity(this)

  // u = Y2 * Z1 - Y1 * Z2
  var u = other.y.multiply(this.z).subtract(this.y.multiply(other.z)).mod(this.curve.p)

  if (u.signum() !== 0) return false

  // v = X2 * Z1 - X1 * Z2
  var v = other.x.multiply(this.z).subtract(this.x.multiply(other.z)).mod(this.curve.p)

  return v.signum() === 0
}

Point.prototype.negate = function () {
  var y = this.curve.p.subtract(this.y)

  return new Point(this.curve, this.x, y, this.z)
}

Point.prototype.add = function (b) {
  if (this.curve.isInfinity(this)) return b
  if (this.curve.isInfinity(b)) return this

  var x1 = this.x
  var y1 = this.y
  var x2 = b.x
  var y2 = b.y

  // u = Y2 * Z1 - Y1 * Z2
  var u = y2.multiply(this.z).subtract(y1.multiply(b.z)).mod(this.curve.p)
  // v = X2 * Z1 - X1 * Z2
  var v = x2.multiply(this.z).subtract(x1.multiply(b.z)).mod(this.curve.p)

  if (v.signum() === 0) {
    if (u.signum() === 0) {
      return this.twice() // this == b, so double
    }

    return this.curve.infinity // this = -b, so infinity
  }

  var v2 = v.square()
  var v3 = v2.multiply(v)
  var x1v2 = x1.multiply(v2)
  var zu2 = u.square().multiply(this.z)

  // x3 = v * (z2 * (z1 * u^2 - 2 * x1 * v^2) - v^3)
  var x3 = zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.p)
  // y3 = z2 * (3 * x1 * u * v^2 - y1 * v^3 - z1 * u^3) + u * v^3
  var y3 = x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v3)).mod(this.curve.p)
  // z3 = v^3 * z1 * z2
  var z3 = v3.multiply(this.z).multiply(b.z).mod(this.curve.p)

  return new Point(this.curve, x3, y3, z3)
}

Point.prototype.twice = function () {
  if (this.curve.isInfinity(this)) return this
  if (this.y.signum() === 0) return this.curve.infinity

  var x1 = this.x
  var y1 = this.y

  var y1z1 = y1.multiply(this.z).mod(this.curve.p)
  var y1sqz1 = y1z1.multiply(y1).mod(this.curve.p)
  var a = this.curve.a

  // w = 3 * x1^2 + a * z1^2
  var w = x1.square().multiply(THREE)

  if (a.signum() !== 0) {
    w = w.add(this.z.square().multiply(a))
  }

  w = w.mod(this.curve.p)
  // x3 = 2 * y1 * z1 * (w^2 - 8 * x1 * y1^2 * z1)
  var x3 = w.square().subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.p)
  // y3 = 4 * y1^2 * z1 * (3 * w * x1 - 2 * y1^2 * z1) - w^3
  var y3 = w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.pow(3)).mod(this.curve.p)
  // z3 = 8 * (y1 * z1)^3
  var z3 = y1z1.pow(3).shiftLeft(3).mod(this.curve.p)

  return new Point(this.curve, x3, y3, z3)
}

// Simple NAF (Non-Adjacent Form) multiplication algorithm
// TODO: modularize the multiplication algorithm
Point.prototype.multiply = function (k) {
  if (this.curve.isInfinity(this)) return this
  if (k.signum() === 0) return this.curve.infinity

  var e = k
  var h = e.multiply(THREE)

  var neg = this.negate()
  var R = this

  for (var i = h.bitLength() - 2; i > 0; --i) {
    var hBit = h.testBit(i)
    var eBit = e.testBit(i)

    R = R.twice()

    if (hBit !== eBit) {
      R = R.add(hBit ? this : neg)
    }
  }

  return R
}

// Compute this*j + x*k (simultaneous multiplication)
Point.prototype.multiplyTwo = function (j, x, k) {
  var i = Math.max(j.bitLength(), k.bitLength()) - 1
  var R = this.curve.infinity
  var both = this.add(x)

  while (i >= 0) {
    var jBit = j.testBit(i)
    var kBit = k.testBit(i)

    R = R.twice()

    if (jBit) {
      if (kBit) {
        R = R.add(both)
      } else {
        R = R.add(this)
      }
    } else if (kBit) {
      R = R.add(x)
    }
    --i
  }

  return R
}

Point.prototype.getEncoded = function (compressed) {
  if (compressed == null) compressed = this.compressed
  if (this.curve.isInfinity(this)) return Buffer.alloc(1, 0) // Infinity point encoded is simply '00'

  var x = this.affineX
  var y = this.affineY
  var byteLength = this.curve.pLength
  var buffer

  // 0x02/0x03 | X
  if (compressed) {
    buffer = Buffer.allocUnsafe(1 + byteLength)
    buffer.writeUInt8(y.isEven() ? 0x02 : 0x03, 0)

  // 0x04 | X | Y
  } else {
    buffer = Buffer.allocUnsafe(1 + byteLength + byteLength)
    buffer.writeUInt8(0x04, 0)

    y.toBuffer(byteLength).copy(buffer, 1 + byteLength)
  }

  x.toBuffer(byteLength).copy(buffer, 1)

  return buffer
}

Point.decodeFrom = function (curve, buffer) {
  var type = buffer.readUInt8(0)
  var compressed = (type !== 4)

  var byteLength = Math.floor((curve.p.bitLength() + 7) / 8)
  var x = BigInteger.fromBuffer(buffer.slice(1, 1 + byteLength))

  var Q
  if (compressed) {
    assert.equal(buffer.length, byteLength + 1, 'Invalid sequence length')
    assert(type === 0x02 || type === 0x03, 'Invalid sequence tag')

    var isOdd = (type === 0x03)
    Q = curve.pointFromX(isOdd, x)
  } else {
    assert.equal(buffer.length, 1 + byteLength + byteLength, 'Invalid sequence length')

    var y = BigInteger.fromBuffer(buffer.slice(1 + byteLength))
    Q = Point.fromAffine(curve, x, y)
  }

  Q.compressed = compressed
  return Q
}

Point.prototype.toString = function () {
  if (this.curve.isInfinity(this)) return '(INFINITY)'

  return '(' + this.affineX.toString() + ',' + this.affineY.toString() + ')'
}

module.exports = Point


/***/ }),
/* 373 */
/***/ (function(module, exports, __webpack_require__) {

var assert = __webpack_require__(45)
var BigInteger = __webpack_require__(57)

var Point = __webpack_require__(372)

function Curve (p, a, b, Gx, Gy, n, h) {
  this.p = p
  this.a = a
  this.b = b
  this.G = Point.fromAffine(this, Gx, Gy)
  this.n = n
  this.h = h

  this.infinity = new Point(this, null, null, BigInteger.ZERO)

  // result caching
  this.pOverFour = p.add(BigInteger.ONE).shiftRight(2)

  // determine size of p in bytes
  this.pLength = Math.floor((this.p.bitLength() + 7) / 8)
}

Curve.prototype.pointFromX = function (isOdd, x) {
  var alpha = x.pow(3).add(this.a.multiply(x)).add(this.b).mod(this.p)
  var beta = alpha.modPow(this.pOverFour, this.p) // XXX: not compatible with all curves

  var y = beta
  if (beta.isEven() ^ !isOdd) {
    y = this.p.subtract(y) // -y % p
  }

  return Point.fromAffine(this, x, y)
}

Curve.prototype.isInfinity = function (Q) {
  if (Q === this.infinity) return true

  return Q.z.signum() === 0 && Q.y.signum() !== 0
}

Curve.prototype.isOnCurve = function (Q) {
  if (this.isInfinity(Q)) return true

  var x = Q.affineX
  var y = Q.affineY
  var a = this.a
  var b = this.b
  var p = this.p

  // Check that xQ and yQ are integers in the interval [0, p - 1]
  if (x.signum() < 0 || x.compareTo(p) >= 0) return false
  if (y.signum() < 0 || y.compareTo(p) >= 0) return false

  // and check that y^2 = x^3 + ax + b (mod p)
  var lhs = y.square().mod(p)
  var rhs = x.pow(3).add(a.multiply(x)).add(b).mod(p)
  return lhs.equals(rhs)
}

/**
 * Validate an elliptic curve point.
 *
 * See SEC 1, section 3.2.2.1: Elliptic Curve Public Key Validation Primitive
 */
Curve.prototype.validate = function (Q) {
  // Check Q != O
  assert(!this.isInfinity(Q), 'Point is at infinity')
  assert(this.isOnCurve(Q), 'Point is not on the curve')

  // Check nQ = O (where Q is a scalar multiple of G)
  var nQ = Q.multiply(this.n)
  assert(this.isInfinity(nQ), 'Point is not a scalar multiple of G')

  return true
}

module.exports = Curve


/***/ }),
/* 374 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _bytebuffer = __webpack_require__(130);

var _SerializerValidation = __webpack_require__(145);

var _SerializerValidation2 = _interopRequireDefault(_SerializerValidation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DB_MAX_INSTANCE_ID = _bytebuffer.Long.fromNumber(Math.pow(2, 48) - 1);

var ObjectId = function () {
    function ObjectId(space, type, instance) {
        _classCallCheck(this, ObjectId);

        this.space = space;
        this.type = type;
        this.instance = instance;
        var instance_string = this.instance.toString();
        var _ObjectId = this.space + '.' + this.type + '.' + instance_string;
        if (!_SerializerValidation2.default.is_digits(instance_string)) {
            throw new ('Invalid object id ' + _ObjectId)();
        }
    }

    ObjectId.fromString = function fromString(value) {
        if (value.space !== undefined && value.type !== undefined && value.instance !== undefined) {
            return value;
        }

        var params = _SerializerValidation2.default.require_match(/^([0-9]+)\.([0-9]+)\.([0-9]+)$/, _SerializerValidation2.default.required(value, "ObjectId"), "ObjectId");
        return new ObjectId(parseInt(params[1]), parseInt(params[2]), _bytebuffer.Long.fromString(params[3]));
    };

    ObjectId.fromLong = function fromLong(long) {
        var space = long.shiftRight(56).toInt();
        var type = long.shiftRight(48).toInt() & 0x00ff;
        var instance = long.and(DB_MAX_INSTANCE_ID);
        return new ObjectId(space, type, instance);
    };

    ObjectId.fromByteBuffer = function fromByteBuffer(b) {
        return ObjectId.fromLong(b.readUint64());
    };

    ObjectId.prototype.toLong = function toLong() {
        return _bytebuffer.Long.fromNumber(this.space).shiftLeft(56).or(_bytebuffer.Long.fromNumber(this.type).shiftLeft(48).or(this.instance));
    };

    ObjectId.prototype.appendByteBuffer = function appendByteBuffer(b) {
        b.writeUint8(this.space);
        b.writeUint8(this.type);
        return b.writeUint64(this.instance);
    };

    ObjectId.prototype.toString = function toString() {
        return this.space + '.' + this.type + '.' + this.instance.toString();
    };

    return ObjectId;
}();

exports.default = ObjectId;
module.exports = exports['default'];

/***/ }),
/* 375 */
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(81));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * Base64 encoding strategy.
	     */
	    var Base64 = C_enc.Base64 = {
	        /**
	         * Converts a word array to a Base64 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Base64 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;
	            var map = this._map;

	            // Clamp excess bits
	            wordArray.clamp();

	            // Convert
	            var base64Chars = [];
	            for (var i = 0; i < sigBytes; i += 3) {
	                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
	                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
	                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

	                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

	                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
	                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
	                }
	            }

	            // Add padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                while (base64Chars.length % 4) {
	                    base64Chars.push(paddingChar);
	                }
	            }

	            return base64Chars.join('');
	        },

	        /**
	         * Converts a Base64 string to a word array.
	         *
	         * @param {string} base64Str The Base64 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
	         */
	        parse: function (base64Str) {
	            // Shortcuts
	            var base64StrLength = base64Str.length;
	            var map = this._map;
	            var reverseMap = this._reverseMap;

	            if (!reverseMap) {
	                    reverseMap = this._reverseMap = [];
	                    for (var j = 0; j < map.length; j++) {
	                        reverseMap[map.charCodeAt(j)] = j;
	                    }
	            }

	            // Ignore padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                var paddingIndex = base64Str.indexOf(paddingChar);
	                if (paddingIndex !== -1) {
	                    base64StrLength = paddingIndex;
	                }
	            }

	            // Convert
	            return parseLoop(base64Str, base64StrLength, reverseMap);

	        },

	        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
	    };

	    function parseLoop(base64Str, base64StrLength, reverseMap) {
	      var words = [];
	      var nBytes = 0;
	      for (var i = 0; i < base64StrLength; i++) {
	          if (i % 4) {
	              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
	              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
	              words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);
	              nBytes++;
	          }
	      }
	      return WordArray.create(words, nBytes);
	    }
	}());


	return CryptoJS.enc.Base64;

}));

/***/ }),
/* 376 */
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(81), __webpack_require__(460), __webpack_require__(461));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./sha1", "./hmac"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var MD5 = C_algo.MD5;

	    /**
	     * This key derivation function is meant to conform with EVP_BytesToKey.
	     * www.openssl.org/docs/crypto/EVP_BytesToKey.html
	     */
	    var EvpKDF = C_algo.EvpKDF = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hash algorithm to use. Default: MD5
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: MD5,
	            iterations: 1
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.EvpKDF.create();
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Derives a key from a password.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            // Shortcut
	            var cfg = this.cfg;

	            // Init hasher
	            var hasher = cfg.hasher.create();

	            // Initial values
	            var derivedKey = WordArray.create();

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                if (block) {
	                    hasher.update(block);
	                }
	                var block = hasher.update(password).finalize(salt);
	                hasher.reset();

	                // Iterations
	                for (var i = 1; i < iterations; i++) {
	                    block = hasher.finalize(block);
	                    hasher.reset();
	                }

	                derivedKey.concat(block);
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Derives a key from a password.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.EvpKDF(password, salt);
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.EvpKDF = function (password, salt, cfg) {
	        return EvpKDF.create(cfg).compute(password, salt);
	    };
	}());


	return CryptoJS.EvpKDF;

}));

/***/ }),
/* 377 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

exports.__esModule = true;

var _ecdsa = __webpack_require__(464);

var _hash2 = __webpack_require__(58);

var _ecurve = __webpack_require__(215);

var _assert = __webpack_require__(45);

var _assert2 = _interopRequireDefault(_assert);

var _bigi = __webpack_require__(57);

var _bigi2 = _interopRequireDefault(_bigi);

var _PublicKey = __webpack_require__(97);

var _PublicKey2 = _interopRequireDefault(_PublicKey);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var secp256k1 = (0, _ecurve.getCurveByName)('secp256k1');

var Signature = function () {
    function Signature(r1, s1, i1) {
        _classCallCheck(this, Signature);

        this.r = r1;
        this.s = s1;
        this.i = i1;
        _assert2.default.equal(this.r != null, true, 'Missing parameter');
        _assert2.default.equal(this.s != null, true, 'Missing parameter');
        _assert2.default.equal(this.i != null, true, 'Missing parameter');
    }

    Signature.fromBuffer = function fromBuffer(buf) {
        var i, r, s;
        _assert2.default.equal(buf.length, 65, 'Invalid signature length');
        i = buf.readUInt8(0);
        _assert2.default.equal(i - 27, i - 27 & 7, 'Invalid signature parameter');
        r = _bigi2.default.fromBuffer(buf.slice(1, 33));
        s = _bigi2.default.fromBuffer(buf.slice(33));
        return new Signature(r, s, i);
    };

    Signature.prototype.toBuffer = function toBuffer() {
        var buf;
        buf = new Buffer(65);
        buf.writeUInt8(this.i, 0);
        this.r.toBuffer(32).copy(buf, 1);
        this.s.toBuffer(32).copy(buf, 33);
        return buf;
    };

    Signature.prototype.recoverPublicKeyFromBuffer = function recoverPublicKeyFromBuffer(buffer) {
        return this.recoverPublicKey((0, _hash2.sha256)(buffer));
    };

    /**
        @return {PublicKey}
    */
    Signature.prototype.recoverPublicKey = function recoverPublicKey(sha256_buffer) {
        var Q = void 0,
            e = void 0,
            i = void 0;
        e = _bigi2.default.fromBuffer(sha256_buffer);
        i = this.i;
        i -= 27;
        i = i & 3;
        Q = (0, _ecdsa.recoverPubKey)(secp256k1, e, this, i);
        return _PublicKey2.default.fromPoint(Q);
    };

    /**
        @param {Buffer} buf
        @param {PrivateKey} private_key
        @return {Signature}
    */
    Signature.signBuffer = function signBuffer(buf, private_key) {
        var _hash = (0, _hash2.sha256)(buf);
        return Signature.signBufferSha256(_hash, private_key);
    };

    /** Sign a buffer of exactally 32 bytes in size (sha256(text))
        @param {Buffer} buf - 32 bytes binary
        @param {PrivateKey} private_key
        @return {Signature}
    */


    Signature.signBufferSha256 = function signBufferSha256(buf_sha256, private_key) {
        if (buf_sha256.length !== 32 || !Buffer.isBuffer(buf_sha256)) throw new Error("buf_sha256: 32 byte buffer requred");
        var der, e, ecsignature, i, lenR, lenS, nonce;
        i = null;
        nonce = 0;
        e = _bigi2.default.fromBuffer(buf_sha256);
        while (true) {
            ecsignature = (0, _ecdsa.sign)(secp256k1, buf_sha256, private_key.d, nonce++);
            der = ecsignature.toDER();
            lenR = der[3];
            lenS = der[5 + lenR];
            if (lenR === 32 && lenS === 32) {
                i = (0, _ecdsa.calcPubKeyRecoveryParam)(secp256k1, e, ecsignature, private_key.toPublicKey().Q);
                i += 4; // compressed
                i += 27; // compact  //  24 or 27 :( forcing odd-y 2nd key candidate)
                break;
            }
            if (nonce % 10 === 0) {
                console.log("WARN: " + nonce + " attempts to find canonical signature");
            }
        }
        return new Signature(ecsignature.r, ecsignature.s, i);
    };

    Signature.sign = function sign(string, private_key) {
        return Signature.signBuffer(new Buffer(string), private_key);
    };

    /**
        @param {Buffer} un-hashed
        @param {./PublicKey}
        @return {boolean}
    */
    Signature.prototype.verifyBuffer = function verifyBuffer(buf, public_key) {
        var _hash = (0, _hash2.sha256)(buf);
        return this.verifyHash(_hash, public_key);
    };

    Signature.prototype.verifyHash = function verifyHash(hash, public_key) {
        _assert2.default.equal(hash.length, 32, "A SHA 256 should be 32 bytes long, instead got " + hash.length);
        return (0, _ecdsa.verify)(secp256k1, hash, {
            r: this.r,
            s: this.s
        }, public_key.Q);
    };

    /* <HEX> */

    Signature.prototype.toByteBuffer = function toByteBuffer() {
        var b;
        b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);
        this.appendByteBuffer(b);
        return b.copy(0, b.offset);
    };

    Signature.fromHex = function fromHex(hex) {
        return Signature.fromBuffer(new Buffer(hex, "hex"));
    };

    Signature.prototype.toHex = function toHex() {
        return this.toBuffer().toString("hex");
    };

    Signature.signHex = function signHex(hex, private_key) {
        var buf;
        buf = new Buffer(hex, 'hex');
        return Signature.signBuffer(buf, private_key);
    };

    Signature.prototype.verifyHex = function verifyHex(hex, public_key) {
        var buf;
        buf = new Buffer(hex, 'hex');
        return this.verifyBuffer(buf, public_key);
    };

    return Signature;
}();

exports.default = Signature;
module.exports = exports['default'];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),
/* 378 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

exports.__esModule = true;
exports.default = enforce;
function enforce(type, value) {
  // Copied from https://github.com/bitcoinjs/bitcoinjs-lib
  switch (type) {
    case 'Array':
      {
        if (Array.isArray(value)) return;
        break;
      }

    case 'Boolean':
      {
        if (typeof value === 'boolean') return;
        break;
      }

    case 'Buffer':
      {
        if (Buffer.isBuffer(value)) return;
        break;
      }

    case 'Number':
      {
        if (typeof value === 'number') return;
        break;
      }

    case 'String':
      {
        if (typeof value === 'string') return;
        break;
      }

    default:
      {
        if (getName(value.constructor) === getName(type)) return;
      }
  }

  throw new TypeError('Expected ' + (getName(type) || type) + ', got ' + value);
}

function getName(fn) {
  // Why not fn.name: https://kangax.github.io/compat-table/es6/#function_name_property
  var match = fn.toString().match(/function (.*?)\(/);
  return match ? match[1] : null;
}
module.exports = exports['default'];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),
/* 379 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = normalize;
function normalize(brainKey) {
    if (typeof brainKey !== 'string') {
        throw new Error("string required for brainKey");
    }
    brainKey = brainKey.trim();
    return brainKey.split(/[\t\n\v\f\r ]+/).join(' ');
}
module.exports = exports['default'];

/***/ }),
/* 380 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, Buffer) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!function(globals){
'use strict'

//*** UMD BEGIN
if (true) { //require.js / AMD
  !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
    return secureRandom
  }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
} else if (typeof module !== 'undefined' && module.exports) { //CommonJS
  module.exports = secureRandom
} else { //script / browser
  globals.secureRandom = secureRandom
}
//*** UMD END

//options.type is the only valid option
function secureRandom(count, options) {
  options = options || {type: 'Array'}
  //we check for process.pid to prevent browserify from tricking us
  if (typeof process != 'undefined' && typeof process.pid == 'number') {
    return nodeRandom(count, options)
  } else {
    var crypto = window.crypto || window.msCrypto
    if (!crypto) throw new Error("Your browser does not support window.crypto.")
    return browserRandom(count, options)
  }
}

function nodeRandom(count, options) {
  var crypto = __webpack_require__(466)
  var buf = crypto.randomBytes(count)

  switch (options.type) {
    case 'Array':
      return [].slice.call(buf)
    case 'Buffer':
      return buf
    case 'Uint8Array':
      var arr = new Uint8Array(count)
      for (var i = 0; i < count; ++i) { arr[i] = buf.readUInt8(i) }
      return arr
    default:
      throw new Error(options.type + " is unsupported.")
  }
}

function browserRandom(count, options) {
  var nativeArr = new Uint8Array(count)
  var crypto = window.crypto || window.msCrypto
  crypto.getRandomValues(nativeArr)

  switch (options.type) {
    case 'Array':
      return [].slice.call(nativeArr)
    case 'Buffer':
      try { var b = new Buffer(1) } catch(e) { throw new Error('Buffer not supported in this environment. Use Node.js or Browserify for browser support.')}
      return new Buffer(nativeArr)
    case 'Uint8Array':
      return nativeArr
    default:
      throw new Error(options.type + " is unsupported.")
  }
}

secureRandom.randomArray = function(byteCount) {
  return secureRandom(byteCount, {type: 'Array'})
}

secureRandom.randomUint8Array = function(byteCount) {
  return secureRandom(byteCount, {type: 'Uint8Array'})
}

secureRandom.randomBuffer = function(byteCount) {
  return secureRandom(byteCount, {type: 'Buffer'})
}


}(this);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9), __webpack_require__(2).Buffer))

/***/ }),
/* 381 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.stealth_memo_data = exports.signed_transaction = exports.transaction = exports.asset_claim_fees = exports.asset_settle_cancel = exports.transfer_from_blind = exports.blind_transfer = exports.blind_input = exports.transfer_to_blind = exports.blind_output = exports.stealth_confirmation = exports.override_transfer = exports.balance_claim = exports.assert = exports.block_id_predicate = exports.asset_symbol_eq_lit_predicate = exports.account_name_eq_lit_predicate = exports.custom = exports.worker_create = undefined;
exports.burn_worker_initializer = exports.vesting_balance_worker_initializer = exports.refund_worker_initializer = exports.vesting_balance_withdraw = exports.vesting_balance_create = exports.cdd_vesting_policy_initializer = exports.linear_vesting_policy_initializer = exports.committee_member_update_global_parameters = exports.chain_parameters = exports.committee_member_update = exports.committee_member_create = exports.withdraw_permission_delete = exports.withdraw_permission_claim = exports.withdraw_permission_update = exports.withdraw_permission_create = exports.proposal_delete = exports.proposal_update = exports.proposal_create = exports.op_wrapper = exports.witness_update = exports.witness_create = exports.asset_publish_feed = exports.price_feed = exports.asset_global_settle = exports.asset_settle = exports.asset_fund_fee_pool = exports.asset_reserve = exports.asset_issue = exports.asset_update_feed_producers=exports.asset_update_restricted = exports.asset_update_bitasset = exports.asset_update = exports.asset_create = exports.bitasset_options = exports.asset_options = exports.price = exports.account_transfer = exports.account_upgrade = exports.account_update =exports.contract_create=exports.call_contract_function=exports.register_nh_asset_creator=exports.create_world_view=exports.relate_world_view=exports.create_nh_asset=exports.update_collateral_for_gas=exports.delete_nh_asset=exports.transfer_nh_asset=exports.create_nh_asset_order=exports.cancel_nh_asset_order=exports.fill_nh_asset_order=exports.revise_contract=exports.crontab_create=exports.crontab_cancel=exports.crontab_recover=exports.account_create = exports.account_options = exports.authority = exports.fill_order = exports.call_order_update = exports.limit_order_cancel = exports.limit_order_create = exports.transfer = exports.memo_data = exports.signed_block_header = exports.block_header = exports.signed_block = exports.processed_transaction = exports.asset = exports.void_result = exports.fee_schedule = exports.asset_claim_fees_operation_fee_parameters = exports.asset_settle_cancel_operation_fee_parameters = exports.transfer_from_blind_operation_fee_parameters = exports.blind_transfer_operation_fee_parameters = exports.transfer_to_blind_operation_fee_parameters = exports.override_transfer_operation_fee_parameters = exports.balance_claim_operation_fee_parameters = exports.assert_operation_fee_parameters = exports.custom_operation_fee_parameters = exports.worker_create_operation_fee_parameters = exports.vesting_balance_withdraw_operation_fee_parameters = exports.vesting_balance_create_operation_fee_parameters = exports.committee_member_update_global_parameters_operation_fee_parameters = exports.committee_member_update_operation_fee_parameters = exports.committee_member_create_operation_fee_parameters = exports.withdraw_permission_delete_operation_fee_parameters = exports.withdraw_permission_claim_operation_fee_parameters = exports.withdraw_permission_update_operation_fee_parameters = exports.withdraw_permission_create_operation_fee_parameters = exports.proposal_delete_operation_fee_parameters = exports.proposal_update_operation_fee_parameters = exports.proposal_create_operation_fee_parameters = exports.witness_update_operation_fee_parameters = exports.witness_create_operation_fee_parameters = exports.asset_publish_feed_operation_fee_parameters = exports.asset_global_settle_operation_fee_parameters = exports.asset_settle_operation_fee_parameters = exports.asset_fund_fee_pool_operation_fee_parameters = exports.asset_reserve_operation_fee_parameters = exports.asset_issue_operation_fee_parameters = exports.asset_update_feed_producers_operation_fee_parameters = exports.asset_update_bitasset_operation_fee_parameters = exports.asset_update_operation_fee_parameters = exports.asset_create_operation_fee_parameters = exports.account_transfer_operation_fee_parameters = exports.account_upgrade_operation_fee_parameters = exports.account_update_operation_fee_parameters = exports.account_create_operation_fee_parameters = exports.fill_order_operation_fee_parameters = exports.call_order_update_operation_fee_parameters = exports.limit_order_cancel_operation_fee_parameters = exports.limit_order_create_operation_fee_parameters = exports.transfer_operation_fee_parameters = exports.operation = undefined;

var _types = __webpack_require__(218);

var _types2 = _interopRequireDefault(_types);

var _serializer = __webpack_require__(213);

var _serializer2 = _interopRequireDefault(_serializer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var uint8 = _types2.default.uint8,
    uint16 = _types2.default.uint16,
    uint32 = _types2.default.uint32,
    int64 = _types2.default.int64,
    int32 = _types2.default.int32,
    double=_types2.default.double,
    varint32 = _types2.default.varint32,
    uint64 = _types2.default.uint64,
    string = _types2.default.string,
    bytes = _types2.default.bytes,
    bool = _types2.default.bool,
    array = _types2.default.array,
    fixed_array = _types2.default.fixed_array,
    protocol_id_type = _types2.default.protocol_id_type,
    nh_protocol_id_type = _types2.default.nh_protocol_id_type,
    object_id_type = _types2.default.object_id_type,
    vote_id = _types2.default.vote_id,
    future_extensions = _types2.default.future_extensions,
    static_variant = _types2.default.static_variant,
    lua_types = _types2.default.lua_types,
    table=_types2.default.table,

    map = _types2.default.map,
    pair = _types2.default.pair,

    
    set = _types2.default.set,
    public_key = _types2.default.public_key,
    address = _types2.default.address,
    time_point_sec = _types2.default.time_point_sec,
    optional = _types2.default.optional;


future_extensions =string; //_types2.default.void;

/*
When updating generated code
Replace:  operation = static_variant [
with:     operation.st_operations = [

Delete:
public_key = new Serializer(
    "public_key"
    key_data: bytes 33
)

*/
// Place-holder, their are dependencies on "operation" .. The final list of
// operations is not avialble until the very end of the generated code.
// See: operation.st_operations = ...
var operation = static_variant();
// module.exports["operation"] = operation;

exports.operation = operation;
// For module.exports

var Serializer = function Serializer(operation_name, serilization_types_object) {
    return new _serializer2.default(operation_name, serilization_types_object);
    // return module.exports[operation_name] = s;
};

// Custom-types follow Generated code:

// ##  Generated code follows
// # programs/js_operation_serializer > npm i -g decaffeinate
// ## -------------------------------
var transfer_operation_fee_parameters = exports.transfer_operation_fee_parameters = new Serializer("transfer_operation_fee_parameters", { fee: uint64,
    price_per_kbyte: uint32 });

var limit_order_create_operation_fee_parameters = exports.limit_order_create_operation_fee_parameters = new Serializer("limit_order_create_operation_fee_parameters", { fee: uint64 });

var limit_order_cancel_operation_fee_parameters = exports.limit_order_cancel_operation_fee_parameters = new Serializer("limit_order_cancel_operation_fee_parameters", { fee: uint64 });

var call_order_update_operation_fee_parameters = exports.call_order_update_operation_fee_parameters = new Serializer("call_order_update_operation_fee_parameters", { fee: uint64 });

var fill_order_operation_fee_parameters = exports.fill_order_operation_fee_parameters = new Serializer("fill_order_operation_fee_parameters");

var account_create_operation_fee_parameters = exports.account_create_operation_fee_parameters = new Serializer("account_create_operation_fee_parameters", { basic_fee: uint64,
    premium_fee: uint64,
    price_per_kbyte: uint32 });

var account_update_operation_fee_parameters = exports.account_update_operation_fee_parameters = new Serializer("account_update_operation_fee_parameters", { fee: int64,
    price_per_kbyte: uint32 });

//43
var contract_create_operation_fee_parameters = exports.contract_create_operation_fee_parameters = new Serializer("account_update_operation_fee_parameters", { fee: int64,
        price_per_kbyte: uint32 });
 //44
var call_contract_function_operation_fee_parameters = exports.call_contract_function_operation_fee_parameters = new Serializer("call_contract_function_operation_fee_parameters", { fee: int64,
    price_per_kbyte: uint32 });      
    
//46
var register_nh_asset_creator_operation_fee_parameters = exports.register_nh_asset_creator_operation_fee_parameters = new Serializer("account_update_operation_fee_parameters", { fee: int64,
    price_per_kbyte: uint32 });
//47 
var create_world_view_operation_fee_parameters = exports.create_world_view_operation_fee_parameters = new Serializer("create_world_view_operation_fee_parameters", { fee: int64,
    price_per_kbyte: uint32 });

//48
var relate_world_view_operation_fee_parameters = exports.relate_world_view_operation_fee_parameters = new Serializer("relate_world_view_operation_fee_parameters", { fee: int64,
    price_per_kbyte: uint32 });

//49
var create_nh_asset_operation_fee_parameters = exports.create_nh_asset_operation_fee_parameters = new Serializer("create_nh_asset_operation_fee_parameters", { fee: int64,
    price_per_kbyte: uint32 });


var update_collateral_for_gas_operation_fee_parameters = exports.update_collateral_for_gas_operation_fee_parameters = new Serializer("update_collateral_for_gas_operation_fee_parameters", { fee: int64,
    price_per_kbyte: uint32 });

//50
var delete_nh_asset_operation_fee_parameters = exports.delete_nh_asset_operation_fee_parameters = new Serializer("delete_nh_asset_operation_fee_parameters", { fee: int64,
    price_per_kbyte: uint32 });

//51
var transfer_nh_asset_operation_fee_parameters = exports.transfer_nh_asset_operation_fee_parameters = new Serializer("transfer_nh_asset_operation_fee_parameters", { fee: int64,
    price_per_kbyte: uint32 });

//52
var create_nh_asset_order_operation_fee_parameters = exports.create_nh_asset_order_operation_fee_parameters = new Serializer("create_nh_asset_order_operation_fee_parameters", { fee: int64,
    price_per_kbyte: uint32 }); 

//53
var cancel_nh_asset_order_operation_fee_parameters = exports.cancel_nh_asset_order_operation_fee_parameters = new Serializer("cancel_nh_asset_order_operation_fee_parameters", { fee: int64,
    price_per_kbyte: uint32 }); 

//54
var fill_nh_asset_order_operation_fee_parameters = exports.fill_nh_asset_order_operation_fee_parameters = new Serializer("fill_nh_asset_order_operation_fee_parameters", { fee: int64,
    price_per_kbyte: uint32 }); 
//59
var revise_contract_operation_fee_parameters = exports.revise_contract_operation_fee_parameters = new Serializer("revise_contract_operation_fee_parameters", { fee: int64,
    price_per_kbyte: uint32 });    

//60
var crontab_create_operation_fee_parameters = exports.crontab_create_operation_fee_parameters = new Serializer("crontab_create_operation_fee_parameters", { fee: int64,
    price_per_kbyte: uint32 });    

//61
var crontab_cancel_operation_fee_parameters = exports.crontab_cancel_operation_fee_parameters = new Serializer("crontab_cancel_operation_fee_parameters", { fee: int64,
    price_per_kbyte: uint32 }); 
       
//62
var crontab_recover_operation_fee_parameters = exports.crontab_recover_operation_fee_parameters = new Serializer("crontab_recover_operation_fee_parameters", { fee: int64,
    price_per_kbyte: uint32 });    
    

//44
var fba_distribute_operation_fee_parameters = exports.fba_distribute_operation_fee_parameters = new Serializer("fba_distribute_operation_fee_parameters", { fee: int64,
            price_per_kbyte: uint32 });
//45

var bid_collateral_operation_fee_parameters = exports.bid_collateral_operation_fee_parameters = new Serializer("bid_collateral_operation_fee_parameters", { fee: int64,
            price_per_kbyte: uint32 });
            

            
var account_upgrade_operation_fee_parameters = exports.account_upgrade_operation_fee_parameters = new Serializer("account_upgrade_operation_fee_parameters", { membership_annual_fee: uint64,
    membership_lifetime_fee: uint64 });

var account_transfer_operation_fee_parameters = exports.account_transfer_operation_fee_parameters = new Serializer("account_transfer_operation_fee_parameters", { fee: uint64 });

var asset_create_operation_fee_parameters = exports.asset_create_operation_fee_parameters = new Serializer("asset_create_operation_fee_parameters", { symbol3: uint64,
    symbol4: uint64,
    long_symbol: uint64,
    price_per_kbyte: uint32 });

var asset_update_operation_fee_parameters = exports.asset_update_operation_fee_parameters = new Serializer("asset_update_operation_fee_parameters", { fee: uint64,
    price_per_kbyte: uint32 });


    
var asset_update_restricted_operation_fee_parameters = exports.asset_update_restricted_operation_fee_parameters = new Serializer("asset_update_restricted_operation_fee_parameters", { fee: uint64 });

var asset_update_bitasset_operation_fee_parameters = exports.asset_update_bitasset_operation_fee_parameters = new Serializer("asset_update_bitasset_operation_fee_parameters", { fee: uint64 });

var asset_update_feed_producers_operation_fee_parameters = exports.asset_update_feed_producers_operation_fee_parameters = new Serializer("asset_update_feed_producers_operation_fee_parameters", { fee: uint64 });

var asset_issue_operation_fee_parameters = exports.asset_issue_operation_fee_parameters = new Serializer("asset_issue_operation_fee_parameters", { fee: uint64,
    price_per_kbyte: uint32 });

var asset_reserve_operation_fee_parameters = exports.asset_reserve_operation_fee_parameters = new Serializer("asset_reserve_operation_fee_parameters", { fee: uint64 });

var asset_fund_fee_pool_operation_fee_parameters = exports.asset_fund_fee_pool_operation_fee_parameters = new Serializer("asset_fund_fee_pool_operation_fee_parameters", { fee: uint64 });

var asset_settle_operation_fee_parameters = exports.asset_settle_operation_fee_parameters = new Serializer("asset_settle_operation_fee_parameters", { fee: uint64 });

var asset_global_settle_operation_fee_parameters = exports.asset_global_settle_operation_fee_parameters = new Serializer("asset_global_settle_operation_fee_parameters", { fee: uint64 });

var asset_publish_feed_operation_fee_parameters = exports.asset_publish_feed_operation_fee_parameters = new Serializer("asset_publish_feed_operation_fee_parameters", { fee: uint64 });

var witness_create_operation_fee_parameters = exports.witness_create_operation_fee_parameters = new Serializer("witness_create_operation_fee_parameters", { fee: uint64 });

var witness_update_operation_fee_parameters = exports.witness_update_operation_fee_parameters = new Serializer("witness_update_operation_fee_parameters", { fee: int64 });

var proposal_create_operation_fee_parameters = exports.proposal_create_operation_fee_parameters = new Serializer("proposal_create_operation_fee_parameters", { fee: uint64,
    price_per_kbyte: uint32 });

var proposal_update_operation_fee_parameters = exports.proposal_update_operation_fee_parameters = new Serializer("proposal_update_operation_fee_parameters", { fee: uint64,
    price_per_kbyte: uint32 });

var proposal_delete_operation_fee_parameters = exports.proposal_delete_operation_fee_parameters = new Serializer("proposal_delete_operation_fee_parameters", { fee: uint64 });

var withdraw_permission_create_operation_fee_parameters = exports.withdraw_permission_create_operation_fee_parameters = new Serializer("withdraw_permission_create_operation_fee_parameters", { fee: uint64 });

var withdraw_permission_update_operation_fee_parameters = exports.withdraw_permission_update_operation_fee_parameters = new Serializer("withdraw_permission_update_operation_fee_parameters", { fee: uint64 });

var withdraw_permission_claim_operation_fee_parameters = exports.withdraw_permission_claim_operation_fee_parameters = new Serializer("withdraw_permission_claim_operation_fee_parameters", { fee: uint64,
    price_per_kbyte: uint32 });

var withdraw_permission_delete_operation_fee_parameters = exports.withdraw_permission_delete_operation_fee_parameters = new Serializer("withdraw_permission_delete_operation_fee_parameters", { fee: uint64 });

var committee_member_create_operation_fee_parameters = exports.committee_member_create_operation_fee_parameters = new Serializer("committee_member_create_operation_fee_parameters", { fee: uint64 });

var committee_member_update_operation_fee_parameters = exports.committee_member_update_operation_fee_parameters = new Serializer("committee_member_update_operation_fee_parameters", { fee: uint64 });

var committee_member_update_global_parameters_operation_fee_parameters = exports.committee_member_update_global_parameters_operation_fee_parameters = new Serializer("committee_member_update_global_parameters_operation_fee_parameters", { fee: uint64 });

var vesting_balance_create_operation_fee_parameters = exports.vesting_balance_create_operation_fee_parameters = new Serializer("vesting_balance_create_operation_fee_parameters", { fee: uint64 });

var vesting_balance_withdraw_operation_fee_parameters = exports.vesting_balance_withdraw_operation_fee_parameters = new Serializer("vesting_balance_withdraw_operation_fee_parameters", { fee: uint64 });

var worker_create_operation_fee_parameters = exports.worker_create_operation_fee_parameters = new Serializer("worker_create_operation_fee_parameters", { fee: uint64 });

var custom_operation_fee_parameters = exports.custom_operation_fee_parameters = new Serializer("custom_operation_fee_parameters", { fee: uint64,
    price_per_kbyte: uint32 });

var assert_operation_fee_parameters = exports.assert_operation_fee_parameters = new Serializer("assert_operation_fee_parameters", { fee: uint64 });

var balance_claim_operation_fee_parameters = exports.balance_claim_operation_fee_parameters = new Serializer("balance_claim_operation_fee_parameters");

var override_transfer_operation_fee_parameters = exports.override_transfer_operation_fee_parameters = new Serializer("override_transfer_operation_fee_parameters", { fee: uint64,
    price_per_kbyte: uint32 });

var transfer_to_blind_operation_fee_parameters = exports.transfer_to_blind_operation_fee_parameters = new Serializer("transfer_to_blind_operation_fee_parameters", { fee: uint64,
    price_per_output: uint32 });

var blind_transfer_operation_fee_parameters = exports.blind_transfer_operation_fee_parameters = new Serializer("blind_transfer_operation_fee_parameters", { fee: uint64,
    price_per_output: uint32 });

var transfer_from_blind_operation_fee_parameters = exports.transfer_from_blind_operation_fee_parameters = new Serializer("transfer_from_blind_operation_fee_parameters", { fee: uint64 });

var asset_settle_cancel_operation_fee_parameters = exports.asset_settle_cancel_operation_fee_parameters = new Serializer("asset_settle_cancel_operation_fee_parameters");

var asset_claim_fees_operation_fee_parameters = exports.asset_claim_fees_operation_fee_parameters = new Serializer("asset_claim_fees_operation_fee_parameters", { fee: uint64 });

var fee_parameters = static_variant([
    transfer_operation_fee_parameters, limit_order_create_operation_fee_parameters, limit_order_cancel_operation_fee_parameters, call_order_update_operation_fee_parameters, fill_order_operation_fee_parameters, 
    account_create_operation_fee_parameters, account_update_operation_fee_parameters, account_upgrade_operation_fee_parameters, asset_create_operation_fee_parameters, asset_update_operation_fee_parameters,

    asset_update_restricted_operation_fee_parameters,asset_update_bitasset_operation_fee_parameters,asset_update_feed_producers_operation_fee_parameters, asset_issue_operation_fee_parameters, asset_reserve_operation_fee_parameters,
    // asset_fund_fee_pool_operation_fee_parameters,
    asset_settle_operation_fee_parameters, asset_global_settle_operation_fee_parameters,
     asset_publish_feed_operation_fee_parameters, asset_publish_feed_operation_fee_parameters,//witness_create_operation_fee_parameters,
     witness_update_operation_fee_parameters,
   proposal_create_operation_fee_parameters, proposal_update_operation_fee_parameters, proposal_delete_operation_fee_parameters, withdraw_permission_create_operation_fee_parameters, withdraw_permission_update_operation_fee_parameters, 
   withdraw_permission_claim_operation_fee_parameters, withdraw_permission_delete_operation_fee_parameters, committee_member_create_operation_fee_parameters, committee_member_update_operation_fee_parameters, committee_member_update_global_parameters_operation_fee_parameters, vesting_balance_create_operation_fee_parameters, vesting_balance_withdraw_operation_fee_parameters, worker_create_operation_fee_parameters, balance_claim_operation_fee_parameters, transfer_to_blind_operation_fee_parameters, blind_transfer_operation_fee_parameters, transfer_from_blind_operation_fee_parameters, asset_settle_cancel_operation_fee_parameters,
    asset_claim_fees_operation_fee_parameters,fba_distribute_operation_fee_parameters, bid_collateral_operation_fee_parameters,
    contract_create_operation_fee_parameters,call_contract_function_operation_fee_parameters,call_contract_function_operation_fee_parameters,
    register_nh_asset_creator_operation_fee_parameters,create_world_view_operation_fee_parameters,relate_world_view_operation_fee_parameters,create_nh_asset_operation_fee_parameters,delete_nh_asset_operation_fee_parameters,
    transfer_nh_asset_operation_fee_parameters,create_nh_asset_order_operation_fee_parameters,cancel_nh_asset_order_operation_fee_parameters,fill_nh_asset_order_operation_fee_parameters,revise_contract_operation_fee_parameters,
    crontab_create_operation_fee_parameters,crontab_cancel_operation_fee_parameters,crontab_recover_operation_fee_parameters]);
var fee_schedule = exports.fee_schedule = new Serializer("fee_schedule", { parameters: set(fee_parameters),
    scale: uint32 });

var void_result = exports.void_result = new Serializer("void_result");

var asset = exports.asset = new Serializer("asset", { amount: int64,
    asset_id: protocol_id_type("asset") });

var operation_result = static_variant([void_result, object_id_type, asset]);
var processed_transaction = exports.processed_transaction = new Serializer("processed_transaction", { ref_block_num: uint16,
    ref_block_prefix: uint32,
    expiration: time_point_sec,
    operations: array(operation),
    extensions: set(future_extensions),
    signatures: array(bytes(65)),
    operation_results: array(operation_result) });

var signed_block = exports.signed_block = new Serializer("signed_block", { previous: bytes(20),
    timestamp: time_point_sec,
    witness: protocol_id_type("witness"),
    transaction_merkle_root: bytes(20),
    extensions: set(future_extensions),
    witness_signature: bytes(65),
    transactions: array(processed_transaction) });

var block_header = exports.block_header = new Serializer("block_header", { previous: bytes(20),
    timestamp: time_point_sec,
    witness: protocol_id_type("witness"),
    transaction_merkle_root: bytes(20),
    extensions: set(future_extensions) });

var signed_block_header = exports.signed_block_header = new Serializer("signed_block_header", { previous: bytes(20),
    timestamp: time_point_sec,
    witness: protocol_id_type("witness"),
    transaction_merkle_root: bytes(20),
    extensions: set(future_extensions),
    witness_signature: bytes(65) });

var memo_data = exports.memo_data = new Serializer("memo_data", { from: public_key,
    to: public_key,
    nonce: uint64,
    message: bytes() });

var memo_type = static_variant([string, memo_data]);

var transfer = exports.transfer = new Serializer("transfer", { 
    from: protocol_id_type("account"),
    to: protocol_id_type("account"),
    amount: asset,
    memo: optional(memo_type),
    extensions: set(future_extensions) });
      
var limit_order_create = exports.limit_order_create = new Serializer("limit_order_create", {
    seller: protocol_id_type("account"),
    amount_to_sell: asset,
    min_to_receive: asset,
    expiration: time_point_sec,
    fill_or_kill: bool,
    extensions: set(future_extensions) });

var limit_order_cancel = exports.limit_order_cancel = new Serializer("limit_order_cancel", {
    fee_paying_account: protocol_id_type("account"),
    order: protocol_id_type("limit_order"),
    extensions: set(future_extensions) });

var call_order_update = exports.call_order_update = new Serializer("call_order_update", {
     //fee: asset,
    funding_account: protocol_id_type("account"),
    delta_collateral: asset,
    delta_debt: asset,
    extensions: set(future_extensions) });

var fill_order = exports.fill_order = new Serializer("fill_order", {
    order_id: object_id_type,
    account_id: protocol_id_type("account"),
    pays: asset,
    receives: asset });

var authority = exports.authority = new Serializer("authority", { weight_threshold: uint32,
    account_auths: map(protocol_id_type("account"), uint16),
    key_auths: map(public_key, uint16),
    address_auths: map(address, uint16) });

var account_options = exports.account_options = new Serializer("account_options", { memo_key: public_key,
    // voting_account: protocol_id_type("account"),
    // num_witness: uint16,
    // num_committee: uint16,
    votes: set(vote_id),
    extensions: set(future_extensions) });

var account_create = exports.account_create = new Serializer("account_create", {
    registrar: protocol_id_type("account"),
    // referrer: protocol_id_type("account"),
    // referrer_percent: uint16,
    name: string,
    owner: authority,
    active: authority,
    options: account_options,
    extensions: set(future_extensions) });

var account_update = exports.account_update = new Serializer("account_update", {
    lock_with_vote:optional(pair(uint32,asset)),
    account: protocol_id_type("account"),
    owner: optional(authority),
    active: optional(authority),
    new_options: optional(account_options),
    extensions: set(future_extensions) });

 //45
var execute_bid = exports.execute_bid = new Serializer("execute_bid", { 
    owner: protocol_id_type("account"),
    name: string,
    data: string,
    extensions: set(future_extensions) });

//46
var contract_create = exports.contract_create = new Serializer("contract_create", { 
    owner: protocol_id_type("account"),
    name: string,
    data: string,
    contract_authority:public_key,
    extensions: set(future_extensions) });

// var vector_lua_types = lua_types([int64, double, string, bool,table(lua_types([int64,double,string,bool])),optional(memo_data),asset]);

var call_contract_function = exports.call_contract_function = new Serializer("call_contract_function", {
    caller: protocol_id_type("account"),
    contract_id: protocol_id_type("contract_id_type"),
    function_name: string,
    value_list:array(lua_types),
    extensions: set(future_extensions) });

var register_nh_asset_creator = exports.register_nh_asset_creator = new Serializer("register_nh_asset_creator", {
    fee_paying_account: protocol_id_type("account")});

var create_world_view = exports.create_world_view = new Serializer("create_world_view", {
    fee_paying_account: protocol_id_type("account"),
    world_view:string
});

var relate_world_view = exports.relate_world_view = new Serializer("relate_world_view", {
    related_account: protocol_id_type("account"),
    world_view:string,
    view_owner:protocol_id_type("account")
});

// var _base_describe = static_variant([void_result, object_id_type, asset]);

var create_nh_asset = exports.create_nh_asset = new Serializer("create_nh_asset", {
    fee_paying_account: protocol_id_type("account"),
    owner:protocol_id_type("account"),
    asset_id:string,
    world_view:string,
    base_describe:string
});

var update_collateral_for_gas = exports.update_collateral_for_gas = new Serializer("update_collateral_for_gas", {
    mortgager: protocol_id_type("account"),
    beneficiary:protocol_id_type("account"),
    collateral:int64
});

var delete_nh_asset = exports.delete_nh_asset = new Serializer("delete_nh_asset", {
    fee_paying_account: protocol_id_type("account"),
    nh_asset:nh_protocol_id_type("nh_item_object_type")
});

var transfer_nh_asset = exports.transfer_nh_asset = new Serializer("transfer_nh_asset", { 
    from: protocol_id_type("account"),
    to:protocol_id_type("account"),
    nh_asset:nh_protocol_id_type("nh_item_object_type")
});

var create_nh_asset_order = exports.create_nh_asset_order = new Serializer("create_nh_asset_order", {
    seller: protocol_id_type("account"),
    otcaccount:protocol_id_type("account"),
    pending_orders_fee:asset,
    nh_asset:nh_protocol_id_type("nh_item_object_type"),
    memo:string,
    price:asset,
    expiration:time_point_sec
});


var cancel_nh_asset_order=exports.cancel_nh_asset_order=new Serializer("cancel_nh_asset_order", {
    order: nh_protocol_id_type("nh_item_order_object_type"),
    fee_paying_account:protocol_id_type("account"),
    extensions: set(future_extensions) 
});


var fill_nh_asset_order=exports.fill_nh_asset_order=new Serializer("fill_nh_asset_order", {
    order: nh_protocol_id_type("nh_item_order_object_type"),
    fee_paying_account:protocol_id_type("account"),
    seller:protocol_id_type("account"),
    nh_asset:nh_protocol_id_type("nh_item_object_type"),
    price_amount:string,
    price_asset_id:protocol_id_type("asset"),
    price_asset_symbol:string,
    extensions: set(future_extensions) 
});


var revise_contract=exports.revise_contract=new Serializer("revise_contract", {
    reviser:protocol_id_type("account"),
    contract_id: protocol_id_type("contract_id_type"),
    data:string,
    extensions: set(future_extensions) 
});

var op_wrapper = exports.op_wrapper = new Serializer("op_wrapper", { op: operation });


var crontab_create=exports.crontab_create=new Serializer("crontab_create", { fee: asset,
    crontab_creator:protocol_id_type("account"),
    crontab_ops: array(op_wrapper),
    start_time:time_point_sec,
    execute_interval:uint64,
    scheduled_execute_times:uint64,
    extensions: set(future_extensions) 
});

var crontab_cancel=exports.crontab_cancel=new Serializer("crontab_cancel", { fee: asset,
    fee_paying_account:protocol_id_type("account"),
    task: protocol_id_type("crontab_id_type"),
    extensions: set(future_extensions) 
});


var crontab_recover=exports.crontab_recover=new Serializer("crontab_recover", { fee: asset,
    crontab_owner:protocol_id_type("account"),
    crontab: protocol_id_type("crontab_id_type"),
    restart_time:time_point_sec,
    extensions: set(future_extensions) 
});

var fba_distribute = exports.fba_distribute = new Serializer("fba_distribute", {
    owner: protocol_id_type("account"),
    name: string,
    data: string,
    extensions: set(future_extensions) });

var bid_collateral = exports.bid_collateral = new Serializer("bid_collateral", {
    owner: protocol_id_type("account"),
    name: string,
    data: string,
    extensions: set(future_extensions) });


var account_upgrade = exports.account_upgrade = new Serializer("account_upgrade", { 
    account_to_upgrade: protocol_id_type("account"),
    upgrade_to_lifetime_member: bool,
    extensions: set(future_extensions) });

var account_transfer = exports.account_transfer = new Serializer("account_transfer", { 
    account_id: protocol_id_type("account"),
    new_owner: protocol_id_type("account"),
    extensions: set(future_extensions) });

var price = exports.price = new Serializer("price", { base: asset,
    quote: asset });

var asset_options = exports.asset_options = new Serializer("asset_options", { max_supply: int64,
    market_fee_percent: uint16,
    max_market_fee: int64,
    issuer_permissions: uint16,
    flags: uint16,
    core_exchange_rate: optional(price),//optional(price)
    description: string,
    extensions: set(future_extensions) });

var bitasset_options = exports.bitasset_options = new Serializer("bitasset_options", { feed_lifetime_sec: uint32,
    minimum_feeds: uint8,
    force_settlement_delay_sec: uint32,
    force_settlement_offset_percent: uint16,
    maximum_force_settlement_volume: uint16,
    short_backing_asset: protocol_id_type("asset"),
    extensions: set(future_extensions) });

var asset_create = exports.asset_create = new Serializer("asset_create", {
    issuer: protocol_id_type("account"),
    symbol: string,
    precision: uint8,
    common_options: asset_options,
    bitasset_opts: optional(bitasset_options),
    // is_prediction_market: bool,
    extensions: set(future_extensions) });

var asset_update = exports.asset_update = new Serializer("asset_update", { //fee: asset,
    issuer: protocol_id_type("account"),
    asset_to_update: protocol_id_type("asset"),
    new_issuer: optional(protocol_id_type("account")),
    new_options: asset_options,
    extensions: set(future_extensions) });

      
var asset_update_restricted = exports.asset_update_restricted = new Serializer("asset_update_restricted", {
    payer: protocol_id_type("account"),
    target_asset: protocol_id_type("asset"),
    isadd: bool,
    restricted_type:uint8,
    restricted_list:array(object_id_type),
    extensions: set(future_extensions) });   

var asset_update_bitasset = exports.asset_update_bitasset = new Serializer("asset_update_bitasset", { //fee: asset,
    issuer: protocol_id_type("account"),
    asset_to_update: protocol_id_type("asset"),
    new_options: bitasset_options,
    extensions: set(future_extensions) });

var asset_update_feed_producers = exports.asset_update_feed_producers = new Serializer("asset_update_feed_producers", {
    issuer: protocol_id_type("account"),
    asset_to_update: protocol_id_type("asset"),
    new_feed_producers: set(protocol_id_type("account")),
    extensions: set(future_extensions) });

var asset_issue = exports.asset_issue = new Serializer("asset_issue", { 
    issuer: protocol_id_type("account"),
    asset_to_issue: asset,
    issue_to_account: protocol_id_type("account"),
    memo: optional(memo_type),
    extensions: set(future_extensions) });

var asset_reserve = exports.asset_reserve = new Serializer("asset_reserve", {
    payer: protocol_id_type("account"),
    amount_to_reserve: asset,
    extensions: set(future_extensions) });

var asset_fund_fee_pool = exports.asset_fund_fee_pool = new Serializer("asset_fund_fee_pool", {
    from_account: protocol_id_type("account"),
    asset_id: protocol_id_type("asset"),
    amount: int64,
    extensions: set(future_extensions) });

var asset_settle = exports.asset_settle = new Serializer("asset_settle", { 
    account: protocol_id_type("account"),
    amount: asset,
    extensions: set(future_extensions) });

var asset_global_settle = exports.asset_global_settle = new Serializer("asset_global_settle", { 
    issuer: protocol_id_type("account"),
    asset_to_settle: protocol_id_type("asset"),
    settle_price: price,
    extensions: set(future_extensions) });

var price_feed = exports.price_feed = new Serializer("price_feed", { settlement_price: price,
    maintenance_collateral_ratio: uint16,
    maximum_short_squeeze_ratio: uint16,
    //core_exchange_rate: price//
   });

var asset_publish_feed = exports.asset_publish_feed = new Serializer("asset_publish_feed", { //fee: asset,//
    publisher: protocol_id_type("account"),
    asset_id: protocol_id_type("asset"),
    feed: price_feed,
    extensions: set(future_extensions) });

var witness_create = exports.witness_create = new Serializer("witness_create", { //fee: asset,
    witness_account: protocol_id_type("account"),
    url: string,
    block_signing_key: public_key });

var witness_update = exports.witness_update = new Serializer("witness_update", {
    witness: protocol_id_type("witness"),
    witness_account: protocol_id_type("account"),
    new_url: optional(string),
    new_signing_key: optional(public_key),
    work_status:bool });


var proposal_create = exports.proposal_create = new Serializer("proposal_create", { 
    fee_paying_account: protocol_id_type("account"),
    expiration_time: time_point_sec,
    proposed_ops: array(op_wrapper),
    review_period_seconds: optional(uint32),
    extensions: set(future_extensions) });

var proposal_update = exports.proposal_update = new Serializer("proposal_update", { 
    fee_paying_account: protocol_id_type("account"),
    proposal: protocol_id_type("proposal"),
    active_approvals_to_add: set(protocol_id_type("account")),
    active_approvals_to_remove: set(protocol_id_type("account")),
    owner_approvals_to_add: set(protocol_id_type("account")),
    owner_approvals_to_remove: set(protocol_id_type("account")),
    key_approvals_to_add: set(public_key),
    key_approvals_to_remove: set(public_key),
    extensions: set(future_extensions) });

var proposal_delete = exports.proposal_delete = new Serializer("proposal_delete", {
    fee_paying_account: protocol_id_type("account"),
    using_owner_authority: bool,
    proposal: protocol_id_type("proposal"),
    extensions: set(future_extensions) });

var withdraw_permission_create = exports.withdraw_permission_create = new Serializer("withdraw_permission_create", { fee: asset,
    withdraw_from_account: protocol_id_type("account"),
    authorized_account: protocol_id_type("account"),
    withdrawal_limit: asset,
    withdrawal_period_sec: uint32,
    periods_until_expiration: uint32,
    period_start_time: time_point_sec });

var withdraw_permission_update = exports.withdraw_permission_update = new Serializer("withdraw_permission_update", { fee: asset,
    withdraw_from_account: protocol_id_type("account"),
    authorized_account: protocol_id_type("account"),
    permission_to_update: protocol_id_type("withdraw_permission"),
    withdrawal_limit: asset,
    withdrawal_period_sec: uint32,
    period_start_time: time_point_sec,
    periods_until_expiration: uint32 });

var withdraw_permission_claim = exports.withdraw_permission_claim = new Serializer("withdraw_permission_claim", { fee: asset,
    withdraw_permission: protocol_id_type("withdraw_permission"),
    withdraw_from_account: protocol_id_type("account"),
    withdraw_to_account: protocol_id_type("account"),
    amount_to_withdraw: asset,
    memo: optional(memo_data) });

var withdraw_permission_delete = exports.withdraw_permission_delete = new Serializer("withdraw_permission_delete", { fee: asset,
    withdraw_from_account: protocol_id_type("account"),
    authorized_account: protocol_id_type("account"),
    withdrawal_permission: protocol_id_type("withdraw_permission") });

var committee_member_create = exports.committee_member_create = new Serializer("committee_member_create", {
    committee_member_account: protocol_id_type("account"),
    url: string });

var committee_member_update = exports.committee_member_update = new Serializer("committee_member_update", {
    committee_member: protocol_id_type("committee_member"),
    committee_member_account: protocol_id_type("account"),
    new_url: optional(string),
    work_status:bool });

var chain_parameters = exports.chain_parameters = new Serializer("chain_parameters", { current_fees: fee_schedule,
    block_interval: uint8,
    maintenance_interval: uint32,
    maintenance_skip_slots: uint8,
    committee_proposal_review_period: uint32,
    maximum_transaction_size: uint32,
    maximum_block_size: uint32,
    maximum_time_until_expiration: uint32,
    maximum_proposal_lifetime: uint32,
    maximum_asset_whitelist_authorities: uint8,
    maximum_asset_feed_publishers: uint8,
    maximum_witness_count: uint16,
    maximum_committee_count: uint16,
    maximum_authority_membership: uint16,
    reserve_percent_of_fee: uint16,
    network_percent_of_fee: uint16,
    lifetime_referrer_percent_of_fee: uint16,
    cashback_vesting_period_seconds: uint32,
    cashback_vesting_threshold: int64,
    count_non_member_votes: bool,
    allow_non_member_whitelists: bool,
    witness_pay_per_block: int64,
    worker_budget_per_day: int64,
    max_predicate_opcode: uint16,
    fee_liquidation_threshold: int64,
    accounts_per_fee_scale: uint16,
    account_fee_scale_bitshifts: uint8,
    max_authority_depth: uint8,
    extensions: set(future_extensions) });

var committee_member_update_global_parameters = exports.committee_member_update_global_parameters = new Serializer("committee_member_update_global_parameters", { fee: asset,
    new_parameters: chain_parameters });

var linear_vesting_policy_initializer = exports.linear_vesting_policy_initializer = new Serializer("linear_vesting_policy_initializer", { begin_timestamp: time_point_sec,
    vesting_cliff_seconds: uint32,
    vesting_duration_seconds: uint32 });

var cdd_vesting_policy_initializer = exports.cdd_vesting_policy_initializer = new Serializer("cdd_vesting_policy_initializer", { start_claim: time_point_sec,
    vesting_seconds: uint32 });

var vesting_policy_initializer = static_variant([linear_vesting_policy_initializer, cdd_vesting_policy_initializer]);

var vesting_balance_create = exports.vesting_balance_create = new Serializer("vesting_balance_create", { fee: asset,
    creator: protocol_id_type("account"),
    owner: protocol_id_type("account"),
    amount: asset,
    policy: vesting_policy_initializer });

var vesting_balance_withdraw = exports.vesting_balance_withdraw = new Serializer("vesting_balance_withdraw", {
    vesting_balance: protocol_id_type("vesting_balance"),
    owner: protocol_id_type("account"),
    amount: asset });

var refund_worker_initializer = exports.refund_worker_initializer = new Serializer("refund_worker_initializer");

var vesting_balance_worker_initializer = exports.vesting_balance_worker_initializer = new Serializer("vesting_balance_worker_initializer", { pay_vesting_period_days: uint16 });

var burn_worker_initializer = exports.burn_worker_initializer = new Serializer("burn_worker_initializer");

var worker_initializer = static_variant([refund_worker_initializer, vesting_balance_worker_initializer, burn_worker_initializer]);

var worker_create = exports.worker_create = new Serializer("worker_create", { fee: asset,
    owner: protocol_id_type("account"),
    work_begin_date: time_point_sec,
    work_end_date: time_point_sec,
    daily_pay: int64,
    name: string,
    url: string,
    initializer: worker_initializer });

var custom = exports.custom = new Serializer("custom", { fee: asset,
    payer: protocol_id_type("account"),
    required_auths: set(protocol_id_type("account")),
    id: uint16,
    data: bytes() });

var account_name_eq_lit_predicate = exports.account_name_eq_lit_predicate = new Serializer("account_name_eq_lit_predicate", { account_id: protocol_id_type("account"),
    name: string });

var asset_symbol_eq_lit_predicate = exports.asset_symbol_eq_lit_predicate = new Serializer("asset_symbol_eq_lit_predicate", { asset_id: protocol_id_type("asset"),
    symbol: string });

var block_id_predicate = exports.block_id_predicate = new Serializer("block_id_predicate", { id: bytes(20) });

var predicate = static_variant([account_name_eq_lit_predicate, asset_symbol_eq_lit_predicate, block_id_predicate]);

var assert = exports.assert = new Serializer("assert", { fee: asset,
    fee_paying_account: protocol_id_type("account"),
    predicates: array(predicate),
    required_auths: set(protocol_id_type("account")),
    extensions: set(future_extensions) });

var balance_claim = exports.balance_claim = new Serializer("balance_claim", { fee: asset,
    deposit_to_account: protocol_id_type("account"),
    balance_to_claim: protocol_id_type("balance"),
    balance_owner_key: public_key,
    total_claimed: asset });

var override_transfer = exports.override_transfer = new Serializer("override_transfer", { fee: asset,
    issuer: protocol_id_type("account"),
    from: protocol_id_type("account"),
    to: protocol_id_type("account"),
    amount: asset,
    memo: optional(memo_data),
    extensions: set(future_extensions) });

var stealth_confirmation = exports.stealth_confirmation = new Serializer("stealth_confirmation", { one_time_key: public_key,
    to: optional(public_key),
    encrypted_memo: bytes() });

var blind_output = exports.blind_output = new Serializer("blind_output", { commitment: bytes(33),
    range_proof: bytes(),
    owner: authority,
    stealth_memo: optional(stealth_confirmation) });

var transfer_to_blind = exports.transfer_to_blind = new Serializer("transfer_to_blind", { fee: asset,
    amount: asset,
    from: protocol_id_type("account"),
    blinding_factor: bytes(32),
    outputs: array(blind_output) });

var blind_input = exports.blind_input = new Serializer("blind_input", { commitment: bytes(33),
    owner: authority });

var blind_transfer = exports.blind_transfer = new Serializer("blind_transfer", {
    inputs: array(blind_input),
    outputs: array(blind_output) });

var transfer_from_blind = exports.transfer_from_blind = new Serializer("transfer_from_blind", { 
    amount: asset,
    to: protocol_id_type("account"),
    blinding_factor: bytes(32),
    inputs: array(blind_input) });

var asset_settle_cancel = exports.asset_settle_cancel = new Serializer("asset_settle_cancel", { fee: asset,
    settlement: protocol_id_type("force_settlement"),
    account: protocol_id_type("account"),
    amount: asset,
    extensions: set(future_extensions) });

var asset_claim_fees = exports.asset_claim_fees = new Serializer("asset_claim_fees", {
    issuer: protocol_id_type("account"),
    amount_to_claim: asset,
    extensions: set(future_extensions) });

operation.st_operations = [
    transfer, limit_order_create, limit_order_cancel, call_order_update, fill_order, 
    account_create, account_update, account_upgrade, asset_create, asset_update,
    asset_update_restricted,asset_update_bitasset,asset_update_feed_producers, asset_issue, asset_reserve,
    asset_settle, asset_global_settle, asset_publish_feed,witness_create, witness_update,
    proposal_create,proposal_update,proposal_delete,committee_member_create,committee_member_update,
    // witness_update, 
    vesting_balance_create,committee_member_update_global_parameters,vesting_balance_withdraw,worker_create, balance_claim, 
    asset_settle_cancel, asset_claim_fees,bid_collateral,execute_bid,contract_create,
    call_contract_function,call_contract_function, register_nh_asset_creator,create_world_view,relate_world_view,
    create_nh_asset,delete_nh_asset,transfer_nh_asset,create_nh_asset_order,cancel_nh_asset_order,
    fill_nh_asset_order,46,47,48,49,
    revise_contract,crontab_create,crontab_cancel,crontab_recover,
    update_collateral_for_gas];

var transaction = exports.transaction = new Serializer("transaction", { ref_block_num: uint16,
    ref_block_prefix: uint32,
    expiration: time_point_sec,
    operations: array(operation),
    extensions: set(future_extensions) });

var signed_transaction = exports.signed_transaction = new Serializer("signed_transaction", { ref_block_num: uint16,
    ref_block_prefix: uint32,
    expiration: time_point_sec,
    operations: array(operation),
    extensions: set(future_extensions),
    signatures: array(bytes(65)) });
//# -------------------------------
//#  Generated code end
//# -------------------------------

// Custom Types

var stealth_memo_data = exports.stealth_memo_data = new Serializer("stealth_memo_data", {
    from: optional(public_key),
    amount: asset,
    blinding_factor: bytes(32),
    commitment: bytes(33),
    check: uint32
});
// var stealth_confirmation = new Serializer(
//     "stealth_confirmation", {
//     one_time_key: public_key,
//     to: optional( public_key ),
//     encrypted_memo: stealth_memo_data
// })

/***/ }),
/* 382 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = template;

/** Console print any transaction object with zero default values. */
function template(op) {

    var object = op.toObject(void 0, { use_default: true, annotate: true });

    // visual (with descriptions)
    console.error(JSON.stringify(object, null, 4));

    // usable in a copy-paste

    object = op.toObject(void 0, { use_default: true, annotate: false });

    // copy-paste one-lineer
    console.error(JSON.stringify(object));
}
module.exports = exports["default"];

/***/ }),
/* 383 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;


/**
    Account names may contain one or more names separated by a dot.
    Each name needs to start with a letter and may contain
    numbers, or well placed dashes.
    @see is_valid_name graphene/libraries/chain/protocol/account.cpp
*/
var id_regex = /\b\d+\.\d+\.(\d+)\b/;

var chainValidation = {
    is_account_name: function is_account_name(value) {
        var allow_too_short = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        var i, label, len, length, ref;

        if (this.is_empty(value)) {
            return false;
        }

        length = value.length;

        if (!allow_too_short && length < 3 || length > 63) {
            return false;
        }

        ref = value.split('.');

        for (i = 0, len = ref.length; i < len; i++) {

            label = ref[i];

            if (!(/^[a-z][a-z0-9-]*$/.test(label) && !/--/.test(label) && /[a-z0-9]$/.test(label))) {
                return false;
            }
        }
        return true;
    },

    is_object_id: function is_object_id(obj_id) {
        if ('string' != typeof obj_id) return false;

        var match = id_regex.exec(obj_id);
        return match !== null && obj_id.split(".").length === 3;
    },

    is_empty: function is_empty(value) {
        return value == null || value.length === 0;
    },

    is_account_name_error: function is_account_name_error(value, allow_too_short) {
        var i, label, len, length, ref, suffix;
        if (allow_too_short == null) {
            allow_too_short = false;
        }
        suffix = "Account name should ";
        if (this.is_empty(value)) {
            return suffix + "not be empty.";
        }
        length = value.length;
        if (!allow_too_short && length < 3) {
            return suffix + "be longer.";
        }
        if (length > 63) {
            return suffix + "be shorter.";
        }
        if (/\./.test(value)) {
            suffix = "Each account segment should ";
        }
        ref = value.split('.');
        for (i = 0, len = ref.length; i < len; i++) {
            label = ref[i];
            if (!/^[~a-z]/.test(label)) {
                return suffix + "start with a letter.";
            }
            if (!/^[~a-z0-9-]*$/.test(label)) {
                return suffix + "have only letters, digits, or dashes.";
            }
            if (/--/.test(label)) {
                return suffix + "have only one dash in a row.";
            }
            if (!/[a-z0-9]$/.test(label)) {
                return suffix + "end with a letter or digit.";
            }
            if (!(label.length >= 3)) {
                return suffix + "be longer";
            }
        }
        return null;
    },

    is_cheap_name: function is_cheap_name(account_name) {
        return (/[0-9-]/.test(account_name) || !/[aeiouy]/.test(account_name)
        );
    },

    is_empty_user_input: function is_empty_user_input(value) {
        if (this.is_empty(value)) {
            return true;
        }
        if ((value + "").trim() === "") {
            return true;
        }
        return false;
    },

    required: function required(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

        if (this.is_empty(value)) {
            throw new Error("value required for " + field_name + ": " + value);
        }
        return value;
    },

    /** @see is_valid_symbol graphene/libraries/chain/protocol/asset_ops.cpp */
    is_valid_symbol_error: function is_valid_symbol_error(value) {
        var suffix = "Asset name should ";
        if (this.is_empty(value)) {
            return suffix + "not be empty.";
        }
        if (value.split('.').length > 2) {
            return suffix + "have only one dot.";
        }
        if (value.length < 3) {
            return suffix + "be longer.";
        }
        if (value.length > 16) {
            return suffix + "be shorter.";
        }
        if (!/^[A-Z]/.test(value)) {
            return suffix + "start with a letter";
        }
        if (!/[A-Z]$/.test(value)) {
            return suffix + "end with a letter";
        }
        if (/^[A-Z0-9\.]$/.test(value)) {
            return suffix + "contain only letters numbers and perhaps a dot.";
        }
        return null;
    }
};

exports.default = chainValidation;
module.exports = exports['default'];

/***/ }),
/* 384 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = emitter;

var _eventEmitter = __webpack_require__(468);

var _eventEmitter2 = _interopRequireDefault(_eventEmitter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _emitter;
function emitter() {
    if (!_emitter) {
        _emitter = (0, _eventEmitter2.default)({});
    }
    return _emitter;
}
module.exports = exports["default"];

/***/ }),
/* 385 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// ES3 safe
var _undefined = void 0;

module.exports = function (value) { return value !== _undefined && value !== null; };


/***/ }),
/* 386 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.SerializerValidation = exports.template = exports.ops = exports.types = exports.fp = exports.Serializer = undefined;

var _serializer = __webpack_require__(213);

var _serializer2 = _interopRequireDefault(_serializer);

var _FastParser = __webpack_require__(214);

var _FastParser2 = _interopRequireDefault(_FastParser);

var _types = __webpack_require__(218);

var _types2 = _interopRequireDefault(_types);

var _operations = __webpack_require__(381);

var ops = _interopRequireWildcard(_operations);

var _template = __webpack_require__(382);

var _template2 = _interopRequireDefault(_template);

var _SerializerValidation = __webpack_require__(145);

var _SerializerValidation2 = _interopRequireDefault(_SerializerValidation);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.Serializer = _serializer2.default;
exports.fp = _FastParser2.default;
exports.types = _types2.default;
exports.ops = ops;
exports.template = _template2.default;
exports.SerializerValidation = _SerializerValidation2.default;

/***/ }),
/* 387 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = __webpack_require__(3);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _promise = __webpack_require__(4);

var _promise2 = _interopRequireDefault(_promise);

var _keys = __webpack_require__(24);

var _keys2 = _interopRequireDefault(_keys);

var _classCallCheck2 = __webpack_require__(11);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(15);

var _createClass3 = _interopRequireDefault(_createClass2);

var _persistentStorage = __webpack_require__(147);

var _persistentStorage2 = _interopRequireDefault(_persistentStorage);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var NodesManager = function () {
  function NodesManager(_ref) {
    var nodes = _ref.nodes,
        defaultNode = _ref.defaultNode;
    (0, _classCallCheck3.default)(this, NodesManager);

    this._nodes = nodes;
    this._selectedNodeUrl = defaultNode;
    this.firstTestPing = true;
  }

  (0, _createClass3.default)(NodesManager, [{
    key: 'addAPINode',
    value: function addAPINode(node) {
      this._nodes[node.url] = { location: node.name };
    }
  }, {
    key: 'deleteAPINode',
    value: function deleteAPINode(url) {
      delete this._nodes[url];
      _persistentStorage2.default.saveNodesData({ data: this._nodes });
    }
  }, {
    key: 'setAPINode',
    value: function setAPINode(nodes) {
      this._nodes = nodes;
      return this.testNodesPings();
    }
  }, {
    key: '_retrieveCachedNodesData',
    value: function _retrieveCachedNodesData() {
      var _this = this;

      var cachedData = _persistentStorage2.default.getSavedNodesData();
      if (!this._nodes) return;

      (0, _keys2.default)(this._nodes).forEach(function (url) {
        var cachedNode = cachedData[url];
        if (cachedNode && cachedNode.ping && typeof cachedNode.ping === 'number') {
          _this._nodes[url].ping = cachedNode.ping;
        }
      });
    }
  }, {
    key: '_selectFastestNode',
    value: function _selectFastestNode() {
      var _this2 = this;

      if (!this._nodes) return;
      (0, _keys2.default)(this._nodes).forEach(function (url) {
        var node = _this2._nodes[url];
        var selectedNode = _this2._nodes[_this2._selectedNodeUrl];
        if (node.ping && node.ping <= (selectedNode ? selectedNode.ping : 100000)) {
          _this2._selectedNodeUrl = url;
        }
      });
      return this._selectedNodeUrl;
    }
  }, {
    key: 'testNodesPings',
    value: function testNodesPings() {
      var _this3 = this;

      if (!this._nodes) return;
      return new _promise2.default(function (resolve) {
        _promise2.default.all((0, _keys2.default)(_this3._nodes).map(function _callee(url) {
          return _regenerator2.default.async(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (!(url !== _this3._selectedNodeUrl || _this3.firstTestPing || !_this3._nodes[url].ping)) {
                    _context.next = 4;
                    break;
                  }

                  _context.next = 3;
                  return _regenerator2.default.awrap(NodesManager._pingNode(url));

                case 3:
                  _this3._nodes[url].ping = _context.sent;

                case 4:
                case 'end':
                  return _context.stop();
              }
            }
          }, null, _this3);
        })).then(function () {
          _persistentStorage2.default.saveNodesData({ data: _this3._nodes });
          _this3.firstTestPing = false;
          resolve(_this3._nodes);
        });
      });
    }
  }, {
    key: 'getInitialNodeUrl',
    value: function getInitialNodeUrl() {
      this._retrieveCachedNodesData();
      return this._selectFastestNode();
    }
  }, {
    key: 'getAnotherNodeUrl',
    value: function getAnotherNodeUrl(url) {
      var urls = (0, _keys2.default)(this._nodes);
      if (url) {
        var index = urls.indexOf(url);
        urls.splice(index, 1);
      }

      return urls[Math.floor(Math.random() * urls.length)];
    }
  }], [{
    key: '_pingNode',
    value: function _pingNode(url) {
      return new _promise2.default(function (resolve) {
        var date = new Date();
        try {
          var ping_timer = setTimeout(function () {
            resolve(0);
          }, 2000);

          var socket = new WebSocket(url);
          socket.onopen = function () {
            clearTimeout(ping_timer);
            socket.close();
            socket = null;
            resolve(new Date() - date);
          };
          socket.onerror = function () {
            clearTimeout(ping_timer);
            resolve(0);
          };
        } catch (e) {
          resolve(e.message);
        }
      });
    }
  }]);
  return NodesManager;
}();

exports.default = NodesManager;

/***/ }),
/* 388 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getVestingBalances = exports.createAccount = exports.getAccountRefsOfAccount = exports.getAccountIdByOwnerPubkey = exports.getUser = exports.getAccount = exports.clear_accs = exports.suggestBrainkey = undefined;

var _stringify = __webpack_require__(18);

var _stringify2 = _interopRequireDefault(_stringify);

var _regenerator = __webpack_require__(3);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _bcxjsCores = __webpack_require__(7);

var _bcxjsWs = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var suggestBrainkey = exports.suggestBrainkey = function suggestBrainkey(dictionary) {
  return _bcxjsCores.key.suggest_brain_key(dictionary);
};

var _accs = {};
var clear_accs = exports.clear_accs = function clear_accs() {
  _accs = {};
};

var getAccount = exports.getAccount = function _callee(id) {
  var isCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var response, user;
  return _regenerator2.default.async(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          if (!isCache) {
            _context.next = 7;
            break;
          }

          if (!(id in _accs)) {
            _context.next = 6;
            break;
          }

          if (!_accs[id]) {
            _context.next = 4;
            break;
          }

          return _context.abrupt('return', { code: 1, data: _accs[id], success: true });

        case 4:
          _context.next = 7;
          break;

        case 6:
          _accs[id] = { account: { name: id } };

        case 7:
          _context.prev = 7;

          if (/^1.2.\d+/.test(id)) {
            _context.next = 10;
            break;
          }

          return _context.abrupt('return', { code: 0 });

        case 10:
          _context.next = 12;
          return _regenerator2.default.awrap(_bcxjsWs.Apis.instance().db_api().exec('get_objects', [[id]]));

        case 12:
          response = _context.sent;

          if (!(response && response[0])) {
            _context.next = 18;
            break;
          }

          user = {
            account: response[0]
          };


          if (isCache) {
            _accs[response[0].id] = user;
            _accs[response[0].name] = user;
          }
          return _context.abrupt('return', {
            code: 1,
            data: user,
            success: true
          });

        case 18:
          return _context.abrupt('return', {
            code: 104,
            message: nameOrId + ' Account not found',
            error: { message: nameOrId + ' Account not found' },
            success: false
          });

        case 21:
          _context.prev = 21;
          _context.t0 = _context['catch'](7);
          return _context.abrupt('return', {
            code: 0,
            message: _context.t0.message,
            error: _context.t0,
            success: false
          });

        case 24:
        case 'end':
          return _context.stop();
      }
    }
  }, null, undefined, [[7, 21]]);
};

var getUser = exports.getUser = function _callee2(nameOrId) {
  var isCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var isSubscribe = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var response, user;
  return _regenerator2.default.async(function _callee2$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          if (!(isCache && _accs[nameOrId])) {
            _context2.next = 2;
            break;
          }

          return _context2.abrupt('return', { code: 1, data: _accs[nameOrId], success: true });

        case 2:
          if (_bcxjsWs.Apis.instance().db_api()) {
            _context2.next = 4;
            break;
          }

          return _context2.abrupt('return', {
            success: false,
            code: 102,
            message: "The network is busy, please check your network connection",
            error: {
              message: "The network is busy, please check your network connection"
            }
          });

        case 4:
          _context2.prev = 4;
          _context2.next = 7;
          return _regenerator2.default.awrap(_bcxjsWs.Apis.instance().db_api().exec('get_full_accounts', [[nameOrId], isSubscribe]));

        case 7:
          response = _context2.sent;

          if (!(response && response[0])) {
            _context2.next = 12;
            break;
          }

          user = response[0][1];


          if (isCache) {
            _accs[user.account.id] = user;
            _accs[user.account.name] = user;
          }

          return _context2.abrupt('return', {
            code: 1,
            data: user,
            success: true
          });

        case 12:
          return _context2.abrupt('return', {
            code: 104,
            message: nameOrId + ' Account not found',
            error: { message: nameOrId + ' Account not found' },
            success: false
          });

        case 15:
          _context2.prev = 15;
          _context2.t0 = _context2['catch'](4);
          return _context2.abrupt('return', {
            code: 0,
            message: _context2.t0.message,
            error: _context2.t0,
            success: false
          });

        case 18:
        case 'end':
          return _context2.stop();
      }
    }
  }, null, undefined, [[4, 15]]);
};

var getAccountIdByOwnerPubkey = exports.getAccountIdByOwnerPubkey = function _callee3(ownerPubkey) {
  var res;
  return _regenerator2.default.async(function _callee3$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return _regenerator2.default.awrap(_bcxjsWs.Apis.instance().db_api().exec('get_key_references', [[ownerPubkey]]));

        case 2:
          res = _context3.sent;
          return _context3.abrupt('return', res ? res[0] : null);

        case 4:
        case 'end':
          return _context3.stop();
      }
    }
  }, null, undefined);
};

var getAccountRefsOfAccount = exports.getAccountRefsOfAccount = function _callee4(account_id) {
  var res;
  return _regenerator2.default.async(function _callee4$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          _context4.next = 2;
          return _regenerator2.default.awrap(_bcxjsWs.Apis.instance().db_api().exec('get_account_references', [account_id]));

        case 2:
          res = _context4.sent;
          return _context4.abrupt('return', res);

        case 4:
        case 'end':
          return _context4.stop();
      }
    }
  }, null, undefined);
};

var createAccount = exports.createAccount = function _callee5(_ref, faucetUrl) {
  var name = _ref.name,
      ownerPubkey = _ref.ownerPubkey,
      activePubkey = _ref.activePubkey,
      referrer = _ref.referrer;
  var response, result, code, data, msg, res, error;
  return _regenerator2.default.async(function _callee5$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          _context5.prev = 0;
          _context5.next = 3;
          return _regenerator2.default.awrap(fetch(faucetUrl + '/api/v1/accounts', {
            method: 'post',
            mode: 'cors',
            headers: {
              Accept: 'application/json',
              'Content-type': 'application/json',
              Authorization: "YnVmZW5nQDIwMThidWZlbmc="
              // Origin:"United Labs of BCTech."
              //'Content-type': 'application/x-www-form-urlencoded'
            },
            body: (0, _stringify2.default)({
              account: {
                name: name,
                owner_key: ownerPubkey,
                active_key: activePubkey,
                memo_key: activePubkey,
                refcode: null,
                referrer: referrer
              }
            })
          }));

        case 3:
          response = _context5.sent;
          _context5.next = 6;
          return _regenerator2.default.awrap(response.json());

        case 6:
          result = _context5.sent;

          if (!(result && "code" in result)) {
            _context5.next = 12;
            break;
          }

          code = result.code, data = result.data, msg = result.msg;
          res = {
            success: code == 200,
            code: code,
            data: data,
            msg: msg,
            message: msg
          };

          if (code != 200) {
            res.error = msg;
          }
          return _context5.abrupt('return', res);

        case 12:
          if (!(!result || result && result.error)) {
            _context5.next = 16;
            break;
          }

          error = result.error;

          if ("base" in error) {
            error = error.base[0];
          } else if ("name" in error) {
            error = error.name[0];
          } else if ("remote_ip" in error) {
            error = error.remote_ip[0];
          }
          return _context5.abrupt('return', {
            success: false,
            error: error
          });

        case 16:
          return _context5.abrupt('return', {
            success: true,
            data: result,
            code: 1
          });

        case 19:
          _context5.prev = 19;
          _context5.t0 = _context5['catch'](0);
          return _context5.abrupt('return', {
            success: false,
            error: _context5.t0.message, //'Account creation error'
            error_obj: _context5.t0
          });

        case 22:
        case 'end':
          return _context5.stop();
      }
    }
  }, null, undefined, [[0, 19]]);
};

var getVestingBalances = exports.getVestingBalances = function _callee6(account_id) {
  var res;
  return _regenerator2.default.async(function _callee6$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          _context6.next = 2;
          return _regenerator2.default.awrap(_bcxjsWs.Apis.instance().db_api().exec('get_vesting_balances', [account_id]));

        case 2:
          res = _context6.sent;
          return _context6.abrupt('return', res ? res : null);

        case 4:
        case 'end':
          return _context6.stop();
      }
    }
  }, null, undefined);
};

exports.default = {
  suggestBrainkey: suggestBrainkey, getAccount: getAccount, getUser: getUser, getAccountIdByOwnerPubkey: getAccountIdByOwnerPubkey,
  getAccountRefsOfAccount: getAccountRefsOfAccount, createAccount: createAccount, getVestingBalances: getVestingBalances, clear_accs: clear_accs
};

/***/ }),
/* 389 */
/***/ (function(module, exports) {

module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),
/* 390 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(502), __esModule: true };

/***/ }),
/* 391 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof2 = __webpack_require__(26);

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
};

/***/ }),
/* 392 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _setPrototypeOf = __webpack_require__(504);

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = __webpack_require__(508);

var _create2 = _interopRequireDefault(_create);

var _typeof2 = __webpack_require__(26);

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
  }

  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
};

/***/ }),
/* 393 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _toConsumableArray2 = __webpack_require__(144);

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _defineProperty2 = __webpack_require__(27);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _promise = __webpack_require__(4);

var _promise2 = _interopRequireDefault(_promise);

var _keys = __webpack_require__(24);

var _keys2 = _interopRequireDefault(_keys);

var _classCallCheck2 = __webpack_require__(11);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(15);

var _createClass3 = _interopRequireDefault(_createClass2);

var _regenerator = __webpack_require__(3);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _bcxjsWs = __webpack_require__(8);

var _utils2 = __webpack_require__(96);

var utils = _interopRequireWildcard(_utils2);

var _chainListener = __webpack_require__(224);

var _chainListener2 = _interopRequireDefault(_chainListener);

var _subscriptions = __webpack_require__(225);

var _subscriptions2 = _interopRequireDefault(_subscriptions);

var _immutable = __webpack_require__(23);

var _immutable2 = _interopRequireDefault(_immutable);

var _MarketClasses = __webpack_require__(148);

var _bcxjsCores = __webpack_require__(7);

var _utils3 = __webpack_require__(59);

var _utils4 = _interopRequireDefault(_utils3);

var _market_utils = __webpack_require__(226);

var _market_utils2 = _interopRequireDefault(_market_utils);

var _api = __webpack_require__(10);

var _api2 = _interopRequireDefault(_api);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var operations = _bcxjsCores.ChainTypes.operations;

var nullPrice = {
  getPrice: function getPrice() {
    return 0;
  },
  sellPrice: function sellPrice() {
    return 0;
  }
};

var findOrder = function findOrder(orderId) {
  return function (order) {
    return orderId === order.id;
  };
};

var calcOrderRate = function calcOrderRate(order) {
  var _order$sell_price = order.sell_price,
      quoteAmount = _order$sell_price.quote.amount,
      baseAmount = _order$sell_price.base.amount;

  return baseAmount / quoteAmount;
};

var loadLimitOrders = function _callee(baseId, quoteId) {
  var limit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 500;
  var orders, buyOrders, sellOrders;
  return _regenerator2.default.async(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return _regenerator2.default.awrap(_bcxjsWs.Apis.instance().db_api().exec('get_limit_orders', [baseId, quoteId, limit]));

        case 2:
          orders = _context.sent;
          buyOrders = [];
          sellOrders = [];

          orders.forEach(function (order) {
            if (order.sell_price.base.asset_id === baseId) {
              buyOrders.push(order);
            } else {
              sellOrders.push(order);
            }
          });
          return _context.abrupt('return', { buyOrders: buyOrders, sellOrders: sellOrders });

        case 7:
        case 'end':
          return _context.stop();
      }
    }
  }, null, undefined);
};

var _marketAddSubscription = false;

var Market = function () {
  function Market() {
    var base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "1.3.0";
    (0, _classCallCheck3.default)(this, Market);

    this.base = base;
    this.markets = {};
    this.fee = 578;
    this.marketData = {};
    this.marketLimitOrders = _immutable2.default.Map();
    this.marketCallOrders = _immutable2.default.Map();
    this.activeMarketHistory = _immutable2.default.OrderedSet();

    // const marketsSubscription = new Subscriptions.Markets({
    //   callback: this.onMarketUpdate.bind(this)
    // });
    // console.info("marketsSubscription",marketsSubscription);
    // listener.addSubscription(marketsSubscription);
  }

  (0, _createClass3.default)(Market, [{
    key: 'getFee',
    value: function getFee() {
      return this.fee;
    }
  }, {
    key: 'getCallback',
    value: function getCallback(pays, receives) {
      if (pays === this.base) {
        if (this.isSubscribed(receives)) {
          return this.markets[receives].callback;
        }
      }
      if (receives === this.base) {
        if (this.isSubscribed(pays)) {
          return this.markets[pays].callback;
        }
      }
      return false;
    }
  }, {
    key: 'getOrdersArray',
    value: function getOrdersArray(pays, receives) {
      if (pays === this.base) {
        if (this.isSubscribed(receives)) {
          return this.markets[receives].orders.buy;
        }
      }
      if (receives === this.base) {
        if (this.isSubscribed(pays)) {
          return this.markets[pays].orders.sell;
        }
      }
      return false;
    }
  }, {
    key: 'onMarketUpdate',
    value: function onMarketUpdate(type, object) {
      var _this = this;

      var assetId = this.quoteAsset.get("id");
      clearTimeout(this.marketUpdateTimer);
      this.marketUpdateTimer = setTimeout(function () {
        _this.subscribeToMarket(assetId);
      }, 300);
    }
  }, {
    key: 'onOrderDelete',
    value: function onOrderDelete(notification) {
      var _this2 = this;

      (0, _keys2.default)(this.markets).forEach(function (market) {
        (0, _keys2.default)(_this2.markets[market].orders).forEach(function (type) {
          var idx = _this2.markets[market].orders[type].findIndex(findOrder(notification));
          if (idx >= 0) {
            _this2.markets[market].orders[type].splice(idx, 1);
            _this2.markets[market].callback('DELETE ORDER');
          }
        });
      });
    }
  }, {
    key: 'onNewLimitOrder',
    value: function onNewLimitOrder(order) {
      var _order$sell_price2 = order.sell_price,
          pays = _order$sell_price2.base.asset_id,
          receives = _order$sell_price2.quote.asset_id;


      var orders = this.getOrdersArray(pays, receives);

      if (orders) {
        orders.push(order);
        var callback = this.getCallback(pays, receives);
        callback('ADD ORDER');
      }
    }
  }, {
    key: 'onOrderFill',
    value: function onOrderFill(data) {
      var _data$op$ = data.op[1],
          orderId = _data$op$.order_id,
          _data$op$$pays = _data$op$.pays,
          amount = _data$op$$pays.amount,
          pays = _data$op$$pays.asset_id,
          receives = _data$op$.receives.asset_id;


      var orders = this.getOrdersArray(pays, receives);

      if (orders) {
        var idx = orders.findIndex(findOrder(orderId));
        if (idx !== -1) {
          orders[idx].for_sale -= amount;
          var callback = this.getCallback(pays, receives);
          callback('FILL ORDER');
        }
      }
    }
  }, {
    key: 'isSubscribed',
    value: function isSubscribed(assetId) {
      return this.markets[assetId] !== undefined;
    }
  }, {
    key: 'setDefaultObjects',
    value: function setDefaultObjects(assetId) {
      if (!this.markets[assetId]) {
        this.markets[assetId] = {
          orders: {
            buy: [], sell: []
          },
          callback: function callback() {}
        };
      }
    }
  }, {
    key: 'subscribeToMarket',
    value: function subscribeToMarket(assetId, callback) {
      var _this3 = this,
          _assets;

      var _ref, buyOrders, sellOrders, history, assets;

      return _regenerator2.default.async(function subscribeToMarket$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!(assetId === this.base)) {
                _context3.next = 2;
                break;
              }

              return _context3.abrupt('return');

            case 2:
              _context3.next = 4;
              return _regenerator2.default.awrap(loadLimitOrders(this.base, assetId));

            case 4:
              _ref = _context3.sent;
              buyOrders = _ref.buyOrders;
              sellOrders = _ref.sellOrders;


              if (!this.markets[assetId]) {
                this.setDefaultObjects(assetId);
                this.markets[assetId].callback = callback;
              }

              // console.log('setting default: ' + assetId + ' : ', this.markets[assetId]);
              this.markets[assetId].orders.buy = buyOrders;
              this.markets[assetId].orders.sell = sellOrders;

              this.marketData = this.markets[assetId];
              this.marketData.limits = buyOrders.concat(sellOrders);
              _context3.next = 14;
              return _regenerator2.default.awrap(_bcxjsWs.Apis.instance().history_api().exec("get_fill_order_history", [this.base, assetId, 200]));

            case 14:
              this.marketData.history = _context3.sent;

              if (!(this.hasMyTradeHistory && this.currentAccount)) {
                _context3.next = 22;
                break;
              }

              _context3.next = 18;
              return _regenerator2.default.awrap(_bcxjsWs.Apis.instance().history_api().exec('get_account_history', [this.currentAccount.account.id, '1.11.0', 100, '1.11.0']));

            case 18:
              history = _context3.sent;
              _context3.next = 21;
              return _regenerator2.default.awrap(_promise2.default.all(history.map(function _callee2(item) {
                var block_res;
                return _regenerator2.default.async(function _callee2$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        _context2.next = 2;
                        return _regenerator2.default.awrap(_api2.default.Operations.get_block_header(item.block_num));

                      case 2:
                        block_res = _context2.sent;

                        if (block_res.code == 1) {
                          item.block_time = new Date(block_res.data.timestamp + "Z").format("yyyy/MM/dd HH:mm:ss");
                        }
                        return _context2.abrupt('return', item);

                      case 5:
                      case 'end':
                        return _context2.stop();
                    }
                  }
                }, null, _this3);
              })));

            case 21:
              this.currentAccount.history = _context3.sent;

            case 22:

              this.marketData.history.forEach(function (order) {
                order.op.time = order.time;
                _this3.activeMarketHistory = _this3.activeMarketHistory.add(order.op);
              });
              assets = (_assets = {}, (0, _defineProperty3.default)(_assets, this.quoteAsset.get("id"), { precision: this.quoteAsset.get("precision") }), (0, _defineProperty3.default)(_assets, this.baseAsset.get("id"), { precision: this.baseAsset.get("precision") }), _assets);

              this.marketLimitOrders = _immutable2.default.Map();
              this._marketLimitOrders = _immutable2.default.Map();
              this.marketData.limits.forEach(function (order) {
                _bcxjsCores.ChainStore._updateObject(order, false, false);
                if (typeof order.for_sale !== "number") {
                  order.for_sale = parseInt(order.for_sale, 10);
                }
                order.expiration = new Date(order.expiration);
                _this3.marketLimitOrders = _this3.marketLimitOrders.set(order.id, new _MarketClasses.LimitOrder(order, assets, assetId));
                _this3._marketLimitOrders = _this3._marketLimitOrders.set(order.id, new _MarketClasses.LimitOrder(order, assets, assetId));
              });
              this._orderBook();
              this.markets[assetId].callback && this.markets[assetId].callback();

            case 29:
            case 'end':
              return _context3.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: '_orderBook',
    value: function _orderBook() {
      var limitsChanged = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var callsChanged = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      // Loop over limit orders and return array containing bids
      var constructBids = function constructBids(orderArray) {
        var bids = orderArray.filter(function (a) {
          return a.isBid();
        }).sort(function (a, b) {
          return a.getPrice() - b.getPrice();
        }).map(function (order) {
          return order;
        }).toArray();

        // Sum bids at same price
        if (bids.length > 1) {
          for (var i = bids.length - 2; i >= 0; i--) {
            if (bids[i].getPrice() === bids[i + 1].getPrice()) {
              bids[i].sum(bids[i + 1]);
              bids.splice(i + 1, 1);
            }
          }
        }
        return bids;
      };
      // Loop over limit orders and return array containing asks
      var constructAsks = function constructAsks(orderArray) {
        var asks = orderArray.filter(function (a) {
          return !a.isBid();
        }).sort(function (a, b) {
          return a.getPrice() - b.getPrice();
        }).map(function (order) {
          return order;
        }).toArray();
        // Sum asks at same price
        if (asks.length > 1) {
          for (var i = asks.length - 2; i >= 0; i--) {
            if (asks[i].getPrice() === asks[i + 1].getPrice()) {
              asks[i].sum(asks[i + 1]);
              asks.splice(i + 1, 1);
            }
          }
        }
        return asks;
      };

      // Assign to store variables
      if (limitsChanged) {
        // console.time("Construct limit orders " + this.activeMarket);
        this.marketData.bids = constructBids(this.marketLimitOrders);
        this.marketData.asks = constructAsks(this.marketLimitOrders);
        if (!callsChanged) {
          this._combineOrders();
        }
        // console.timeEnd("Construct limit orders " + this.activeMarket);
      }

      if (callsChanged) {
        // console.time("Construct calls " + this.activeMarket);
        this.marketData.calls = this.constructCalls(this.marketCallOrders);
        this._combineOrders();
        // console.timeEnd("Construct calls " + this.activeMarket);
      }
      // console.log("time to construct orderbook:", new Date() - orderBookStart, "ms");
    }
  }, {
    key: 'constructCalls',
    value: function constructCalls(callsArray) {
      var _this4 = this;

      var calls = [];
      if (callsArray.size) {
        calls = callsArray.sort(function (a, b) {
          return a.getPrice() - b.getPrice();
        }).map(function (order) {
          if (_this4.invertedCalls) {
            _this4.lowestCallPrice = !_this4.lowestCallPrice ? order.getPrice(false) : Math.max(_this4.lowestCallPrice, order.getPrice(false));
          } else {
            _this4.lowestCallPrice = !_this4.lowestCallPrice ? order.getPrice(false) : Math.min(_this4.lowestCallPrice, order.getPrice(false));
          }

          return order;
        }).toArray();

        // Sum calls at same price
        if (calls.length > 1) {
          for (var i = calls.length - 2; i >= 0; i--) {
            calls[i] = calls[i].sum(calls[i + 1]);
            calls.splice(i + 1, 1);
          }
        }
      }
      return calls;
    }
  }, {
    key: 'unsubscribeFromMarket',
    value: function unsubscribeFromMarket(assetId) {
      if (this.isSubscribed(assetId)) {
        delete this.markets[assetId];
      }
    }
  }, {
    key: 'unsubscribeFromExchangeRate',
    value: function unsubscribeFromExchangeRate(assetId) {
      this.unsubscribeFromMarket(assetId);
    }
  }, {
    key: 'unsubscribeFromMarkets',
    value: function unsubscribeFromMarkets() {
      this.markets = {};
    }
  }, {
    key: 'subscribeToExchangeRate',
    value: function subscribeToExchangeRate(trxPair, currentAccount, hasMyTradeHistory, callback) {
      var _this5 = this;

      var asset_ress, assetId, canReceiveInBasePrev, wrappedCallback;
      return _regenerator2.default.async(function subscribeToExchangeRate$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              this.currentAccount = currentAccount;
              this.hasMyTradeHistory = hasMyTradeHistory;
              trxPair = trxPair.split("_");
              _context4.next = 5;
              return _regenerator2.default.awrap(_promise2.default.all(trxPair.map(function (asset, index) {
                return _api2.default.Assets.fetch_asset_one(asset);
              })));

            case 5:
              asset_ress = _context4.sent;

              if (!(asset_ress[0].code != 1)) {
                _context4.next = 9;
                break;
              }

              callback && callback(asset_ress[0]);
              return _context4.abrupt('return');

            case 9:
              if (!(asset_ress[1].code != 1)) {
                _context4.next = 12;
                break;
              }

              callback && callback(asset_ress[1]);
              return _context4.abrupt('return');

            case 12:
              this.quoteAsset = _immutable2.default.fromJS(asset_ress[0].data);
              this.baseAsset = _immutable2.default.fromJS(asset_ress[1].data);
              this.base = this.baseAsset.get("id");
              assetId = this.quoteAsset.get("id");


              this.amount = currentAccount && currentAccount.balances[assetId] ? currentAccount.balances[assetId].balance : 0;

              canReceiveInBasePrev = 0;

              this.firstCallSub = true;

              wrappedCallback = function wrappedCallback() {
                var canReceiveInBase = _this5.calcExchangeRate(assetId, 'sell', _this5.amount);
                if (canReceiveInBase !== canReceiveInBasePrev && canReceiveInBase > 0) {
                  canReceiveInBasePrev = canReceiveInBase;
                }

                var _marketData = _this5.marketData,
                    combinedBids = _marketData.combinedBids,
                    combinedAsks = _marketData.combinedAsks;

                var _marketsData = {
                  orders: {
                    buy: _this5.ordersToObject(combinedBids),
                    sell: _this5.ordersToObject(combinedAsks)
                  },
                  my_orders: _this5.currentAccount ? _this5.getMyOrders() : [],
                  last_trade_history: _this5.getTradeHistory()
                  //_marketsData.my_last_trade_history=
                };_this5.getMyHistory().then(function (data) {
                  _marketsData.my_last_trade_history = data;
                  callback({ code: 1, data: _marketsData }, assetId, canReceiveInBase, _this5.firstCallSub);
                  _this5.firstCallSub = false;
                });
              };

              _context4.next = 22;
              return _regenerator2.default.awrap(this.subscribeToMarket(assetId, wrappedCallback));

            case 22:
            case 'end':
              return _context4.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: 'getMyHistory',
    value: function getMyHistory() {
      var _this6 = this;

      var keyIndex, flipped, ApiObject, ApiObjectDyn;
      return _regenerator2.default.async(function getMyHistory$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              if (!(!this.hasMyTradeHistory || !this.currentAccount)) {
                _context6.next = 2;
                break;
              }

              return _context6.abrupt('return', []);

            case 2:
              keyIndex = -1;
              flipped = this.baseAsset.get("id").split(".")[2] > this.quoteAsset.get("id").split(".")[2];
              _context6.next = 6;
              return _regenerator2.default.awrap(_api2.default.Explorer.getGlobalObject());

            case 6:
              _context6.t0 = _context6.sent.data;
              ApiObject = [_context6.t0];
              _context6.next = 10;
              return _regenerator2.default.awrap(_api2.default.Explorer.getDynGlobalObject(false));

            case 10:
              _context6.t1 = _context6.sent.data;
              ApiObjectDyn = [_context6.t1];
              return _context6.abrupt('return', _promise2.default.all(_immutable2.default.fromJS(this.currentAccount.history).filter(function (a) {
                var opType = a.getIn(["op", 0]);
                return opType === operations.fill_order;
              }).filter(function (a) {
                var quoteID = _this6.quoteAsset.get("id");
                var baseID = _this6.baseAsset.get("id");
                var pays = a.getIn(["op", 1, "pays", "asset_id"]);
                var receives = a.getIn(["op", 1, "receives", "asset_id"]);
                var hasQuote = quoteID === pays || quoteID === receives;
                var hasBase = baseID === pays || baseID === receives;
                return hasQuote && hasBase;
              }).sort(function (a, b) {
                return a.get("block_num") - a.get("block_num");
              }).map(function _callee3(trx) {
                var order, paysAsset, receivesAsset, isAsk, parsed_order, block_num, price, date, block_res;
                return _regenerator2.default.async(function _callee3$(_context5) {
                  while (1) {
                    switch (_context5.prev = _context5.next) {
                      case 0:
                        order = trx.toJS().op[1];
                        //console.debug('order',trx.toJS());

                        keyIndex++;
                        paysAsset = void 0, receivesAsset = void 0, isAsk = false;

                        if (order.pays.asset_id === _this6.baseAsset.get("id")) {
                          paysAsset = _this6.baseAsset;
                          receivesAsset = _this6.quoteAsset;
                          isAsk = true;
                        } else {
                          paysAsset = _this6.quoteAsset;
                          receivesAsset = _this6.baseAsset;
                        }

                        parsed_order = _market_utils2.default.parse_order_history(order, paysAsset, receivesAsset, isAsk, flipped);
                        block_num = trx.get("block_num");
                        price = parsed_order.int + ".";


                        price += parsed_order.dec || "";
                        price += parsed_order.trailing || "";

                        date = "";
                        _context5.next = 12;
                        return _regenerator2.default.awrap(_api2.default.Operations.get_block_header(block_num));

                      case 12:
                        block_res = _context5.sent;

                        if (block_res.code == 1) {
                          date = new Date(block_res.data.timestamp + "Z").format("yyyy/MM/dd HH:mm:ss");
                        } else {
                          date = _api2.default.Operations._getOperationDate(trx.toJS(), ApiObject, ApiObjectDyn);
                        }

                        return _context5.abrupt('return', {
                          price: price,
                          price_unit: _this6.baseAsset.get("symbol"),
                          amount: _utils4.default.formatNumber(parsed_order.receives, 4),
                          amount_unit: _this6.quoteAsset.get("symbol"),
                          turnover: _utils4.default.formatNumber(parsed_order.pays, 4),
                          turnover_unit: _this6.baseAsset.get("symbol"),
                          block_num: block_num,
                          block_time: date, //trx.get("block_time"),
                          type: parsed_order.className == "orderHistoryBid" ? "buy" : "sell"
                        });

                      case 15:
                      case 'end':
                        return _context5.stop();
                    }
                  }
                }, null, _this6);
              }).toArray()));

            case 13:
            case 'end':
              return _context6.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: 'getTradeHistory',
    value: function getTradeHistory() {
      var _this7 = this;

      var index = 0;
      var keyIndex = -1;
      var flipped = this.baseAsset.get("id").split(".")[2] > this.quoteAsset.get("id").split(".")[2];

      return this.activeMarketHistory.filter(function (a) {
        index++;
        return index % 2 === 0;
      }).take(100).map(function (order) {
        //console.debug('order:',order)
        keyIndex++;
        var paysAsset = void 0,
            receivesAsset = void 0,
            isAsk = false;
        if (order.pays.asset_id === _this7.baseAsset.get("id")) {
          paysAsset = _this7.baseAsset;
          receivesAsset = _this7.quoteAsset;
          isAsk = true;
        } else {
          paysAsset = _this7.quoteAsset;
          receivesAsset = _this7.baseAsset;
        }

        var parsed_order = _market_utils2.default.parse_order_history(order, paysAsset, receivesAsset, isAsk, flipped);
        // let time = parsed_order.time.split(':');
        // if (time.length > 2) {
        //     time = time[0].substr(2) + ':' + time[1];
        // }

        var price = parsed_order.int + ".";

        //if(formattedPrice.full >= 1){
        price += parsed_order.dec || "";
        price += parsed_order.trailing || "";
        //}
        return {
          price: price,
          price_unit: _this7.baseAsset.get("symbol") + "/" + _this7.quoteAsset.get("symbol"),
          amount: _utils4.default.formatNumber(parsed_order.receives, 4),
          amount_unit: _this7.quoteAsset.get("symbol"),
          turnover: _utils4.default.formatNumber(parsed_order.pays, 4),
          turnover_unit: _this7.baseAsset.get("symbol"),
          block_time: parsed_order.time,
          type: parsed_order.className == "orderHistoryBid" ? "buy" : "sell"
        };
      }).toArray();
    }
  }, {
    key: 'getMyOrders',
    value: function getMyOrders() {
      var _this8 = this;

      var buyOrders = this._marketLimitOrders.filter(function (a) {
        return a.seller === _this8.currentAccount.account.id && a.sell_price.quote.asset_id !== _this8.baseAsset.get("id");
      }).sort(function (a, b) {
        var _market_utils$parseOr = _market_utils2.default.parseOrder(a, _this8.baseAsset, _this8.quoteAsset),
            a_price = _market_utils$parseOr.price;

        var _market_utils$parseOr2 = _market_utils2.default.parseOrder(b, _this8.baseAsset, _this8.quoteAsset),
            b_price = _market_utils$parseOr2.price;

        return b_price.full - a_price.full;
      }).toArray().map(function (item) {
        item.type = "buy";
        return item;
      });

      var sellOrders = this._marketLimitOrders.filter(function (a) {
        return a.seller === _this8.currentAccount.account.id && a.sell_price.quote.asset_id === _this8.baseAsset.get("id");
      }).sort(function (a, b) {
        var _market_utils$parseOr3 = _market_utils2.default.parseOrder(a, _this8.baseAsset, _this8.quoteAsset),
            a_price = _market_utils$parseOr3.price;

        var _market_utils$parseOr4 = _market_utils2.default.parseOrder(b, _this8.baseAsset, _this8.quoteAsset),
            b_price = _market_utils$parseOr4.price;

        return a_price.full - b_price.full;
      }).toArray().map(function (item) {
        item.type = "sell";
        return item;
      });

      return this.ordersToObject(buyOrders.concat(sellOrders));
    }
  }, {
    key: 'ordersToObject',
    value: function ordersToObject(orders) {
      var _this9 = this;

      return orders.map(function (order) {
        var isBid = order.isBid();

        var _market_utils$parseOr5 = _market_utils2.default.parseOrder(order, _this9.baseAsset, _this9.quoteAsset),
            price = _market_utils$parseOr5.price;

        var item = {
          order_id: order.id,
          price: _utils4.default.format_number(price.full, _this9.baseAsset.get("precision")),
          price_unit: _this9.baseAsset.get("symbol"),
          amount: _utils4.default.format_number(order[isBid ? "amountToReceive" : "amountForSale"]().getAmount({ real: true }), _this9.quoteAsset.get("precision")),
          amount_unit: _this9.quoteAsset.get("symbol"),
          turnover: _utils4.default.format_number(order[isBid ? "amountForSale" : "amountToReceive"]().getAmount({ real: true }), _this9.baseAsset.get("precision")),
          turnover_unit: _this9.baseAsset.get("symbol"),
          expiration: new Date(order.expiration + "Z").format("yyyy/MM/dd HH:mm:ss")
        };
        if (order.type) {
          item.type = order.type;
        }
        return item;
      });
    }
  }, {
    key: 'calcExchangeRate',
    value: function calcExchangeRate(assetId, weWantTo, amount) {
      var totalPay = amount;
      var totalReceive = 0;

      var requiredType = weWantTo === 'sell' ? 'buy' : 'sell';
      // console.log('cakc exchange rate for ' + assetId + ': ', this.markets[assetId]);
      var orders = [].concat((0, _toConsumableArray3.default)(this.markets[assetId].orders[requiredType])).sort(function (a, b) {
        return calcOrderRate(b) - calcOrderRate(a);
      });
      for (var i = 0; i < orders.length; i += 1) {
        var _orders$i = orders[i],
            saleAmount = _orders$i.for_sale,
            price = _orders$i.sell_price;

        var orderPrice = price.base.amount / price.quote.amount;
        var weCanPayHere = saleAmount / orderPrice;

        if (totalPay > weCanPayHere) {
          totalReceive += saleAmount;
          totalPay -= weCanPayHere;
        } else {
          totalReceive += totalPay * orderPrice;
          break;
        }
      }
      return Math.floor(totalReceive);
    }
  }, {
    key: 'generateOrders',
    value: function generateOrders(_ref2) {
      var _this10 = this;

      var update = _ref2.update,
          balances = _ref2.balances,
          baseBalances = _ref2.baseBalances,
          userId = _ref2.userId;

      var calculated = utils.getValuesToUpdate(balances, baseBalances, update);
      var sellOrders = [];
      var buyOrders = [];

      (0, _keys2.default)(calculated.sell).forEach(function (assetId) {
        var toSell = calculated.sell[assetId];
        // if (!toSell) return;
        var toReceive = _this10.calcExchangeRate(assetId, 'sell', toSell);
        var fee = _this10.getFee(assetId);
        if (toReceive > fee) {
          toReceive -= fee;
          var orderObject = {
            sell: {
              asset_id: assetId,
              amount: toSell
            },
            receive: {
              asset_id: _this10.base,
              amount: toReceive
            },
            userId: userId,
            fillOrKill: true
          };
          var order = utils.createOrder(orderObject);

          sellOrders.push(order);
        }
      });

      (0, _keys2.default)(calculated.buy).forEach(function (assetId) {
        var toSellBase = calculated.buy[assetId];
        var fee = _this10.getFee(assetId);
        if (toSellBase > fee) {
          toSellBase -= fee;
          var toReceive = _this10.calcExchangeRate(assetId, 'buy', toSellBase);
          if (!toReceive) return;
          var orderObject = {
            sell: {
              asset_id: _this10.base,
              amount: toSellBase
            },
            receive: {
              asset_id: assetId,
              amount: toReceive
            },
            userId: userId
          };
          var order = utils.createOrder(orderObject);
          buyOrders.push(order);
        }
      });

      return {
        sellOrders: sellOrders,
        buyOrders: buyOrders
      };
    }
  }, {
    key: '_combineOrders',
    value: function _combineOrders() {
      var hasCalls = !!this.marketCallOrders.size;
      var isBid = hasCalls && this.marketCallOrders.first().isBid();
      if (isBid) {
        this.marketData.combinedBids = this.marketData.bids.concat(this.marketData.calls);
        this.marketData.combinedAsks = this.marketData.asks.concat([]);
      } else {
        this.marketData.combinedBids = this.marketData.bids.concat([]);
        this.marketData.combinedAsks = this.marketData.asks.concat(this.marketData.calls || []);
      }

      var totalToReceive = new _MarketClasses.Asset({
        asset_id: this.quoteAsset.get("id"),
        precision: this.quoteAsset.get("precision")
      });

      var totalForSale = new _MarketClasses.Asset({
        asset_id: this.baseAsset.get("id"),
        precision: this.baseAsset.get("precision")
      });
      this.marketData.combinedBids.sort(function (a, b) {
        return b.getPrice() - a.getPrice();
      }).forEach(function (a) {
        totalToReceive.plus(a.amountToReceive(false));
        totalForSale.plus(a.amountForSale());

        a.setTotalForSale(totalForSale.clone());
        a.setTotalToReceive(totalToReceive.clone());
      });

      totalToReceive = new _MarketClasses.Asset({
        asset_id: this.baseAsset.get("id"),
        precision: this.baseAsset.get("precision")
      });

      totalForSale = new _MarketClasses.Asset({
        asset_id: this.quoteAsset.get("id"),
        precision: this.quoteAsset.get("precision")
      });

      this.marketData.combinedAsks.sort(function (a, b) {
        return b.getPrice() - a.getPrice();
      }).forEach(function (a) {
        totalForSale.plus(a.amountForSale());
        totalToReceive.plus(a.amountToReceive(true));
        a.setTotalForSale(totalForSale.clone());
        a.setTotalToReceive(totalToReceive.clone());
      });

      this.marketData.lowestAsk = !this.marketData.combinedAsks.length ? nullPrice : this.marketData.combinedAsks[0];

      this.marketData.highestBid = !this.marketData.combinedBids.length ? nullPrice : this.marketData.combinedBids[0];
    }
  }]);
  return Market;
}();

exports.default = Market;

/***/ }),
/* 394 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = {
    permission_flags: {
        charge_market_fee: 0x01 /**< an issuer-specified percentage of all market trades in this asset is paid to the issuer */
        , white_list: 0x02 /**< accounts must be whitelisted in order to hold this asset */
        , override_authority: 0x04 /**< issuer may transfer asset back to himself */
        , transfer_restricted: 0x08 /**< require the issuer to be one party to every transfer */
        , disable_force_settle: 0x10 /**< disable force settling */
        , global_settle: 0x20 /**< allow the bitasset issuer to force a global settling -- this may be set in permissions, but not flags */
        , disable_issuer: 0x40 /**< allow the asset to be used with confidential transactions */
        , //disable_confidential: 0x40 /**< allow the asset to be used with confidential transactions */,

        witness_fed_asset: 0x80 /**< allow the asset to be fed by witnesses */
        , committee_fed_asset: 0x100 /**< allow the asset to be fed by the committee */
    },
    uia_permission_mask: ["charge_market_fee", "white_list", "override_authority", "transfer_restricted", "disable_confidential"],
    GRAPHENE_100_PERCENT: 10000,
    GRAPHENE_1_PERCENT: 10000 / 100,
    GRAPHENE_MAX_SHARE_SUPPLY: "1000000000000000"
};

/***/ }),
/* 395 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _stringify = __webpack_require__(18);

var _stringify2 = _interopRequireDefault(_stringify);

var _localStorageImpl = __webpack_require__(549);

var _localStorageImpl2 = _interopRequireDefault(_localStorageImpl);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// if (null === ls) throw "localStorage is required but isn't available on this platform";

exports.default = function (key) {
    var STORAGE_KEY = key;
    if (null === _localStorageImpl2.default) {
        return null;
    }
    return {
        get: function get(key) {
            var dv = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            var rv = void 0;
            if ((0, _localStorageImpl.ls_key_exists)(STORAGE_KEY + key, _localStorageImpl2.default)) {
                rv = JSON.parse(_localStorageImpl2.default.getItem(STORAGE_KEY + key));
            }
            return rv ? rv : dv;
        },
        set: function set(key, object) {
            if (object && object.toJS) {
                object = object.toJS();
            }
            _localStorageImpl2.default.setItem(STORAGE_KEY + key, (0, _stringify2.default)(object));
        },
        remove: function remove(key) {
            _localStorageImpl2.default.removeItem(STORAGE_KEY + key);
        },
        has: function has(key) {
            return (0, _localStorageImpl.ls_key_exists)(STORAGE_KEY + key, _localStorageImpl2.default);
        }
    };
};

/***/ }),
/* 396 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _tcomb = __webpack_require__(552);

var _tcomb2 = _interopRequireDefault(_tcomb);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Asset = _tcomb2.default.struct({
    bitasset_data_id: _tcomb2.default.maybe(_tcomb2.default.Str),
    bitasset_data: _tcomb2.default.maybe(_tcomb2.default.Obj),
    dynamic_asset_data_id: _tcomb2.default.Str,
    dynamic_data: _tcomb2.default.maybe(_tcomb2.default.Obj),
    id: _tcomb2.default.Str,
    issuer: _tcomb2.default.Str,
    market_asset: _tcomb2.default.Bool,
    options: _tcomb2.default.Obj,
    precision: _tcomb2.default.Num,
    symbol: _tcomb2.default.Str
}, "Asset");

var Block = _tcomb2.default.struct({
    extensions: _tcomb2.default.Arr,
    id: _tcomb2.default.Num,
    previous: _tcomb2.default.Str,
    timestamp: _tcomb2.default.Dat,
    transactions: _tcomb2.default.Arr,
    transaction_merkle_root: _tcomb2.default.Str,
    witness: _tcomb2.default.Str,
    witness_signature: _tcomb2.default.Str
}, "Block");

var WalletTcomb = _tcomb2.default.struct({
    public_name: _tcomb2.default.Str,
    created: _tcomb2.default.Dat,
    last_modified: _tcomb2.default.Dat,
    backup_date: _tcomb2.default.maybe(_tcomb2.default.Dat),
    password_pubkey: _tcomb2.default.Str,
    encryption_key: _tcomb2.default.Str,
    encrypted_brainkey: _tcomb2.default.maybe(_tcomb2.default.Str),
    brainkey_pubkey: _tcomb2.default.Str,
    brainkey_sequence: _tcomb2.default.Num,
    brainkey_backup_date: _tcomb2.default.maybe(_tcomb2.default.Dat),
    deposit_keys: _tcomb2.default.maybe(_tcomb2.default.Obj),
    // password_checksum: t.Str,
    chain_id: _tcomb2.default.Str
}, "WalletTcomb");

var PrivateKeyTcomb = _tcomb2.default.struct({
    id: _tcomb2.default.maybe(_tcomb2.default.Num),
    pubkey: _tcomb2.default.Str,
    label: _tcomb2.default.maybe(_tcomb2.default.Str),
    import_account_names: _tcomb2.default.maybe(_tcomb2.default.Arr),
    brainkey_sequence: _tcomb2.default.maybe(_tcomb2.default.Num),
    encrypted_key: _tcomb2.default.Str
}, "PrivateKeyTcomb");

//let PublicKeyTcomb = t.struct({
//    id: t.maybe(t.Num),
//    pubkey: t.Str,
//    United Labs of BCTech.
//    key_id: t.maybe(t.Str)
//}, "PublicKeyTcomb");

var LimitOrder = _tcomb2.default.struct({
    expiration: _tcomb2.default.Dat,
    for_sale: _tcomb2.default.Num,
    id: _tcomb2.default.Str,
    sell_price: _tcomb2.default.Obj,
    seller: _tcomb2.default.Str
}, "LimitOrder");

var SettleOrder = _tcomb2.default.struct({
    settlement_date: _tcomb2.default.Dat,
    balance: _tcomb2.default.Obj,
    owner: _tcomb2.default.Str
}, "SettleOrder");

var ShortOrder = _tcomb2.default.struct({
    expiration: _tcomb2.default.Dat,
    for_sale: _tcomb2.default.Num,
    id: _tcomb2.default.Str,
    sell_price: _tcomb2.default.Obj,
    seller: _tcomb2.default.Str
}, "ShortOrder");

var CallOrder = _tcomb2.default.struct({
    borrower: _tcomb2.default.Str,
    call_price: _tcomb2.default.Obj,
    collateral: _tcomb2.default.Num,
    debt: _tcomb2.default.Num,
    id: _tcomb2.default.Str
}, "CallOrder");

module.exports = {
    Asset: Asset,
    Block: Block,
    WalletTcomb: WalletTcomb,
    //PublicKeyTcomb: PublicKeyTcomb,
    PrivateKeyTcomb: PrivateKeyTcomb,
    LimitOrder: LimitOrder,
    ShortOrder: ShortOrder,
    CallOrder: CallOrder,
    SettleOrder: SettleOrder
};

/***/ }),
/* 397 */
/***/ (function(module, exports, __webpack_require__) {

var getFunctionName = __webpack_require__(132);

function replacer(key, value) {
  if (typeof value === 'function') {
    return getFunctionName(value);
  }
  return value;
}

module.exports = function stringify(x) {
  try { // handle "Converting circular structure to JSON" error
    return JSON.stringify(x, replacer, 2);
  }
  catch (e) {
    return String(x);
  }
};

/***/ }),
/* 398 */
/***/ (function(module, exports, __webpack_require__) {

var irreducible = __webpack_require__(40);
var isBoolean = __webpack_require__(152);

module.exports = irreducible('Boolean', isBoolean);


/***/ }),
/* 399 */
/***/ (function(module, exports, __webpack_require__) {

var irreducible = __webpack_require__(40);
var isNil = __webpack_require__(53);

module.exports = irreducible('Nil', isNil);


/***/ }),
/* 400 */
/***/ (function(module, exports, __webpack_require__) {

var irreducible = __webpack_require__(40);
var isNumber = __webpack_require__(229);

module.exports = irreducible('Number', isNumber);


/***/ }),
/* 401 */
/***/ (function(module, exports, __webpack_require__) {

var isType = __webpack_require__(37);

module.exports = function isUnion(x) {
  return isType(x) && ( x.meta.kind === 'union' );
};

/***/ }),
/* 402 */
/***/ (function(module, exports, __webpack_require__) {

var assert = __webpack_require__(20);
var isTypeName = __webpack_require__(46);
var isFunction = __webpack_require__(36);
var getTypeName = __webpack_require__(35);
var isIdentity = __webpack_require__(63);
var create = __webpack_require__(64);
var is = __webpack_require__(65);
var isArray = __webpack_require__(62);

function getDefaultName(type) {
  return 'Array<' + getTypeName(type) + '>';
}

function list(type, name) {

  if (true) {
    assert(isFunction(type), function () { return 'Invalid argument type ' + assert.stringify(type) + ' supplied to list(type, [name]) combinator (expected a type)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to list(type, [name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(type);
  var typeNameCache = getTypeName(type);
  var identity = isIdentity(type); // the list is identity iif type is identity

  function List(value, path) {

    if (false) {
      if (identity) {
        return value; // just trust the input if elements must not be hydrated
      }
    }

    if (true) {
      path = path || [displayName];
      assert(isArray(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (expected an array of ' + typeNameCache + ')'; });
    }

    var idempotent = true; // will remain true if I can reutilise the input
    var ret = []; // make a temporary copy, will be discarded if idempotent remains true
    for (var i = 0, len = value.length; i < len; i++ ) {
      var actual = value[i];
      var instance = create(type, actual, (  true ? path.concat(i + ': ' + typeNameCache) : null ));
      idempotent = idempotent && ( actual === instance );
      ret.push(instance);
    }

    if (idempotent) { // implements idempotency
      ret = value;
    }

    if (true) {
      Object.freeze(ret);
    }

    return ret;
  }

  List.meta = {
    kind: 'list',
    type: type,
    name: name,
    identity: identity
  };

  List.displayName = displayName;

  List.is = function (x) {
    return isArray(x) && x.every(function (e) {
      return is(e, type);
    });
  };

  List.update = function (instance, patch) {
    return List(assert.update(instance, patch));
  };

  return List;
}

list.getDefaultName = getDefaultName;
module.exports = list;


/***/ }),
/* 403 */
/***/ (function(module, exports, __webpack_require__) {

var getTypeName = __webpack_require__(35);

function getDefaultInterfaceName(props) {
  return '{' + Object.keys(props).map(function (prop) {
    return prop + ': ' + getTypeName(props[prop]);
  }).join(', ') + '}';
}

module.exports = getDefaultInterfaceName;


/***/ }),
/* 404 */
/***/ (function(module, exports, __webpack_require__) {

var assert = __webpack_require__(20);
var isFunction = __webpack_require__(36);
var isArray = __webpack_require__(62);
var mixin = __webpack_require__(233);
var isStruct = __webpack_require__(566);
var isInterface = __webpack_require__(567);
var isObject = __webpack_require__(61);
var refinement = __webpack_require__(230);
var decompose = __webpack_require__(568);

function compose(predicates, unrefinedType, name) {
  var result = predicates.reduce(function (type, predicate) {
    return refinement(type, predicate);
  }, unrefinedType);
  if (name) {
    result.displayName = name;
    result.meta.name = name;
  }
  return result;
}

function getProps(type) {
  return isObject(type) ? type : type.meta.props;
}

function getDefaultProps(type) {
  return isObject(type) ? null : type.meta.defaultProps;
}

function pushAll(arr, elements) {
  Array.prototype.push.apply(arr, elements);
}

function extend(combinator, mixins, options) {
  if (true) {
    assert(isFunction(combinator), function () { return 'Invalid argument combinator supplied to extend(combinator, mixins, options), expected a function'; });
    assert(isArray(mixins), function () { return 'Invalid argument mixins supplied to extend(combinator, mixins, options), expected an array'; });
  }
  var props = {};
  var prototype = {};
  var predicates = [];
  var defaultProps = {};
  mixins.forEach(function (x, i) {
    var decomposition = decompose(x);
    var unrefinedType = decomposition.unrefinedType;
    if (true) {
      assert(isObject(unrefinedType) || isStruct(unrefinedType) || isInterface(unrefinedType), function () { return 'Invalid argument mixins[' + i + '] supplied to extend(combinator, mixins, options), expected an object, struct, interface or a refinement (of struct or interface)'; });
    }
    pushAll(predicates, decomposition.predicates);
    mixin(props, getProps(unrefinedType));
    mixin(prototype, unrefinedType.prototype);
    mixin(defaultProps, getDefaultProps(unrefinedType), true);
  });
  options = combinator.getOptions(options);
  options.defaultProps = mixin(defaultProps, options.defaultProps, true);
  var result = compose(predicates, combinator(props, {
    strict: options.strict,
    defaultProps: options.defaultProps
  }), options.name);
  mixin(result.prototype, prototype);
  return result;
}

module.exports = extend;


/***/ }),
/* 405 */
/***/ (function(module, exports, __webpack_require__) {

var assert = __webpack_require__(20);
var isTypeName = __webpack_require__(46);
var isFunction = __webpack_require__(36);
var getTypeName = __webpack_require__(35);
var isIdentity = __webpack_require__(63);
var isArray = __webpack_require__(62);
var create = __webpack_require__(64);
var is = __webpack_require__(65);

function getDefaultName(types) {
  return '[' + types.map(getTypeName).join(', ') + ']';
}

function tuple(types, name) {

  if (true) {
    assert(isArray(types) && types.every(isFunction), function () { return 'Invalid argument types ' + assert.stringify(types) + ' supplied to tuple(types, [name]) combinator (expected an array of types)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to tuple(types, [name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(types);
  var identity = types.every(isIdentity);

  function Tuple(value, path) {

    if (false) {
      if (identity) {
        return value;
      }
    }

    if (true) {
      path = path || [displayName];
      assert(isArray(value) && value.length === types.length, function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (expected an array of length ' + types.length + ')'; });
    }

    var idempotent = true;
    var ret = [];
    for (var i = 0, len = types.length; i < len; i++) {
      var expected = types[i];
      var actual = value[i];
      var instance = create(expected, actual, (  true ? path.concat(i + ': ' + getTypeName(expected)) : null ));
      idempotent = idempotent && ( actual === instance );
      ret.push(instance);
    }

    if (idempotent) { // implements idempotency
      ret = value;
    }

    if (true) {
      Object.freeze(ret);
    }

    return ret;
  }

  Tuple.meta = {
    kind: 'tuple',
    types: types,
    name: name,
    identity: identity
  };

  Tuple.displayName = displayName;

  Tuple.is = function (x) {
    return isArray(x) &&
      x.length === types.length &&
      types.every(function (type, i) {
        return is(x[i], type);
      });
  };

  Tuple.update = function (instance, patch) {
    return Tuple(assert.update(instance, patch));
  };

  return Tuple;
}

tuple.getDefaultName = getDefaultName;
module.exports = tuple;

/***/ }),
/* 406 */
/***/ (function(module, exports) {

function assign(x, y) {
  for (var k in y) {
    if (y.hasOwnProperty(k)) {
      x[k] = y[k];
    }
  }
  return x;
}

module.exports = assign;


/***/ }),
/* 407 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _stringify = __webpack_require__(18);

var _stringify2 = _interopRequireDefault(_stringify);

var _promise = __webpack_require__(4);

var _promise2 = _interopRequireDefault(_promise);

exports.backup = backup;
exports.createWalletObject = createWalletObject;
exports.createWalletBackup = createWalletBackup;
exports.decryptWalletBackup = decryptWalletBackup;

var _idbInstance = __webpack_require__(60);

var _idbInstance2 = _interopRequireDefault(_idbInstance);

var _bcxjsLzma = __webpack_require__(577);

var _bcxjsCores = __webpack_require__(7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function backup(backup_pubkey) {
    return new _promise2.default(function (resolve) {
        resolve(createWalletObject().then(function (wallet_object) {
            var compression = 1;
            return createWalletBackup(backup_pubkey, wallet_object, compression);
        }));
    });
}

function createWalletObject() {
    return _idbInstance2.default.backup();
}

function createWalletBackup(backup_pubkey, wallet_object, compression_mode, entropy) {
    return new _promise2.default(function (resolve) {
        var public_key = _bcxjsCores.PublicKey.fromPublicKeyString(backup_pubkey);
        var onetime_private_key = _bcxjsCores.key.get_random_key(entropy);
        var walletString = (0, _stringify2.default)(wallet_object, null, 0);
        (0, _bcxjsLzma.compress)(walletString, compression_mode, function (compressedWalletBytes) {
            var backup_buffer = _bcxjsCores.Aes.encrypt_with_checksum(onetime_private_key, public_key, null /*nonce*/, compressedWalletBytes);

            var onetime_public_key = onetime_private_key.toPublicKey();
            var backup = Buffer.concat([onetime_public_key.toBuffer(), backup_buffer]);
            resolve(backup);
        });
    });
}

function decryptWalletBackup(backup_wif, backup_buffer) {
    return new _promise2.default(function (resolve, reject) {
        if (!Buffer.isBuffer(backup_buffer)) backup_buffer = new Buffer(backup_buffer, "binary");

        var private_key = _bcxjsCores.PrivateKey.fromWif(backup_wif);
        var public_key = void 0;
        try {
            public_key = _bcxjsCores.PublicKey.fromBuffer(backup_buffer.slice(0, 33));
        } catch (e) {
            console.error(e, e.stack);
            throw new Error("Invalid backup file");
        }

        backup_buffer = backup_buffer.slice(33);
        try {
            backup_buffer = _bcxjsCores.Aes.decrypt_with_checksum(private_key, public_key, null /*nonce*/, backup_buffer);
        } catch (error) {
            // console.log("Error decrypting wallet", error, error.stack);
            reject("invalid_decryption_key");
            return;
        }

        try {
            (0, _bcxjsLzma.decompress)(backup_buffer, function (wallet_string) {
                try {
                    var wallet_object = JSON.parse(wallet_string);
                    resolve(wallet_object);
                } catch (error) {
                    if (!wallet_string) wallet_string = "";
                    console.error("Error parsing wallet json", wallet_string.substring(0, 10) + "...");
                    reject("Error parsing wallet json");
                }
            });
        } catch (error) {
            console.log("Error decompressing wallet", error, error.stack);
            reject("Error decompressing wallet");
            return;
        }
    });
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),
/* 408 */,
/* 409 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(13);
var $export = __webpack_require__(16);
var meta = __webpack_require__(102);
var fails = __webpack_require__(47);
var hide = __webpack_require__(39);
var redefineAll = __webpack_require__(135);
var forOf = __webpack_require__(91);
var anInstance = __webpack_require__(134);
var isObject = __webpack_require__(25);
var setToStringTag = __webpack_require__(79);
var dP = __webpack_require__(31).f;
var each = __webpack_require__(246)(0);
var DESCRIPTORS = __webpack_require__(30);

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  if (!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    C = wrapper(function (target, iterable) {
      anInstance(target, C, NAME, '_c');
      target._c = new Base();
      if (iterable != undefined) forOf(iterable, IS_MAP, target[ADDER], target);
    });
    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','), function (KEY) {
      var IS_ADDER = KEY == 'add' || KEY == 'set';
      if (KEY in proto && !(IS_WEAK && KEY == 'clear')) hide(C.prototype, KEY, function (a, b) {
        anInstance(this, C, KEY);
        if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;
        var result = this._c[KEY](a === 0 ? 0 : a, b);
        return IS_ADDER ? this : result;
      });
    });
    IS_WEAK || dP(C.prototype, 'size', {
      get: function () {
        return this._c.size;
      }
    });
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F, O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};


/***/ }),
/* 410 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(16);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = new Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};


/***/ }),
/* 411 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(16);
var aFunction = __webpack_require__(78);
var ctx = __webpack_require__(41);
var forOf = __webpack_require__(91);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};


/***/ }),
/* 412 */,
/* 413 */,
/* 414 */,
/* 415 */,
/* 416 */,
/* 417 */,
/* 418 */,
/* 419 */,
/* 420 */,
/* 421 */,
/* 422 */,
/* 423 */,
/* 424 */,
/* 425 */,
/* 426 */,
/* 427 */,
/* 428 */,
/* 429 */,
/* 430 */,
/* 431 */,
/* 432 */,
/* 433 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(82);
__webpack_require__(75);
module.exports = __webpack_require__(434);


/***/ }),
/* 434 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(33);
var get = __webpack_require__(136);
module.exports = __webpack_require__(6).getIterator = function (it) {
  var iterFn = get(it);
  if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};


/***/ }),
/* 435 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(436), __esModule: true };

/***/ }),
/* 436 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(82);
__webpack_require__(75);
module.exports = __webpack_require__(437);


/***/ }),
/* 437 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(98);
var ITERATOR = __webpack_require__(17)('iterator');
var Iterators = __webpack_require__(54);
module.exports = __webpack_require__(6).isIterable = function (it) {
  var O = Object(it);
  return O[ITERATOR] !== undefined
    || '@@iterator' in O
    // eslint-disable-next-line no-prototype-builtins
    || Iterators.hasOwnProperty(classof(O));
};


/***/ }),
/* 438 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = __webpack_require__(26);

var _typeof3 = _interopRequireDefault(_typeof2);

var _promise = __webpack_require__(4);

var _promise2 = _interopRequireDefault(_promise);

var _defineProperty2 = __webpack_require__(27);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _classCallCheck2 = __webpack_require__(11);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(15);

var _createClass3 = _interopRequireDefault(_createClass2);

var _vue = __webpack_require__(19);

var _vue2 = _interopRequireDefault(_vue);

var _vuex = __webpack_require__(129);

var _vuex2 = _interopRequireDefault(_vuex);

var _setting = __webpack_require__(439);

var _setting2 = _interopRequireDefault(_setting);

var _account = __webpack_require__(521);

var _account2 = _interopRequireDefault(_account);

var _connection = __webpack_require__(525);

var _connection2 = _interopRequireDefault(_connection);

var _transactions = __webpack_require__(529);

var _transactions2 = _interopRequireDefault(_transactions);

var _user = __webpack_require__(541);

var _user2 = _interopRequireDefault(_user);

var _assets = __webpack_require__(544);

var _assets2 = _interopRequireDefault(_assets);

var _market = __webpack_require__(550);

var _market2 = _interopRequireDefault(_market);

var _operations = __webpack_require__(551);

var _operations2 = _interopRequireDefault(_operations);

var _PrivateKeyStore = __webpack_require__(150);

var _PrivateKeyStore2 = _interopRequireDefault(_PrivateKeyStore);

var _WalletDb = __webpack_require__(575);

var _WalletDb2 = _interopRequireDefault(_WalletDb);

var _contract = __webpack_require__(579);

var _contract2 = _interopRequireDefault(_contract);

var _history = __webpack_require__(580);

var _history2 = _interopRequireDefault(_history);

var _vote = __webpack_require__(581);

var _vote2 = _interopRequireDefault(_vote);

var _NHAssets = __webpack_require__(582);

var _NHAssets2 = _interopRequireDefault(_NHAssets);

var _proposals = __webpack_require__(583);

var _proposals2 = _interopRequireDefault(_proposals);

var _explorer = __webpack_require__(585);

var _explorer2 = _interopRequireDefault(_explorer);

var _AddressIndex = __webpack_require__(586);

var _AddressIndex2 = _interopRequireDefault(_AddressIndex);

var _AccountRefsStore = __webpack_require__(587);

var _AccountRefsStore2 = _interopRequireDefault(_AccountRefsStore);

var _WalletManagerStore = __webpack_require__(588);

var _WalletManagerStore2 = _interopRequireDefault(_WalletManagerStore);

var _CachedPropertyStore = __webpack_require__(589);

var _CachedPropertyStore2 = _interopRequireDefault(_CachedPropertyStore);

var _BackupStore = __webpack_require__(590);

var _BackupStore2 = _interopRequireDefault(_BackupStore);

var _AccountStore = __webpack_require__(593);

var _AccountStore2 = _interopRequireDefault(_AccountStore);

var _index = __webpack_require__(96);

var utils = _interopRequireWildcard(_index);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// require('babel-polyfill');
__webpack_require__(600);

var BCX = function () {
  function BCX(params) {
    var _modules;

    (0, _classCallCheck3.default)(this, BCX);

    //Vuex.Storeinitialization
    _vue2.default.use(_vuex2.default);
    this.api = new _vuex2.default.Store({
      modules: (_modules = {
        setting: _setting2.default,
        account: _account2.default,
        transactions: _transactions2.default,
        connection: _connection2.default,
        user: _user2.default,
        assets: _assets2.default
      }, (0, _defineProperty3.default)(_modules, 'setting', _setting2.default), (0, _defineProperty3.default)(_modules, 'market', _market2.default), (0, _defineProperty3.default)(_modules, 'history', _history2.default), (0, _defineProperty3.default)(_modules, 'operations', _operations2.default), (0, _defineProperty3.default)(_modules, 'PrivateKeyStore', _PrivateKeyStore2.default), (0, _defineProperty3.default)(_modules, 'WalletDb', _WalletDb2.default), (0, _defineProperty3.default)(_modules, 'contract', _contract2.default), (0, _defineProperty3.default)(_modules, 'vote', _vote2.default), (0, _defineProperty3.default)(_modules, 'NHAssets', _NHAssets2.default), (0, _defineProperty3.default)(_modules, 'proposals', _proposals2.default), (0, _defineProperty3.default)(_modules, 'explorer', _explorer2.default), (0, _defineProperty3.default)(_modules, 'AddressIndex', _AddressIndex2.default), (0, _defineProperty3.default)(_modules, 'AccountRefsStore', _AccountRefsStore2.default), (0, _defineProperty3.default)(_modules, 'WalletManagerStore', _WalletManagerStore2.default), (0, _defineProperty3.default)(_modules, 'CachedPropertyStore', _CachedPropertyStore2.default), (0, _defineProperty3.default)(_modules, 'BackupStore', _BackupStore2.default), (0, _defineProperty3.default)(_modules, 'AccountStore', _AccountStore2.default), _modules)
    });

    this.apiMethodsInt();

    this.apiConfig(params, false);
  }

  (0, _createClass3.default)(BCX, [{
    key: 'getApiConfig',
    value: function getApiConfig() {
      return this.api.getters["setting/getApiConfig"];
    }
  }, {
    key: 'apiConfig',
    value: function apiConfig(params) {
      var _this = this;

      var isSwitchNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      //API parameters initialization
      if (isSwitchNode) {
        return this.api.dispatch("setting/setSettingsAPIS", params).then(function (res) {
          return _this.switchAPINode({
            url: params.default_ws_node || _this.api.getters["setting/g_settingsAPIs"].select_ws_node,
            callback: params.callback
          });
        });
      } else {
        return this.api.dispatch("setting/setSettingsAPIS", params);
      }
    }

    //initialization and connect websocket. Can be called without initialization, API will automatic initialization if not initialized.

  }, {
    key: 'init',
    value: function init(params) {
      var _this2 = this;

      if (params && (params.callback || typeof params == "function")) {
        this.api.dispatch("connection/initConnection", params);
      } else {
        this.api.dispatch("setting/setSettingsAPIS", params);
        return new _promise2.default(function (resolve) {
          //using params.callback, to compatible with API.
          if ((typeof params === 'undefined' ? 'undefined' : (0, _typeof3.default)(params)) != "object") params = {};
          params.callback = function (res) {
            return resolve(res);
          };
          _this2.api.dispatch("connection/initConnection", params);
        });
      }
    }
  }, {
    key: 'lookupWSNodeList',
    value: function lookupWSNodeList(params) {
      return this.api.dispatch("connection/lookupWSNodeList", params);
    }
    //abstractable methods initialization

  }, {
    key: 'apiMethodsInt',
    value: function apiMethodsInt() {
      var _this3 = this;

      var apiMethods = {
        queryAccountInfo: "user/getUserInfo", //query user info 
        queryAccountBalances: "user/getAccountBalances", //query account's specified asset
        queryAccountAllBalances: "user/getUserAllBalance", //query account's owned assets
        queryTransactionBaseFee: "assets/getTransactionBaseFee", //get transaction base fee
        queryFees: "assets/queryFees",
        createAccountWithPassword: "account/createAccountWithPassword",
        createAccountWithPublicKey: "account/createAccountWithPublicKey",
        passwordLogin: "account/passwordLogin",
        logout: "account/_logout",
        createAccountWithWallet: "account/createAccountWithWallet",
        backupDownload: "WalletDb/backupDownload", //backup wallet file and download
        loadWalletFile: "BackupStore/incommingWebFile", //load wallet file
        restoreWallet: "BackupStore/onRestore", //restore wallet with wallet file
        deleteWallet: "WalletManagerStore/deleteWallet",
        importPrivateKey: "account/importPrivateKey",
        lockAccount: "WalletDb/lockWallet",
        queryContract: "contract/getContract",
        queryAccountContractData: "contract/queryAccountContractData", //query account's contract info
        queryNHAssetOrders: "NHAssets/queryNHAssetOrders",
        queryNHAssets: "NHAssets/lookupNHAssets", //query NHA's info
        queryWorldViews: "NHAssets/lookupWorldViews",
        queryBlock: "explorer/queryBlock",
        queryTransaction: "explorer/queryTransaction",
        lookupWitnessesForExplorer: "explorer/getExplorerWitnesses", //query blocks production info
        // lookupWSNodeList:"connection/lookupWSNodeList",//get API server list
        deleteAPINode: "connection/deleteAPINode", //delete an API server address
        addAPINode: "setting/addAPINode", //add an API server address
        queryAssets: "assets/queryAssets",
        queryDynGlobalObject: "explorer/getDynGlobalObject",
        unsubscribe: "operations/unsubscribe",
        queryDataByIds: "explorer/getDataByIds",
        queryPriceHistory: "market/queryPriceHistory",
        queryAssetRestricted: "assets/queryAssetRestricted",
        queryGas: "assets/estimationGas",
        formatOperations: "operations/formatOperations" //
      };
      var use_accountOpt_methods = {
        getPrivateKey: "account/_getPrivateKey",
        changePassword: "account/changePassword",
        upgradeAccount: "account/upgradeAccount",

        witnessCreate: "vote/witnessCreate",
        committeeMemberCreate: "vote/committeeMemberCreate",
        witnessUpdate: "vote/witnessUpdate",
        committeeMemberUpdate: "vote/committeeMemberUpdate",

        registerCreator: "NHAssets/registerCreator",
        creatWorldView: "NHAssets/creatWorldView",
        creatNHAsset: "NHAssets/creatNHAsset",
        deleteNHAsset: "NHAssets/deleteNHAsset",
        cancelNHAssetOrder: "NHAssets/cancelNHAssetOrder",
        fillNHAssetOrder: "NHAssets/fillNHAssetOrder", //Order matching
        approvalProposal: "proposals/submitProposal",
        relateNHAsset: "NHAssets/relateNHAsset", //Compose NHAs

        createAsset: "assets/_createAsset",
        issueAsset: "assets/issueAsset",
        updateAsset: "assets/_updateAsset",
        reserveAsset: "assets/reserveAsset",
        assetFundFeePool: "assets/assetFundFeePool",
        assetClaimFees: "assets/assetClaimFees",
        assetUpdateRestricted: "assets/assetUpdateRestricted",
        assetPublishFeed: "assets/assetPublishFeed",
        assetUpdateFeedProducers: "assets/assetUpdateFeedProducers",
        assetGlobalSettle: "assets/assetGlobalSettle",
        assetSettle: "assets/assetSettle",

        createLimitOrder: "market/createLimitOrder",
        cancelLimitOrder: "market/cancelLimitOrder",
        callOrderUpdate: "market/callOrderUpdate",

        createContract: "contract/createContract",
        updateContract: "contract/updateContract",
        callContractFunction: "contract/callContractFunction",

        transferAsset: "transactions/transferAsset",
        // 2020-05-13 xulin add
        encryptionOneMome: "transactions/encryptionOneMome",
        setCurrentAccount: "AccountStore/setCurrentAccount",
        proposeRelateWorldView: "NHAssets/proposeRelateWorldView",
        updateCollateralForGas: "assets/updateCollateralForGas",
        claimVestingBalance: "account/claimVestingBalance"

      };

      var use_validateAccount_methods = {
        queryUserOperations: "operations/queryUserOperations", //query account history
        queryAccountOperations: "operations/queryUserOperations",
        queryNHCreator: "NHAssets/queryNHCreator", //query a developer and its worldviews
        queryAccountNHAssets: "NHAssets/queryAccountNHAssets",
        queryAccountNHAssetOrders: "NHAssets/queryAccountNHAssetOrders",
        queryNHAssetsByCreator: "NHAssets/queryNHAssetsByCreator",
        getAccountProposals: "proposals/loadAccountProposals",
        queryDebt: "market/queryDebt",
        queryVestingBalance: "account/queryVestingBalance"
      };

      var _loop = function _loop(key) {
        _this3[key] = function (params) {
          return _this3.promiseCompatible(apiMethods[key], params);
        };
      };

      for (var key in apiMethods) {
        _loop(key);
      }

      var _loop2 = function _loop2(key) {
        _this3[key] = function (params) {
          return _this3.promiseCompatible('account/_accountOpt', {
            method: use_accountOpt_methods[key],
            params: params,
            callback: params ? params.callback : null
          });
        };
      };

      for (var key in use_accountOpt_methods) {
        _loop2(key);
      }

      var _loop3 = function _loop3(key) {
        _this3[key] = function (params) {
          if (!params) params = {};
          return _this3.promiseCompatible('account/_validateAccount', {
            method: use_validateAccount_methods[key],
            params: params,
            account: params.account || _this3.getAccountInfo().account_id,
            callback: params.callback
          });
        };
      };

      for (var key in use_validateAccount_methods) {
        _loop3(key);
      }
    }

    //return promise when callback isnot income

  }, {
    key: 'promiseCompatible',
    value: function promiseCompatible(methodPath, params) {
      var _this4 = this;

      var initPromise = void 0;
      if (this.api.getters["connection/isWsConnected"]) {
        initPromise = this.api.dispatch(methodPath, params);
      } else {
        initPromise = this.init().then(function (init_res) {
          return init_res.code == 1 ? _this4.api.dispatch(methodPath, params) : init_res;
        });
      }
      if (!params || !params.callback) return initPromise;
      initPromise.then(function (res) {
        params.callback(res);
      });
    }

    /*************Interfaces need Special Parameters processing***start****/

    // 2020-03-05  xulin_add è§£ç­¾å’ŒéªŒç­¾

  }, {
    key: 'signString',
    value: function signString(params) {
      var _this5 = this;

      return new _promise2.default(function (resolve) {
        var result = _this5.promiseCompatible("transactions/_signString", params);
        resolve(result);
      });
    }
  }, {
    key: 'checkingSignString',
    value: function checkingSignString(params) {
      return this.promiseCompatible("transactions/_checkingSignString", params);
    }

    // 2020-03-05  xulin_add ç­¾åå’ŒéªŒç­¾

  }, {
    key: 'decodeOneMemo',
    value: function decodeOneMemo(params) {
      return this.promiseCompatible("transactions/_decodeOneMemo", params, this.api);
    }
  }, {
    key: 'transferNHAsset',
    value: function transferNHAsset(params) {
      var toAccount = params.toAccount,
          callback = params.callback;

      return this.promiseCompatible("account/_validateAccount", {
        method: "NHAssets/transferNHAsset",
        params: params,
        account: toAccount,
        accountFieldName: "to_account_id",
        callback: callback
      });
    }
  }, {
    key: 'creatNHAssetOrder',
    value: function creatNHAssetOrder(params) {
      return this.promiseCompatible("account/_validateAccount", {
        method: "NHAssets/creatNHAssetOrder",
        params: params,
        account: params.otcAccount,
        accountFieldName: "otc_account_id",
        callback: params.callback
      });
    }
  }, {
    key: 'disconnect',
    value: function disconnect(params) {
      if (typeof params == "function") {
        params = { callback: params };
      }
      return this.promiseCompatible("connection/disconnect", params);
    }
  }, {
    key: 'privateKeyLogin',
    value: function privateKeyLogin(params) {
      var privateKey = params.privateKey,
          _params$password = params.password,
          password = _params$password === undefined ? "" : _params$password;

      return this.promiseCompatible("account/keyLogin", {
        wif: privateKey,
        password: password,
        callback: params.callback
      });
    }
  }, {
    key: 'unlockAccount',
    value: function unlockAccount(params) {
      var userInfo = this.getAccountInfo();
      if (userInfo.mode == "account") {
        params.account = userInfo.account_name;
      } else if (userInfo.mode == "wallet") {
        params.unlock = true;
      }

      var callback = params.callback;
      delete params.callback;
      return this.promiseCompatible("WalletDb/validatePassword", params).then(function (res) {
        if (res.code == 1) res.message = "The Account has been unlocked";
        delete res.cloudMode;
        delete res.success;
        callback && callback(res);
        callback = null;
        return res;
      });
    }
    /*********Interfaces need Special Parameters processing***end****/

  }, {
    key: 'getWsConnected',
    value: function getWsConnected() {
      return this.api.getters['connection/isWsConnected'];
    }
  }, {
    key: 'getAccountInfo',
    value: function getAccountInfo() {
      var getters = this.api.getters;
      var accountObject = this.api.getters["user/getAccountObject"];
      var res = {
        account_id: getters["account/getAccountUserId"] || "",
        locked: getters["WalletDb/isLocked"]
      };
      res.account_name = accountObject ? accountObject.name : "";
      res.mode = this.api.getters["WalletDb/wallet"] ? "wallet" : "account";
      return res;
    }
  }, {
    key: 'getAccounts',
    value: function getAccounts(params) {
      var _this6 = this;

      if (params && params.callback) {
        this.init().then(function (init_res) {
          params.callback(init_res.code == 1 ? {
            code: 1,
            data: {
              accounts: _this6.api.getters["WalletDb/wallet"] ? _this6.api.getters["AccountStore/linkedAccounts"].toJS() : [],
              current_account: _this6.getAccountInfo()
            }
          } : init_res);
        });
      }
      return {
        accounts: this.api.getters["WalletDb/wallet"] ? this.api.getters["AccountStore/linkedAccounts"].toJS() : [],
        current_account: this.getAccountInfo()
      };
    }
  }, {
    key: 'psdChangePrivateKey',
    value: function psdChangePrivateKey(password) {
      var myAccountName = this.getAccountInfo();

      var active_private = this.promiseCompatible("account/_psdChangePrivateKey", {
        account: myAccountName.account_name,
        password: password
      });
    }
  }, {
    key: 'psdDecodeMemo',
    value: function psdDecodeMemo(memo, account, password) {
      if (this.getAccountInfo().isLocked) {
        return { code: 114, message: "Account is locked or not logged in" };
      }
      if (memo) {
        var result = this.api.getters["PrivateKeyStore/psdDecodeMemo"](memo, this.api, account, password);
        // return {code:1,data:this.api.getters["PrivateKeyStore/psdDecodeMemo"](memo,this.api,account, password)};
        return result;
      } else {
        return { code: 129, message: "Parameter 'memo' can not be empty" };
      }
    }
    //decrypt memo

  }, {
    key: 'decodeMemo',
    value: function decodeMemo(memo) {
      if (this.getAccountInfo().isLocked) {
        return { code: 114, message: "Account is locked or not logged in" };
      }
      if (memo) {
        return { code: 1, data: this.api.getters["PrivateKeyStore/decodeMemo"](memo, this.api) };
      } else {
        return { code: 129, message: "Parameter 'memo' can not be empty" };
      }
    }
  }, {
    key: 'generateKeys',
    value: function generateKeys() {
      var random_key = utils.getRandomKey();
      return {
        private_key: random_key.toWif(),
        public_key: random_key.toPublicKey().toString()
      };
    }
  }, {
    key: 'subscribeToUserOperations',
    value: function subscribeToUserOperations(params) {
      this.subscribeInitCheck("account/_validateAccount", {
        method: "operations/subscribeToUserOperations",
        params: params,
        accountFieldName: "userId",
        account: params.account || "",
        callback: params.callback
      });
    }
  }, {
    key: 'subscribeToAccountOperations',
    value: function subscribeToAccountOperations(params) {
      this.subscribeToUserOperations(params);
    }
  }, {
    key: 'subscribeToChainTranscation',
    value: function subscribeToChainTranscation(params) {
      this.subscribeInitCheck("operations/subscribeToAllOperations", params);
    }
  }, {
    key: 'subscribeToBlocks',
    value: function subscribeToBlocks(params) {
      this.subscribeInitCheck("operations/subscribeBlocks", params);
    }
  }, {
    key: 'subscribeToRpcConnectionStatus',
    value: function subscribeToRpcConnectionStatus(params) {
      if ((typeof params === 'undefined' ? 'undefined' : (0, _typeof3.default)(params)) != "object" && typeof params == "function") {
        params = { callback: params };
      }
      this.api.dispatch("connection/setSubscribeToRpcConnectionStatusCallback", params);
    }
  }, {
    key: 'queryTransactionPair',
    value: function queryTransactionPair(params) {
      this.subscribeInitCheck("market/getTransactionPairData", params);
    }
  }, {
    key: 'queryMarketStats',
    value: function queryMarketStats(params) {
      this.subscribeInitCheck("market/getMarketStats", params);
    }
  }, {
    key: 'subscribeInitCheck',
    value: function subscribeInitCheck(method, params) {
      var _this7 = this;

      this.init().then(function (init_res) {
        if (init_res.code == 1) {
          _this7.api.dispatch(method, params);
        } else {
          params.callback && params.callback(init_res);
        }
      });
    }

    /**********Interfaces cannot return value, callbacks only **start** */

  }, {
    key: 'queryVotes',
    value: function queryVotes(params) {
      var _this8 = this;

      var initPromise = new _promise2.default(function (resolve) {
        _this8.init().then(function (init_res) {
          if (init_res.code == 1) {
            var _params$type = params.type,
                type = _params$type === undefined ? "witnesses" : _params$type,
                _params$queryAccount = params.queryAccount,
                queryAccount = _params$queryAccount === undefined ? "" : _params$queryAccount,
                _params$isExplorer = params.isExplorer,
                isExplorer = _params$isExplorer === undefined ? false : _params$isExplorer;

            _this8.api.dispatch("vote/getVoteObjects", {
              type: type, queryAccount: queryAccount, isExplorer: isExplorer,
              callback: function callback(res) {
                resolve(res);
              }
            });
          } else {
            resolve(init_res);
          }
        });
      });

      if (!params.callback) return initPromise;
      initPromise.then(function (res) {
        params.callback(res);
      });
    }
  }, {
    key: 'publishVotes',
    value: function publishVotes(params) {
      var _this9 = this;

      var initPromise = new _promise2.default(function (resolve) {
        _this9.init(function (init_res) {
          if (init_res.code == 1) {
            var vote_ids = params.vote_ids,
                votes = params.votes,
                type = params.type;

            if (!vote_ids || votes == undefined || type == undefined) {
              resolve({ code: 101, message: "Parameter is missing" });
              return;
            }
            if (!Array.isArray(vote_ids) || isNaN(Number(votes)) || !/witnesses|committee/.test(type)) {
              resolve({ code: 1011, message: "Parameter error" });
              return;
            }
            if (votes == 0) {
              vote_ids.length = 0;
            }
            _this9.api.dispatch("account/accountOpt", {
              method: "vote/publishVotes",
              params: {
                vote_ids: vote_ids,
                votes: votes,
                type: type,
                callback: function callback(res) {
                  resolve(res);
                }
              }
            });
          } else {
            resolve(init_res);
          }
        });
      });
      if (!params.callback) return initPromise;
      initPromise.then(function (res) {
        params.callback(res);
      });
    }
  }, {
    key: 'switchAPINode',
    value: function switchAPINode(params) {
      var _this10 = this;

      //donot send to promiseCompatible Interface, and donot check RPC connection
      // let initPromise=new Promise((resolve)=>{
      //     this.init(init_res=>{
      //       if(init_res.code==1){
      //         this.api.dispatch("connection/switchNode",{
      //            url:params.url,
      //            callback:res=>{ resolve(res); }
      //         });
      //       }else{
      //         resolve(init_res);
      //       }
      //    })
      // });
      // if(!params.callback) return initPromise;
      // initPromise.then(res=>{ params.callback(res);})


      var initPromise = new _promise2.default(function (resolve) {
        _this10.api.dispatch("connection/switchNode", {
          url: params.url,
          callback: function callback(res) {
            resolve(res);
          }
        });
      });
      if (!params.callback) return initPromise;
      initPromise.then(function (res) {
        params.callback(res);
      });

      // return this.api.dispatch("connection/switchNode",{
      //   url:params.url
      // });
    }
    /**********Interfaces cannot return value, callbacks only **end** United Labs of BCTech.*/

  }, {
    key: 'testNodesPings',
    value: function testNodesPings(nodes) {
      return utils.testNodesPings(nodes);
    }
  }]);
  return BCX;
}();

exports.default = BCX;

/***/ }),
/* 439 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _defineProperty2 = __webpack_require__(27);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _regenerator = __webpack_require__(3);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _extends2 = __webpack_require__(76);

var _extends3 = _interopRequireDefault(_extends2);

var _stringify = __webpack_require__(18);

var _stringify2 = _interopRequireDefault(_stringify);

var _keys = __webpack_require__(24);

var _keys2 = _interopRequireDefault(_keys);

var _mutations;

var _vue = __webpack_require__(19);

var _vue2 = _interopRequireDefault(_vue);

var _mutations2 = __webpack_require__(14);

var types = _interopRequireWildcard(_mutations2);

var _helper = __webpack_require__(34);

var _helper2 = _interopRequireDefault(_helper);

var _api = __webpack_require__(10);

var _api2 = _interopRequireDefault(_api);

var _bcxjsWs = __webpack_require__(8);

var _persistentStorage = __webpack_require__(147);

var _persistentStorage2 = _interopRequireDefault(_persistentStorage);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var initialState = {
    versions: "2.2.8",
    ops_limit: 100,
    autoReconnect: true,
    defaultSettings: {
        locale: "zh",
        unit: "1.3.0",
        showSettles: false,
        showAssetPercent: false,
        walletLockTimeout: 60 * 10
    },
    settingsAPIs: {
        default_ws_node: "",
        select_ws_node: "",
        ws_node_list: {},
        networks: [],
        default_faucet: "",
        //defaultAssetsNames: ['COCOS'],
        referrer: '',
        check_cached_account_data: true,
        check_cached_nodes_data: false,
        sub_max_ops: 13,
        real_sub: true
    },
    trx_results: ["error_result", "void_result", "object_id_result", "asset_result", "contract_result", "logger_result"]
};
var getters = {
    trx_results: function trx_results(state) {
        return state.trx_results;
    },
    SELECT_WS_NODE_URL: function SELECT_WS_NODE_URL(state) {
        return state.settingsAPIs.select_ws_node;
    },
    default_ws_node: function default_ws_node(state) {
        return state.settingsAPIs.default_ws_node;
    },
    networks: function networks(state) {
        return state.settingsAPIs.networks;
    },
    worker: function worker(state) {
        return state.settingsAPIs.worker;
    },
    g_settingsAPIs: function g_settingsAPIs(state) {
        return state.settingsAPIs;
    },
    defaultSettings: function defaultSettings(state) {
        return state.defaultSettings;
    },
    ws_node_list: function ws_node_list(state) {
        var nodes = state.settingsAPIs.ws_node_list;
        return (0, _keys2.default)(nodes).map(function (key) {
            var _nodes$key = nodes[key],
                location = _nodes$key.location,
                ping = _nodes$key.ping;

            return {
                url: key,
                name: location,
                ping: ping
            };
        });
    },
    ops_limit: function ops_limit(state) {
        return state.ops_limit;
    },
    autoReconnect: function autoReconnect(state) {
        return state.autoReconnect;
    },
    getApiConfig: function getApiConfig(state) {
        var settingsAPIs = state.settingsAPIs,
            ops_limit = state.ops_limit,
            autoReconnect = state.autoReconnect,
            defaultSettings = state.defaultSettings,
            versions = state.versions;

        var _settingsAPIs = JSON.parse((0, _stringify2.default)(settingsAPIs));
        delete _settingsAPIs.referrer;

        return JSON.parse((0, _stringify2.default)((0, _extends3.default)({}, _settingsAPIs, {
            versions: versions,
            ops_limit: ops_limit,
            auto_reconnect: autoReconnect,
            locale: defaultSettings.locale,
            unit: defaultSettings.unit
        })));
    }
};
var actions = {
    setAutoReconnect: function setAutoReconnect(_ref, b) {
        var commit = _ref.commit;

        commit(types.SET_AUTO_RECONNECT, b);
    },
    setSettingsAPIS: function setSettingsAPIS(_ref2, params) {
        var commit = _ref2.commit,
            dispatch = _ref2.dispatch;

        if (!params || typeof params == "function") {
            return { code: 0 };
        }
        var app_keys = params.app_keys,
            check_cached_account_data = params.check_cached_account_data;
        //contract authorization app_keys configuration

        if (app_keys != undefined && app_keys && Array.isArray(app_keys)) dispatch("PrivateKeyStore/setAppkeys", app_keys, { root: true });

        //whether check and use the local cache of accounts info
        if (check_cached_account_data) dispatch("account/checkCachedUserData", null, { root: true });

        commit(types.SET_SETTINGS_APIS, params);
        return { code: 1 };
    },
    set_SELECT_WS_NODE: function set_SELECT_WS_NODE(_ref3, url) {
        var commit = _ref3.commit;

        commit(types.SET_SELECT_WS_NODE, url);
    },
    addAPINode: function addAPINode(_ref4, node) {
        var commit = _ref4.commit,
            dispatch = _ref4.dispatch,
            state = _ref4.state;
        var url, nodes;
        return _regenerator2.default.async(function addAPINode$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        if (_helper2.default.trimParams(node)) {
                            _context.next = 2;
                            break;
                        }

                        return _context.abrupt('return', { code: 101, message: "Parameter is missing" });

                    case 2:
                        url = node.url;

                        if (/^ws{1,2}:\/\/./.test(url)) {
                            _context.next = 5;
                            break;
                        }

                        return _context.abrupt('return', { code: 139, message: "Node address must start with ws:// or wss://" });

                    case 5:
                        nodes = state.settingsAPIs.ws_node_list;

                        if (!(0, _keys2.default)(nodes).find(function (n_url) {
                            return n_url === url;
                        })) {
                            _context.next = 8;
                            break;
                        }

                        return _context.abrupt('return', { code: 140, message: "API server node address already exists" });

                    case 8:
                        commit(types.ADD_API_NODE, node); //referring here may cause ping missing

                        _context.next = 11;
                        return _regenerator2.default.awrap(dispatch("connection/addAPINode", node, { root: true }));

                    case 11:
                        return _context.abrupt('return', { code: 1, data: JSON.parse((0, _stringify2.default)(nodes)) });

                    case 12:
                    case 'end':
                        return _context.stop();
                }
            }
        }, null, undefined);
    },
    deleteAPINode: function deleteAPINode(_ref5, url) {
        var commit = _ref5.commit,
            dispatch = _ref5.dispatch;

        commit(types.DELETE_API_NODE, url);
        dispatch("connection/deleteAPINode", url, { root: true });
    }
};

var mutations = (_mutations = {}, (0, _defineProperty3.default)(_mutations, types.SET_AUTO_RECONNECT, function (state, b) {
    state.autoReconnect = b;
}), (0, _defineProperty3.default)(_mutations, types.SET_SETTINGS_APIS, function (state, params) {
    var default_ws_node = params.default_ws_node,
        faucet_url = params.faucet_url,
        unit = params.unit,
        ws_node_list = params.ws_node_list,
        networks = params.networks,
        check_cached_account_data = params.check_cached_account_data,
        check_cached_nodes_data = params.check_cached_nodes_data,
        worker = params.worker,
        auto_reconnect = params.auto_reconnect,
        sub_max_ops = params.sub_max_ops,
        real_sub = params.real_sub,
        locale = params.locale;


    var settingsAPIs = state.settingsAPIs;

    if (default_ws_node != undefined) settingsAPIs.default_ws_node = default_ws_node;

    if (faucet_url != undefined) settingsAPIs.default_faucet = faucet_url;

    if (unit != undefined) state.defaultSettings.unit = unit;

    if (sub_max_ops) _api2.default.ChainListener.sub_max_ops = sub_max_ops;

    //chain config
    if (networks) {
        _bcxjsWs.ChainConfig.networks = networks;
        settingsAPIs.networks = networks;
        console.log('bcxjs version\uFF1A' + state.versions);
    }

    if (check_cached_account_data != undefined) settingsAPIs.check_cached_account_data = !!check_cached_account_data;
    if (check_cached_nodes_data != undefined) {
        settingsAPIs.check_cached_nodes_data = !!check_cached_nodes_data;
        !check_cached_nodes_data && _persistentStorage2.default.clearNodesData();
    }
    var cached_nodes_data = _persistentStorage2.default.getSavedNodesData();
    if (settingsAPIs.check_cached_nodes_data && (0, _keys2.default)(cached_nodes_data).length) {
        settingsAPIs.ws_node_list = _persistentStorage2.default.getSavedNodesData();
    } else if (ws_node_list) {
        settingsAPIs.ws_node_list = {};
        ws_node_list.forEach(function (node) {
            settingsAPIs.ws_node_list[node.url] = { location: node.name };
        });
        _api2.default.Connection.setAPINode(settingsAPIs.ws_node_list);
    }

    if (worker != undefined) settingsAPIs.worker = !!worker;
    if (auto_reconnect != undefined) state.autoReconnect = !!auto_reconnect;

    if (real_sub != undefined) {
        _api2.default.ChainListener.real_sub = real_sub;
        settingsAPIs.real_sub = real_sub;
    }

    if (locale != undefined) {
        state.defaultSettings.locale = locale;
    }
}), (0, _defineProperty3.default)(_mutations, types.SET_SELECT_WS_NODE, function (state, url) {
    state.settingsAPIs.select_ws_node = url;
}), (0, _defineProperty3.default)(_mutations, types.ADD_API_NODE, function (state, _ref6) {
    var name = _ref6.name,
        url = _ref6.url;

    _vue2.default.set(state.settingsAPIs.ws_node_list, url, { location: name });
}), (0, _defineProperty3.default)(_mutations, types.DELETE_API_NODE, function (state, url) {
    _vue2.default.delete(state.settingsAPIs.ws_node_list, url);
}), _mutations);

exports.default = {
    state: initialState,
    actions: actions,
    mutations: mutations,
    getters: getters,
    namespaced: true
};

/***/ }),
/* 440 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(441);
module.exports = __webpack_require__(6).Object.keys;


/***/ }),
/* 441 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(51);
var $keys = __webpack_require__(77);

__webpack_require__(366)('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});


/***/ }),
/* 442 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 443 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var GrapheneApi = function () {
    function GrapheneApi(ws_rpc, api_name) {
        _classCallCheck(this, GrapheneApi);

        this.ws_rpc = ws_rpc;
        this.api_name = api_name;
    }

    GrapheneApi.prototype.init = function init() {
        var self = this;
        return this.ws_rpc.call([1, this.api_name, []]).then(function (response) {
            //console.log("[GrapheneApi.js:11] ----- GrapheneApi.init ----->", this.api_name, response);
            self.api_id = response;
            return self;
        });
    };

    GrapheneApi.prototype.exec = function exec(method, params) {
        return this.ws_rpc.call([this.api_id, method, params]).catch(function (error) {
            // console.log("!!! GrapheneApi error: ", method, params, error, JSON.stringify(error));
            throw error;
        });
    };

    return GrapheneApi;
}();

exports.default = GrapheneApi;
module.exports = exports["default"];

/***/ }),
/* 444 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _ApiInstances = __webpack_require__(368);

var _ApiInstances2 = _interopRequireDefault(_ApiInstances);

var _ChainWebSocket = __webpack_require__(369);

var _ChainWebSocket2 = _interopRequireDefault(_ChainWebSocket);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Manager = function () {
    function Manager(_ref) {
        var url = _ref.url,
            urls = _ref.urls,
            autoFallback = _ref.autoFallback,
            closeCb = _ref.closeCb,
            optionalApis = _ref.optionalApis,
            urlChangeCallback = _ref.urlChangeCallback;

        _classCallCheck(this, Manager);

        this.url = url;
        this.urls = urls.filter(function (a) {
            return a !== url;
        });
        this.autoFallback = autoFallback;
        this.closeCb = closeCb;
        this.optionalApis = optionalApis || {};
        this.isConnected = false;
        this.urlChangeCallback = urlChangeCallback;
    }

    Manager.prototype.setCloseCb = function setCloseCb(cb) {
        this.closeCb = cb;
    };

    Manager.close = function close() {
        return _ApiInstances2.default.close();
    };

    Manager.prototype.logFailure = function logFailure(method, url, err) {
        var message = err && err.message ? err.message : "";
        console.error(method, "Failed to connect to " + url + (message ? " Error: " + JSON.stringify(message) : ""));
    };

    Manager.prototype._onClose = function _onClose() {
        this.isConnected = false;
        if (this.closeCb) {
            this.closeCb();
            this.setCloseCb(null);
        }
        if (this.autoFallback) {
            this.connectWithFallback();
        };
    };

    Manager.prototype.connect = function connect() {
        var _this = this;

        var _connect = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        var url = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.url;

        return new Promise(function (resolve, reject) {
            _ApiInstances2.default.instance(url, _connect, undefined, _this.optionalApis, _this._onClose.bind(_this)).init_promise.then(function (res) {
                _this.url = url;
                _this.isConnected = true;
                resolve(res);
            }).catch(function (err) {
                _ApiInstances2.default.close().then(function () {
                    reject(err);
                });
            });
        });
    };

    Manager.prototype.connectWithFallback = function connectWithFallback() {
        var connect = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        var url = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.url;
        var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

        var _this2 = this;

        var resolve = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        var reject = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

        if (reject && index > this.urls.length) return reject(new Error("Tried " + index + " connections, none of which worked: " + JSON.stringify(this.urls.concat(this.url))));
        var fallback = function fallback(err, resolve, reject) {
            if (_this2.urlChangeCallback) _this2.urlChangeCallback(_this2.urls[index]);
            return _this2.connectWithFallback(connect, _this2.urls[index], index + 1, resolve, reject);
        };
        if (resolve && reject) {
            return this.connect(connect, url).then(resolve).catch(function (err) {
                fallback(err, resolve, reject);
            });
        } else {
            return new Promise(function (resolve, reject) {
                _this2.connect(connect, undefined).then(resolve).catch(function (err) {
                    fallback(err, resolve, reject);
                });
            });
        }
    };

    Manager.prototype.checkConnections = function checkConnections() {
        var rpc_user = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        var rpc_password = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

        var _this3 = this;

        var resolve = arguments[2];
        var reject = arguments[3];

        var connectionStartTimes = {};
        var checkFunction = function checkFunction(resolve, reject) {
            var fullList = _this3.urls.concat(_this3.url);
            var connectionPromises = [];

            fullList.forEach(function (url) {
                /* Use default timeout and no reconnecting-websocket */
                var conn = new _ChainWebSocket2.default(url, function () {}, undefined, false);
                connectionStartTimes[url] = new Date().getTime();
                connectionPromises.push(function () {
                    return conn.login(rpc_user, rpc_password).then(function (data) {
                        var _result;

                        var result = (_result = {}, _result[url] = new Date().getTime() - connectionStartTimes[url], _result);
                        return conn.close().then(function () {
                            return result;
                        });
                    }).catch(function (err) {
                        _this3.logFailure("checkConnections", url, err);
                        if (url === _this3.url) {
                            _this3.url = _this3.urls[0];
                        } else {
                            _this3.urls = _this3.urls.filter(function (a) {
                                return a !== url;
                            });
                        }
                        return conn.close().then(function () {
                            return null;
                        });
                    });
                });
            });

            Promise.all(connectionPromises.map(function (a) {
                return a();
            })).then(function (res) {
                var final = res.filter(function (a) {
                    return !!a;
                }).sort(function (a, b) {
                    return Object.values(a)[0] - Object.values(b)[0];
                }).reduce(function (f, a) {
                    var key = Object.keys(a)[0];
                    f[key] = a[key];
                    return f;
                }, {});

                console.log("Checked " + res.length + " connections, " + (res.length - Object.keys(final).length) + " failed");
                return resolve(final);
            }).catch(function () {
                return _this3.checkConnections(rpc_user, rpc_password, resolve, reject);
            });
        };

        if (resolve && reject) {
            checkFunction(resolve, reject);
        } else {
            return new Promise(checkFunction);
        }
    };

    return Manager;
}();

exports.default = Manager;
module.exports = exports["default"];

/***/ }),
/* 445 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 Copyright 2013 Daniel Wirtz <dcode@dcode.io>
 Copyright 2009 The Closure Library Authors. All Rights Reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS-IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**
 * @license long.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/long.js for details
 */
(function(global, factory) {

    /* AMD */ if (true)
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    /* CommonJS */ else if (typeof require === 'function' && typeof module === "object" && module && module["exports"])
        module["exports"] = factory();
    /* Global */ else
        (global["dcodeIO"] = global["dcodeIO"] || {})["Long"] = factory();

})(this, function() {
    "use strict";

    /**
     * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
     *  See the from* functions below for more convenient ways of constructing Longs.
     * @exports Long
     * @class A Long class for representing a 64 bit two's-complement integer value.
     * @param {number} low The low (signed) 32 bits of the long
     * @param {number} high The high (signed) 32 bits of the long
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @constructor
     */
    function Long(low, high, unsigned) {

        /**
         * The low 32 bits as a signed value.
         * @type {number}
         */
        this.low = low | 0;

        /**
         * The high 32 bits as a signed value.
         * @type {number}
         */
        this.high = high | 0;

        /**
         * Whether unsigned or not.
         * @type {boolean}
         */
        this.unsigned = !!unsigned;
    }

    // The internal representation of a long is the two given signed, 32-bit values.
    // We use 32-bit pieces because these are the size of integers on which
    // Javascript performs bit-operations.  For operations like addition and
    // multiplication, we split each number into 16 bit pieces, which can easily be
    // multiplied within Javascript's floating-point representation without overflow
    // or change in sign.
    //
    // In the algorithms below, we frequently reduce the negative case to the
    // positive case by negating the input(s) and then post-processing the result.
    // Note that we must ALWAYS check specially whether those values are MIN_VALUE
    // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
    // a positive number, it overflows back into a negative).  Not handling this
    // case would often result in infinite recursion.
    //
    // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
    // methods on which they depend.

    /**
     * An indicator used to reliably determine if an object is a Long or not.
     * @type {boolean}
     * @const
     * @private
     */
    Long.prototype.__isLong__;

    Object.defineProperty(Long.prototype, "__isLong__", {
        value: true,
        enumerable: false,
        configurable: false
    });

    /**
     * @function
     * @param {*} obj Object
     * @returns {boolean}
     * @inner
     */
    function isLong(obj) {
        return (obj && obj["__isLong__"]) === true;
    }

    /**
     * Tests if the specified object is a Long.
     * @function
     * @param {*} obj Object
     * @returns {boolean}
     */
    Long.isLong = isLong;

    /**
     * A cache of the Long representations of small integer values.
     * @type {!Object}
     * @inner
     */
    var INT_CACHE = {};

    /**
     * A cache of the Long representations of small unsigned integer values.
     * @type {!Object}
     * @inner
     */
    var UINT_CACHE = {};

    /**
     * @param {number} value
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromInt(value, unsigned) {
        var obj, cachedObj, cache;
        if (unsigned) {
            value >>>= 0;
            if (cache = (0 <= value && value < 256)) {
                cachedObj = UINT_CACHE[value];
                if (cachedObj)
                    return cachedObj;
            }
            obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
            if (cache)
                UINT_CACHE[value] = obj;
            return obj;
        } else {
            value |= 0;
            if (cache = (-128 <= value && value < 128)) {
                cachedObj = INT_CACHE[value];
                if (cachedObj)
                    return cachedObj;
            }
            obj = fromBits(value, value < 0 ? -1 : 0, false);
            if (cache)
                INT_CACHE[value] = obj;
            return obj;
        }
    }

    /**
     * Returns a Long representing the given 32 bit integer value.
     * @function
     * @param {number} value The 32 bit integer in question
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     */
    Long.fromInt = fromInt;

    /**
     * @param {number} value
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromNumber(value, unsigned) {
        if (isNaN(value) || !isFinite(value))
            return unsigned ? UZERO : ZERO;
        if (unsigned) {
            if (value < 0)
                return UZERO;
            if (value >= TWO_PWR_64_DBL)
                return MAX_UNSIGNED_VALUE;
        } else {
            if (value <= -TWO_PWR_63_DBL)
                return MIN_VALUE;
            if (value + 1 >= TWO_PWR_63_DBL)
                return MAX_VALUE;
        }
        if (value < 0)
            return fromNumber(-value, unsigned).neg();
        return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
    }

    /**
     * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
     * @function
     * @param {number} value The number in question
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     */
    Long.fromNumber = fromNumber;

    /**
     * @param {number} lowBits
     * @param {number} highBits
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromBits(lowBits, highBits, unsigned) {
        return new Long(lowBits, highBits, unsigned);
    }

    /**
     * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
     *  assumed to use 32 bits.
     * @function
     * @param {number} lowBits The low 32 bits
     * @param {number} highBits The high 32 bits
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     */
    Long.fromBits = fromBits;

    /**
     * @function
     * @param {number} base
     * @param {number} exponent
     * @returns {number}
     * @inner
     */
    var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

    /**
     * @param {string} str
     * @param {(boolean|number)=} unsigned
     * @param {number=} radix
     * @returns {!Long}
     * @inner
     */
    function fromString(str, unsigned, radix) {
        if (str.length === 0)
            throw Error('empty string');
        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
            return ZERO;
        if (typeof unsigned === 'number') {
            // For goog.math.long compatibility
            radix = unsigned,
            unsigned = false;
        } else {
            unsigned = !! unsigned;
        }
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
            throw RangeError('radix');

        var p;
        if ((p = str.indexOf('-')) > 0)
            throw Error('interior hyphen');
        else if (p === 0) {
            return fromString(str.substring(1), unsigned, radix).neg();
        }

        // Do several (8) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = fromNumber(pow_dbl(radix, 8));

        var result = ZERO;
        for (var i = 0; i < str.length; i += 8) {
            var size = Math.min(8, str.length - i),
                value = parseInt(str.substring(i, i + size), radix);
            if (size < 8) {
                var power = fromNumber(pow_dbl(radix, size));
                result = result.mul(power).add(fromNumber(value));
            } else {
                result = result.mul(radixToPower);
                result = result.add(fromNumber(value));
            }
        }
        result.unsigned = unsigned;
        return result;
    }

    /**
     * Returns a Long representation of the given string, written using the specified radix.
     * @function
     * @param {string} str The textual representation of the Long
     * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
     * @returns {!Long} The corresponding Long value
     */
    Long.fromString = fromString;

    /**
     * @function
     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
     * @returns {!Long}
     * @inner
     */
    function fromValue(val) {
        if (val /* is compatible */ instanceof Long)
            return val;
        if (typeof val === 'number')
            return fromNumber(val);
        if (typeof val === 'string')
            return fromString(val);
        // Throws for non-objects, converts non-instanceof Long:
        return fromBits(val.low, val.high, val.unsigned);
    }

    /**
     * Converts the specified value to a Long.
     * @function
     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
     * @returns {!Long}
     */
    Long.fromValue = fromValue;

    // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
    // no runtime penalty for these.

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_16_DBL = 1 << 16;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_24_DBL = 1 << 24;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

    /**
     * @type {!Long}
     * @const
     * @inner
     */
    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

    /**
     * @type {!Long}
     * @inner
     */
    var ZERO = fromInt(0);

    /**
     * Signed zero.
     * @type {!Long}
     */
    Long.ZERO = ZERO;

    /**
     * @type {!Long}
     * @inner
     */
    var UZERO = fromInt(0, true);

    /**
     * Unsigned zero.
     * @type {!Long}
     */
    Long.UZERO = UZERO;

    /**
     * @type {!Long}
     * @inner
     */
    var ONE = fromInt(1);

    /**
     * Signed one.
     * @type {!Long}
     */
    Long.ONE = ONE;

    /**
     * @type {!Long}
     * @inner
     */
    var UONE = fromInt(1, true);

    /**
     * Unsigned one.
     * @type {!Long}
     */
    Long.UONE = UONE;

    /**
     * @type {!Long}
     * @inner
     */
    var NEG_ONE = fromInt(-1);

    /**
     * Signed negative one.
     * @type {!Long}
     */
    Long.NEG_ONE = NEG_ONE;

    /**
     * @type {!Long}
     * @inner
     */
    var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

    /**
     * Maximum signed value.
     * @type {!Long}
     */
    Long.MAX_VALUE = MAX_VALUE;

    /**
     * @type {!Long}
     * @inner
     */
    var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

    /**
     * Maximum unsigned value.
     * @type {!Long}
     */
    Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

    /**
     * @type {!Long}
     * @inner
     */
    var MIN_VALUE = fromBits(0, 0x80000000|0, false);

    /**
     * Minimum signed value.
     * @type {!Long}
     */
    Long.MIN_VALUE = MIN_VALUE;

    /**
     * @alias Long.prototype
     * @inner
     */
    var LongPrototype = Long.prototype;

    /**
     * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
     * @returns {number}
     */
    LongPrototype.toInt = function toInt() {
        return this.unsigned ? this.low >>> 0 : this.low;
    };

    /**
     * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
     * @returns {number}
     */
    LongPrototype.toNumber = function toNumber() {
        if (this.unsigned)
            return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };

    /**
     * Converts the Long to a string written in the specified radix.
     * @param {number=} radix Radix (2-36), defaults to 10
     * @returns {string}
     * @override
     * @throws {RangeError} If `radix` is out of range
     */
    LongPrototype.toString = function toString(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
            throw RangeError('radix');
        if (this.isZero())
            return '0';
        if (this.isNegative()) { // Unsigned Longs are never negative
            if (this.eq(MIN_VALUE)) {
                // We need to change the Long value before it can be negated, so we remove
                // the bottom-most digit in this base and then recurse to do the rest.
                var radixLong = fromNumber(radix),
                    div = this.div(radixLong),
                    rem1 = div.mul(radixLong).sub(this);
                return div.toString(radix) + rem1.toInt().toString(radix);
            } else
                return '-' + this.neg().toString(radix);
        }

        // Do several (6) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
            rem = this;
        var result = '';
        while (true) {
            var remDiv = rem.div(radixToPower),
                intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
                digits = intval.toString(radix);
            rem = remDiv;
            if (rem.isZero())
                return digits + result;
            else {
                while (digits.length < 6)
                    digits = '0' + digits;
                result = '' + digits + result;
            }
        }
    };

    /**
     * Gets the high 32 bits as a signed integer.
     * @returns {number} Signed high bits
     */
    LongPrototype.getHighBits = function getHighBits() {
        return this.high;
    };

    /**
     * Gets the high 32 bits as an unsigned integer.
     * @returns {number} Unsigned high bits
     */
    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
        return this.high >>> 0;
    };

    /**
     * Gets the low 32 bits as a signed integer.
     * @returns {number} Signed low bits
     */
    LongPrototype.getLowBits = function getLowBits() {
        return this.low;
    };

    /**
     * Gets the low 32 bits as an unsigned integer.
     * @returns {number} Unsigned low bits
     */
    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
        return this.low >>> 0;
    };

    /**
     * Gets the number of bits needed to represent the absolute value of this Long.
     * @returns {number}
     */
    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
        if (this.isNegative()) // Unsigned Longs are never negative
            return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        var val = this.high != 0 ? this.high : this.low;
        for (var bit = 31; bit > 0; bit--)
            if ((val & (1 << bit)) != 0)
                break;
        return this.high != 0 ? bit + 33 : bit + 1;
    };

    /**
     * Tests if this Long's value equals zero.
     * @returns {boolean}
     */
    LongPrototype.isZero = function isZero() {
        return this.high === 0 && this.low === 0;
    };

    /**
     * Tests if this Long's value is negative.
     * @returns {boolean}
     */
    LongPrototype.isNegative = function isNegative() {
        return !this.unsigned && this.high < 0;
    };

    /**
     * Tests if this Long's value is positive.
     * @returns {boolean}
     */
    LongPrototype.isPositive = function isPositive() {
        return this.unsigned || this.high >= 0;
    };

    /**
     * Tests if this Long's value is odd.
     * @returns {boolean}
     */
    LongPrototype.isOdd = function isOdd() {
        return (this.low & 1) === 1;
    };

    /**
     * Tests if this Long's value is even.
     * @returns {boolean}
     */
    LongPrototype.isEven = function isEven() {
        return (this.low & 1) === 0;
    };

    /**
     * Tests if this Long's value equals the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.equals = function equals(other) {
        if (!isLong(other))
            other = fromValue(other);
        if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
            return false;
        return this.high === other.high && this.low === other.low;
    };

    /**
     * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.eq = LongPrototype.equals;

    /**
     * Tests if this Long's value differs from the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.notEquals = function notEquals(other) {
        return !this.eq(/* validates */ other);
    };

    /**
     * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.neq = LongPrototype.notEquals;

    /**
     * Tests if this Long's value is less than the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lessThan = function lessThan(other) {
        return this.comp(/* validates */ other) < 0;
    };

    /**
     * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lt = LongPrototype.lessThan;

    /**
     * Tests if this Long's value is less than or equal the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
        return this.comp(/* validates */ other) <= 0;
    };

    /**
     * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lte = LongPrototype.lessThanOrEqual;

    /**
     * Tests if this Long's value is greater than the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.greaterThan = function greaterThan(other) {
        return this.comp(/* validates */ other) > 0;
    };

    /**
     * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.gt = LongPrototype.greaterThan;

    /**
     * Tests if this Long's value is greater than or equal the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
        return this.comp(/* validates */ other) >= 0;
    };

    /**
     * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.gte = LongPrototype.greaterThanOrEqual;

    /**
     * Compares this Long's value with the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
     *  if the given one is greater
     */
    LongPrototype.compare = function compare(other) {
        if (!isLong(other))
            other = fromValue(other);
        if (this.eq(other))
            return 0;
        var thisNeg = this.isNegative(),
            otherNeg = other.isNegative();
        if (thisNeg && !otherNeg)
            return -1;
        if (!thisNeg && otherNeg)
            return 1;
        // At this point the sign bits are the same
        if (!this.unsigned)
            return this.sub(other).isNegative() ? -1 : 1;
        // Both are positive if at least one is unsigned
        return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
    };

    /**
     * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
     *  if the given one is greater
     */
    LongPrototype.comp = LongPrototype.compare;

    /**
     * Negates this Long's value.
     * @returns {!Long} Negated Long
     */
    LongPrototype.negate = function negate() {
        if (!this.unsigned && this.eq(MIN_VALUE))
            return MIN_VALUE;
        return this.not().add(ONE);
    };

    /**
     * Negates this Long's value. This is an alias of {@link Long#negate}.
     * @function
     * @returns {!Long} Negated Long
     */
    LongPrototype.neg = LongPrototype.negate;

    /**
     * Returns the sum of this and the specified Long.
     * @param {!Long|number|string} addend Addend
     * @returns {!Long} Sum
     */
    LongPrototype.add = function add(addend) {
        if (!isLong(addend))
            addend = fromValue(addend);

        // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;

        var b48 = addend.high >>> 16;
        var b32 = addend.high & 0xFFFF;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 0xFFFF;

        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 + b48;
        c48 &= 0xFFFF;
        return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
    };

    /**
     * Returns the difference of this and the specified Long.
     * @param {!Long|number|string} subtrahend Subtrahend
     * @returns {!Long} Difference
     */
    LongPrototype.subtract = function subtract(subtrahend) {
        if (!isLong(subtrahend))
            subtrahend = fromValue(subtrahend);
        return this.add(subtrahend.neg());
    };

    /**
     * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
     * @function
     * @param {!Long|number|string} subtrahend Subtrahend
     * @returns {!Long} Difference
     */
    LongPrototype.sub = LongPrototype.subtract;

    /**
     * Returns the product of this and the specified Long.
     * @param {!Long|number|string} multiplier Multiplier
     * @returns {!Long} Product
     */
    LongPrototype.multiply = function multiply(multiplier) {
        if (this.isZero())
            return ZERO;
        if (!isLong(multiplier))
            multiplier = fromValue(multiplier);
        if (multiplier.isZero())
            return ZERO;
        if (this.eq(MIN_VALUE))
            return multiplier.isOdd() ? MIN_VALUE : ZERO;
        if (multiplier.eq(MIN_VALUE))
            return this.isOdd() ? MIN_VALUE : ZERO;

        if (this.isNegative()) {
            if (multiplier.isNegative())
                return this.neg().mul(multiplier.neg());
            else
                return this.neg().mul(multiplier).neg();
        } else if (multiplier.isNegative())
            return this.mul(multiplier.neg()).neg();

        // If both longs are small, use float multiplication
        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
            return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

        // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
        // We can skip products that would overflow.

        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;

        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 0xFFFF;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 0xFFFF;

        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 0xFFFF;
        return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
    };

    /**
     * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
     * @function
     * @param {!Long|number|string} multiplier Multiplier
     * @returns {!Long} Product
     */
    LongPrototype.mul = LongPrototype.multiply;

    /**
     * Returns this Long divided by the specified. The result is signed if this Long is signed or
     *  unsigned if this Long is unsigned.
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Quotient
     */
    LongPrototype.divide = function divide(divisor) {
        if (!isLong(divisor))
            divisor = fromValue(divisor);
        if (divisor.isZero())
            throw Error('division by zero');
        if (this.isZero())
            return this.unsigned ? UZERO : ZERO;
        var approx, rem, res;
        if (!this.unsigned) {
            // This section is only relevant for signed longs and is derived from the
            // closure library as a whole.
            if (this.eq(MIN_VALUE)) {
                if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                    return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
                else if (divisor.eq(MIN_VALUE))
                    return ONE;
                else {
                    // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                    var halfThis = this.shr(1);
                    approx = halfThis.div(divisor).shl(1);
                    if (approx.eq(ZERO)) {
                        return divisor.isNegative() ? ONE : NEG_ONE;
                    } else {
                        rem = this.sub(divisor.mul(approx));
                        res = approx.add(rem.div(divisor));
                        return res;
                    }
                }
            } else if (divisor.eq(MIN_VALUE))
                return this.unsigned ? UZERO : ZERO;
            if (this.isNegative()) {
                if (divisor.isNegative())
                    return this.neg().div(divisor.neg());
                return this.neg().div(divisor).neg();
            } else if (divisor.isNegative())
                return this.div(divisor.neg()).neg();
            res = ZERO;
        } else {
            // The algorithm below has not been made for unsigned longs. It's therefore
            // required to take special care of the MSB prior to running it.
            if (!divisor.unsigned)
                divisor = divisor.toUnsigned();
            if (divisor.gt(this))
                return UZERO;
            if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
                return UONE;
            res = UZERO;
        }

        // Repeat the following until the remainder is less than other:  find a
        // floating-point that approximates remainder / other *from below*, add this
        // into the result, and subtract it from the remainder.  It is critical that
        // the approximate value is less than or equal to the real value so that the
        // remainder never becomes negative.
        rem = this;
        while (rem.gte(divisor)) {
            // Approximate the result of division. This may be a little greater or
            // smaller than the actual value.
            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

            // We will tweak the approximate result by changing it in the 48-th digit or
            // the smallest non-fractional digit, whichever is larger.
            var log2 = Math.ceil(Math.log(approx) / Math.LN2),
                delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

            // Decrease the approximation until it is smaller than the remainder.  Note
            // that if it is too large, the product overflows and is negative.
                approxRes = fromNumber(approx),
                approxRem = approxRes.mul(divisor);
            while (approxRem.isNegative() || approxRem.gt(rem)) {
                approx -= delta;
                approxRes = fromNumber(approx, this.unsigned);
                approxRem = approxRes.mul(divisor);
            }

            // We know the answer can't be zero... and actually, zero would cause
            // infinite recursion since we would make no progress.
            if (approxRes.isZero())
                approxRes = ONE;

            res = res.add(approxRes);
            rem = rem.sub(approxRem);
        }
        return res;
    };

    /**
     * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
     * @function
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Quotient
     */
    LongPrototype.div = LongPrototype.divide;

    /**
     * Returns this Long modulo the specified.
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Remainder
     */
    LongPrototype.modulo = function modulo(divisor) {
        if (!isLong(divisor))
            divisor = fromValue(divisor);
        return this.sub(this.div(divisor).mul(divisor));
    };

    /**
     * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
     * @function
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Remainder
     */
    LongPrototype.mod = LongPrototype.modulo;

    /**
     * Returns the bitwise NOT of this Long.
     * @returns {!Long}
     */
    LongPrototype.not = function not() {
        return fromBits(~this.low, ~this.high, this.unsigned);
    };

    /**
     * Returns the bitwise AND of this Long and the specified.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     */
    LongPrototype.and = function and(other) {
        if (!isLong(other))
            other = fromValue(other);
        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };

    /**
     * Returns the bitwise OR of this Long and the specified.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     */
    LongPrototype.or = function or(other) {
        if (!isLong(other))
            other = fromValue(other);
        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };

    /**
     * Returns the bitwise XOR of this Long and the given one.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     */
    LongPrototype.xor = function xor(other) {
        if (!isLong(other))
            other = fromValue(other);
        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };

    /**
     * Returns this Long with bits shifted to the left by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shiftLeft = function shiftLeft(numBits) {
        if (isLong(numBits))
            numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
            return this;
        else if (numBits < 32)
            return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
        else
            return fromBits(0, this.low << (numBits - 32), this.unsigned);
    };

    /**
     * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shl = LongPrototype.shiftLeft;

    /**
     * Returns this Long with bits arithmetically shifted to the right by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shiftRight = function shiftRight(numBits) {
        if (isLong(numBits))
            numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
            return this;
        else if (numBits < 32)
            return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
        else
            return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
    };

    /**
     * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shr = LongPrototype.shiftRight;

    /**
     * Returns this Long with bits logically shifted to the right by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
        if (isLong(numBits))
            numBits = numBits.toInt();
        numBits &= 63;
        if (numBits === 0)
            return this;
        else {
            var high = this.high;
            if (numBits < 32) {
                var low = this.low;
                return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
            } else if (numBits === 32)
                return fromBits(high, 0, this.unsigned);
            else
                return fromBits(high >>> (numBits - 32), 0, this.unsigned);
        }
    };

    /**
     * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shru = LongPrototype.shiftRightUnsigned;

    /**
     * Converts this Long to signed.
     * @returns {!Long} Signed long
     */
    LongPrototype.toSigned = function toSigned() {
        if (!this.unsigned)
            return this;
        return fromBits(this.low, this.high, false);
    };

    /**
     * Converts this Long to unsigned.
     * @returns {!Long} Unsigned long
     */
    LongPrototype.toUnsigned = function toUnsigned() {
        if (this.unsigned)
            return this;
        return fromBits(this.low, this.high, true);
    };

    /**
     * Converts this Long to its byte representation.
     * @param {boolean=} le Whether little or big endian, defaults to big endian
     * @returns {!Array.<number>} Byte representation
     */
    LongPrototype.toBytes = function(le) {
        return le ? this.toBytesLE() : this.toBytesBE();
    }

    /**
     * Converts this Long to its little endian byte representation.
     * @returns {!Array.<number>} Little endian byte representation
     */
    LongPrototype.toBytesLE = function() {
        var hi = this.high,
            lo = this.low;
        return [
             lo         & 0xff,
            (lo >>>  8) & 0xff,
            (lo >>> 16) & 0xff,
            (lo >>> 24) & 0xff,
             hi         & 0xff,
            (hi >>>  8) & 0xff,
            (hi >>> 16) & 0xff,
            (hi >>> 24) & 0xff
        ];
    }

    /**
     * Converts this Long to its big endian byte representation.
     * @returns {!Array.<number>} Big endian byte representation
     */
    LongPrototype.toBytesBE = function() {
        var hi = this.high,
            lo = this.low;
        return [
            (hi >>> 24) & 0xff,
            (hi >>> 16) & 0xff,
            (hi >>>  8) & 0xff,
             hi         & 0xff,
            (lo >>> 24) & 0xff,
            (lo >>> 16) & 0xff,
            (lo >>>  8) & 0xff,
             lo         & 0xff
        ];
    }

    return Long;
});


/***/ }),
/* 446 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/** Exception nesting.  */
var ErrorWithCause = function () {
    function ErrorWithCause(message, cause) {
        _classCallCheck(this, ErrorWithCause);

        this.message = message;
        if (typeof cause !== "undefined" && cause !== null ? cause.message : undefined) {
            this.message = "cause\t" + cause.message + "\t" + this.message;
        }

        var stack = ""; //(new Error).stack
        if (typeof cause !== "undefined" && cause !== null ? cause.stack : undefined) {
            stack = "caused by\n\t" + cause.stack + "\t" + stack;
        }

        this.stack = this.message + "\n" + stack;
    }

    ErrorWithCause.throw = function _throw(message, cause) {
        var msg = message;
        if (typeof cause !== "undefined" && cause !== null ? cause.message : undefined) {
            msg += "\t cause: " + cause.message + " ";
        }
        if (typeof cause !== "undefined" && cause !== null ? cause.stack : undefined) {
            msg += "\n stack: " + cause.stack + " ";
        }
        throw new Error(msg);
    };

    return ErrorWithCause;
}();

exports.default = ErrorWithCause;
module.exports = exports["default"];

/***/ }),
/* 447 */
/***/ (function(module, exports) {

module.exports = {"_args":[["bigi@1.4.2","/Users/mechaniclin/Desktop/mechaniclin163/CocosPay"]],"_from":"bigi@1.4.2","_id":"bigi@1.4.2","_inBundle":false,"_integrity":"sha1-nGZalfiLiwj8Bc/XMfVhhZ1yWCU=","_location":"/bigi","_phantomChildren":{},"_requested":{"type":"version","registry":true,"raw":"bigi@1.4.2","name":"bigi","escapedName":"bigi","rawSpec":"1.4.2","saveSpec":null,"fetchSpec":"1.4.2"},"_requiredBy":["/","/bcxjs-cores","/ecurve"],"_resolved":"https://registry.npmjs.org/bigi/-/bigi-1.4.2.tgz","_spec":"1.4.2","_where":"/Users/mechaniclin/Desktop/mechaniclin163/CocosPay","bugs":{"url":"https://github.com/cryptocoinjs/bigi/issues"},"dependencies":{},"description":"Big integers.","devDependencies":{"coveralls":"^2.11.2","istanbul":"^0.3.5","jshint":"^2.5.1","mocha":"^2.1.0","mochify":"^2.1.0"},"homepage":"https://github.com/cryptocoinjs/bigi#readme","keywords":["cryptography","math","bitcoin","arbitrary","precision","arithmetic","big","integer","int","number","biginteger","bigint","bignumber","decimal","float"],"main":"./lib/index.js","name":"bigi","repository":{"url":"git+https://github.com/cryptocoinjs/bigi.git","type":"git"},"scripts":{"browser-test":"mochify --wd -R spec","coverage":"istanbul cover ./node_modules/.bin/_mocha -- --reporter list test/*.js","coveralls":"npm run-script coverage && node ./node_modules/.bin/coveralls < coverage/lcov.info","jshint":"jshint --config jshint.json lib/*.js ; true","test":"_mocha -- test/*.js","unit":"mocha"},"testling":{"files":"test/*.js","harness":"mocha","browsers":["ie/9..latest","firefox/latest","chrome/latest","safari/6.0..latest","iphone/6.0..latest","android-browser/4.2..latest"]},"version":"1.4.2"}

/***/ }),
/* 448 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// FIXME: Kind of a weird way to throw exceptions, consider removing
var assert = __webpack_require__(45)
var BigInteger = __webpack_require__(371)

/**
 * Turns a byte array into a big integer.
 *
 * This function will interpret a byte array as a big integer in big
 * endian notation.
 */
BigInteger.fromByteArrayUnsigned = function(byteArray) {
  // BigInteger expects a DER integer conformant byte array
  if (byteArray[0] & 0x80) {
    return new BigInteger([0].concat(byteArray))
  }

  return new BigInteger(byteArray)
}

/**
 * Returns a byte array representation of the big integer.
 *
 * This returns the absolute of the contained value in big endian
 * form. A value of zero results in an empty array.
 */
BigInteger.prototype.toByteArrayUnsigned = function() {
  var byteArray = this.toByteArray()
  return byteArray[0] === 0 ? byteArray.slice(1) : byteArray
}

BigInteger.fromDERInteger = function(byteArray) {
  return new BigInteger(byteArray)
}

/*
 * Converts BigInteger to a DER integer representation.
 *
 * The format for this value uses the most significant bit as a sign
 * bit.  If the most significant bit is already set and the integer is
 * positive, a 0x00 is prepended.
 *
 * Examples:
 *
 *      0 =>     0x00
 *      1 =>     0x01
 *     -1 =>     0xff
 *    127 =>     0x7f
 *   -127 =>     0x81
 *    128 =>   0x0080
 *   -128 =>     0x80
 *    255 =>   0x00ff
 *   -255 =>   0xff01
 *  16300 =>   0x3fac
 * -16300 =>   0xc054
 *  62300 => 0x00f35c
 * -62300 => 0xff0ca4
*/
BigInteger.prototype.toDERInteger = BigInteger.prototype.toByteArray

BigInteger.fromBuffer = function(buffer) {
  // BigInteger expects a DER integer conformant byte array
  if (buffer[0] & 0x80) {
    var byteArray = Array.prototype.slice.call(buffer)

    return new BigInteger([0].concat(byteArray))
  }

  return new BigInteger(buffer)
}

BigInteger.fromHex = function(hex) {
  if (hex === '') return BigInteger.ZERO

  assert.equal(hex, hex.match(/^[A-Fa-f0-9]+/), 'Invalid hex string')
  assert.equal(hex.length % 2, 0, 'Incomplete hex')
  return new BigInteger(hex, 16)
}

BigInteger.prototype.toBuffer = function(size) {
  var byteArray = this.toByteArrayUnsigned()
  var zeros = []

  var padding = size - byteArray.length
  while (zeros.length < padding) zeros.push(0)

  return new Buffer(zeros.concat(byteArray))
}

BigInteger.prototype.toHex = function(size) {
  return this.toBuffer(size).toString('hex')
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),
/* 449 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),
/* 450 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(451);

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(452);

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

exports.promisify.custom = kCustomPromisifiedSymbol

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb, null, ret) },
            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9)))

/***/ }),
/* 451 */
/***/ (function(module, exports) {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}

/***/ }),
/* 452 */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),
/* 453 */
/***/ (function(module, exports, __webpack_require__) {

var BigInteger = __webpack_require__(57)

var curves = __webpack_require__(454)
var Curve = __webpack_require__(373)

function getCurveByName (name) {
  var curve = curves[name]
  if (!curve) return null

  var p = new BigInteger(curve.p, 16)
  var a = new BigInteger(curve.a, 16)
  var b = new BigInteger(curve.b, 16)
  var n = new BigInteger(curve.n, 16)
  var h = new BigInteger(curve.h, 16)
  var Gx = new BigInteger(curve.Gx, 16)
  var Gy = new BigInteger(curve.Gy, 16)

  return new Curve(p, a, b, Gx, Gy, n, h)
}

module.exports = getCurveByName


/***/ }),
/* 454 */
/***/ (function(module, exports) {

module.exports = {"secp128r1":{"p":"fffffffdffffffffffffffffffffffff","a":"fffffffdfffffffffffffffffffffffc","b":"e87579c11079f43dd824993c2cee5ed3","n":"fffffffe0000000075a30d1b9038a115","h":"01","Gx":"161ff7528b899b2d0c28607ca52c5b86","Gy":"cf5ac8395bafeb13c02da292dded7a83"},"secp160k1":{"p":"fffffffffffffffffffffffffffffffeffffac73","a":"00","b":"07","n":"0100000000000000000001b8fa16dfab9aca16b6b3","h":"01","Gx":"3b4c382ce37aa192a4019e763036f4f5dd4d7ebb","Gy":"938cf935318fdced6bc28286531733c3f03c4fee"},"secp160r1":{"p":"ffffffffffffffffffffffffffffffff7fffffff","a":"ffffffffffffffffffffffffffffffff7ffffffc","b":"1c97befc54bd7a8b65acf89f81d4d4adc565fa45","n":"0100000000000000000001f4c8f927aed3ca752257","h":"01","Gx":"4a96b5688ef573284664698968c38bb913cbfc82","Gy":"23a628553168947d59dcc912042351377ac5fb32"},"secp192k1":{"p":"fffffffffffffffffffffffffffffffffffffffeffffee37","a":"00","b":"03","n":"fffffffffffffffffffffffe26f2fc170f69466a74defd8d","h":"01","Gx":"db4ff10ec057e9ae26b07d0280b7f4341da5d1b1eae06c7d","Gy":"9b2f2f6d9c5628a7844163d015be86344082aa88d95e2f9d"},"secp192r1":{"p":"fffffffffffffffffffffffffffffffeffffffffffffffff","a":"fffffffffffffffffffffffffffffffefffffffffffffffc","b":"64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1","n":"ffffffffffffffffffffffff99def836146bc9b1b4d22831","h":"01","Gx":"188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012","Gy":"07192b95ffc8da78631011ed6b24cdd573f977a11e794811"},"secp256k1":{"p":"fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f","a":"00","b":"07","n":"fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141","h":"01","Gx":"79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798","Gy":"483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"},"secp256r1":{"p":"ffffffff00000001000000000000000000000000ffffffffffffffffffffffff","a":"ffffffff00000001000000000000000000000000fffffffffffffffffffffffc","b":"5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b","n":"ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551","h":"01","Gx":"6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296","Gy":"4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"}}

/***/ }),
/* 455 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// base-x encoding / decoding
// Copyright (c) 2018 base-x contributors
// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
// @ts-ignore
var _Buffer = __webpack_require__(1).Buffer
function base (ALPHABET) {
  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }
  var BASE_MAP = new Uint8Array(256)
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i)
    var xc = x.charCodeAt(0)
    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }
    BASE_MAP[xc] = i
  }
  var BASE = ALPHABET.length
  var LEADER = ALPHABET.charAt(0)
  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up
  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up
  function encode (source) {
    if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source) }
    if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }
    if (source.length === 0) { return '' }
        // Skip & count leading zeroes.
    var zeroes = 0
    var length = 0
    var pbegin = 0
    var pend = source.length
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++
      zeroes++
    }
        // Allocate enough space in big-endian base58 representation.
    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0
    var b58 = new Uint8Array(size)
        // Process the bytes.
    while (pbegin !== pend) {
      var carry = source[pbegin]
            // Apply "b58 = b58 * 256 + ch".
      var i = 0
      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
        carry += (256 * b58[it1]) >>> 0
        b58[it1] = (carry % BASE) >>> 0
        carry = (carry / BASE) >>> 0
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i
      pbegin++
    }
        // Skip leading zeroes in base58 result.
    var it2 = size - length
    while (it2 !== size && b58[it2] === 0) {
      it2++
    }
        // Translate the result into a string.
    var str = LEADER.repeat(zeroes)
    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }
    return str
  }
  function decodeUnsafe (source) {
    if (typeof source !== 'string') { throw new TypeError('Expected String') }
    if (source.length === 0) { return _Buffer.alloc(0) }
    var psz = 0
        // Skip leading spaces.
    if (source[psz] === ' ') { return }
        // Skip and count leading '1's.
    var zeroes = 0
    var length = 0
    while (source[psz] === LEADER) {
      zeroes++
      psz++
    }
        // Allocate enough space in big-endian base256 representation.
    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.
    var b256 = new Uint8Array(size)
        // Process the characters.
    while (source[psz]) {
            // Decode character
      var carry = BASE_MAP[source.charCodeAt(psz)]
            // Invalid character
      if (carry === 255) { return }
      var i = 0
      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
        carry += (BASE * b256[it3]) >>> 0
        b256[it3] = (carry % 256) >>> 0
        carry = (carry / 256) >>> 0
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i
      psz++
    }
        // Skip trailing spaces.
    if (source[psz] === ' ') { return }
        // Skip leading zeroes in b256.
    var it4 = size - length
    while (it4 !== size && b256[it4] === 0) {
      it4++
    }
    var vch = _Buffer.allocUnsafe(zeroes + (size - it4))
    vch.fill(0x00, 0, zeroes)
    var j = zeroes
    while (it4 !== size) {
      vch[j++] = b256[it4++]
    }
    return vch
  }
  function decode (string) {
    var buffer = decodeUnsafe(string)
    if (buffer) { return buffer }
    throw new Error('Non-base' + BASE + ' character')
  }
  return {
    encode: encode,
    decodeUnsafe: decodeUnsafe,
    decode: decode
  }
}
module.exports = base


/***/ }),
/* 456 */
/***/ (function(module, exports) {

exports = module.exports = typeof Object.keys === 'function'
  ? Object.keys : shim;

exports.shim = shim;
function shim (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}


/***/ }),
/* 457 */
/***/ (function(module, exports) {

var supportsArgumentsClass = (function(){
  return Object.prototype.toString.call(arguments)
})() == '[object Arguments]';

exports = module.exports = supportsArgumentsClass ? supported : unsupported;

exports.supported = supported;
function supported(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
};

exports.unsupported = unsupported;
function unsupported(object){
  return object &&
    typeof object == 'object' &&
    typeof object.length == 'number' &&
    Object.prototype.hasOwnProperty.call(object, 'callee') &&
    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
    false;
};


/***/ }),
/* 458 */
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(81), __webpack_require__(375), __webpack_require__(459), __webpack_require__(376), __webpack_require__(462));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Lookup tables
	    var SBOX = [];
	    var INV_SBOX = [];
	    var SUB_MIX_0 = [];
	    var SUB_MIX_1 = [];
	    var SUB_MIX_2 = [];
	    var SUB_MIX_3 = [];
	    var INV_SUB_MIX_0 = [];
	    var INV_SUB_MIX_1 = [];
	    var INV_SUB_MIX_2 = [];
	    var INV_SUB_MIX_3 = [];

	    // Compute lookup tables
	    (function () {
	        // Compute double table
	        var d = [];
	        for (var i = 0; i < 256; i++) {
	            if (i < 128) {
	                d[i] = i << 1;
	            } else {
	                d[i] = (i << 1) ^ 0x11b;
	            }
	        }

	        // Walk GF(2^8)
	        var x = 0;
	        var xi = 0;
	        for (var i = 0; i < 256; i++) {
	            // Compute sbox
	            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
	            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
	            SBOX[x] = sx;
	            INV_SBOX[sx] = x;

	            // Compute multiplication
	            var x2 = d[x];
	            var x4 = d[x2];
	            var x8 = d[x4];

	            // Compute sub bytes, mix columns tables
	            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
	            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
	            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
	            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
	            SUB_MIX_3[x] = t;

	            // Compute inv sub bytes, inv mix columns tables
	            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
	            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
	            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
	            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
	            INV_SUB_MIX_3[sx] = t;

	            // Compute next counter
	            if (!x) {
	                x = xi = 1;
	            } else {
	                x = x2 ^ d[d[d[x8 ^ x2]]];
	                xi ^= d[d[xi]];
	            }
	        }
	    }());

	    // Precomputed Rcon lookup
	    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

	    /**
	     * AES block cipher algorithm.
	     */
	    var AES = C_algo.AES = BlockCipher.extend({
	        _doReset: function () {
	            // Skip reset of nRounds has been set before and key did not change
	            if (this._nRounds && this._keyPriorReset === this._key) {
	                return;
	            }

	            // Shortcuts
	            var key = this._keyPriorReset = this._key;
	            var keyWords = key.words;
	            var keySize = key.sigBytes / 4;

	            // Compute number of rounds
	            var nRounds = this._nRounds = keySize + 6;

	            // Compute number of key schedule rows
	            var ksRows = (nRounds + 1) * 4;

	            // Compute key schedule
	            var keySchedule = this._keySchedule = [];
	            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
	                if (ksRow < keySize) {
	                    keySchedule[ksRow] = keyWords[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 1];

	                    if (!(ksRow % keySize)) {
	                        // Rot word
	                        t = (t << 8) | (t >>> 24);

	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

	                        // Mix Rcon
	                        t ^= RCON[(ksRow / keySize) | 0] << 24;
	                    } else if (keySize > 6 && ksRow % keySize == 4) {
	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
	                    }

	                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
	                }
	            }

	            // Compute inv key schedule
	            var invKeySchedule = this._invKeySchedule = [];
	            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
	                var ksRow = ksRows - invKsRow;

	                if (invKsRow % 4) {
	                    var t = keySchedule[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 4];
	                }

	                if (invKsRow < 4 || ksRow <= 4) {
	                    invKeySchedule[invKsRow] = t;
	                } else {
	                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
	                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
	                }
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
	        },

	        decryptBlock: function (M, offset) {
	            // Swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;

	            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

	            // Inv swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;
	        },

	        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
	            // Shortcut
	            var nRounds = this._nRounds;

	            // Get input, add round key
	            var s0 = M[offset]     ^ keySchedule[0];
	            var s1 = M[offset + 1] ^ keySchedule[1];
	            var s2 = M[offset + 2] ^ keySchedule[2];
	            var s3 = M[offset + 3] ^ keySchedule[3];

	            // Key schedule row counter
	            var ksRow = 4;

	            // Rounds
	            for (var round = 1; round < nRounds; round++) {
	                // Shift rows, sub bytes, mix columns, add round key
	                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
	                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
	                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
	                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

	                // Update state
	                s0 = t0;
	                s1 = t1;
	                s2 = t2;
	                s3 = t3;
	            }

	            // Shift rows, sub bytes, add round key
	            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
	            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
	            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
	            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

	            // Set output
	            M[offset]     = t0;
	            M[offset + 1] = t1;
	            M[offset + 2] = t2;
	            M[offset + 3] = t3;
	        },

	        keySize: 256/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
	     */
	    C.AES = BlockCipher._createHelper(AES);
	}());


	return CryptoJS.AES;

}));

/***/ }),
/* 459 */
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(81));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var T = [];

	    // Compute constants
	    (function () {
	        for (var i = 0; i < 64; i++) {
	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
	        }
	    }());

	    /**
	     * MD5 hash algorithm.
	     */
	    var MD5 = C_algo.MD5 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }

	            // Shortcuts
	            var H = this._hash.words;

	            var M_offset_0  = M[offset + 0];
	            var M_offset_1  = M[offset + 1];
	            var M_offset_2  = M[offset + 2];
	            var M_offset_3  = M[offset + 3];
	            var M_offset_4  = M[offset + 4];
	            var M_offset_5  = M[offset + 5];
	            var M_offset_6  = M[offset + 6];
	            var M_offset_7  = M[offset + 7];
	            var M_offset_8  = M[offset + 8];
	            var M_offset_9  = M[offset + 9];
	            var M_offset_10 = M[offset + 10];
	            var M_offset_11 = M[offset + 11];
	            var M_offset_12 = M[offset + 12];
	            var M_offset_13 = M[offset + 13];
	            var M_offset_14 = M[offset + 14];
	            var M_offset_15 = M[offset + 15];

	            // Working varialbes
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];

	            // Computation
	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
	            b = II(b, c, d, a, M_offset_9,  21, T[63]);

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	            var nBitsTotalL = nBitsTotal;
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
	            );
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
	            );

	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                // Shortcut
	                var H_i = H[i];

	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    function FF(a, b, c, d, x, s, t) {
	        var n = a + ((b & c) | (~b & d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function GG(a, b, c, d, x, s, t) {
	        var n = a + ((b & d) | (c & ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function HH(a, b, c, d, x, s, t) {
	        var n = a + (b ^ c ^ d) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function II(a, b, c, d, x, s, t) {
	        var n = a + (c ^ (b | ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */
	    C.MD5 = Hasher._createHelper(MD5);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));


	return CryptoJS.MD5;

}));

/***/ }),
/* 460 */
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(81));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-1 hash algorithm.
	     */
	    var SHA1 = C_algo.SHA1 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476,
	                0xc3d2e1f0
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];

	            // Computation
	            for (var i = 0; i < 80; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
	                    W[i] = (n << 1) | (n >>> 31);
	                }

	                var t = ((a << 5) | (a >>> 27)) + e + W[i];
	                if (i < 20) {
	                    t += ((b & c) | (~b & d)) + 0x5a827999;
	                } else if (i < 40) {
	                    t += (b ^ c ^ d) + 0x6ed9eba1;
	                } else if (i < 60) {
	                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
	                } else /* if (i < 80) */ {
	                    t += (b ^ c ^ d) - 0x359d3e2a;
	                }

	                e = d;
	                d = c;
	                c = (b << 30) | (b >>> 2);
	                b = a;
	                a = t;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA1('message');
	     *     var hash = CryptoJS.SHA1(wordArray);
	     */
	    C.SHA1 = Hasher._createHelper(SHA1);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA1(message, key);
	     */
	    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
	}());


	return CryptoJS.SHA1;

}));

/***/ }),
/* 461 */
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(81));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var C_algo = C.algo;

	    /**
	     * HMAC algorithm.
	     */
	    var HMAC = C_algo.HMAC = Base.extend({
	        /**
	         * Initializes a newly created HMAC.
	         *
	         * @param {Hasher} hasher The hash algorithm to use.
	         * @param {WordArray|string} key The secret key.
	         *
	         * @example
	         *
	         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
	         */
	        init: function (hasher, key) {
	            // Init hasher
	            hasher = this._hasher = new hasher.init();

	            // Convert string to WordArray, else assume WordArray already
	            if (typeof key == 'string') {
	                key = Utf8.parse(key);
	            }

	            // Shortcuts
	            var hasherBlockSize = hasher.blockSize;
	            var hasherBlockSizeBytes = hasherBlockSize * 4;

	            // Allow arbitrary length keys
	            if (key.sigBytes > hasherBlockSizeBytes) {
	                key = hasher.finalize(key);
	            }

	            // Clamp excess bits
	            key.clamp();

	            // Clone key for inner and outer pads
	            var oKey = this._oKey = key.clone();
	            var iKey = this._iKey = key.clone();

	            // Shortcuts
	            var oKeyWords = oKey.words;
	            var iKeyWords = iKey.words;

	            // XOR keys with pad constants
	            for (var i = 0; i < hasherBlockSize; i++) {
	                oKeyWords[i] ^= 0x5c5c5c5c;
	                iKeyWords[i] ^= 0x36363636;
	            }
	            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this HMAC to its initial state.
	         *
	         * @example
	         *
	         *     hmacHasher.reset();
	         */
	        reset: function () {
	            // Shortcut
	            var hasher = this._hasher;

	            // Reset
	            hasher.reset();
	            hasher.update(this._iKey);
	        },

	        /**
	         * Updates this HMAC with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {HMAC} This HMAC instance.
	         *
	         * @example
	         *
	         *     hmacHasher.update('message');
	         *     hmacHasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            this._hasher.update(messageUpdate);

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the HMAC computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The HMAC.
	         *
	         * @example
	         *
	         *     var hmac = hmacHasher.finalize();
	         *     var hmac = hmacHasher.finalize('message');
	         *     var hmac = hmacHasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Shortcut
	            var hasher = this._hasher;

	            // Compute HMAC
	            var innerHash = hasher.finalize(messageUpdate);
	            hasher.reset();
	            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

	            return hmac;
	        }
	    });
	}());


}));

/***/ }),
/* 462 */
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(81), __webpack_require__(376));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./evpkdf"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Cipher core components.
	 */
	CryptoJS.lib.Cipher || (function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var Base64 = C_enc.Base64;
	    var C_algo = C.algo;
	    var EvpKDF = C_algo.EvpKDF;

	    /**
	     * Abstract base cipher template.
	     *
	     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
	     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
	     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
	     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
	     */
	    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {WordArray} iv The IV to use for this operation.
	         */
	        cfg: Base.extend(),

	        /**
	         * Creates this cipher in encryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createEncryptor: function (key, cfg) {
	            return this.create(this._ENC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Creates this cipher in decryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createDecryptor: function (key, cfg) {
	            return this.create(this._DEC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Initializes a newly created cipher.
	         *
	         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
	         */
	        init: function (xformMode, key, cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Store transform mode and key
	            this._xformMode = xformMode;
	            this._key = key;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this cipher to its initial state.
	         *
	         * @example
	         *
	         *     cipher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-cipher logic
	            this._doReset();
	        },

	        /**
	         * Adds data to be encrypted or decrypted.
	         *
	         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.process('data');
	         *     var encrypted = cipher.process(wordArray);
	         */
	        process: function (dataUpdate) {
	            // Append
	            this._append(dataUpdate);

	            // Process available blocks
	            return this._process();
	        },

	        /**
	         * Finalizes the encryption or decryption process.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after final processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.finalize();
	         *     var encrypted = cipher.finalize('data');
	         *     var encrypted = cipher.finalize(wordArray);
	         */
	        finalize: function (dataUpdate) {
	            // Final data update
	            if (dataUpdate) {
	                this._append(dataUpdate);
	            }

	            // Perform concrete-cipher logic
	            var finalProcessedData = this._doFinalize();

	            return finalProcessedData;
	        },

	        keySize: 128/32,

	        ivSize: 128/32,

	        _ENC_XFORM_MODE: 1,

	        _DEC_XFORM_MODE: 2,

	        /**
	         * Creates shortcut functions to a cipher's object interface.
	         *
	         * @param {Cipher} cipher The cipher to create a helper for.
	         *
	         * @return {Object} An object with encrypt and decrypt shortcut functions.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
	         */
	        _createHelper: (function () {
	            function selectCipherStrategy(key) {
	                if (typeof key == 'string') {
	                    return PasswordBasedCipher;
	                } else {
	                    return SerializableCipher;
	                }
	            }

	            return function (cipher) {
	                return {
	                    encrypt: function (message, key, cfg) {
	                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
	                    },

	                    decrypt: function (ciphertext, key, cfg) {
	                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
	                    }
	                };
	            };
	        }())
	    });

	    /**
	     * Abstract base stream cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
	     */
	    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
	        _doFinalize: function () {
	            // Process partial blocks
	            var finalProcessedBlocks = this._process(!!'flush');

	            return finalProcessedBlocks;
	        },

	        blockSize: 1
	    });

	    /**
	     * Mode namespace.
	     */
	    var C_mode = C.mode = {};

	    /**
	     * Abstract base block cipher mode template.
	     */
	    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
	        /**
	         * Creates this mode for encryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
	         */
	        createEncryptor: function (cipher, iv) {
	            return this.Encryptor.create(cipher, iv);
	        },

	        /**
	         * Creates this mode for decryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
	         */
	        createDecryptor: function (cipher, iv) {
	            return this.Decryptor.create(cipher, iv);
	        },

	        /**
	         * Initializes a newly created mode.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
	         */
	        init: function (cipher, iv) {
	            this._cipher = cipher;
	            this._iv = iv;
	        }
	    });

	    /**
	     * Cipher Block Chaining mode.
	     */
	    var CBC = C_mode.CBC = (function () {
	        /**
	         * Abstract base CBC mode.
	         */
	        var CBC = BlockCipherMode.extend();

	        /**
	         * CBC encryptor.
	         */
	        CBC.Encryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // XOR and encrypt
	                xorBlock.call(this, words, offset, blockSize);
	                cipher.encryptBlock(words, offset);

	                // Remember this block to use with next block
	                this._prevBlock = words.slice(offset, offset + blockSize);
	            }
	        });

	        /**
	         * CBC decryptor.
	         */
	        CBC.Decryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // Remember this block to use with next block
	                var thisBlock = words.slice(offset, offset + blockSize);

	                // Decrypt and XOR
	                cipher.decryptBlock(words, offset);
	                xorBlock.call(this, words, offset, blockSize);

	                // This block becomes the previous block
	                this._prevBlock = thisBlock;
	            }
	        });

	        function xorBlock(words, offset, blockSize) {
	            // Shortcut
	            var iv = this._iv;

	            // Choose mixing block
	            if (iv) {
	                var block = iv;

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            } else {
	                var block = this._prevBlock;
	            }

	            // XOR blocks
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= block[i];
	            }
	        }

	        return CBC;
	    }());

	    /**
	     * Padding namespace.
	     */
	    var C_pad = C.pad = {};

	    /**
	     * PKCS #5/7 padding strategy.
	     */
	    var Pkcs7 = C_pad.Pkcs7 = {
	        /**
	         * Pads data using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to pad.
	         * @param {number} blockSize The multiple that the data should be padded to.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
	         */
	        pad: function (data, blockSize) {
	            // Shortcut
	            var blockSizeBytes = blockSize * 4;

	            // Count padding bytes
	            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	            // Create padding word
	            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

	            // Create padding
	            var paddingWords = [];
	            for (var i = 0; i < nPaddingBytes; i += 4) {
	                paddingWords.push(paddingWord);
	            }
	            var padding = WordArray.create(paddingWords, nPaddingBytes);

	            // Add padding
	            data.concat(padding);
	        },

	        /**
	         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to unpad.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
	         */
	        unpad: function (data) {
	            // Get number of padding bytes from last byte
	            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	            // Remove padding
	            data.sigBytes -= nPaddingBytes;
	        }
	    };

	    /**
	     * Abstract base block cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
	     */
	    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Mode} mode The block mode to use. Default: CBC
	         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
	         */
	        cfg: Cipher.cfg.extend({
	            mode: CBC,
	            padding: Pkcs7
	        }),

	        reset: function () {
	            // Reset cipher
	            Cipher.reset.call(this);

	            // Shortcuts
	            var cfg = this.cfg;
	            var iv = cfg.iv;
	            var mode = cfg.mode;

	            // Reset block mode
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                var modeCreator = mode.createEncryptor;
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                var modeCreator = mode.createDecryptor;
	                // Keep at least one block in the buffer for unpadding
	                this._minBufferSize = 1;
	            }

	            if (this._mode && this._mode.__creator == modeCreator) {
	                this._mode.init(this, iv && iv.words);
	            } else {
	                this._mode = modeCreator.call(mode, this, iv && iv.words);
	                this._mode.__creator = modeCreator;
	            }
	        },

	        _doProcessBlock: function (words, offset) {
	            this._mode.processBlock(words, offset);
	        },

	        _doFinalize: function () {
	            // Shortcut
	            var padding = this.cfg.padding;

	            // Finalize
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                // Pad data
	                padding.pad(this._data, this.blockSize);

	                // Process final blocks
	                var finalProcessedBlocks = this._process(!!'flush');
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                // Process final blocks
	                var finalProcessedBlocks = this._process(!!'flush');

	                // Unpad data
	                padding.unpad(finalProcessedBlocks);
	            }

	            return finalProcessedBlocks;
	        },

	        blockSize: 128/32
	    });

	    /**
	     * A collection of cipher parameters.
	     *
	     * @property {WordArray} ciphertext The raw ciphertext.
	     * @property {WordArray} key The key to this ciphertext.
	     * @property {WordArray} iv The IV used in the ciphering operation.
	     * @property {WordArray} salt The salt used with a key derivation function.
	     * @property {Cipher} algorithm The cipher algorithm.
	     * @property {Mode} mode The block mode used in the ciphering operation.
	     * @property {Padding} padding The padding scheme used in the ciphering operation.
	     * @property {number} blockSize The block size of the cipher.
	     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
	     */
	    var CipherParams = C_lib.CipherParams = Base.extend({
	        /**
	         * Initializes a newly created cipher params object.
	         *
	         * @param {Object} cipherParams An object with any of the possible cipher parameters.
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.lib.CipherParams.create({
	         *         ciphertext: ciphertextWordArray,
	         *         key: keyWordArray,
	         *         iv: ivWordArray,
	         *         salt: saltWordArray,
	         *         algorithm: CryptoJS.algo.AES,
	         *         mode: CryptoJS.mode.CBC,
	         *         padding: CryptoJS.pad.PKCS7,
	         *         blockSize: 4,
	         *         formatter: CryptoJS.format.OpenSSL
	         *     });
	         */
	        init: function (cipherParams) {
	            this.mixIn(cipherParams);
	        },

	        /**
	         * Converts this cipher params object to a string.
	         *
	         * @param {Format} formatter (Optional) The formatting strategy to use.
	         *
	         * @return {string} The stringified cipher params.
	         *
	         * @throws Error If neither the formatter nor the default formatter is set.
	         *
	         * @example
	         *
	         *     var string = cipherParams + '';
	         *     var string = cipherParams.toString();
	         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
	         */
	        toString: function (formatter) {
	            return (formatter || this.formatter).stringify(this);
	        }
	    });

	    /**
	     * Format namespace.
	     */
	    var C_format = C.format = {};

	    /**
	     * OpenSSL formatting strategy.
	     */
	    var OpenSSLFormatter = C_format.OpenSSL = {
	        /**
	         * Converts a cipher params object to an OpenSSL-compatible string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The OpenSSL-compatible string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            // Shortcuts
	            var ciphertext = cipherParams.ciphertext;
	            var salt = cipherParams.salt;

	            // Format
	            if (salt) {
	                var wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
	            } else {
	                var wordArray = ciphertext;
	            }

	            return wordArray.toString(Base64);
	        },

	        /**
	         * Converts an OpenSSL-compatible string to a cipher params object.
	         *
	         * @param {string} openSSLStr The OpenSSL-compatible string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
	         */
	        parse: function (openSSLStr) {
	            // Parse base64
	            var ciphertext = Base64.parse(openSSLStr);

	            // Shortcut
	            var ciphertextWords = ciphertext.words;

	            // Test for salt
	            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
	                // Extract salt
	                var salt = WordArray.create(ciphertextWords.slice(2, 4));

	                // Remove salt from ciphertext
	                ciphertextWords.splice(0, 4);
	                ciphertext.sigBytes -= 16;
	            }

	            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
	        }
	    };

	    /**
	     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
	     */
	    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
	         */
	        cfg: Base.extend({
	            format: OpenSSLFormatter
	        }),

	        /**
	         * Encrypts a message.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Encrypt
	            var encryptor = cipher.createEncryptor(key, cfg);
	            var ciphertext = encryptor.finalize(message);

	            // Shortcut
	            var cipherCfg = encryptor.cfg;

	            // Create and return serializable cipher params
	            return CipherParams.create({
	                ciphertext: ciphertext,
	                key: key,
	                iv: cipherCfg.iv,
	                algorithm: cipher,
	                mode: cipherCfg.mode,
	                padding: cipherCfg.padding,
	                blockSize: cipher.blockSize,
	                formatter: cfg.format
	            });
	        },

	        /**
	         * Decrypts serialized ciphertext.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Decrypt
	            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

	            return plaintext;
	        },

	        /**
	         * Converts serialized ciphertext to CipherParams,
	         * else assumed CipherParams already and returns ciphertext unchanged.
	         *
	         * @param {CipherParams|string} ciphertext The ciphertext.
	         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
	         *
	         * @return {CipherParams} The unserialized ciphertext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
	         */
	        _parse: function (ciphertext, format) {
	            if (typeof ciphertext == 'string') {
	                return format.parse(ciphertext, this);
	            } else {
	                return ciphertext;
	            }
	        }
	    });

	    /**
	     * Key derivation function namespace.
	     */
	    var C_kdf = C.kdf = {};

	    /**
	     * OpenSSL key derivation function.
	     */
	    var OpenSSLKdf = C_kdf.OpenSSL = {
	        /**
	         * Derives a key and IV from a password.
	         *
	         * @param {string} password The password to derive from.
	         * @param {number} keySize The size in words of the key to generate.
	         * @param {number} ivSize The size in words of the IV to generate.
	         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
	         *
	         * @return {CipherParams} A cipher params object with the key, IV, and salt.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
	         */
	        execute: function (password, keySize, ivSize, salt) {
	            // Generate random salt
	            if (!salt) {
	                salt = WordArray.random(64/8);
	            }

	            // Derive key and IV
	            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);

	            // Separate key and IV
	            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
	            key.sigBytes = keySize * 4;

	            // Return params
	            return CipherParams.create({ key: key, iv: iv, salt: salt });
	        }
	    };

	    /**
	     * A serializable cipher wrapper that derives the key from a password,
	     * and returns ciphertext as a serializable cipher params object.
	     */
	    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
	         */
	        cfg: SerializableCipher.cfg.extend({
	            kdf: OpenSSLKdf
	        }),

	        /**
	         * Encrypts a message using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Encrypt
	            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

	            // Mix in derived params
	            ciphertext.mixIn(derivedParams);

	            return ciphertext;
	        },

	        /**
	         * Decrypts serialized ciphertext using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Decrypt
	            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

	            return plaintext;
	        }
	    });
	}());


}));

/***/ }),
/* 463 */
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(81));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	return CryptoJS.enc.Hex;

}));

/***/ }),
/* 464 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

exports.__esModule = true;
exports.verifyRaw = exports.verify = exports.sign = exports.recoverPubKey = exports.deterministicGenerateK = exports.calcPubKeyRecoveryParam = undefined;

var _assert = __webpack_require__(45);

var _assert2 = _interopRequireDefault(_assert);

var _hash = __webpack_require__(58);

var _enforce_types = __webpack_require__(378);

var _enforce_types2 = _interopRequireDefault(_enforce_types);

var _bigi = __webpack_require__(57);

var _bigi2 = _interopRequireDefault(_bigi);

var _ecsignature = __webpack_require__(465);

var _ecsignature2 = _interopRequireDefault(_ecsignature);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// https://tools.ietf.org/html/rfc6979#section-3.2
// from github.com/bitcoinjs/bitcoinjs-lib from github.com/cryptocoinjs/ecdsa
function deterministicGenerateK(curve, hash, d, checkSig, nonce) {

  (0, _enforce_types2.default)('Buffer', hash);
  (0, _enforce_types2.default)(_bigi2.default, d);

  if (nonce) {
    hash = (0, _hash.sha256)(Buffer.concat([hash, new Buffer(nonce)]));
  }

  // sanity check
  _assert2.default.equal(hash.length, 32, 'Hash must be 256 bit');

  var x = d.toBuffer(32);
  var k = new Buffer(32);
  var v = new Buffer(32);

  // Step B
  v.fill(1);

  // Step C
  k.fill(0);

  // Step D
  k = (0, _hash.HmacSHA256)(Buffer.concat([v, new Buffer([0]), x, hash]), k);

  // Step E
  v = (0, _hash.HmacSHA256)(v, k);

  // Step F
  k = (0, _hash.HmacSHA256)(Buffer.concat([v, new Buffer([1]), x, hash]), k);

  // Step G
  v = (0, _hash.HmacSHA256)(v, k);

  // Step H1/H2a, ignored as tlen === qlen (256 bit)
  // Step H2b
  v = (0, _hash.HmacSHA256)(v, k);

  var T = _bigi2.default.fromBuffer(v);

  // Step H3, repeat until T is within the interval [1, n - 1]
  while (T.signum() <= 0 || T.compareTo(curve.n) >= 0 || !checkSig(T)) {
    k = (0, _hash.HmacSHA256)(Buffer.concat([v, new Buffer([0])]), k);
    v = (0, _hash.HmacSHA256)(v, k);

    // Step H1/H2a, again, ignored as tlen === qlen (256 bit)
    // Step H2b again
    v = (0, _hash.HmacSHA256)(v, k);

    T = _bigi2.default.fromBuffer(v);
  }

  return T;
}

function sign(curve, hash, d, nonce) {

  var e = _bigi2.default.fromBuffer(hash);
  var n = curve.n;
  var G = curve.G;

  var r, s;
  var k = deterministicGenerateK(curve, hash, d, function (k) {
    // find canonically valid signature
    var Q = G.multiply(k);

    if (curve.isInfinity(Q)) return false;

    r = Q.affineX.mod(n);
    if (r.signum() === 0) return false;

    s = k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n);
    if (s.signum() === 0) return false;

    return true;
  }, nonce);

  var N_OVER_TWO = n.shiftRight(1);

  // enforce low S values, see bip62: 'low s values in signatures'
  if (s.compareTo(N_OVER_TWO) > 0) {
    s = n.subtract(s);
  }

  return new _ecsignature2.default(r, s);
}

function verifyRaw(curve, e, signature, Q) {
  var n = curve.n;
  var G = curve.G;

  var r = signature.r;
  var s = signature.s;

  // 1.4.1 Enforce r and s are both integers in the interval [1, n âˆ’ 1]
  if (r.signum() <= 0 || r.compareTo(n) >= 0) return false;
  if (s.signum() <= 0 || s.compareTo(n) >= 0) return false;

  // c = s^-1 mod n
  var c = s.modInverse(n);

  // 1.4.4 Compute u1 = es^âˆ’1 mod n
  //               u2 = rs^âˆ’1 mod n
  var u1 = e.multiply(c).mod(n);
  var u2 = r.multiply(c).mod(n);

  // 1.4.5 Compute R = (xR, yR) = u1G + u2Q
  var R = G.multiplyTwo(u1, Q, u2);

  // 1.4.5 (cont.) Enforce R is not at infinity
  if (curve.isInfinity(R)) return false;

  // 1.4.6 Convert the field element R.x to an integer
  var xR = R.affineX;

  // 1.4.7 Set v = xR mod n
  var v = xR.mod(n);

  // 1.4.8 If v = r, output "valid", and if v != r, output "invalid"
  return v.equals(r);
}

function verify(curve, hash, signature, Q) {
  // 1.4.2 H = Hash(M), already done by the user
  // 1.4.3 e = H
  var e = _bigi2.default.fromBuffer(hash);
  return verifyRaw(curve, e, signature, Q);
}

/**
  * Recover a public key from a signature.
  *
  * See SEC 1: Elliptic Curve Cryptography, section 4.1.6, "Public
  * Key Recovery Operation".
  *
  * http://www.secg.org/download/aid-780/sec1-v2.pdf
  */
function recoverPubKey(curve, e, signature, i) {
  _assert2.default.strictEqual(i & 3, i, 'Recovery param is more than two bits');

  var n = curve.n;
  var G = curve.G;

  var r = signature.r;
  var s = signature.s;

  (0, _assert2.default)(r.signum() > 0 && r.compareTo(n) < 0, 'Invalid r value');
  (0, _assert2.default)(s.signum() > 0 && s.compareTo(n) < 0, 'Invalid s value');

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = i & 1;

  // The more significant bit specifies whether we should use the
  // first or second candidate key.
  var isSecondKey = i >> 1;

  // 1.1 Let x = r + jn
  var x = isSecondKey ? r.add(n) : r;
  var R = curve.pointFromX(isYOdd, x);

  // 1.4 Check that nR is at infinity
  var nR = R.multiply(n);
  (0, _assert2.default)(curve.isInfinity(nR), 'nR is not a valid curve point');

  // Compute -e from e
  var eNeg = e.negate().mod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  var rInv = r.modInverse(n);

  var Q = R.multiplyTwo(s, G, eNeg).multiply(rInv);
  curve.validate(Q);

  return Q;
}

/**
  * Calculate pubkey extraction parameter.
  *
  * When extracting a pubkey from a signature, we have to
  * distinguish four different cases. Rather than putting this
  * burden on the verifier, Bitcoin includes a 2-bit value with the
  * signature.
  *
  * This function simply tries all four cases and returns the value
  * that resulted in a successful pubkey recovery.
  */
function calcPubKeyRecoveryParam(curve, e, signature, Q) {
  for (var i = 0; i < 4; i++) {
    var Qprime = recoverPubKey(curve, e, signature, i);

    // 1.6.2 Verify Q
    if (Qprime.equals(Q)) {
      return i;
    }
  }

  throw new Error('Unable to find valid recovery factor');
}

exports.calcPubKeyRecoveryParam = calcPubKeyRecoveryParam;
exports.deterministicGenerateK = deterministicGenerateK;
exports.recoverPubKey = recoverPubKey;
exports.sign = sign;
exports.verify = verify;
exports.verifyRaw = verifyRaw;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),
/* 465 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

exports.__esModule = true;

var _assert = __webpack_require__(45);

var _assert2 = _interopRequireDefault(_assert);

var _enforce_types = __webpack_require__(378);

var _enforce_types2 = _interopRequireDefault(_enforce_types);

var _bigi = __webpack_require__(57);

var _bigi2 = _interopRequireDefault(_bigi);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// from https://github.com/bitcoinjs/bitcoinjs-lib
function ECSignature(r, s) {
  (0, _enforce_types2.default)(_bigi2.default, r);
  (0, _enforce_types2.default)(_bigi2.default, s);

  this.r = r;
  this.s = s;
}

// Import operations
ECSignature.parseCompact = function (buffer) {
  _assert2.default.equal(buffer.length, 65, 'Invalid signature length');
  var i = buffer.readUInt8(0) - 27;

  // At most 3 bits
  _assert2.default.equal(i, i & 7, 'Invalid signature parameter');
  var compressed = !!(i & 4);

  // Recovery param only
  i = i & 3;

  var r = _bigi2.default.fromBuffer(buffer.slice(1, 33));
  var s = _bigi2.default.fromBuffer(buffer.slice(33));

  return {
    compressed: compressed,
    i: i,
    signature: new ECSignature(r, s)
  };
};

ECSignature.fromDER = function (buffer) {
  _assert2.default.equal(buffer.readUInt8(0), 0x30, 'Not a DER sequence');
  _assert2.default.equal(buffer.readUInt8(1), buffer.length - 2, 'Invalid sequence length');
  _assert2.default.equal(buffer.readUInt8(2), 0x02, 'Expected a DER integer');

  var rLen = buffer.readUInt8(3);
  (0, _assert2.default)(rLen > 0, 'R length is zero');

  var offset = 4 + rLen;
  _assert2.default.equal(buffer.readUInt8(offset), 0x02, 'Expected a DER integer (2)');

  var sLen = buffer.readUInt8(offset + 1);
  (0, _assert2.default)(sLen > 0, 'S length is zero');

  var rB = buffer.slice(4, offset);
  var sB = buffer.slice(offset + 2);
  offset += 2 + sLen;

  if (rLen > 1 && rB.readUInt8(0) === 0x00) {
    (0, _assert2.default)(rB.readUInt8(1) & 0x80, 'R value excessively padded');
  }

  if (sLen > 1 && sB.readUInt8(0) === 0x00) {
    (0, _assert2.default)(sB.readUInt8(1) & 0x80, 'S value excessively padded');
  }

  _assert2.default.equal(offset, buffer.length, 'Invalid DER encoding');
  var r = _bigi2.default.fromDERInteger(rB);
  var s = _bigi2.default.fromDERInteger(sB);

  (0, _assert2.default)(r.signum() >= 0, 'R value is negative');
  (0, _assert2.default)(s.signum() >= 0, 'S value is negative');

  return new ECSignature(r, s);
};

// FIXME: 0x00, 0x04, 0x80 are SIGHASH_* boundary constants, importing Transaction causes a circular dependency
ECSignature.parseScriptSignature = function (buffer) {
  var hashType = buffer.readUInt8(buffer.length - 1);
  var hashTypeMod = hashType & ~0x80;

  (0, _assert2.default)(hashTypeMod > 0x00 && hashTypeMod < 0x04, 'Invalid hashType');

  return {
    signature: ECSignature.fromDER(buffer.slice(0, -1)),
    hashType: hashType
  };
};

// Export operations
ECSignature.prototype.toCompact = function (i, compressed) {
  if (compressed) i += 4;
  i += 27;

  var buffer = new Buffer(65);
  buffer.writeUInt8(i, 0);

  this.r.toBuffer(32).copy(buffer, 1);
  this.s.toBuffer(32).copy(buffer, 33);

  return buffer;
};

ECSignature.prototype.toDER = function () {
  var rBa = this.r.toDERInteger();
  var sBa = this.s.toDERInteger();

  var sequence = [];

  // INTEGER
  sequence.push(0x02, rBa.length);
  sequence = sequence.concat(rBa);

  // INTEGER
  sequence.push(0x02, sBa.length);
  sequence = sequence.concat(sBa);

  // SEQUENCE
  sequence.unshift(0x30, sequence.length);

  return new Buffer(sequence);
};

ECSignature.prototype.toScriptSignature = function (hashType) {
  var hashTypeBuffer = new Buffer(1);
  hashTypeBuffer.writeUInt8(hashType, 0);

  return Buffer.concat([this.toDER(), hashTypeBuffer]);
};

exports.default = ECSignature;
module.exports = exports['default'];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),
/* 466 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 467 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _immutable = __webpack_require__(23);

var _immutable2 = _interopRequireDefault(_immutable);

var _bcxjsWs = __webpack_require__(8);

var _ChainTypes = __webpack_require__(131);

var _ChainTypes2 = _interopRequireDefault(_ChainTypes);

var _ChainValidation = __webpack_require__(383);

var _ChainValidation2 = _interopRequireDefault(_ChainValidation);

var _bigi = __webpack_require__(57);

var _bigi2 = _interopRequireDefault(_bigi);

var _EmitterInstance = __webpack_require__(384);

var _EmitterInstance2 = _interopRequireDefault(_EmitterInstance);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var object_type = _ChainTypes2.default.object_type,
    impl_object_type = _ChainTypes2.default.impl_object_type;

var emitter = (0, _EmitterInstance2.default)();

var op_history = parseInt(object_type.operation_history, 10);
var limit_order = parseInt(object_type.limit_order, 10);
var call_order = parseInt(object_type.call_order, 10);
var proposal = parseInt(object_type.proposal, 10);
// let balance_type  = parseInt(object_type.balance, 10);
// let vesting_balance_type  = parseInt(object_type.vesting_balance, 10);
var witness_object_type = parseInt(object_type.witness, 10);
var worker_object_type = parseInt(object_type.worker, 10);
var committee_member_object_type = parseInt(object_type.committee_member, 10);
var account_object_type = parseInt(object_type.account, 10);
var asset_object_type = parseInt(object_type.asset, 10);

var order_prefix = "1." + limit_order + ".";
var call_order_prefix = "1." + call_order + ".";
var proposal_prefix = "1." + proposal + ".";
var operation_history_prefix = "1." + op_history + ".";
var balance_prefix = "2." + parseInt(impl_object_type.account_balance, 10) + ".";
var account_stats_prefix = "2." + parseInt(impl_object_type.account_statistics, 10) + ".";
var transaction_prefix = "2." + parseInt(impl_object_type.transaction, 10) + ".";
var account_transaction_history_prefix = "2." + parseInt(impl_object_type.account_transaction_history, 10) + ".";
// let asset_dynamic_data_prefix = "2." + parseInt(impl_object_type.asset_dynamic_data,10) + ".";
var bitasset_data_prefix = "2." + parseInt(impl_object_type.asset_bitasset_data, 10) + ".";
var block_summary_prefix = "2." + parseInt(impl_object_type.block_summary, 10) + ".";

// let vesting_balance_prefix = "1." + vesting_balance_type + ".";
var witness_prefix = "1." + witness_object_type + ".";
var worker_prefix = "1." + worker_object_type + ".";
var committee_prefix = "1." + committee_member_object_type + ".";
var asset_prefix = "1." + asset_object_type + ".";
var account_prefix = "1." + account_object_type + ".";

var DEBUG = JSON.parse(process.env.npm_config__graphene_chain_chain_debug || false);

/**
 *  @brief maintains a local cache of blockchain state
 *
 *  The ChainStore maintains a local cache of blockchain state and exposes
 *  an API that makes it easy to query objects and receive updates when
 *  objects are available.
 */

var ChainStore = function () {
    function ChainStore() {
        _classCallCheck(this, ChainStore);

        /** tracks everyone who wants to receive updates when the cache changes */
        this.subscribers = new Set();
        this.subscribed = false;

        this.clearCache();
        // this.progress = 0;
        // this.chain_time_offset is used to estimate the blockchain time
        this.chain_time_offset = [];
        this.dispatchFrequency = 40;
    }

    /**
     * Clears all cached state.  This should be called any time the network connection is
     * reset.
     */


    ChainStore.prototype.clearCache = function clearCache() {
        /*
        * Tracks specific objects such as accounts that can trigger additional
        * fetching that should only happen if we're actually interested in the account
        */
        this.subbed_accounts = new Set();
        this.subbed_witnesses = new Set();
        this.subbed_committee = new Set();

        this.objects_by_id = new Map();
        this.accounts_by_name = new Map();
        this.assets_by_symbol = new Map();
        this.account_ids_by_key = _immutable2.default.Map();
        this.account_ids_by_account = _immutable2.default.Map();

        this.balance_objects_by_address = new Map();
        this.get_account_refs_of_keys_calls = new Set();
        this.get_account_refs_of_accounts_calls = new Set();
        this.account_history_requests = new Map(); ///< tracks pending history requests
        this.witness_by_account_id = new Map();
        this.workers = new Set();
        this.committee_by_account_id = new Map();
        this.objects_by_vote_id = new Map();
        this.fetching_get_full_accounts = new Map();
        this.get_full_accounts_subscriptions = new Map();
        clearTimeout(this.timeout);
        this.dispatched = false;
    };

    ChainStore.prototype.resetCache = function resetCache(subscribe_to_new) {
        this.subscribed = false;
        this.subError = null;
        this.clearCache();
        this.head_block_time_string = null;
        return this.init(subscribe_to_new).catch(function (err) {
            console.log("resetCache init error:", err());
        });
    };

    ChainStore.prototype.setDispatchFrequency = function setDispatchFrequency(freq) {
        this.dispatchFrequency = freq;
    };

    ChainStore.prototype.init = function init() {
        var _this = this;

        var subscribe_to_new = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        var reconnectCounter = 0;
        var _init = function _init(resolve, reject) {
            if (_this.subscribed) return resolve();
            var db_api = _bcxjsWs.Apis.instance().db_api();
            if (!db_api) {
                return reject(new Error("Api not found, please initialize the api instance before calling the ChainStore"));
            }
            return db_api.exec("get_objects", [["2.1.0"]]).then(function (optional_objects) {
                //if(DEBUG) console.log("... optional_objects",optional_objects ? optional_objects[0].id : null)
                for (var i = 0; i < optional_objects.length; i++) {
                    var optional_object = optional_objects[i];
                    if (optional_object) {
                        /*
                        ** Because 2.1.0 gets fetched here before the set_subscribe_callback,
                        ** the new witness_node subscription model makes it so we
                        ** never get subscribed to that object, therefore
                        ** this._updateObject is commented out here
                        */
                        // this._updateObject( optional_object, true );

                        var head_time = new Date(optional_object.time + "+00:00").getTime();
                        _this.head_block_time_string = optional_object.time;
                        _this.chain_time_offset.push(new Date().getTime() - timeStringToDate(optional_object.time).getTime());
                        var now = new Date().getTime();
                        var delta = (now - head_time) / 1000;
                        // let start = Date.parse("Sep 1, 2015");
                        // let progress_delta = head_time - start;
                        // this.progress = progress_delta / (now-start);
                        if (delta < 60) {
                            _bcxjsWs.Apis.instance().db_api().exec("set_subscribe_callback", [_this.onUpdate.bind(_this), subscribe_to_new]).then(function () {
                                console.log("synced and subscribed, chainstore ready");
                                _this.subscribed = true;
                                _this.subError = null;
                                _this.notifySubscribers();
                                resolve();
                            }).catch(function (error) {
                                _this.subscribed = false;
                                _this.subError = error;
                                _this.notifySubscribers();
                                reject(error);
                                console.log("Error: ", error);
                            });
                        } else {
                            console.log("not yet synced, retrying in 1s");
                            _this.subscribed = false;
                            reconnectCounter++;
                            _this.notifySubscribers();
                            if (reconnectCounter > 1) {
                                _this.subError = new Error("ChainStore sync error, please check your system clock");
                                return reject(_this.subError);
                            }
                            setTimeout(_init.bind(_this, resolve, reject), 1000);
                        }
                    } else {
                        setTimeout(_init.bind(_this, resolve, reject), 1000);
                    }
                }
            }).catch(function (error) {
                // in the event of an error clear the pending state for id
                console.log("!!! Chain API error", error);
                _this.objects_by_id.delete("2.1.0");
                reject(error);
            });
        };

        return new Promise(function (resolve, reject) {
            return _init(resolve, reject);
        });
    };

    ChainStore.prototype._subTo = function _subTo(type, id) {
        var key = "subbed_" + type;
        if (!this[key].has(id)) this[key].add(id);
    };

    ChainStore.prototype.unSubFrom = function unSubFrom(type, id) {
        var key = "subbed_" + type;
        this[key].delete(id);
        this.objects_by_id.delete(id);
    };

    ChainStore.prototype._isSubbedTo = function _isSubbedTo(type, id) {
        var key = "subbed_" + type;
        return this[key].has(id);
    };
    ChainStore.prototype.setCustomSubscribeCallback = function setCustomSubscribeCallback(_mainCallback) {
        this._mainCallback=_mainCallback;
    };
    
    ChainStore.prototype.onUpdate = function onUpdate(updated_objects /// map from account id to objects
    ) {
        var cancelledOrders = [];
        var closedCallOrders = [];
        
        this._mainCallback&&this._mainCallback(updated_objects);

        for (var a = 0; a < updated_objects.length; ++a) {
            for (var i = 0; i < updated_objects[a].length; ++i) {
                var _obj = updated_objects[a][i];
                if (_ChainValidation2.default.is_object_id(_obj)) {
                    // An entry containing only an object ID means that object was removed
                    // console.log("removed obj", obj);
                    // Check if the object exists in the ChainStore
                    var old_obj = this.objects_by_id.get(_obj);

                    if (_obj.search(order_prefix) == 0) {
                        // Limit orders

                        cancelledOrders.push(_obj);
                        if (old_obj) {
                            var account = this.objects_by_id.get(old_obj.get("seller"));
                            if (account && account.has("orders")) {
                                var limit_orders = account.get("orders");
                                if (account.get("orders").has(_obj)) {
                                    account = account.set("orders", limit_orders.delete(_obj));
                                    this.objects_by_id.set(account.get("id"), account);
                                }
                            }
                        }
                    }

                    if (_obj.search(call_order_prefix) == 0) {
                        // Call orders
                        closedCallOrders.push(_obj);
                        if (old_obj) {
                            var _account = this.objects_by_id.get(old_obj.get("borrower"));
                            if (_account && _account.has("call_orders")) {
                                var call_orders = _account.get("call_orders");
                                if (_account.get("call_orders").has(_obj)) {
                                    _account = _account.set("call_orders", call_orders.delete(_obj));
                                    this.objects_by_id.set(_account.get("id"), _account);
                                }
                            }
                        }
                    }

                    // Remove the object (if it already exists), set to null to indicate it does not exist
                    if (old_obj) this.objects_by_id.set(_obj, null);
                } else {
                    this._updateObject(_obj);
                }
            }
        }

        // Cancelled limit order(s), emit event for any listeners to update their state
        if (cancelledOrders.length) emitter.emit("cancel-order", cancelledOrders);
        // Closed call order, emit event for any listeners to update their state
        if (closedCallOrders.length) emitter.emit("close-call", closedCallOrders);

        // console.log("objects in store count:", this.objects_by_id.size, updated_objects[0].reduce((final, o) => {
        //     if (o && o.id) {
        //         final.changed.push(o.id);
        //     } else {
        //         final.removed.push(o);
        //     }
        //     return final;
        // }, {changed: [], removed: []}));
        this.notifySubscribers();
    };

    ChainStore.prototype.notifySubscribers = function notifySubscribers() {
        var _this2 = this;

        // Dispatch at most only once every x milliseconds
        if (!this.dispatched) {
            this.dispatched = true;
            this.timeout = setTimeout(function () {
                _this2.dispatched = false;
                _this2.subscribers.forEach(function (callback) {
                    callback();
                });
            }, this.dispatchFrequency);
        }
    };

    /**
     *  Add a callback that will be called anytime any object in the cache is updated
     */


    ChainStore.prototype.subscribe = function subscribe(callback) {
        if (this.subscribers.has(callback)) return console.error("Subscribe callback already exists", callback);
        this.subscribers.add(callback);
    };

    /**
     *  Remove a callback that was previously added via subscribe
     */


    ChainStore.prototype.unsubscribe = function unsubscribe(callback) {
        if (!this.subscribers.has(callback)) return console.error("Unsubscribe callback does not exists", callback);
        this.subscribers.delete(callback);
    };

    /** Clear an object from the cache to force it to be fetched again. This may
     * be useful if a query failed the first time and the wallet has reason to believe
     * it may succeede the second time.
     */


    ChainStore.prototype.clearObjectCache = function clearObjectCache(id) {
        this.objects_by_id.delete(id);
    };

    /**
     * There are three states an object id could be in:
     *
     * 1. undefined       - returned if a query is pending
     * 3. defined         - return an object
     * 4. null            - query return null
     *
     */


    ChainStore.prototype.getObject = function getObject(id) {
        var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var autosubscribe = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        var no_full_account = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
        var isCache = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;

        if (!_ChainValidation2.default.is_object_id(id)) throw Error("argument is not an object id: " + JSON.stringify(id));

        var result = this.objects_by_id.get(id);

        var subChange = id.substring(0, account_prefix.length) == account_prefix && !this.get_full_accounts_subscriptions.get(id, false) && autosubscribe;
        if (result === null && !force) return result;
        if (result === undefined || force || subChange) return this.fetchObject(id, force, autosubscribe, no_full_account);
        if (result === true) return undefined;

        return result;
    };

    /**
     *  @return undefined if a query is pending
     *  @return null if id_or_symbol has been queired and does not exist
     *  @return object if the id_or_symbol exists
     */


    ChainStore.prototype.getAsset = function getAsset(id_or_symbol) {
        var _this3 = this;

        if (!id_or_symbol) return null;

        if (_ChainValidation2.default.is_object_id(id_or_symbol)) {
            var asset = this.getObject(id_or_symbol);

            if (asset && asset.get("bitasset") && !asset.getIn(["bitasset", "current_feed"])) {
                return undefined;
            }
            return asset;
        }

        /// TODO: verify id_or_symbol is a valid symbol name

        var asset_id = this.assets_by_symbol.get(id_or_symbol);

        if (_ChainValidation2.default.is_object_id(asset_id)) {
            var _asset = this.getObject(asset_id);

            if (_asset && _asset.get("bitasset") && !_asset.getIn(["bitasset", "current_feed"])) {
                return undefined;
            }
            return _asset;
        }

        if (asset_id === null) return null;

        if (asset_id === true) return undefined;

        _bcxjsWs.Apis.instance().db_api().exec("lookup_asset_symbols", [[id_or_symbol]]).then(function (asset_objects) {
            // console.log( "lookup symbol ", id_or_symbol )
            if (asset_objects.length && asset_objects[0]) _this3._updateObject(asset_objects[0], true);else {
                _this3.assets_by_symbol.set(id_or_symbol, null);
                _this3.notifySubscribers();
            }
        }).catch(function (error) {
            console.log("Error: ", error);
            _this3.assets_by_symbol.delete(id_or_symbol);
        });

        return undefined;
    };

    /**
     *  @param the public key to find accounts that reference it
     *
     *  @return Set of account ids that reference the given key
     *  @return a empty Set if no items are found
     *  @return undefined if the result is unknown
     *
     *  If this method returns undefined, then it will send a request to
     *  the server for the current set of accounts after which the
     *  server will notify us of any accounts that reference these keys
     */


    ChainStore.prototype.getAccountRefsOfKey = function getAccountRefsOfKey(key) {
        var _this4 = this;

        if (this.get_account_refs_of_keys_calls.has(key)) return this.account_ids_by_key.get(key);else {
            this.get_account_refs_of_keys_calls.add(key);

            _bcxjsWs.Apis.instance().db_api().exec("get_key_references", [[key]]).then(function (vec_account_id) {
                var refs = _immutable2.default.Set();
                vec_account_id = vec_account_id[0];
                refs = refs.withMutations(function (r) {
                    for (var i = 0; i < vec_account_id.length; ++i) {
                        r.add(vec_account_id[i]);
                    }
                });
                _this4.account_ids_by_key = _this4.account_ids_by_key.set(key, refs);
                _this4.notifySubscribers();
            }).catch(function (err) {
                console.error("get_key_references", err);
                _this4.account_ids_by_key = _this4.account_ids_by_key.delete(key);
                _this4.get_account_refs_of_keys_calls.delete(key);
            });
            return undefined;
        }
        return undefined;
    };

    /**
     *  @param the account id to find accounts that reference it
     *
     *  @return Set of account ids that reference the given key
     *  @return a empty Set if no items are found
     *  @return undefined if the result is unknown
     *
     *  If this method returns undefined, then it will send a request to
     *  the server for the current set of accounts after which the
     *  server will notify us of any accounts that reference these keys
     */


    ChainStore.prototype.getAccountRefsOfAccount = function getAccountRefsOfAccount(account_id) {
        var _this5 = this;

        if (this.get_account_refs_of_accounts_calls.has(account_id)) return this.account_ids_by_account.get(account_id);else {
            this.get_account_refs_of_accounts_calls.add(account_id);

            _bcxjsWs.Apis.instance().db_api().exec("get_account_references", [account_id]).then(function (vec_account_id) {
                var refs = _immutable2.default.Set();
                refs = refs.withMutations(function (r) {
                    for (var i = 0; i < vec_account_id.length; ++i) {
                        r.add(vec_account_id[i]);
                    }
                });
                _this5.account_ids_by_account = _this5.account_ids_by_account.set(account_id, refs);
                _this5.notifySubscribers();
            }).catch(function (err) {
                console.error("get_account_references", err);
                _this5.account_ids_by_account = _this5.account_ids_by_account.delete(account_id);
                _this5.get_account_refs_of_accounts_calls.delete(account_id);
            });
            return undefined;
        }
        return undefined;
    };

    /**
     * @return a Set of balance ids that are claimable with the given address
     * @return undefined if a query is pending and the set is not known at this time
     * @return a empty Set if no items are found
     *
     * If this method returns undefined, then it will send a request to the server for
     * the current state after which it will be subscribed to changes to this set.
     */


    ChainStore.prototype.getBalanceObjects = function getBalanceObjects(address) {
        var _this6 = this;

        var current = this.balance_objects_by_address.get(address);
        if (current === undefined) {
            /** because balance objects are simply part of the genesis state, there is no need to worry about
             * having to update them / merge them or index them in updateObject.
             */
            this.balance_objects_by_address.set(address, _immutable2.default.Set());
            _bcxjsWs.Apis.instance().db_api().exec("get_balance_objects", [[address]]).then(function (balance_objects) {
                var set = new Set();
                for (var i = 0; i < balance_objects.length; ++i) {
                    _this6._updateObject(balance_objects[i]);
                    set.add(balance_objects[i].id);
                }
                _this6.balance_objects_by_address.set(address, _immutable2.default.Set(set));
                _this6.notifySubscribers();
            }, function () {
                _this6.balance_objects_by_address.delete(address);
            });
        }
        return this.balance_objects_by_address.get(address);
    };

    /**
     *  If there is not already a pending request to fetch this object, a new
     *  request will be made.
     *
     *  @return null if the object does not exist,
     *  @return undefined if the object might exist but is not in cache
     *  @return the object if it does exist and is in our cache
     */


    ChainStore.prototype.fetchObject = function fetchObject(id) {
        var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        var _this7 = this;

        var autosubscribe = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        var no_full_account = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

        if (typeof id !== "string") {
            var _result = [];
            for (var i = 0; i < id.length; ++i) {
                _result.push(this.fetchObject(id[i], force, autosubscribe));
            }return _result;
        }

        if (DEBUG) console.log("!!! fetchObject: ", id, this.subscribed, !this.subscribed && !force);

        if (!this.subscribed && !force) return undefined;

        if (DEBUG) console.log("maybe fetch object: ", id);
        if (!_ChainValidation2.default.is_object_id(id)) throw Error("argument is not an object id: " + id);

        if (id.search("1.2.") === 0 && !no_full_account) return this.fetchFullAccount(id, autosubscribe);
        if (id.search(witness_prefix) === 0) this._subTo("witnesses", id);
        if (id.search(committee_prefix) === 0) this._subTo("committee", id);

        var result = this.objects_by_id.get(id);
        if (result === undefined) {
            // the fetch
            if (DEBUG) console.log("fetching object: ", id);
            this.objects_by_id.set(id, true);
            if (!_bcxjsWs.Apis.instance().db_api()) return null;
            _bcxjsWs.Apis.instance().db_api().exec("get_objects", [[id]]).then(function (optional_objects) {
                //if(DEBUG) console.log("... optional_objects",optional_objects ? optional_objects[0].id : null)
                for (var _i = 0; _i < optional_objects.length; _i++) {
                    var optional_object = optional_objects[_i];
                    if (optional_object) _this7._updateObject(optional_object, true);else {
                        _this7.objects_by_id.set(id, null);
                        _this7.notifySubscribers();
                    }
                }
            }).catch(function (error) {
                // in the event of an error clear the pending state for id
                console.log("!!! Chain API error", error);
                _this7.objects_by_id.delete(id);
            });
        } else if (result === true)
            // then we are waiting a response
            return undefined;
        return result; // we have a response, return it
    };

    /**
     *  @return null if no such account exists
     *  @return undefined if such an account may exist, and fetch the the full account if not already pending
     *  @return the account object if it does exist
     */


    ChainStore.prototype.getAccount = function getAccount(name_or_id) {
        var autosubscribe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        if (!name_or_id) return null;

        if ((typeof name_or_id === "undefined" ? "undefined" : _typeof(name_or_id)) === "object") {
            if (name_or_id.id) return this.getAccount(name_or_id.id, autosubscribe);else if (name_or_id.get) return this.getAccount(name_or_id.get("id"), autosubscribe);else return undefined;
        }

        if (_ChainValidation2.default.is_object_id(name_or_id)) {
            var account = this.getObject(name_or_id, false, autosubscribe);
            if (account === null) {
                return null;
            }
            /* If sub status changes from false to true, force full fetch */
            var currentSub = this.get_full_accounts_subscriptions.get(name_or_id, false);
            if (!currentSub && autosubscribe || account === undefined || account.get("name") === undefined) {
                return this.fetchFullAccount(name_or_id, autosubscribe);
            }
            return account;
        } else if (_ChainValidation2.default.is_account_name(name_or_id, true)) {
            var account_id = this.accounts_by_name.get(name_or_id);
            if (account_id === null) return null; // already fetched and it wasn't found
            if (account_id === undefined)
                // then no query, fetch it
                return this.fetchFullAccount(name_or_id, autosubscribe);

            return this.getObject(account_id, false, autosubscribe); // return it
        } else {
            console.log("!is_object_id && !is_account_name");
            return null;
        }
        //throw Error( `Argument is not an account name or id: ${name_or_id}` )
    };

    /**
     *  @return undefined if the account name is not yet cached, and fetch the the full account if not already pending
     *  @return null if the account name or id are unvalid, or the account does not exist
     *  @return the account name
     */


    ChainStore.prototype.getAccountName = function getAccountName(id) {
        var account = this.objects_by_id.get(id);
        if (account === true) return undefined;
        if (!account) {
            this.getObject(id, false, false, true);
            return undefined;
        }
        return account.get("name");
    };

    /**
     * This method will attempt to lookup witness by account_id.
     * If witness doesn't exist it will return null, if witness is found it will return witness object,
     * if it's not fetched yet it will return undefined.
     * @param account_id - account id
     */


    ChainStore.prototype.getWitnessById = function getWitnessById(account_id) {
        var witness_id = this.witness_by_account_id.get(account_id);
        if (witness_id === undefined) {
            this.fetchWitnessByAccount(account_id);
            return undefined;
        } else if (witness_id) {
            this._subTo("witnesses", witness_id);
        }

        return witness_id ? this.getObject(witness_id) : null;
    };

    /**
     * This method will attempt to lookup committee member by account_id.
     * If committee member doesn't exist it will return null, if committee member is found it will return committee member object,
     * if it's not fetched yet it will return undefined.
     * @param account_id - account id
     */


    ChainStore.prototype.getCommitteeMemberById = function getCommitteeMemberById(account_id) {
        var cm_id = this.committee_by_account_id.get(account_id);
        if (cm_id === undefined) {
            this.fetchCommitteeMemberByAccount(account_id);
            return undefined;
        } else if (cm_id) {
            this._subTo("committee", cm_id);
        }
        return cm_id ? this.getObject(cm_id) : null;
    };

    /**
     * Obsolete! Please use getWitnessById
     * This method will attempt to lookup the account, and then query to see whether or not there is
     * a witness for this account.  If the answer is known, it will return the witness_object, otherwise
     * it will attempt to look it up and return null.   Once the lookup has completed on_update will
     * be called.
     *
     * @param id_or_account may either be an account_id, a witness_id, or an account_name
     */
    // getWitness( id_or_account )
    // {
    //     let account = this.getAccount( id_or_account );
    //     if( !account ) return null;
    //     let account_id = account.get("id");
    //
    //     let witness_id = this.witness_by_account_id.get( account_id );
    //     if( witness_id === undefined )
    //         this.fetchWitnessByAccount( account_id );
    //     return this.getObject( witness_id );
    //
    //     if( ChainValidation.is_account_name(id_or_account, true) || (id_or_account.substring(0,4) == "1.2."))
    //     {
    //         let account = this.getAccount( id_or_account );
    //         if( !account )
    //         {
    //             this.lookupAccountByName( id_or_account ).then ( account => {
    //                 if( !account ) return null;
    //
    //                 let account_id = account.get("id");
    //                 let witness_id = this.witness_by_account_id.get( account_id );
    //                 if( ChainValidation.is_object_id( witness_id ) )
    //                     return this.getObject( witness_id, on_update );
    //
    //                 if( witness_id == undefined )
    //                     this.fetchWitnessByAccount( account_id ).then( witness => {
    //                         this.witness_by_account_id.set( account_id, witness?witness.get("id"):null );
    //                         if( witness && on_update ) on_update();
    //                     })
    //                 }, () => {
    //                     let witness_id = this.witness_by_account_id.set( id_or_account, null )
    //                 } )
    //         }
    //         else
    //         {
    //             let account_id = account.get("id")
    //             let witness_id = this.witness_by_account_id.get( account_id )
    //             if( ChainValidation.is_object_id( witness_id ) )
    //             return this.getObject( witness_id, on_update )
    //
    //             if( witness_id == undefined )
    //             this.fetchWitnessByAccount( account_id ).then( witness => {
    //                 this.witness_by_account_id.set( account_id, witness?witness.get("id"):null )
    //                 if( witness && on_update ) on_update()
    //             })
    //         }
    //         return null
    //     }
    //     return null
    // }

    // Obsolete! Please use getCommitteeMemberById
    // getCommitteeMember( id_or_account, on_update = null )
    // {
    //     if( ChainValidation.is_account_name(id_or_account, true) || (id_or_account.substring(0,4) == "1.2."))
    //     {
    //         let account = this.getAccount( id_or_account )
    //
    //         if( !account )
    //         {
    //             this.lookupAccountByName( id_or_account ).then( account=>{
    //                 let account_id = account.get("id")
    //                 let committee_id = this.committee_by_account_id.get( account_id )
    //                 if( ChainValidation.is_object_id( committee_id ) ) return this.getObject( committee_id, on_update )
    //
    //                 if( committee_id == undefined )
    //                 {
    //                     this.fetchCommitteeMemberByAccount( account_id ).then( committee => {
    //                         this.committee_by_account_id.set( account_id, committee ? committee.get("id") : null )
    //                         if( on_update && committee) on_update()
    //                     } )
    //                 }
    //             }, error => {
    //                 let witness_id = this.committee_by_account_id.set( id_or_account, null )
    //             })
    //         }
    //         else
    //         {
    //             let account_id = account.get("id")
    //             let committee_id = this.committee_by_account_id.get( account_id )
    //             if( ChainValidation.is_object_id( committee_id ) ) return this.getObject( committee_id, on_update )
    //
    //             if( committee_id == undefined )
    //             {
    //                 this.fetchCommitteeMemberByAccount( account_id ).then( committee => {
    //                     this.committee_by_account_id.set( account_id, committee ? committee.get("id") : null )
    //                     if( on_update && committee) on_update()
    //                 } )
    //             }
    //         }
    //     }
    //     return null
    // }

    /**
     *
     * @return a promise with the workers array
     */


    ChainStore.prototype.fetchAllWorkers = function fetchAllWorkers() {
        var _this8 = this;

        return new Promise(function (resolve, reject) {
            _bcxjsWs.Apis.instance().db_api().exec("get_all_workers", []).then(function (workers_array) {
                if (workers_array && workers_array.length) {
                    workers_array.forEach(function (worker) {
                        _this8._updateObject(worker, false);
                    });
                    resolve(workers_array);
                    _this8.notifySubscribers();
                } else {
                    resolve([]);
                }
            }, reject);
        });
    };

    /**
     *
     * @return a promise with the witness object
     */


    ChainStore.prototype.fetchWitnessByAccount = function fetchWitnessByAccount(account_id) {
        var _this9 = this;

        return new Promise(function (resolve, reject) {
            _bcxjsWs.Apis.instance().db_api().exec("get_witness_by_account", [account_id]).then(function (optional_witness_object) {
                if (optional_witness_object) {
                    _this9._subTo("witnesses", optional_witness_object.id);
                    _this9.witness_by_account_id = _this9.witness_by_account_id.set(optional_witness_object.witness_account, optional_witness_object.id);
                    var witness_object = _this9._updateObject(optional_witness_object, true);
                    resolve(witness_object);
                } else {
                    _this9.witness_by_account_id = _this9.witness_by_account_id.set(account_id, null);
                    _this9.notifySubscribers();
                    resolve(null);
                }
            }, reject);
        });
    };
    /**
     *
     * @return a promise with the witness object
     */


    ChainStore.prototype.fetchCommitteeMemberByAccount = function fetchCommitteeMemberByAccount(account_id) {
        var _this10 = this;

        return new Promise(function (resolve, reject) {
            _bcxjsWs.Apis.instance().db_api().exec("get_committee_member_by_account", [account_id]).then(function (optional_committee_object) {
                if (optional_committee_object) {
                    _this10._subTo("committee", optional_committee_object.id);
                    _this10.committee_by_account_id = _this10.committee_by_account_id.set(optional_committee_object.committee_member_account, optional_committee_object.id);
                    var committee_object = _this10._updateObject(optional_committee_object, true);
                    resolve(committee_object);
                } else {
                    _this10.committee_by_account_id = _this10.committee_by_account_id.set(account_id, null);
                    _this10.notifySubscribers();
                    resolve(null);
                }
            }, reject);
        });
    };

    /**
     *  Fetches an account and all of its associated data in a single query
     *
     *  @param an account name or account id
     *
     *  @return undefined if the account in question is in the process of being fetched
     *  @return the object if it has already been fetched
     *  @return null if the object has been queried and was not found
     */


    ChainStore.prototype.fetchFullAccount = function fetchFullAccount(name_or_id) {
        var _this11 = this;

        var autosubscribe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        if (DEBUG) console.log("Fetch full account: ", name_or_id);

        var fetch_account = false;
        var subChanged = this.get_full_accounts_subscriptions.has(name_or_id) && this.get_full_accounts_subscriptions.get(name_or_id) === false && autosubscribe;

        var is_object_id = _ChainValidation2.default.is_object_id(name_or_id);
        var is_account_name = !is_object_id && _ChainValidation2.default.is_account_name(name_or_id, true);

        if (is_object_id && !subChanged) {
            var current = this.objects_by_id.get(name_or_id);
            fetch_account = current === undefined;
            if (!fetch_account && current && current.get("name") && current.has("balances")) return current;
        } else if (!subChanged) {
            if (!is_account_name) throw Error("argument is not an account name: " + name_or_id);

            var account_id = this.accounts_by_name.get(name_or_id);
            if (_ChainValidation2.default.is_object_id(account_id)) return this.getAccount(account_id, autosubscribe);
        }

        /// only fetch once every 5 seconds if it wasn't found, or if the subscribe status changed to true
        if (subChanged || !this.fetching_get_full_accounts.has(name_or_id) || Date.now() - this.fetching_get_full_accounts.get(name_or_id) > 5000) {
            this.fetching_get_full_accounts.set(name_or_id, Date.now());
            _bcxjsWs.Apis.instance().db_api().exec("get_full_accounts", [[name_or_id], autosubscribe]).then(function (results) {
                if (results.length === 0) {
                    if (is_object_id) {
                        _this11.objects_by_id.set(name_or_id, null);
                        _this11.notifySubscribers();
                    } else if (is_account_name) {
                        _this11.accounts_by_name.set(name_or_id, null);
                        _this11.notifySubscribers();
                    }
                    return;
                }
                var full_account = results[0][1];
                _this11.get_full_accounts_subscriptions.set(full_account.account.name, autosubscribe);
                _this11.get_full_accounts_subscriptions.set(full_account.account.id, autosubscribe);
                if (DEBUG) console.log("full_account: ", full_account);
                /* Add this account to list of subbed accounts */
                _this11._subTo("accounts", full_account.account.id);
                var account = full_account.account,
                    assets = full_account.assets,
                    vesting_balances = full_account.vesting_balances,
                    statistics = full_account.statistics,
                    call_orders = full_account.call_orders,
                    limit_orders = full_account.limit_orders,
                    referrer_name = full_account.referrer_name,
                    registrar_name = full_account.registrar_name,
                    lifetime_referrer_name = full_account.lifetime_referrer_name,
                    votes = full_account.votes,
                    proposals = full_account.proposals;


                _this11.accounts_by_name.set(account.name, account.id);
                account.assets = new _immutable2.default.List(assets || []);
                account.referrer_name = referrer_name;
                account.lifetime_referrer_name = lifetime_referrer_name;
                account.registrar_name = registrar_name;
                account.balances = {};
                account.orders = new _immutable2.default.Set();
                account.vesting_balances = new _immutable2.default.Set();
                account.balances = new _immutable2.default.Map();
                account.call_orders = new _immutable2.default.Set();
                account.proposals = new _immutable2.default.Set();
                account.vesting_balances = account.vesting_balances.withMutations(function (set) {
                    vesting_balances.forEach(function (vb) {
                        _this11._updateObject(vb);
                        set.add(vb.id);
                    });
                });

                var sub_to_objects = [];

                votes.forEach(function (v) {
                    return _this11._updateObject(v);
                });

                account.balances = account.balances.withMutations(function (map) {
                    full_account.balances.forEach(function (b) {
                        _this11._updateObject(b);
                        map.set(b.asset_type, b.id);
                        if (autosubscribe) sub_to_objects.push(b.id);
                    });
                });
                account.orders = account.orders.withMutations(function (set) {
                    limit_orders.forEach(function (order) {
                        _this11._updateObject(order);
                        set.add(order.id);
                        if (autosubscribe) sub_to_objects.push(order.id);
                    });
                });
                account.call_orders = account.call_orders.withMutations(function (set) {
                    call_orders.forEach(function (co) {
                        _this11._updateObject(co);
                        set.add(co.id);
                        if (autosubscribe) sub_to_objects.push(co.id);
                    });
                });

                account.proposals = account.proposals.withMutations(function (set) {
                    proposals.forEach(function (p) {
                        _this11._updateObject(p);
                        set.add(p.id);
                        if (autosubscribe) sub_to_objects.push(p.id);
                    });
                });

                /*
                    * In order to receive notifications for these objects
                    * we need to manually fetch them with get_objects. This
                    * is only done if autosubscribe is true
                    */
                if (sub_to_objects.length) _bcxjsWs.Apis.instance().db_api().exec("get_objects", [sub_to_objects]);

                _this11._updateObject(statistics);
                var updated_account = _this11._updateObject(account);
                _this11.fetchRecentHistory(updated_account);
                _this11.notifySubscribers();
            }).catch(function (error) {
                console.log("Error: ", error);
                if (_ChainValidation2.default.is_object_id(name_or_id)) _this11.objects_by_id.delete(name_or_id);else _this11.accounts_by_name.delete(name_or_id);
            });
        }
        return undefined;
    };

    ChainStore.prototype.getAccountMemberStatus = function getAccountMemberStatus(account) {
        if (account === undefined) return undefined;
        if (account === null) return "unknown";
        if (account.get("lifetime_referrer") == account.get("id")) return "lifetime";
        var exp = new Date(account.get("membership_expiration_date")).getTime();
        var now = new Date().getTime();
        if (exp < now) return "basic";
        return "annual";
    };

    ChainStore.prototype.getAccountBalance = function getAccountBalance(account, asset_type) {
        var balances = account.get("balances");
        if (!balances) return 0;

        var balance_obj_id = balances.get(asset_type);
        if (balance_obj_id) {
            var bal_obj = this.objects_by_id.get(balance_obj_id);
            if (bal_obj) return bal_obj.get("balance");
        }
        return 0;
    };

    /**
     * There are two ways to extend the account history, add new more
     * recent history, and extend historic hstory. This method will fetch
     * the most recent account history and prepend it to the list of
     * historic operations.
     *
     *  @param account immutable account object
     *  @return a promise with the account history
     */


    ChainStore.prototype.fetchRecentHistory = function fetchRecentHistory(account) {
        var _this12 = this;

        var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;

        // console.log( "get account history: ", account )
        /// TODO: make sure we do not submit a query if there is already one
        /// in flight...
        var account_id = account;
        if (!_ChainValidation2.default.is_object_id(account_id) && account.toJS) account_id = account.get("id");

        if (!_ChainValidation2.default.is_object_id(account_id)) return;

        account = this.objects_by_id.get(account_id);
        if (!account) return;

        var pending_request = this.account_history_requests.get(account_id);
        if (pending_request) {
            pending_request.requests++;
            return pending_request.promise;
        } else pending_request = { requests: 0 };

        var most_recent = "1." + op_history + ".0";
        var history = account.get("history");

        if (history && history.size) most_recent = history.first().get("id");

        /// starting at 0 means start at NOW, set this to something other than 0
        /// to skip recent transactions and fetch the tail
        var start = "1." + op_history + ".0";

        pending_request.promise = new Promise(function (resolve, reject) {
            _bcxjsWs.Apis.instance().history_api().exec("get_account_history", [account_id, most_recent, limit, start]).then(function (operations) {
                var current_account = _this12.objects_by_id.get(account_id);
                if (!current_account) return;
                var current_history = current_account.get("history");
                if (!current_history) current_history = _immutable2.default.List();
                var updated_history = _immutable2.default.fromJS(operations);
                updated_history = updated_history.withMutations(function (list) {
                    for (var i = 0; i < current_history.size; ++i) {
                        list.push(current_history.get(i));
                    }
                });
                var updated_account = current_account.set("history", updated_history);
                _this12.objects_by_id.set(account_id, updated_account);

                //if( current_history != updated_history )
                //   this._notifyAccountSubscribers( account_id )

                var pending_request = _this12.account_history_requests.get(account_id);
                _this12.account_history_requests.delete(account_id);
                if (pending_request.requests > 0) {
                    // it looks like some more history may have come in while we were
                    // waiting on the result, lets fetch anything new before we resolve
                    // this query.
                    _this12.fetchRecentHistory(updated_account, limit).then(resolve, reject);
                } else resolve(updated_account);
            }); // end then
        });

        this.account_history_requests.set(account_id, pending_request);
        return pending_request.promise;
    };

    //_notifyAccountSubscribers( account_id )
    //{
    //   let sub = this.subscriptions_by_account.get( account_id )
    //   let acnt = this.objects_by_id.get(account_id)
    //   if( !sub ) return
    //   for( let item of sub.subscriptions )
    //      item( acnt )
    //}

    /**
     *  Callback that receives notification of objects that have been
     *  added, remove, or changed and are relevant to account_id
     *
     *  This method updates or removes objects from the main index and
     *  then updates the account object with relevant meta-info depending
     *  upon the type of account
     */
    // _updateAccount( account_id, payload )
    // {
    //    let updates = payload[0]

    //    for( let i = 0; i < updates.length; ++i )
    //    {
    //       let update = updates[i]
    //       if( typeof update  == 'string' )
    //       {
    //          let old_obj = this._removeObject( update )

    //          if( update.search( order_prefix ) == 0 )
    //          {
    //                acnt = acnt.setIn( ['orders'], set => set.delete(update) )
    //          }
    //          else if( update.search( vesting_balance_prefix ) == 0 )
    //          {
    //                acnt = acnt.setIn( ['vesting_balances'], set => set.delete(update) )
    //          }
    //       }
    //       else
    //       {
    //          let updated_obj = this._updateObject( update )
    //          if( update.id.search( balance_prefix ) == 0 )
    //          {
    //             if( update.owner == account_id )
    //                acnt = acnt.setIn( ["balances"], map => map.set(update.asset_type,update.id) )
    //          }
    //          else if( update.id.search( order_prefix ) == 0 )
    //          {
    //             if( update.owner == account_id )
    //                acnt = acnt.setIn( ['orders'], set => set.add(update.id) )
    //          }
    //          else if( update.id.search( vesting_balance_prefix ) == 0 )
    //          {
    //             if( update.owner == account_id )
    //                acnt = acnt.setIn( ['vesting_balances'], set => set.add(update.id) )
    //          }

    //          this.objects_by_id.set( acnt.id, acnt )
    //       }
    //    }
    //    this.fetchRecentHistory( acnt )
    // }

    /**
     *  Updates the object in place by only merging the set
     *  properties of object.
     *
     *  This method will create an immutable object with the given ID if
     *  it does not already exist.
     *
     *  This is a "private" method called when data is received from the
     *  server and should not be used by others.
     *
     *  @pre object.id must be a valid object ID
     *  @return an Immutable constructed from object and deep merged with the current state
     */


    ChainStore.prototype._updateObject = function _updateObject(object) {
        var notify_subscribers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var emit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

        if (!("id" in object)) {
            console.log("object with no id:", object);
            /* Settle order updates look different and need special handling */
            if ("balance" in object && "owner" in object && "settlement_date" in object) {
                // Settle order object
                emitter.emit("settle-order-update", object);
            }
            return;
        }

        /*
        * A lot of objects get spammed by the API that we don't care about, filter these out here
        */
        // Transaction object
        if (object.id.substring(0, transaction_prefix.length) == transaction_prefix) {
            return; // console.log("not interested in transaction:", object);
        } else if (object.id.substring(0, account_transaction_history_prefix.length) == account_transaction_history_prefix) {
            // transaction_history object
            if (!this._isSubbedTo("accounts", object.account)) {
                return; // console.log("not interested in transaction_history of", object.account);
            }
        } else if (object.id.substring(0, order_prefix.length) == order_prefix) {
            // limit_order object
            if (!this._isSubbedTo("accounts", object.seller)) {
                return; // console.log("not interested in limit_orders of", object.seller);
            }
        } else if (object.id.substring(0, call_order_prefix.length) == call_order_prefix) {
            // call_order object
            if (!this._isSubbedTo("accounts", object.borrower)) {
                return; // console.log("not interested in call_orders of", object.borrower);
            }
        } else if (object.id.substring(0, balance_prefix.length) == balance_prefix) {
            // balance object
            if (!this._isSubbedTo("accounts", object.owner)) {
                return; // console.log("not interested in balance_object of", object.owner);
            }
        } else if (object.id.substring(0, operation_history_prefix.length) == operation_history_prefix) {
            // operation_history object
            return; // console.log("not interested in operation_history", object);
        } else if (object.id.substring(0, block_summary_prefix.length) == block_summary_prefix) {
            // block_summary object
            return; // console.log("not interested in block_summary_prefix", object);
        } else if (object.id.substring(0, account_stats_prefix.length) == account_stats_prefix) {
            // account_stats object
            if (!this._isSubbedTo("accounts", object.owner)) {
                return; // console.log("not interested in stats of", object.owner);
            }
        } else if (object.id.substring(0, witness_prefix.length) == witness_prefix) {
            // witness object
            if (!this._isSubbedTo("witnesses", object.id)) {
                return;
            }
        } else if (object.id.substring(0, committee_prefix.length) == committee_prefix) {
            // committee_member object
            if (!this._isSubbedTo("committee", object.id)) {
                return;
            }
        } else if (object.id.substring(0, 4) === "0.0." || object.id.substring(0, 2) === "5.") {
            /*
            ** The witness node spams these random objects related to markets,
            ** they are never needed by the GUI and thus only fill up the memory,
            ** so we ignore them
            */
            return;
        }

        // DYNAMIC GLOBAL OBJECT
        if (object.id == "2.1.0") {
            object.participation = 100 * ((0, _bigi2.default)(object.recent_slots_filled).bitCount() / 128.0);
            this.head_block_time_string = object.time;
            this.chain_time_offset.push(Date.now() - timeStringToDate(object.time).getTime());
            if (this.chain_time_offset.length > 10) this.chain_time_offset.shift(); // remove first
        }

        var current = this.objects_by_id.get(object.id);
        if (!current) {
            // console.log("add object:", object.id);
            current = _immutable2.default.Map();
        }
        var prior = current;
        if (current === undefined || current === true) this.objects_by_id.set(object.id, current = _immutable2.default.fromJS(object));else {
            this.objects_by_id.set(object.id, current = current.mergeDeep(_immutable2.default.fromJS(object)));
        }

        // BALANCE OBJECT
        if (object.id.substring(0, balance_prefix.length) == balance_prefix) {
            var owner = this.objects_by_id.get(object.owner);
            if (owner === undefined || owner === null || owner === true) {
                return;
                /*  This prevents the full account from being looked up later
                owner = {id:object.owner, balances:{ } }
                owner.balances[object.asset_type] = object.id
                owner = Immutable.fromJS( owner )
                */
            } else {
                var balances = owner.get("balances");
                if (!balances) owner = owner.set("balances", _immutable2.default.Map());
                owner = owner.setIn(["balances", object.asset_type], object.id);
            }
            this.objects_by_id.set(object.owner, owner);
        } else if (object.id.substring(0, account_stats_prefix.length) == account_stats_prefix) {
            // ACCOUNT STATS OBJECT
            try {
                var prior_most_recent_op = prior.get("most_recent_op", "2.9.0");

                if (prior_most_recent_op != object.most_recent_op) {
                    this.fetchRecentHistory(object.owner);
                }
            } catch (err) {
                console.log("prior error:", "object:", obj, "prior", prior, "err:", err);
            }
        } else if (object.id.substring(0, witness_prefix.length) == witness_prefix) {
            // WITNESS OBJECT
            if (this._isSubbedTo("witnesses", object.id)) {
                this.witness_by_account_id.set(object.witness_account, object.id);
                this.objects_by_vote_id.set(object.vote_id, object.id);
            } else {
                return;
            }
        } else if (object.id.substring(0, committee_prefix.length) == committee_prefix) {
            // COMMITTEE MEMBER OBJECT
            if (this._isSubbedTo("committee", object.id)) {
                this.committee_by_account_id.set(object.committee_member_account, object.id);
                this.objects_by_vote_id.set(object.vote_id, object.id);
            } else {
                return;
            }
        } else if (object.id.substring(0, account_prefix.length) == account_prefix) {
            // ACCOUNT OBJECT
            current = current.set("active", _immutable2.default.fromJS(object.active));
            current = current.set("owner", _immutable2.default.fromJS(object.owner));
            current = current.set("options", _immutable2.default.fromJS(object.options));
            current = current.set("whitelisting_accounts", _immutable2.default.fromJS(object.whitelisting_accounts));
            current = current.set("blacklisting_accounts", _immutable2.default.fromJS(object.blacklisting_accounts));
            current = current.set("whitelisted_accounts", _immutable2.default.fromJS(object.whitelisted_accounts));
            current = current.set("blacklisted_accounts", _immutable2.default.fromJS(object.blacklisted_accounts));
            this.objects_by_id.set(object.id, current);
            this.accounts_by_name.set(object.name, object.id);
        } else if (object.id.substring(0, asset_prefix.length) == asset_prefix) {
            // ASSET OBJECT
            this.assets_by_symbol.set(object.symbol, object.id);
            // let dynamic = current.get( "dynamic" );
            // if( !dynamic ) {
            //     let dad = this.getObject( object.dynamic_asset_data_id, true );
            //     if( !dad )
            //         dad = Immutable.Map();
            //     if( !dad.get( "asset_id" ) ) {
            //         dad = dad.set( "asset_id", object.id );
            //     }
            //     this.objects_by_id.set( object.dynamic_asset_data_id, dad );

            // current = current.set( "dynamic", dad );
            // this.objects_by_id.set( object.id, current );
            // }

            var bitasset = current.get("bitasset");
            if (!bitasset && object.bitasset_data_id) {
                var bad = this.getObject(object.bitasset_data_id, true);
                if (!bad) bad = _immutable2.default.Map();

                if (!bad.get("asset_id")) {
                    bad = bad.set("asset_id", object.id);
                }
                this.objects_by_id.set(object.bitasset_data_id, bad);

                current = current.set("bitasset", bad);
                this.objects_by_id.set(object.id, current);
            }
            // } else if( object.id.substring(0, asset_dynamic_data_prefix.length) == asset_dynamic_data_prefix ) {
            // ASSET DYNAMIC DATA OBJECT
            // let asset_id = asset_prefix + object.id.substring( asset_dynamic_data_prefix.length )
            // let asset_id = current.get( "asset_id" );
            // if (asset_id) {
            //     let asset_obj = this.getObject( asset_id );
            //     if(asset_obj && asset_obj.set) {
            //         asset_obj = asset_obj.set( "dynamic", current );
            //         this.objects_by_id.set( asset_id, asset_obj );
            //     }
            // }
        } else if (object.id.substring(0, worker_prefix.length) == worker_prefix) {
            // WORKER OBJECT
            this.objects_by_vote_id.set(object.vote_for, object.id);
            this.objects_by_vote_id.set(object.vote_against, object.id);

            if (!this.workers.has(object.id)) this.workers.add(object.id);
        } else if (object.id.substring(0, bitasset_data_prefix.length) == bitasset_data_prefix) {
            // BITASSET DATA OBJECT
            var asset_id = current.get("asset_id");
            if (asset_id) {
                var asset = this.getObject(asset_id);
                if (asset) {
                    asset = asset.set("bitasset", current);
                    emitter.emit("bitasset-update", asset);
                    this.objects_by_id.set(asset_id, asset);
                }
            }
        } else if (object.id.substring(0, call_order_prefix.length) == call_order_prefix) {
            // CALL ORDER OBJECT
            // Update nested call_orders inside account object
            if (emit) {
                emitter.emit("call-order-update", object);
            }

            var account = this.objects_by_id.get(object.borrower);
            if (account) {
                if (!account.has("call_orders")) account = account.set("call_orders", new _immutable2.default.Set());
                var call_orders = account.get("call_orders");
                if (!call_orders.has(object.id)) {
                    account = account.set("call_orders", call_orders.add(object.id));
                    this.objects_by_id.set(account.get("id"), account);
                    _bcxjsWs.Apis.instance().db_api().exec("get_objects", [[object.id]]); // Force subscription to the object in the witness node by calling get_objects
                }
            }
        } else if (object.id.substring(0, order_prefix.length) == order_prefix) {
            // LIMIT ORDER OBJECT
            var _account2 = this.objects_by_id.get(object.seller);
            if (_account2) {
                if (!_account2.has("orders")) _account2 = _account2.set("orders", new _immutable2.default.Set());
                var limit_orders = _account2.get("orders");
                if (!limit_orders.has(object.id)) {
                    _account2 = _account2.set("orders", limit_orders.add(object.id));
                    this.objects_by_id.set(_account2.get("id"), _account2);
                    _bcxjsWs.Apis.instance().db_api().exec("get_objects", [[object.id]]); // Force subscription to the object in the witness node by calling get_objects
                }
            }
            // POROPOSAL OBJECT
        } else if (object.id.substring(0, proposal_prefix.length) == proposal_prefix) {
            this.addProposalData(object.required_active_approvals, object.id);
            this.addProposalData(object.required_owner_approvals, object.id);
        }

        if (notify_subscribers) {
            this.notifySubscribers();
        }
        return current;
    };

    ChainStore.prototype.getObjectsByVoteIds = function getObjectsByVoteIds(vote_ids) {
        var _this13 = this;

        var result = [];
        var missing = [];
        for (var i = 0; i < vote_ids.length; ++i) {
            var _obj2 = this.objects_by_vote_id.get(vote_ids[i]);
            if (_obj2) result.push(this.getObject(_obj2));else {
                result.push(null);
                missing.push(vote_ids[i]);
            }
        }

        if (missing.length) {
            // we may need to fetch some objects
            _bcxjsWs.Apis.instance().db_api().exec("lookup_vote_ids", [missing]).then(function (vote_obj_array) {
                // console.log("missing ===========> ", missing);
                // console.log(
                //     "vote objects ===========> ",
                //     vote_obj_array
                // );
                for (var _i2 = 0; _i2 < vote_obj_array.length; ++_i2) {
                    if (vote_obj_array[_i2]) {
                        var isWitness = vote_obj_array[_i2].id.substring(0, witness_prefix.length) == witness_prefix;
                        _this13._subTo(isWitness ? "witnesses" : "committee", vote_obj_array[_i2].id);
                        _this13._updateObject(vote_obj_array[_i2]);
                    }
                }
            }).catch(function (error) {
                console.log("Error looking up vote ids: ", error);
            });
        }
        return result;
    };

    ChainStore.prototype.getObjectByVoteID = function getObjectByVoteID(vote_id) {
        var obj_id = this.objects_by_vote_id.get(vote_id);
        if (obj_id) return this.getObject(obj_id);
        return undefined;
    };

    ChainStore.prototype.getHeadBlockDate = function getHeadBlockDate() {
        return timeStringToDate(this.head_block_time_string);
    };

    ChainStore.prototype.getEstimatedChainTimeOffset = function getEstimatedChainTimeOffset() {
        if (this.chain_time_offset.length === 0) return 0;
        // Immutable is fast, sorts numbers correctly, and leaves the original unmodified
        // This will fix itself if the user changes their clock
        var median_offset = _immutable2.default.List(this.chain_time_offset).sort().get(Math.floor((this.chain_time_offset.length - 1) / 2));
        // console.log("median_offset", median_offset)
        return median_offset;
    };

    ChainStore.prototype.addProposalData = function addProposalData(approvals, objectId) {
        var _this14 = this;

        approvals.forEach(function (id) {
            var impactedAccount = _this14.objects_by_id.get(id);
            if (impactedAccount) {
                var proposals = impactedAccount.get("proposals", _immutable2.default.Set());

                if (!proposals.includes(objectId)) {
                    proposals = proposals.add(objectId);
                    impactedAccount = impactedAccount.set("proposals", proposals);
                    _this14.objects_by_id.set(impactedAccount.get("id"), impactedAccount);
                }
            }
        });
    };

    return ChainStore;
}();

var chain_store = new ChainStore();

function FetchChainObjects(method, object_ids, timeout, subMap) {
    var get_object = method.bind(chain_store);

    return new Promise(function (resolve, reject) {
        var timeout_handle = null;

        function onUpdate() {
            var not_subscribed_yet = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

            var res = object_ids.map(function (id) {
                if (method.name === "getAccount") return get_object(id, subMap[id]);
                if (method.name === "getObject") return get_object(id,false, subMap[id]);
                return get_object(id);
            });
            if (res.findIndex(function (o) {
                return o === undefined;
            }) === -1) {
                if (timeout_handle) clearTimeout(timeout_handle);
                if (!not_subscribed_yet) chain_store.unsubscribe(onUpdate);
                resolve(res);
                return true;
            }
            return false;
        }

        var resolved = onUpdate(true);
        if (!resolved) chain_store.subscribe(onUpdate);

        if (timeout && !resolved) timeout_handle = setTimeout(function () {
            chain_store.unsubscribe(onUpdate);
            reject(method.name + " request timed out after " + timeout + "ms with object ids: " + JSON.stringify(object_ids));
        }, timeout);
    });
}
chain_store.FetchChainObjects = FetchChainObjects;

function FetchChain(methodName, objectIds) {
    var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3000;
    var subMap = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    var method = chain_store[methodName];
    if (!method) throw new Error("ChainStore does not have method " + methodName);

    var arrayIn = Array.isArray(objectIds);
    if (!arrayIn) objectIds = [objectIds];

    return chain_store.FetchChainObjects(method, _immutable2.default.List(objectIds), timeout, subMap).then(function (res) {
        return arrayIn ? res : res.get(0);
    });
}

chain_store.FetchChain = FetchChain;

function timeStringToDate(time_string) {
    if (!time_string) return new Date("1970-01-01T00:00:00.000Z");
    if (!/Z$/.test(time_string)) {
        //does not end in Z
        // https://github.com/cryptonomex/graphene/issues/368
        time_string = time_string + "Z";
    }
    return new Date(time_string);
}

exports.default = chain_store;
module.exports = exports["default"];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9)))

/***/ }),
/* 468 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var d        = __webpack_require__(469)
  , callable = __webpack_require__(486)

  , apply = Function.prototype.apply, call = Function.prototype.call
  , create = Object.create, defineProperty = Object.defineProperty
  , defineProperties = Object.defineProperties
  , hasOwnProperty = Object.prototype.hasOwnProperty
  , descriptor = { configurable: true, enumerable: false, writable: true }

  , on, once, off, emit, methods, descriptors, base;

on = function (type, listener) {
	var data;

	callable(listener);

	if (!hasOwnProperty.call(this, '__ee__')) {
		data = descriptor.value = create(null);
		defineProperty(this, '__ee__', descriptor);
		descriptor.value = null;
	} else {
		data = this.__ee__;
	}
	if (!data[type]) data[type] = listener;
	else if (typeof data[type] === 'object') data[type].push(listener);
	else data[type] = [data[type], listener];

	return this;
};

once = function (type, listener) {
	var once, self;

	callable(listener);
	self = this;
	on.call(this, type, once = function () {
		off.call(self, type, once);
		apply.call(listener, this, arguments);
	});

	once.__eeOnceListener__ = listener;
	return this;
};

off = function (type, listener) {
	var data, listeners, candidate, i;

	callable(listener);

	if (!hasOwnProperty.call(this, '__ee__')) return this;
	data = this.__ee__;
	if (!data[type]) return this;
	listeners = data[type];

	if (typeof listeners === 'object') {
		for (i = 0; (candidate = listeners[i]); ++i) {
			if ((candidate === listener) ||
					(candidate.__eeOnceListener__ === listener)) {
				if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
				else listeners.splice(i, 1);
			}
		}
	} else {
		if ((listeners === listener) ||
				(listeners.__eeOnceListener__ === listener)) {
			delete data[type];
		}
	}

	return this;
};

emit = function (type) {
	var i, l, listener, listeners, args;

	if (!hasOwnProperty.call(this, '__ee__')) return;
	listeners = this.__ee__[type];
	if (!listeners) return;

	if (typeof listeners === 'object') {
		l = arguments.length;
		args = new Array(l - 1);
		for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

		listeners = listeners.slice();
		for (i = 0; (listener = listeners[i]); ++i) {
			apply.call(listener, this, args);
		}
	} else {
		switch (arguments.length) {
		case 1:
			call.call(listeners, this);
			break;
		case 2:
			call.call(listeners, this, arguments[1]);
			break;
		case 3:
			call.call(listeners, this, arguments[1], arguments[2]);
			break;
		default:
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) {
				args[i - 1] = arguments[i];
			}
			apply.call(listeners, this, args);
		}
	}
};

methods = {
	on: on,
	once: once,
	off: off,
	emit: emit
};

descriptors = {
	on: d(on),
	once: d(once),
	off: d(off),
	emit: d(emit)
};

base = defineProperties({}, descriptors);

module.exports = exports = function (o) {
	return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
};
exports.methods = methods;


/***/ }),
/* 469 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isValue         = __webpack_require__(385)
  , isPlainFunction = __webpack_require__(470)
  , assign          = __webpack_require__(474)
  , normalizeOpts   = __webpack_require__(482)
  , contains        = __webpack_require__(483);

var d = (module.exports = function (dscr, value/*, options*/) {
	var c, e, w, options, desc;
	if (arguments.length < 2 || typeof dscr !== "string") {
		options = value;
		value = dscr;
		dscr = null;
	} else {
		options = arguments[2];
	}
	if (isValue(dscr)) {
		c = contains.call(dscr, "c");
		e = contains.call(dscr, "e");
		w = contains.call(dscr, "w");
	} else {
		c = w = true;
		e = false;
	}

	desc = { value: value, configurable: c, enumerable: e, writable: w };
	return !options ? desc : assign(normalizeOpts(options), desc);
});

d.gs = function (dscr, get, set/*, options*/) {
	var c, e, options, desc;
	if (typeof dscr !== "string") {
		options = set;
		set = get;
		get = dscr;
		dscr = null;
	} else {
		options = arguments[3];
	}
	if (!isValue(get)) {
		get = undefined;
	} else if (!isPlainFunction(get)) {
		options = get;
		get = set = undefined;
	} else if (!isValue(set)) {
		set = undefined;
	} else if (!isPlainFunction(set)) {
		options = set;
		set = undefined;
	}
	if (isValue(dscr)) {
		c = contains.call(dscr, "c");
		e = contains.call(dscr, "e");
	} else {
		c = true;
		e = false;
	}

	desc = { get: get, set: set, configurable: c, enumerable: e };
	return !options ? desc : assign(normalizeOpts(options), desc);
};


/***/ }),
/* 470 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isFunction = __webpack_require__(471);

var classRe = /^\s*class[\s{/}]/, functionToString = Function.prototype.toString;

module.exports = function (value) {
	if (!isFunction(value)) return false;
	if (classRe.test(functionToString.call(value))) return false;
	return true;
};


/***/ }),
/* 471 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isPrototype = __webpack_require__(472);

module.exports = function (value) {
	if (typeof value !== "function") return false;

	if (!hasOwnProperty.call(value, "length")) return false;

	try {
		if (typeof value.length !== "number") return false;
		if (typeof value.call !== "function") return false;
		if (typeof value.apply !== "function") return false;
	} catch (error) {
		return false;
	}

	return !isPrototype(value);
};


/***/ }),
/* 472 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(473);

module.exports = function (value) {
	if (!isObject(value)) return false;
	try {
		if (!value.constructor) return false;
		return value.constructor.prototype === value;
	} catch (error) {
		return false;
	}
};


/***/ }),
/* 473 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isValue = __webpack_require__(385);

// prettier-ignore
var possibleTypes = { "object": true, "function": true, "undefined": true /* document.all */ };

module.exports = function (value) {
	if (!isValue(value)) return false;
	return hasOwnProperty.call(possibleTypes, typeof value);
};


/***/ }),
/* 474 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(475)() ? Object.assign : __webpack_require__(476);


/***/ }),
/* 475 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
	var assign = Object.assign, obj;
	if (typeof assign !== "function") return false;
	obj = { foo: "raz" };
	assign(obj, { bar: "dwa" }, { trzy: "trzy" });
	return obj.foo + obj.bar + obj.trzy === "razdwatrzy";
};


/***/ }),
/* 476 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var keys  = __webpack_require__(477)
  , value = __webpack_require__(481)
  , max   = Math.max;

module.exports = function (dest, src/*, â€¦srcn*/) {
	var error, i, length = max(arguments.length, 2), assign;
	dest = Object(value(dest));
	assign = function (key) {
		try {
			dest[key] = src[key];
		} catch (e) {
			if (!error) error = e;
		}
	};
	for (i = 1; i < length; ++i) {
		src = arguments[i];
		keys(src).forEach(assign);
	}
	if (error !== undefined) throw error;
	return dest;
};


/***/ }),
/* 477 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(478)() ? Object.keys : __webpack_require__(479);


/***/ }),
/* 478 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
	try {
		Object.keys("primitive");
		return true;
	} catch (e) {
		return false;
	}
};


/***/ }),
/* 479 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isValue = __webpack_require__(223);

var keys = Object.keys;

module.exports = function (object) { return keys(isValue(object) ? Object(object) : object); };


/***/ }),
/* 480 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// eslint-disable-next-line no-empty-function
module.exports = function () {};


/***/ }),
/* 481 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isValue = __webpack_require__(223);

module.exports = function (value) {
	if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
	return value;
};


/***/ }),
/* 482 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isValue = __webpack_require__(223);

var forEach = Array.prototype.forEach, create = Object.create;

var process = function (src, obj) {
	var key;
	for (key in src) obj[key] = src[key];
};

// eslint-disable-next-line no-unused-vars
module.exports = function (opts1/*, â€¦options*/) {
	var result = create(null);
	forEach.call(arguments, function (options) {
		if (!isValue(options)) return;
		process(Object(options), result);
	});
	return result;
};


/***/ }),
/* 483 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(484)() ? String.prototype.contains : __webpack_require__(485);


/***/ }),
/* 484 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var str = "razdwatrzy";

module.exports = function () {
	if (typeof str.contains !== "function") return false;
	return str.contains("dwa") === true && str.contains("foo") === false;
};


/***/ }),
/* 485 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var indexOf = String.prototype.indexOf;

module.exports = function (searchString/*, position*/) {
	return indexOf.call(this, searchString, arguments[1]) > -1;
};


/***/ }),
/* 486 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (fn) {
	if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
	return fn;
};


/***/ }),
/* 487 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

exports.__esModule = true;

var _assert = __webpack_require__(45);

var _assert2 = _interopRequireDefault(_assert);

var _ecc = __webpack_require__(219);

var _serializer = __webpack_require__(386);

var _bcxjsWs = __webpack_require__(8);

var _ChainTypes = __webpack_require__(131);

var _ChainTypes2 = _interopRequireDefault(_ChainTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var head_block_time_string, committee_min_review;

var TransactionBuilder = function () {
    function TransactionBuilder() {
        _classCallCheck(this, TransactionBuilder);

        this.ref_block_num = 0;
        this.ref_block_prefix = 0;
        this.expiration = 0;
        this.operations = [];
        this.signatures = [];
        this.signer_private_keys = [];
        this.debug_time=new Date().getTime();
        // semi-private method bindings
        this._broadcast = _broadcast.bind(this);
    }

    /**
        @arg {string} name - like "transfer"
        @arg {object} operation - JSON matchching the operation's format
    */


    TransactionBuilder.prototype.add_type_operation = function add_type_operation(name, operation) {
        this.add_operation(this.get_type_operation(name, operation));
        return;
    };

    /**
        This does it all: set fees, finalize, sign, and broadcast (if wanted).
         @arg {ConfidentialWallet} cwallet - must be unlocked, used to gather signing keys
         @arg {array<string>} [signer_pubkeys = null] - Optional ["GPHAbc9Def0...", ...].  These are additional signing keys.  Some balance claims require propritary address formats, the witness node can't tell us which ones are needed so they must be passed in.  If the witness node can figure out a signing key (mostly all other transactions), it should not be passed in here.
         @arg {boolean} [broadcast = false]
    */


    TransactionBuilder.prototype.process_transaction = function process_transaction(cwallet) {
        var _this = this;

        var signer_pubkeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var broadcast = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        var wallet_object = cwallet.wallet.wallet_object;
        if (_bcxjsWs.Apis.instance().chain_id !== wallet_object.get("chain_id")) return Promise.reject("Mismatched chain_id; expecting " + wallet_object.get("chain_id") + ", but got " + _bcxjsWs.Apis.instance().chain_id);
        return this.set_required_fees().then(function () {
            var signer_pubkeys_added = {};
            if (signer_pubkeys) {
                // Balance claims are by address, only the private
                // key holder can know about these additional
                // potential keys.
                var pubkeys = cwallet.getPubkeys_having_PrivateKey(signer_pubkeys);
                if (!pubkeys.length) throw new Error("Missing signing key");

                for (var _iterator = pubkeys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
                    var _ref;

                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        _i = _iterator.next();
                        if (_i.done) break;
                        _ref = _i.value;
                    }

                    var pubkey_string = _ref;

                    var private_key = cwallet.getPrivateKey(pubkey_string);
                    _this.add_signer(private_key, pubkey_string);
                    signer_pubkeys_added[pubkey_string] = true;
                }
            }

            return _this.get_potential_signatures().then(function (_ref2) {
                var pubkeys = _ref2.pubkeys,
                    addys = _ref2.addys;

                var my_pubkeys = cwallet.getPubkeys_having_PrivateKey(pubkeys, addys);

                //{//Testing only, don't send All public keys!
                //    var pubkeys_all = PrivateKeyStore.getPubkeys() // All public keys
                //    this.get_required_signatures(pubkeys_all).then( required_pubkey_strings =>
                //        console.log('get_required_signatures all\t',required_pubkey_strings.sort(), pubkeys_all))
                //    this.get_required_signatures(my_pubkeys).then( required_pubkey_strings =>
                //        console.log('get_required_signatures normal\t',required_pubkey_strings.sort(), pubkeys))
                //}

                return _this.get_required_signatures(my_pubkeys).then(function (required_pubkeys) {
                    for (var _iterator2 = required_pubkeys, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
                        var _ref3;

                        if (_isArray2) {
                            if (_i2 >= _iterator2.length) break;
                            _ref3 = _iterator2[_i2++];
                        } else {
                            _i2 = _iterator2.next();
                            if (_i2.done) break;
                            _ref3 = _i2.value;
                        }

                        var _pubkey_string = _ref3;

                        if (signer_pubkeys_added[_pubkey_string]) continue;
                        var private_key = cwallet.getPrivateKey(_pubkey_string);
                        if (!private_key)
                            // This should not happen, get_required_signatures will only
                            // returned keys from my_pubkeys
                            throw new Error("Missing signing key for " + _pubkey_string);
                        _this.add_signer(private_key, _pubkey_string);
                    }
                });
            }).then(function () {
                return broadcast ? _this.broadcast() : _this.serialize();
            });
        });
    };

    /** Typically this is called automatically just prior to signing.  Once finalized this transaction can not be changed. */


    TransactionBuilder.prototype.finalize = function finalize() {
        var _this2 = this;

        return new Promise(function (resolve, reject) {
            if (_this2.tr_buffer) {
                throw new Error("already finalized");
            }

            resolve(_bcxjsWs.Apis.instance().db_api().exec("get_objects", [["2.1.0"]]).then(function (r) {
                head_block_time_string = r[0].time;
                if (_this2.expiration === 0) _this2.expiration = base_expiration_sec() + _bcxjsWs.ChainConfig.expire_in_secs;
                _this2.ref_block_num = r[0].head_block_number & 0xffff;
                _this2.ref_block_prefix = new Buffer(r[0].head_block_id, "hex").readUInt32LE(4);
                //DEBUG console.log("ref_block",@ref_block_num,@ref_block_prefix,r)

                var iterable = _this2.operations;

                for (var i = 0, op; i < iterable.length; i++) {
                    op = iterable[i];
                    if (op[1]["finalize"]) {
                        op[1].finalize();
                    }
                }
                _this2.tr_buffer = _serializer.ops.transaction.toBuffer(_this2);
            }));
        });
    };

    /** @return {string} hex transaction ID */


    TransactionBuilder.prototype.id = function id() {
        if (!this.tr_buffer) {
            throw new Error("not finalized");
        }
        return _ecc.hash.sha256(this.tr_buffer).toString("hex").substring(0, 40);
    };

    /**
        Typically one will use {@link this.add_type_operation} instead.
        @arg {array} operation - [operation_id, operation]
    */


    TransactionBuilder.prototype.add_operation = function add_operation(operation) {
        if (this.tr_buffer) {
            throw new Error("already finalized");
        }
        (0, _assert2.default)(operation, "operation");
        if (!Array.isArray(operation)) {
            throw new Error("Expecting array [operation_id, operation]");
        }
        this.operations.push(operation);
        return;
    };

    TransactionBuilder.prototype.get_type_operation = function get_type_operation(name, operation) {
        if (this.tr_buffer) {
            throw new Error("already finalized");
        }
        (0, _assert2.default)(name, "name");
        (0, _assert2.default)(operation, "operation");
        var _type = _serializer.ops[name];
        (0, _assert2.default)(_type, "Unknown operation " + name);
        var operation_id = _ChainTypes2.default.operations[_type.operation_name];
        if (operation_id === undefined) {
            throw new Error("unknown operation: " + _type.operation_name);
        }
        if (!operation.fee) {
            operation.fee = { amount: 0, asset_id: 0 };
        }
        if (name === "proposal_create") {
            /*
            * Proposals involving the committee account require a review
            * period to be set, look for them here
            */
            var requiresReview = false,
                extraReview = 0;
            operation.proposed_ops.forEach(function (op) {
                var COMMITTE_ACCOUNT = 0;
                var key = void 0;

                switch (op.op[0]) {
                    case 0:
                        // transfer
                        key = "from";
                        break;

                    case 6: //account_update
                    case 17:
                        // asset_settle
                        key = "account";
                        break;

                    case 10: // asset_create
                    case 11: // asset_update
                    case 12: // asset_update_bitasset
                    case 13: // asset_update_feed_producers
                    case 14: // asset_issue
                    case 18: // asset_global_settle
                    case 43:
                        // asset_claim_fees
                        key = "issuer";
                        break;

                    case 15:
                        // asset_reserve
                        key = "payer";
                        break;

                    case 16:
                        // asset_fund_fee_pool
                        key = "from_account";
                        break;

                    case 22: // proposal_create
                    case 23: // proposal_update
                    case 24:
                        // proposal_delete
                        key = "fee_paying_account";
                        break;

                    case 31:
                        // committee_member_update_global_parameters
                        requiresReview = true;
                        extraReview = 60 * 60 * 24 * 13; // Make the review period 2 weeks total
                        break;
                }
                if (key in op.op[1] && op.op[1][key] === COMMITTE_ACCOUNT) {
                    requiresReview = true;
                }
            });
            operation.expiration_time || (operation.expiration_time = base_expiration_sec() + _bcxjsWs.ChainConfig.expire_in_secs_proposal);
            if (requiresReview) {
                operation.review_period_seconds = extraReview + Math.max(committee_min_review, 24 * 60 * 60 || _bcxjsWs.ChainConfig.review_in_secs_committee);
                /*
                * Expiration time must be at least equal to
                * now + review_period_seconds, so we add one hour to make sure
                */
                operation.expiration_time += 60 * 60 + extraReview;
            }
        }
        var operation_instance = _type.fromObject(operation);
        return [operation_id, operation_instance];
    };

    /* optional: fetch the current head block */

    TransactionBuilder.prototype.update_head_block = function update_head_block() {
        return Promise.all([_bcxjsWs.Apis.instance().db_api().exec("get_objects", [["2.0.0"]]), _bcxjsWs.Apis.instance().db_api().exec("get_objects", [["2.1.0"]])]).then(function (res) {
            var g = res[0],
                r = res[1];

            head_block_time_string = r[0].time;
            committee_min_review = g[0].parameters.committee_proposal_review_period;
        });
    };

    /** optional: there is a deafult expiration */


    TransactionBuilder.prototype.set_expire_seconds = function set_expire_seconds(sec) {
        if (this.tr_buffer) {
            throw new Error("already finalized");
        }
        return this.expiration = base_expiration_sec() + sec;
    };

    /* Wraps this transaction in a proposal_create transaction */


    TransactionBuilder.prototype.propose = function propose(proposal_create_options) {
        if (this.tr_buffer) {
            throw new Error("already finalized");
        }
        if (!this.operations.length) {
            throw new Error("add operation first");
        }

        (0, _assert2.default)(proposal_create_options, "proposal_create_options");
        (0, _assert2.default)(proposal_create_options.fee_paying_account, "proposal_create_options.fee_paying_account");

        var proposed_ops = this.operations.map(function (op) {
            return { op: op };
        });

        this.operations = [];
        this.signatures = [];
        this.signer_private_keys = [];
        proposal_create_options.proposed_ops = proposed_ops;
        this.add_type_operation("proposal_create", proposal_create_options);
        return this;
    };

    TransactionBuilder.prototype.crontab = function crontab(crontab_create_options) {
        if (this.tr_buffer) {
            throw new Error("already finalized");
        }
        if (!this.operations.length) {
            throw new Error("add operation first");
        }

        // (0, _assert2.default)(crontab_create_options, "proposal_create_options");
        // (0, _assert2.default)(crontab_create_options.fee_paying_account, "crontab_create_options.fee_paying_account");

        var crontab_ops = this.operations.map(function (op) {
            return { op: op };
        });

        this.operations = [];
        this.signatures = [];
        this.signer_private_keys = [];
        crontab_create_options.crontab_ops = crontab_ops;
        this.add_type_operation("crontab_create", crontab_create_options);
        return this;
    };

    TransactionBuilder.prototype.has_proposed_operation = function has_proposed_operation() {
        var hasProposed = false;
        for (var i = 0; i < this.operations.length; i++) {
            if ("proposed_ops" in this.operations[i][1]) {
                hasProposed = true;
                break;
            }
        }

        return hasProposed;
    };

    /** optional: the fees can be obtained from the witness node */


    TransactionBuilder.prototype.set_required_fees = function set_required_fees(asset_id, removeDuplicates) {
        var _this3 = this;

        if (this.tr_buffer) {
            throw new Error("already finalized");
        }
        if (!this.operations.length) {
            throw new Error("add operations first");
        }

        function isProposal(op) {
            return op[0] === 22;
        }

        var operations = [];
        var proposed_ops = [];
        var feeAssets = [];
        var proposalFeeAssets = [];
        var potentialDuplicates = {};
        function getDuplicateOriginalIndex(op, index) {
            var key = getOperationKey(op);
            var duplicate = potentialDuplicates[key];
            if (!!duplicate) {
                if (duplicate.original === index) return index;else if (duplicate.duplicates.indexOf(index) !== -1) {
                    return duplicate.original;
                }
            }
        }
        function getOperationKey(op) {
            var key = null;
            switch (op[0]) {
                case 0:
                    // transfer
                    var memoDummy = new Array(op[1].memo.message.length + 1).join("a");
                    key = op[0] + "_" + op[1].amount.asset_id + "_" + memoDummy;
                    break;
                default:
            }
            return key;
        }
        for (var i = 0, op; i < this.operations.length; i++) {
            op = this.operations[i];
            var opObject = _serializer.ops.operation.toObject(op);
            var isDuplicate = false;
            if (removeDuplicates) {
                var key = getOperationKey(opObject);
                if (key) {
                    if (!potentialDuplicates[key]) potentialDuplicates[key] = {
                        original: i,
                        duplicates: []
                    };else {
                        potentialDuplicates[key].duplicates.push(i);
                        isDuplicate = true;
                    }
                }
            }
            /*
            * If the operation creates a proposal, we should check the fee pool
            * of the suggested proposal fee assets to prevent users from creating
            * proposals that will most likely fail due to empty fee pools
            */
            if (isProposal(op)) {
                if(op[1].proposed_ops)
                op[1].proposed_ops.forEach(function (prop) {
                    // console.log("proposed op", prop.op[1].fee);
                    proposed_ops.push(prop);
                    if (proposalFeeAssets.indexOf(prop.op[1].fee.asset_id) === -1) proposalFeeAssets.push("1.3." + prop.op[1].fee.asset_id);
                });
            }
            if (!isDuplicate) {
                operations.push(opObject);
                if (feeAssets.indexOf(operations[i][1].fee.asset_id) === -1) feeAssets.push(operations[i][1].fee.asset_id);
            }
        }

        if (!asset_id) {
            var op1_fee = operations[0][1].fee;
            if (op1_fee && op1_fee.asset_id !== null) {
                asset_id = op1_fee.asset_id;
            } else {
                asset_id = "1.3.0";
            }
        }

        var promises = [];
        promises.push(Promise.all(feeAssets.map(function (id) {
            return _bcxjsWs.Apis.instance().db_api().exec("get_required_fees", [operations, id]);
        })).catch(function (err) {
            console.error("get_required_fees API error: ", err.message);
        }));

        /*
        * Add the proposal fee asset ids to feeAssets here to fetch their
        * dynamic objects without calling get_required_fees with them as well
        */
        if (proposalFeeAssets.length) {
            proposalFeeAssets.forEach(function (id) {
                if (feeAssets.indexOf(id) === -1) feeAssets.push(id);
            });
        }

        if (feeAssets.length > 1 || feeAssets[0] !== "1.3.0") {
            /*
            * If we're paying with any assets other than CORE, we need to fetch
            * the dynamic asset object and check the fee pool of those assets.
            * The dynamic asset object id is equal to the asset id but with
            * 2.3.x instead of 1.3.x
            */
            var dynamicObjectIds = feeAssets.map(function (a) {
                return a.replace(/^1\./, "2.");
            });
            promises.push(_bcxjsWs.Apis.instance().db_api().exec("get_required_fees", [operations, "1.3.0"]));
            promises.push(_bcxjsWs.Apis.instance().db_api().exec("get_objects", [dynamicObjectIds]));
        }

        return Promise.all(promises).then(function (results) {
            /*
            * allFees and coreFees are arrays containg fee amounts grouped by
            * asset and for each operation in operations
            */
            var allFees = results[0],
                coreFees = results[1],
                dynamicObjects = results[2];

            /*
            * If one of the desired fee assets has an invalid core exchange rate
            * get_required_signatures will fail and the result for all assets
            * will be undefined, if so we just default to coreFees
            */

            if (allFees === undefined) {
                allFees = coreFees;
            }
            /*
            * If the only desired fee asset is CORE, coreFees are not fetched
            * but are equal to allFees
            */
            if (!coreFees) {
                coreFees = allFees[0];
            }

            /* Create a map of fees and proposal fees by asset id */
            var feesByAsset = {};
            var proposalFeesByAsset = {};
            allFees.forEach(function (feeSet) {
                var filteredFeeSet = feeSet.map(function (f) {
                    if (Array.isArray(f)) {
                        // This operation includes a proposal
                        proposalFeesByAsset[f[1][0].asset_id] = f[1];
                        return f[0];
                    }
                    return f;
                });
                var currentAssetId = filteredFeeSet[0].asset_id;

                feesByAsset[currentAssetId] = filteredFeeSet;
            }, {});

            /* Create a map of fee pools by asset id*/
            var feePoolMap = !!dynamicObjects ? dynamicObjects.reduce(function (map, object) {
                map[object.id.replace(/^2\./, "1.")] = object;
                return map;
            }, {}) : {};

            var feeMap = {};
            var proposalFeeMap = {};
            function updateFeeMap(map, asset_id, opIndex, core_fees) {
                if (!map[asset_id]) map[asset_id] = { total: 0, ops: [] };
                if (map[asset_id].propIdx) map[asset_id].propIdx.push(opIndex);else map[asset_id].ops.push(opIndex);

                if (asset_id !== "1.3.0") {
                    map[asset_id].total += core_fees.length ? core_fees[opIndex].amount : core_fees.amount;
                }
                return map;
            }

            var _loop = function _loop(_i3) {
                var op = operations[_i3];
                var feeAssetId = op[1].fee.asset_id;

                if (isProposal(op)) {
                    feeMap = updateFeeMap(feeMap, feeAssetId, _i3, coreFees[_i3][0]);
                    if(op[1].proposed_ops)
                    op[1].proposed_ops.forEach(function (prop, y) {
                        var propFeeAsset = prop.op[1].fee.asset_id;
                        if (!proposalFeeMap[_i3]) proposalFeeMap[_i3] = {};
                        if (!proposalFeeMap[_i3][propFeeAsset]) proposalFeeMap[_i3][propFeeAsset] = {
                            total: 0,
                            ops: [_i3],
                            propIdx: []
                        };

                        proposalFeeMap[_i3] = updateFeeMap(proposalFeeMap[_i3], propFeeAsset, y, coreFees[_i3][1]);
                    });
                } else {
                    feeMap = updateFeeMap(feeMap, feeAssetId, _i3, coreFees[_i3]);
                }
            };

            for (var _i3 = 0; _i3 < operations.length; _i3++) {
                _loop(_i3);
            }

            /* Check fee pool balances for regular ops */
            function checkPoolBalance(map) {
                if (!Object.keys(map).length) return [];
                var final_fees = [];

                var _loop2 = function _loop2(asset) {
                    var feePool = feePoolMap[asset] ? parseInt(feePoolMap[asset].fee_pool, 10) : 0;
                    /* Fee pool balance insufficient, default to core*/
                    if (map[asset].total > feePool) {
                        map[asset].ops.forEach(function (opIndex) {
                            if (coreFees[opIndex].length === 2 && "propIdx" in map[asset]) {
                                /* Proposal op */
                                map[asset].propIdx.forEach(function (prop_idx) {
                                    final_fees[prop_idx] = coreFees[opIndex][1][prop_idx];
                                });
                            } else if (coreFees[opIndex].length === 2) {
                                final_fees[opIndex] = coreFees[opIndex][0];
                            } else {
                                final_fees[opIndex] = coreFees[opIndex];
                            }
                        });
                        /* Use the desired fee asset */
                    } else {
                        map[asset].ops.forEach(function (opIndex) {
                            if (coreFees[opIndex].length === 2 && "propIdx" in map[asset]) {
                                map[asset].propIdx.forEach(function (prop_idx) {
                                    final_fees[prop_idx] = proposalFeesByAsset[asset][prop_idx];
                                });
                            } else {
                                final_fees[opIndex] = feesByAsset[asset][opIndex];
                            }
                        });
                    }
                };

                for (var asset in map) {
                    _loop2(asset);
                }
                return final_fees;
            }

            var finalFees = checkPoolBalance(feeMap);

            var finalProposalFees = {};
            for (var _key in proposalFeeMap) {
                finalProposalFees[_key] = checkPoolBalance(proposalFeeMap[_key]);
            }

            var set_fee = function set_fee(operation, opIndex) {
                if (!operation.fee || operation.fee.amount === 0 || operation.fee.amount.toString && operation.fee.amount.toString() === "0" // Long
                ) {
                        if (removeDuplicates) {
                            var _op = _serializer.ops.operation.toObject(_this3.operations[opIndex]);
                            var originalIndex = getDuplicateOriginalIndex(_op, opIndex);
                            if (originalIndex >= 0) {
                                // it's a duplicate
                                operation.fee = finalFees[originalIndex];
                            } else {
                                operation.fee = finalFees[opIndex];
                            }
                        } else {
                            operation.fee = finalFees[opIndex];
                        }
                    }
                if (operation.proposed_ops) {
                    var result = [];
                    /*
                    * Loop over proposed_ops and assign fee asset ids as
                    * determined by the fee pool balance check. If the balance
                    * is sufficient the asset_id is kept, if not it defaults to
                    * "1.3.0"
                    */
                    for (var y = 0; y < operation.proposed_ops.length; y++) {
                        if(finalProposalFees[opIndex])
                        operation.proposed_ops[y].op[1].fee.asset_id = finalProposalFees[opIndex][y].asset_id;
                    }

                    return result;
                }
            };
            /* We apply the final fees the the operations */
            for (var _i4 = 0; _i4 < _this3.operations.length; _i4++) {
                set_fee(_this3.operations[_i4][1], _i4);
            }
        });
        //DEBUG console.log('... get_required_fees',operations,asset_id,flat_fees)
    };

    TransactionBuilder.prototype.get_potential_signatures = function get_potential_signatures() {
        var tr_object = _serializer.ops.signed_transaction.toObject(this);
        return Promise.all([_bcxjsWs.Apis.instance().db_api().exec("get_potential_signatures", [tr_object]), _bcxjsWs.Apis.instance().db_api().exec("get_potential_address_signatures", [tr_object])]).then(function (results) {
            return { pubkeys: results[0], addys: results[1] };
        });
    };

    TransactionBuilder.prototype.get_required_signatures = function get_required_signatures(available_keys) {
        if (!available_keys.length) {
            return Promise.resolve([]);
        }
        var tr_object = _serializer.ops.signed_transaction.toObject(this);
        // console.info('tr_object',tr_object);

        //DEBUG console.log('... tr_object',tr_object)
        return _bcxjsWs.Apis.instance().db_api().exec("get_required_signatures", [tr_object, available_keys]).then(function (required_public_keys) {
            //DEBUG console.log('... get_required_signatures',required_public_keys)
            return required_public_keys;
        });
    };

    TransactionBuilder.prototype.add_signer = function add_signer(private_key) {
        var public_key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : private_key.toPublicKey();

        (0, _assert2.default)(private_key.d, "required PrivateKey object");

        if (this.signed) {
            throw new Error("already signed");
        }
        if (!public_key.Q) {
            public_key = _ecc.PublicKey.fromPublicKeyString(public_key);
        }
        // prevent duplicates
        var spHex = private_key.toHex();
        for (var _iterator3 = this.signer_private_keys, _isArray3 = Array.isArray(_iterator3), _i5 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
            var _ref4;

            if (_isArray3) {
                if (_i5 >= _iterator3.length) break;
                _ref4 = _iterator3[_i5++];
            } else {
                _i5 = _iterator3.next();
                if (_i5.done) break;
                _ref4 = _i5.value;
            }

            var sp = _ref4;

            if (sp[0].toHex() === spHex) return;
        }
        this.signer_private_keys.push([private_key, public_key]);
    };

    TransactionBuilder.prototype.sign = function sign() {
        var chain_id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _bcxjsWs.Apis.instance().chain_id;
        if (!this.tr_buffer) {
            throw new Error("not finalized");
        }
        if (this.signed) {
            throw new Error("already signed");
        }

        if (!this.signer_private_keys.length) {
            throw new Error("Transaction was not signed. Do you have a private key? [no_signers]");
        }
        var end = this.signer_private_keys.length;
        for (var i = 0; 0 < end ? i < end : i > end; 0 < end ? i++ : i++) {
            var _signer_private_keys$ = this.signer_private_keys[i],
                private_key = _signer_private_keys$[0],
                public_key = _signer_private_keys$[1];
            var sig = _ecc.Signature.signBuffer(Buffer.concat([new Buffer(chain_id, "hex"), this.tr_buffer]), private_key, public_key);
            this.signatures.push(sig.toBuffer());
        }
        this.signer_private_keys = [];
        this.signed = true;
        return;
    };

    TransactionBuilder.prototype.serialize = function serialize() {
        return _serializer.ops.signed_transaction.toObject(this);
    };

    TransactionBuilder.prototype.toObject = function toObject() {
        return _serializer.ops.signed_transaction.toObject(this);
    };

    TransactionBuilder.prototype.broadcast = function broadcast(was_broadcast_callback) {
        var _this4 = this;

        if (this.tr_buffer) {
            return this._broadcast(was_broadcast_callback);
        } else {
            return this.finalize().then(function () {
                return _this4._broadcast(was_broadcast_callback);
            });
        }
    };

    return TransactionBuilder;
}();

var base_expiration_sec = function base_expiration_sec() {
    var head_block_sec = Math.ceil(getHeadBlockDate().getTime() / 1000);
    var now_sec = Math.ceil(Date.now() / 1000);
    // The head block time should be updated every 3 seconds.  If it isn't
    // then help the transaction to expire (use head_block_sec)
    if (now_sec - head_block_sec > 30) {
        return head_block_sec;
    }
    // If the user's clock is very far behind, use the head block time.
    return Math.max(now_sec, head_block_sec);
};

function _broadcast(was_broadcast_callback) {
    var _this5 = this;

    return new Promise(function (resolve, reject) {
        _this5.debug_time=new Date().getTime();
        if (!_this5.signed) {
            _this5.sign();
        }

        if (!_this5.tr_buffer) {
            throw new Error("not finalized");
        }
        if (!_this5.signatures.length) {
            throw new Error("not signed");
        }
        if (!_this5.operations.length) {
            throw new Error("no operations");
        }

        var tr_object = _serializer.ops.signed_transaction.toObject(_this5,1);
        // console.log('... broadcast_transaction_with_callback !!!')
        
        _bcxjsWs.Apis.instance().network_api().exec("broadcast_transaction_with_callback", [function (res) {
            return resolve(res);
        }, tr_object]).then(function () {
            //console.log('... broadcast success, waiting for callback')
            if (was_broadcast_callback) was_broadcast_callback();
            return;
        }).catch(function (error) {
            // console.log may be redundant for network errors, other errors could occur
            // console.log(error);
            var message = error.message;
            if (!message) {
                message = "";
            }
            error.messageDetail=message + "\n" + "" + " digest " + _ecc.hash.sha256(_this5.tr_buffer).toString("hex") + " transaction " + _this5.tr_buffer.toString("hex") + " " + JSON.stringify(tr_object);
            reject(new Error("@@"+JSON.stringify(error)+"@@"));
            return;
        });
        return;
    });
}

function getHeadBlockDate() {
    return timeStringToDate(head_block_time_string);
}

function timeStringToDate(time_string) {
    if (!time_string) return new Date("1970-01-01T00:00:00.000Z");
    if (!/Z$/.test(time_string))
        //does not end in Z
        // https://github.com/cryptonomex/graphene/issues/368
        time_string = time_string + "Z";
    return new Date(time_string);
}

exports.default = TransactionBuilder;
module.exports = exports["default"];
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),
/* 488 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _assert = __webpack_require__(45);

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
    Convert 12.34 with a precision of 3 into 12340

    @arg {number|string} number - Use strings for large numbers.  This may contain one decimal but no sign
    @arg {number} precision - number of implied decimal places (usually causes right zero padding)
    @return {string} -
*/

var NumberUtils = {
    toImpliedDecimal: function toImpliedDecimal(number, precision) {
        if (typeof number === "number") {
            (0, _assert2.default)(number <= 9007199254740991, "overflow");
            number = "" + number;
        } else if (number.toString) number = number.toString();

        (0, _assert2.default)(typeof number === "string", "number should be an actual number or string: " + (typeof number === "undefined" ? "undefined" : _typeof(number)));
        number = number.trim();
        (0, _assert2.default)(/^[0-9]*\.?[0-9]*$/.test(number), "Invalid decimal number " + number);

        var _number$split = number.split("."),
            _number$split$ = _number$split[0],
            whole = _number$split$ === undefined ? "" : _number$split$,
            _number$split$2 = _number$split[1],
            decimal = _number$split$2 === undefined ? "" : _number$split$2;

        var padding = precision - decimal.length;
        (0, _assert2.default)(padding >= 0, "Too many decimal digits in " + number + " to create an implied decimal of " + precision);

        for (var i = 0; i < padding; i++) {
            decimal += "0";
        }while (whole.charAt(0) === "0") {
            whole = whole.substring(1);
        }return whole + decimal;
    }
};

exports.default = NumberUtils;
module.exports = exports["default"];

/***/ }),
/* 489 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _secureRandom = __webpack_require__(380);

var _secureRandom2 = _interopRequireDefault(_secureRandom);

var _bytebuffer = __webpack_require__(130);

var _ecc = __webpack_require__(219);

var _serializer = __webpack_require__(386);

var _bcxjsWs = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var helper = {};

helper.unique_nonce_entropy = null;
helper.unique_nonce_uint64 = function () {
    var entropy = helper.unique_nonce_entropy = function () {

        if (helper.unique_nonce_entropy === null) {
            //console.log('... secureRandom.randomUint8Array(1)[0]',secureRandom.randomUint8Array(1)[0])
            return parseInt(_secureRandom2.default.randomUint8Array(1)[0]);
        } else {
            return ++helper.unique_nonce_entropy % 256;
        }
    }();
    var long = _bytebuffer.Long.fromNumber(Date.now());
    //console.log('unique_nonce_uint64 date\t',ByteBuffer.allocate(8).writeUint64(long).toHex(0))
    //console.log('unique_nonce_uint64 entropy\t',ByteBuffer.allocate(8).writeUint64(Long.fromNumber(entropy)).toHex(0))
    long = long.shiftLeft(8).or(_bytebuffer.Long.fromNumber(entropy));
    //console.log('unique_nonce_uint64 shift8\t',ByteBuffer.allocate(8).writeUint64(long).toHex(0))
    return long.toString();
};

/* Todo, set fees */
helper.to_json = function (tr) {
    var broadcast = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    return function (tr, broadcast) {
        var tr_object = _serializer.ops.signed_transaction.toObject(tr);
        if (broadcast) {
            var net = _bcxjsWs.Apis.instance().network_api();
            console.log('... tr_object', JSON.stringify(tr_object));
            return net.exec("broadcast_transaction", [tr_object]);
        } else {
            return tr_object;
        }
    }(tr, broadcast);
};

helper.signed_tr_json = function (tr, private_keys) {
    var tr_buffer = _serializer.ops.transaction.toBuffer(tr);
    tr = _serializer.ops.transaction.toObject(tr);
    tr.signatures = function () {
        var result = [];
        for (var i = 0; 0 < private_keys.length ? i < private_keys.length : i > private_keys.length; 0 < private_keys.length ? i++ : i++) {
            var private_key = private_keys[i];
            result.push(_ecc.Signature.signBuffer(tr_buffer, private_key).toHex());
        }
        return result;
    }();
    return tr;
};

helper.expire_in_min = function (min) {
    return Math.round(Date.now() / 1000) + min * 60;
};

helper.seconds_from_now = function (timeout_sec) {
    return Math.round(Date.now() / 1000) + timeout_sec;
};

/**
    Print to the console a JSON representation of any object in
    @graphene/serializer { types }
*/
helper.template = function (serializer_operation_type_name) {
    var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { use_default: true, annotate: true };

    var so = _serializer.ops[serializer_operation_type_name];
    if (!so) {
        throw new Error('unknown serializer_operation_type ' + serializer_operation_type_name);
    }
    return so.toObject(undefined, debug);
};

helper.new_operation = function (serializer_operation_type_name) {
    var so = _serializer.ops[serializer_operation_type_name];
    if (!so) {
        throw new Error('unknown serializer_operation_type ' + serializer_operation_type_name);
    }
    var object = so.toObject(undefined, { use_default: true, annotate: true });
    return so.fromObject(object);
};

helper.instance = function (ObjectId) {
    return ObjectId.substring("0.0.".length);
};

exports.default = helper;
module.exports = exports['default'];

/***/ }),
/* 490 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _PrivateKey = __webpack_require__(146);

var _PrivateKey2 = _interopRequireDefault(_PrivateKey);

var _KeyUtils = __webpack_require__(222);

var _KeyUtils2 = _interopRequireDefault(_KeyUtils);

var _state = __webpack_require__(491);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _keyCachePriv = {};
var _keyCachePub = {};

var AccountLogin = function () {
    function AccountLogin() {
        _classCallCheck(this, AccountLogin);

        var state = { loggedIn: false, roles: ["active", "owner", "memo"] };
        this.get = (0, _state.get)(state);
        this.set = (0, _state.set)(state);

        this.subs = {};
    }

    AccountLogin.prototype.addSubscription = function addSubscription(cb) {
        this.subs[cb] = cb;
    };

    AccountLogin.prototype.setRoles = function setRoles(roles) {
        this.set("roles", roles);
    };

    AccountLogin.prototype.generateKeys = function generateKeys(accountName, password, roles, prefix) {
        var start = new Date().getTime();
        if (!accountName || !password) {
            throw new Error("Account name or password required");
        }
        if (password.length < 12) {
            throw new Error("Password must have at least 12 characters");
        }

        var privKeys = {};
        var pubKeys = {};

        (roles || this.get("roles")).forEach(function (role) {
            var seed = accountName + role + password;
            var pkey = _keyCachePriv[seed] ? _keyCachePriv[seed] : _PrivateKey2.default.fromSeed(_KeyUtils2.default.normalize_brainKey(seed));
            _keyCachePriv[seed] = pkey;

            privKeys[role] = pkey;
            pubKeys[role] = _keyCachePub[seed] ? _keyCachePub[seed] : pkey.toPublicKey().toString(prefix);

            _keyCachePub[seed] = pubKeys[role];
        });

        return { privKeys: privKeys, pubKeys: pubKeys };
    };

    AccountLogin.prototype.checkKeys = function checkKeys(_ref) {
        var _this = this;

        var accountName = _ref.accountName,
            password = _ref.password,
            auths = _ref.auths;

        if (!accountName || !password || !auths) {
            throw new Error("checkKeys: Missing inputs");
        }
        var hasKey = false;

        var _loop = function _loop(role) {
            var _generateKeys = _this.generateKeys(accountName, password, [role]),
                privKeys = _generateKeys.privKeys,
                pubKeys = _generateKeys.pubKeys;

            auths[role].forEach(function (key) {
                if (key[0] === pubKeys[role]) {
                    hasKey = true;
                    _this.set(role, { priv: privKeys[role], pub: pubKeys[role] });
                }
            });
        };

        for (var role in auths) {
            _loop(role);
        };

        if (hasKey) {
            this.set("name", accountName);
        }

        this.set("loggedIn", hasKey);

        return hasKey;
    };

    AccountLogin.prototype.signTransaction = function signTransaction(tr) {
        var _this2 = this;

        var myKeys = {};
        var hasKey = false;

        this.get("roles").forEach(function (role) {
            var myKey = _this2.get(role);
            if (myKey) {
                hasKey = true;
                console.log("adding signer:", myKey.pub);
                tr.add_signer(myKey.priv, myKey.pub);
            }
        });

        if (!hasKey) {
            throw new Error("You do not have any private keys to sign this transaction");
        }
    };

    return AccountLogin;
}();

var accountLogin = new AccountLogin();

exports.default = accountLogin;
module.exports = exports["default"];

/***/ }),
/* 491 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
function get(state) {
    return function (key) {
        return state[key] || "";
    };
}

function set(state) {
    return function (key, value) {
        state[key] = value;
        return this;
    };
}

exports.get = get;
exports.set = set;

/***/ }),
/* 492 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * JavaScript Cookie v2.2.1
 * https://github.com/js-cookie/js-cookie
 *
 * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
 * Released under the MIT license
 */
;(function (factory) {
	var registeredInModuleLoader;
	if (true) {
		!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		registeredInModuleLoader = true;
	}
	if (true) {
		module.exports = factory();
		registeredInModuleLoader = true;
	}
	if (!registeredInModuleLoader) {
		var OldCookies = window.Cookies;
		var api = window.Cookies = factory();
		api.noConflict = function () {
			window.Cookies = OldCookies;
			return api;
		};
	}
}(function () {
	function extend () {
		var i = 0;
		var result = {};
		for (; i < arguments.length; i++) {
			var attributes = arguments[ i ];
			for (var key in attributes) {
				result[key] = attributes[key];
			}
		}
		return result;
	}

	function decode (s) {
		return s.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);
	}

	function init (converter) {
		function api() {}

		function set (key, value, attributes) {
			if (typeof document === 'undefined') {
				return;
			}

			attributes = extend({
				path: '/'
			}, api.defaults, attributes);

			if (typeof attributes.expires === 'number') {
				attributes.expires = new Date(new Date() * 1 + attributes.expires * 864e+5);
			}

			// We're using "expires" because "max-age" is not supported by IE
			attributes.expires = attributes.expires ? attributes.expires.toUTCString() : '';

			try {
				var result = JSON.stringify(value);
				if (/^[\{\[]/.test(result)) {
					value = result;
				}
			} catch (e) {}

			value = converter.write ?
				converter.write(value, key) :
				encodeURIComponent(String(value))
					.replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);

			key = encodeURIComponent(String(key))
				.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent)
				.replace(/[\(\)]/g, escape);

			var stringifiedAttributes = '';
			for (var attributeName in attributes) {
				if (!attributes[attributeName]) {
					continue;
				}
				stringifiedAttributes += '; ' + attributeName;
				if (attributes[attributeName] === true) {
					continue;
				}

				// Considers RFC 6265 section 5.2:
				// ...
				// 3.  If the remaining unparsed-attributes contains a %x3B (";")
				//     character:
				// Consume the characters of the unparsed-attributes up to,
				// not including, the first %x3B (";") character.
				// ...
				stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];
			}

			return (document.cookie = key + '=' + value + stringifiedAttributes);
		}

		function get (key, json) {
			if (typeof document === 'undefined') {
				return;
			}

			var jar = {};
			// To prevent the for loop in the first place assign an empty array
			// in case there are no cookies at all.
			var cookies = document.cookie ? document.cookie.split('; ') : [];
			var i = 0;

			for (; i < cookies.length; i++) {
				var parts = cookies[i].split('=');
				var cookie = parts.slice(1).join('=');

				if (!json && cookie.charAt(0) === '"') {
					cookie = cookie.slice(1, -1);
				}

				try {
					var name = decode(parts[0]);
					cookie = (converter.read || converter)(cookie, name) ||
						decode(cookie);

					if (json) {
						try {
							cookie = JSON.parse(cookie);
						} catch (e) {}
					}

					jar[name] = cookie;

					if (key === name) {
						break;
					}
				} catch (e) {}
			}

			return key ? jar[key] : jar;
		}

		api.set = set;
		api.get = function (key) {
			return get(key, false /* read as raw */);
		};
		api.getJSON = function (key) {
			return get(key, true /* read as json */);
		};
		api.remove = function (key, attributes) {
			set(key, '', extend(attributes, {
				expires: -1
			}));
		};

		api.defaults = {};

		api.withConverter = init;

		return api;
	}

	return init(function () {});
}));


/***/ }),
/* 493 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = __webpack_require__(3);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _bcxjsWs = __webpack_require__(8);

var _nodesManager = __webpack_require__(387);

var _nodesManager2 = _interopRequireDefault(_nodesManager);

var _mutations = __webpack_require__(14);

var types = _interopRequireWildcard(_mutations);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var nodesManager = void 0;
/**
 * Connects to bcxjs-ws with provided callback function
 * United Labs of BCTech.
 */
var connect = function _callee(_ref) {
  var _ref$statusCallback = _ref.statusCallback,
      statusCallback = _ref$statusCallback === undefined ? null : _ref$statusCallback,
      _ref$changeNodeUrl = _ref.changeNodeUrl,
      changeNodeUrl = _ref$changeNodeUrl === undefined ? "" : _ref$changeNodeUrl,
      store = _ref.store,
      _ref$refresh = _ref.refresh,
      refresh = _ref$refresh === undefined ? false : _ref$refresh;

  var _store$rootGetters$se, ws_node_list, select_ws_node, check_cached_nodes_data, url, isTestPing;

  return _regenerator2.default.async(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _store$rootGetters$se = store.rootGetters["setting/g_settingsAPIs"], ws_node_list = _store$rootGetters$se.ws_node_list, select_ws_node = _store$rootGetters$se.select_ws_node, check_cached_nodes_data = _store$rootGetters$se.check_cached_nodes_data;
          url = changeNodeUrl;
          isTestPing = false; //check if ping tested; 

          if (!(!nodesManager || refresh)) {
            _context.next = 8;
            break;
          }

          nodesManager = new _nodesManager2.default({
            nodes: ws_node_list,
            defaultNode: changeNodeUrl
          });
          isTestPing = true;
          _context.next = 8;
          return _regenerator2.default.awrap(nodesManager.testNodesPings());

        case 8:
          if (!url) {
            _context.next = 12;
            break;
          }

          //if connected url is selected address, then get another address
          if (select_ws_node == url) url = nodesManager.getAnotherNodeUrl(url) || url;
          _context.next = 17;
          break;

        case 12:
          //if connected url is null or empty, then connect the fastest one
          nodesManager._selectedNodeUrl = "";

          if (isTestPing) {
            _context.next = 16;
            break;
          }

          _context.next = 16;
          return _regenerator2.default.awrap(nodesManager.testNodesPings());

        case 16:
          url = nodesManager.getInitialNodeUrl();

        case 17:

          if (url) {
            console.log('Connecting to node : ', url);
            store.commit(types.RPC_STATUS_UPDATE, { status: 'connecting', url: url });
            _bcxjsWs.Apis.instance(url, true, 4000, undefined, function () {
              statusCallback && statusCallback('closed');
            }).init_promise.then(function () {
              _bcxjsWs.Apis.setAutoReconnect(false);
              statusCallback && _bcxjsWs.Apis.setRpcConnectionStatusCallback(statusCallback);
              statusCallback && statusCallback('realopen', url);
            }).catch(function (error) {
              statusCallback && statusCallback('error', url);
            });
          } else {
            statusCallback && statusCallback('error', url);
          }

        case 18:
        case 'end':
          return _context.stop();
      }
    }
  }, null, undefined);
};

var testNodesPings = function testNodesPings() {
  var refresh = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

  if (!nodesManager) {
    return;
  }
  if (refresh) {
    return nodesManager.testNodesPings();
  }
  return nodesManager._nodes;
};

var addAPINode = function _callee2(node) {
  return _regenerator2.default.async(function _callee2$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          nodesManager.addAPINode(node);

          if (!nodesManager) {
            _context2.next = 5;
            break;
          }

          _context2.next = 4;
          return _regenerator2.default.awrap(nodesManager.testNodesPings());

        case 4:
          return _context2.abrupt('return', _context2.sent);

        case 5:
        case 'end':
          return _context2.stop();
      }
    }
  }, null, undefined);
};

var deleteAPINode = function deleteAPINode(url) {
  nodesManager.deleteAPINode(url);
};

var setAPINode = function setAPINode(nodes) {
  if (nodesManager) return nodesManager.setAPINode(nodes);
};

var disconnect = function disconnect() {
  _bcxjsWs.Apis.setRpcConnectionStatusCallback(null);
  return _bcxjsWs.Apis.close();
};

exports.default = {
  connect: connect, disconnect: disconnect, testNodesPings: testNodesPings, addAPINode: addAPINode, deleteAPINode: deleteAPINode, setAPINode: setAPINode
};

/***/ }),
/* 494 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer, process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = __webpack_require__(18);

var _stringify2 = _interopRequireDefault(_stringify);

var _extends2 = __webpack_require__(76);

var _extends3 = _interopRequireDefault(_extends2);

var _keys = __webpack_require__(24);

var _keys2 = _interopRequireDefault(_keys);

var _promise = __webpack_require__(4);

var _promise2 = _interopRequireDefault(_promise);

var _getIterator2 = __webpack_require__(52);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _regenerator = __webpack_require__(3);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _from = __webpack_require__(141);

var _from2 = _interopRequireDefault(_from);

var _bcxjsCores = __webpack_require__(7);

var _bcxjsWs = __webpack_require__(8);

var _account = __webpack_require__(388);

var _utils = __webpack_require__(96);

var _helper = __webpack_require__(34);

var _helper2 = _interopRequireDefault(_helper);

var _account_utils = __webpack_require__(495);

var _account_utils2 = _interopRequireDefault(_account_utils);

var _api = __webpack_require__(10);

var _api2 = _interopRequireDefault(_api);

var _immutable = __webpack_require__(23);

var _immutable2 = _interopRequireDefault(_immutable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// 2020-03-05  xulin_add  ç­¾å
var signString = function _callee(transaction, store, signContent) {
  var pubkey, private_key, signBuffer, signArray, signArr, signUint8Array, signre;
  return _regenerator2.default.async(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          pubkey = transaction.account.active.key_auths[0][0];
          _context.next = 3;
          return _regenerator2.default.awrap(store.dispatch("WalletDb/getPrivateKey", pubkey, { root: true }));

        case 3:
          private_key = _context.sent;
          signBuffer = new Buffer(signContent);
          signArray = (0, _from2.default)(signBuffer);

          signArray.unshift(signContent.length);
          signArr = new ArrayBuffer(signArray.length);
          signUint8Array = new Uint8Array(signArr);

          signUint8Array.set(signArray, 0);
          signre = _bcxjsCores.Signature.signBuffer(signUint8Array, private_key);
          return _context.abrupt('return', {
            code: 1,
            data: {
              message: signContent,
              signature: signre.toHex()
            }
          });

        case 12:
        case 'end':
          return _context.stop();
      }
    }
  }, null, undefined);
};

// 2020-03-05  xulin_add  è§£ç­¾
var checkingSignString = function _callee2(checkingSignParams) {
  var checkingSignContent, signContent, signre, signBuffer, signArray, signArr, signUint8Array, signature_obj, mypubkey, userId;
  return _regenerator2.default.async(function _callee2$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          checkingSignContent = checkingSignParams.checkingSignContent, signContent = checkingSignParams.signContent;
          // è§£ç­¾

          signre = '';
          _context2.prev = 2;

          signre = _bcxjsCores.Signature.fromHex(checkingSignContent);
          _context2.next = 9;
          break;

        case 6:
          _context2.prev = 6;
          _context2.t0 = _context2['catch'](2);
          return _context2.abrupt('return', {
            success: false,
            error: "Incorrect information",
            code: 0
          });

        case 9:
          signBuffer = new Buffer(signContent);
          signArray = (0, _from2.default)(signBuffer);

          signArray.unshift(signContent.length);
          signArr = new ArrayBuffer(signArray.length);
          signUint8Array = new Uint8Array(signArr);

          signUint8Array.set(signArray, 0);
          signature_obj = new _bcxjsCores.Signature(signre.r, signre.s, signre.i);
          mypubkey = signature_obj.recoverPublicKeyFromBuffer(signUint8Array);
          _context2.next = 19;
          return _regenerator2.default.awrap(_api2.default.Account.getAccountIdByOwnerPubkey(mypubkey.toPublicKeyString()));

        case 19:
          userId = _context2.sent;

          if (!(userId.length == 0)) {
            _context2.next = 24;
            break;
          }

          return _context2.abrupt('return', {
            success: false,
            error: "Incorrect information",
            code: 0
          });

        case 24:
          return _context2.abrupt('return', { success: true, data: userId, code: 1 });

        case 25:
        case 'end':
          return _context2.stop();
      }
    }
  }, null, undefined, [[2, 6]]);
};

var signTransaction = function _callee3(transaction, store) {
  var _ref, pubkeys, addys, my_pubkeys, required_pubkeys, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, pubkey_string, private_key, app_keys;

  return _regenerator2.default.async(function _callee3$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return _regenerator2.default.awrap(transaction.get_potential_signatures());

        case 2:
          _ref = _context3.sent;
          pubkeys = _ref.pubkeys;
          addys = _ref.addys;
          my_pubkeys = store.rootGetters["PrivateKeyStore/getPubkeys_having_PrivateKey"](pubkeys, addys);
          _context3.next = 8;
          return _regenerator2.default.awrap(transaction.get_required_signatures(my_pubkeys));

        case 8:
          required_pubkeys = _context3.sent;
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          _context3.prev = 12;
          _iterator = (0, _getIterator3.default)(required_pubkeys);

        case 14:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            _context3.next = 25;
            break;
          }

          pubkey_string = _step.value;
          _context3.next = 18;
          return _regenerator2.default.awrap(store.dispatch("WalletDb/getPrivateKey", pubkey_string, { root: true }));

        case 18:
          private_key = _context3.sent;

          if (private_key) {
            _context3.next = 21;
            break;
          }

          throw new Error("Missing signing key for " + pubkey_string);

        case 21:
          transaction.add_signer(private_key, pubkey_string);

        case 22:
          _iteratorNormalCompletion = true;
          _context3.next = 14;
          break;

        case 25:
          _context3.next = 31;
          break;

        case 27:
          _context3.prev = 27;
          _context3.t0 = _context3['catch'](12);
          _didIteratorError = true;
          _iteratorError = _context3.t0;

        case 31:
          _context3.prev = 31;
          _context3.prev = 32;

          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }

        case 34:
          _context3.prev = 34;

          if (!_didIteratorError) {
            _context3.next = 37;
            break;
          }

          throw _iteratorError;

        case 37:
          return _context3.finish(34);

        case 38:
          return _context3.finish(31);

        case 39:
          // console.info("transaction",transaction);
          //Contract authentication
          try {
            app_keys = store.rootGetters["PrivateKeyStore/app_keys"];

            if (app_keys.length && transaction.operations[0][0] == 35) //app_keysåªä½œç”¨äºŽåˆçº¦è°ƒç”¨
              app_keys.forEach(function (app_key) {
                app_key = _bcxjsCores.PrivateKey.fromWif(app_key);
                transaction.add_signer(app_key, app_key.toPublicKey().toPublicKeyString());
              });
          } catch (e) {}

        case 40:
        case 'end':
          return _context3.stop();
      }
    }
  }, null, undefined, [[12, 27, 31, 39], [32,, 34, 38]]);
};

var buildOperationsAndBroadcast = function _callee4(transaction, store, opObjects) {
  var res;
  return _regenerator2.default.async(function _callee4$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          _context4.next = 2;
          return _regenerator2.default.awrap(signTransaction(transaction, store));

        case 2:
          _context4.next = 4;
          return _regenerator2.default.awrap(transaction.update_head_block());

        case 4:
          _context4.next = 6;
          return _regenerator2.default.awrap(transaction.broadcast());

        case 6:
          res = _context4.sent;
          return _context4.abrupt('return', res);

        case 8:
        case 'end':
          return _context4.stop();
      }
    }
  }, null, undefined);
};

var process_transaction = function process_transaction(transaction, store, opObjects) {
  return new _promise2.default(function _callee5(resolve) {
    var broadcastTimeout, transactionResData, _error;

    return _regenerator2.default.async(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            broadcastTimeout = setTimeout(function () {
              resolve({ success: false, error: { message: 'Expiry of the transaction' }, code: 119 });
            }, _bcxjsWs.ChainConfig.expire_in_secs * 2000);
            _context5.prev = 1;
            _context5.next = 4;
            return _regenerator2.default.awrap(buildOperationsAndBroadcast(transaction, store, opObjects));

          case 4:
            transactionResData = _context5.sent;

            clearTimeout(broadcastTimeout);
            resolve({ success: true, data: transactionResData, code: 1 });

            _context5.next = 15;
            break;

          case 9:
            _context5.prev = 9;
            _context5.t0 = _context5['catch'](1);
            _error = {
              message: _context5.t0
            };

            try {
              _context5.t0 = _context5.t0.message.match(/@@.*@@/)[0].replace(/@@/g, "");
              _error = JSON.parse(_context5.t0);
              // if(_error.message.indexOf(' -delta: Insufficient Balance: ')>=0){
              //   let {a,b,r}=_error.data.stack[0].data;
              //   _error.message="Insufficient Balance for the fee of "+r+;//balance after current operation: "+b+",
              // }
            } catch (e) {
              _error = {
                message: _context5.t0.message
              };
            }
            clearTimeout(broadcastTimeout);
            resolve({ success: false, error: _error, code: 0 });

          case 15:
          case 'end':
            return _context5.stop();
        }
      }
    }, null, undefined, [[1, 9]]);
  });
};

var transactionOpWorker = function _callee6(fromId, operations, fromAccount, propose_options, store) {
  var opObjects, keys, aes_private, _passwordKey, app_keys, core_asset, $passwordKey, getPrivateKeyPromises, privateKeys;

  return _regenerator2.default.async(function _callee6$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          if (!process.browser) {
            _context6.next = 26;
            break;
          }

          _context6.next = 3;
          return _regenerator2.default.awrap(buildOPObjects(operations, fromId, fromAccount, store));

        case 3:
          opObjects = _context6.sent;

          if (!(opObjects.success == false)) {
            _context6.next = 6;
            break;
          }

          return _context6.abrupt('return', opObjects);

        case 6:
          keys = store.rootGetters["PrivateKeyStore/keys"];
          aes_private = store.rootGetters["WalletDb/aes_private"];
          _passwordKey = store.rootGetters["WalletDb/_passwordKey"];
          app_keys = store.rootGetters["PrivateKeyStore/app_keys"];
          _context6.next = 12;
          return _regenerator2.default.awrap(_api2.default.Assets.fetch(["1.3.0"], true));

        case 12:
          core_asset = _context6.sent;
          ;

          $passwordKey = {};

          if (!_passwordKey) {
            _context6.next = 19;
            break;
          }

          (0, _keys2.default)(_passwordKey).forEach(function (pubkeyStr) {
            $passwordKey[pubkeyStr] = _passwordKey[pubkeyStr].toWif();
          });
          _context6.next = 25;
          break;

        case 19:
          getPrivateKeyPromises = [];

          (0, _keys2.default)(keys).forEach(function (pubkeyStr) {
            getPrivateKeyPromises.push(store.dispatch("WalletDb/getPrivateKey", pubkeyStr, { root: true }));
          });

          _context6.next = 23;
          return _regenerator2.default.awrap(_promise2.default.all(getPrivateKeyPromises));

        case 23:
          privateKeys = _context6.sent;

          privateKeys.forEach(function (key) {
            $passwordKey[key.toPublicKey().toString()] = key.toWif();
          });

        case 25:
          return _context6.abrupt('return', new _promise2.default(function (resolve) {
            var transactionWorker = __webpack_require__(513);
            var worker = new transactionWorker();
            // console.info("opObjects",opObjects);
            worker.postMessage({
              opObjects: opObjects,
              propose_options: propose_options,
              core_asset: core_asset,
              onlyGetOPFee: store.rootGetters["transactions/onlyGetOPFee"],
              url: store.rootGetters["setting/SELECT_WS_NODE_URL"],
              keys: keys,
              aes_private: aes_private,
              _passwordKey: $passwordKey,
              app_keys: app_keys,
              networks: store.rootGetters["setting/networks"],
              fromId: fromId
            });
            worker.onmessage = function (event) {
              var res = event.data;
              resolve(res);
            };
          }));

        case 26:
        case 'end':
          return _context6.stop();
      }
    }
  }, null, undefined);
};

// 2020-05-13 xulin add åŠ å¯†memo
var oneMomeOp = function _callee7(fromId, operations, fromAccount) {
  var proposeAccountId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
  var store = arguments[4];
  var opObjects;
  return _regenerator2.default.async(function _callee7$(_context7) {
    while (1) {
      switch (_context7.prev = _context7.next) {
        case 0:
          _context7.next = 2;
          return _regenerator2.default.awrap(buildOPObjects(operations, proposeAccountId || fromId, fromAccount, store));

        case 2:
          opObjects = _context7.sent;

          opObjects.success = true;
          return _context7.abrupt('return', opObjects);

        case 5:
        case 'end':
          return _context7.stop();
      }
    }
  }, null, undefined);
};

var transactionOp = function _callee8(fromId, operations, fromAccount) {
  var proposeAccountId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
  var store = arguments[4];
  var opObjects, transaction, propose_options;
  return _regenerator2.default.async(function _callee8$(_context8) {
    while (1) {
      switch (_context8.prev = _context8.next) {
        case 0:
          _context8.next = 2;
          return _regenerator2.default.awrap(buildOPObjects(operations, proposeAccountId || fromId, fromAccount, store));

        case 2:
          opObjects = _context8.sent;

          if (!(opObjects.code && opObjects.code != 1)) {
            _context8.next = 5;
            break;
          }

          return _context8.abrupt('return', opObjects);

        case 5:
          transaction = new _bcxjsCores.TransactionBuilder();
          // console.info("opObjects",opObjects);

          opObjects.forEach(function (op) {
            transaction.add_type_operation(op.type, op.opObject);
          });
          // let {crontab}=store.rootState.crontab;

          // if(crontab){
          //   await transaction.set_required_fees();
          //   await  transaction.update_head_block();
          //   let {startTime,executeInterval,executeTimes}=crontab;

          //   if(startTime==undefined||executeInterval==undefined||executeTimes==undefined){
          //     return {code:101,message:"Crontab parameter is missing"};
          //   }
          //   startTime=parseInt(startTime);
          //   executeInterval=parseInt(executeInterval);
          //   executeTimes=parseInt(executeTimes);
          //   if(isNaN(startTime)||isNaN(executeInterval)||isNaN(executeTimes)){
          //     return {code:1011,message:"Parameter error"};
          //   }

          //   if(startTime<=0||executeInterval<=0||executeTimes<=0){
          //       return {code:176,message:"Crontab must have parameters greater than 0"}
          //   }

          //   let res=await Apis.instance().db_api().exec("get_objects", [["2.1.0"]]);
          //   let now_time=new Date(res[0].time+"Z").getTime();
          //   let crontab_options={
          //     crontab_creator:fromId,
          //     start_time:Math.floor((now_time+startTime)/1000),//+Number(startTime),
          //     execute_interval:executeInterval,
          //     scheduled_execute_times:executeTimes
          //   }
          //   transaction.crontab(crontab_options)   
          // }

          if (!proposeAccountId) {
            _context8.next = 12;
            break;
          }

          _context8.next = 10;
          return _regenerator2.default.awrap(transaction.update_head_block());

        case 10:
          propose_options = {
            fee_paying_account: fromId
          };

          transaction.propose(propose_options);

        case 12:
          return _context8.abrupt('return', process_transaction(transaction, store, opObjects));

        case 13:
        case 'end':
          return _context8.stop();
      }
    }
  }, null, undefined);
};

var buildOPObjects = function _callee9(operations, fromId, fromAccount, store) {
  var opObjects, opObject, opItem, i, opParams, _opParams$asset_id, asset_id, _opParams$fee_asset_i, fee_asset_id, assetObj, name, data, authority, contractId, functionName, valueList, runTime, pending_orders_fee, price, _opParams$priceAssetI, priceAssetId, price_amount_res, _opItem, op_type, to, _opParams$amount, amount, memo, isEncryption, toAccount, amount_res, memo_key, memo_from_privkey;

  return _regenerator2.default.async(function _callee9$(_context9) {
    while (1) {
      switch (_context9.prev = _context9.next) {
        case 0:
          opObjects = [];
          opObject = void 0, opItem = void 0;
          i = 0;

        case 3:
          if (!(i < operations.length)) {
            _context9.next = 104;
            break;
          }

          opObject = null;
          opItem = operations[i];
          _context9.prev = 6;
          opParams = opItem.params;
          _opParams$asset_id = opParams.asset_id, asset_id = _opParams$asset_id === undefined ? "1.3.0" : _opParams$asset_id, _opParams$fee_asset_i = opParams.fee_asset_id, fee_asset_id = _opParams$fee_asset_i === undefined ? "1.3.0" : _opParams$fee_asset_i;
          _context9.next = 11;
          return _regenerator2.default.awrap(_api2.default.Assets.fetch_asset_one(asset_id));

        case 11:
          assetObj = _context9.sent;

          if (!(assetObj.code != 1)) {
            _context9.next = 14;
            break;
          }

          return _context9.abrupt('return', assetObj);

        case 14:
          assetObj = assetObj.data;
          _context9.t0 = opItem.type;
          _context9.next = _context9.t0 === "account_update" ? 18 : _context9.t0 === "contract_create" ? 20 : _context9.t0 === "revise_contract" ? 23 : _context9.t0 === "call_contract_function" ? 25 : _context9.t0 === "create_nh_asset_order" ? 28 : _context9.t0 === "limit_order_cancel" ? 43 : _context9.t0 === "vesting_balance_withdraw" ? 45 : 47;
          break;

        case 18:
          if ("action" in opParams) {
            opObject = getUpdateAccountObject(opParams, fromAccount.account);
          } else {
            opObject = opParams.updateObject;
          }
          return _context9.abrupt('break', 47);

        case 20:
          name = opParams.name, data = opParams.data, authority = opParams.authority;

          opObject = {
            owner: fromId,
            name: name,
            data: data,
            contract_authority: authority,
            extensions: []
          };
          return _context9.abrupt('break', 47);

        case 23:
          opObject = (0, _extends3.default)({
            reviser: fromId
          }, opParams, {
            extensions: []
          });
          return _context9.abrupt('break', 47);

        case 25:
          contractId = opParams.contractId, functionName = opParams.functionName, valueList = opParams.valueList, runTime = opParams.runTime;

          opObject = {
            caller: fromId,
            contract_id: contractId,
            function_name: functionName,
            value_list: valueList,
            extensions: []
          };
          return _context9.abrupt('break', 47);

        case 28:
          pending_orders_fee = opParams.pending_orders_fee, price = opParams.price, _opParams$priceAssetI = opParams.priceAssetId, priceAssetId = _opParams$priceAssetI === undefined ? "1.3.0" : _opParams$priceAssetI;
          _context9.next = 31;
          return _regenerator2.default.awrap(_helper2.default.toOpAmount(pending_orders_fee, assetObj));

        case 31:
          pending_orders_fee = _context9.sent;

          if (pending_orders_fee.success) {
            _context9.next = 34;
            break;
          }

          return _context9.abrupt('return', pending_orders_fee);

        case 34:
          opParams.pending_orders_fee = pending_orders_fee.data;

          _context9.next = 37;
          return _regenerator2.default.awrap(_helper2.default.toOpAmount(price, priceAssetId));

        case 37:
          price_amount_res = _context9.sent;

          if (price_amount_res.success) {
            _context9.next = 40;
            break;
          }

          return _context9.abrupt('return', price_amount_res);

        case 40:
          opParams.price = price_amount_res.data;

          opObject = (0, _extends3.default)({
            seller: fromId
          }, opParams);
          return _context9.abrupt('break', 47);

        case 43:
          opObject = {
            fee_paying_account: fromId,
            order: opParams.orderId
          };
          return _context9.abrupt('break', 47);

        case 45:
          opObject = (0, _extends3.default)({
            owner: fromId
          }, opParams);
          return _context9.abrupt('break', 47);

        case 47:
          _opItem = opItem, op_type = _opItem.op_type;

          if (!(typeof op_type != "undefined")) {
            _context9.next = 95;
            break;
          }

          if (!(op_type >= 37 && op_type <= 45 && op_type != 43)) {
            _context9.next = 62;
            break;
          }

          if ("asset_id" in opParams) opParams.asset_id = assetObj.symbol;

          opObject = opParams;
          _context9.t1 = op_type;
          _context9.next = _context9.t1 === 42 ? 55 : _context9.t1 === 39 ? 57 : 59;
          break;

        case 55:
          opObject.from = fromId;
          return _context9.abrupt('break', 60);

        case 57:
          opObject.related_account = fromId;
          return _context9.abrupt('break', 60);

        case 59:
          opObject.fee_paying_account = fromId;

        case 60:
          _context9.next = 95;
          break;

        case 62:
          if (!(op_type == 0 || op_type == 13)) {
            _context9.next = 94;
            break;
          }

          to = opParams.to, _opParams$amount = opParams.amount, amount = _opParams$amount === undefined ? 0 : _opParams$amount, memo = opParams.memo, isEncryption = opParams.isEncryption;
          _context9.next = 66;
          return _regenerator2.default.awrap((0, _account.getUser)(to));

        case 66:
          toAccount = _context9.sent;

          if (toAccount.success) {
            _context9.next = 69;
            break;
          }

          return _context9.abrupt('return', { success: false, error: 'Account receivable does not exist', code: 116 });

        case 69:
          _context9.next = 71;
          return _regenerator2.default.awrap(_helper2.default.toOpAmount(amount, assetObj));

        case 71:
          amount_res = _context9.sent;

          if (amount_res.success) {
            _context9.next = 74;
            break;
          }

          return _context9.abrupt('return', amount_res);

        case 74:
          amount = amount_res.data;

          opObject = {};
          if (op_type == 0) {
            opObject.from = fromId;
            opObject.to = toAccount.data.account.id;
            opObject.amount = amount;
          } else if (op_type == 13) {
            opObject.issuer = fromId;
            opObject.issue_to_account = toAccount.data.account.id;
            opObject.asset_to_issue = amount;
          }

          if (!memo) {
            _context9.next = 92;
            break;
          }

          if (!isEncryption) {
            _context9.next = 84;
            break;
          }

          memo_key = toAccount.data.account.options.memo_key;
          _context9.next = 82;
          return _regenerator2.default.awrap(store.dispatch("WalletDb/getPrivateKey", fromAccount.account.options.memo_key, { root: true }));

        case 82:
          memo_from_privkey = _context9.sent;

          memo = (0, _utils.encryptMemo)(new Buffer(memo, "utf-8"), memo_from_privkey, memo_key);

        case 84:
          memo.message = memo.message.toString("hex");
          _context9.prev = 85;
          return _context9.abrupt('return', {
            code: 1,
            success: false,
            data: {
              memo: memo
            }
          });

        case 89:
          _context9.prev = 89;
          _context9.t2 = _context9['catch'](85);
          return _context9.abrupt('return', { success: false, error: 'Encrypt memo failed', code: 118 });

        case 92:
          _context9.next = 95;
          break;

        case 94:
          if (!opObject) {
            opObject = opParams;
          }

        case 95:

          opObjects.push({
            type: opItem.type,
            opObject: opObject
          });
          _context9.next = 101;
          break;

        case 98:
          _context9.prev = 98;
          _context9.t3 = _context9['catch'](6);
          return _context9.abrupt('return', {
            success: false,
            error: _context9.t3.message,
            code: 0
          });

        case 101:
          i++;
          _context9.next = 3;
          break;

        case 104:
          return _context9.abrupt('return', opObjects);

        case 105:
        case 'end':
          return _context9.stop();
      }
    }
  }, null, undefined, [[6, 98], [85, 89]]);
};

var getUpdateAccountObject = function getUpdateAccountObject(params, fromAccount) {
  var updated_account = fromAccount;
  var updateObject = { account: updated_account.id };
  var new_options = JSON.parse((0, _stringify2.default)(updated_account.options));

  var action = params.action,
      activePubkey = params.activePubkey,
      ownerPubkey = params.ownerPubkey;

  if (action == "changePassword") {
    var active = JSON.parse((0, _stringify2.default)(updated_account.active));
    var owner = JSON.parse((0, _stringify2.default)(updated_account.owner));
    active.key_auths[0] = [activePubkey, 1];
    owner.key_auths[0] = [ownerPubkey, 1];

    updateObject.active = active;
    updateObject.owner = owner;
    new_options.memo_key = activePubkey;
  }
  updateObject.new_options = new_options;
  return updateObject;
};

exports.default = { oneMomeOp: oneMomeOp, transactionOp: transactionOp, transactionOpWorker: transactionOpWorker, signString: signString, checkingSignString: checkingSignString };
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer, __webpack_require__(9)))

/***/ }),
/* 495 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _promise = __webpack_require__(4);

var _promise2 = _interopRequireDefault(_promise);

var _regenerator = __webpack_require__(3);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _classCallCheck2 = __webpack_require__(11);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(15);

var _createClass3 = _interopRequireDefault(_createClass2);

var _bcxjsCores = __webpack_require__(7);

var _utils = __webpack_require__(59);

var _utils2 = _interopRequireDefault(_utils);

var _trxHelper = __webpack_require__(512);

var _api = __webpack_require__(10);

var _api2 = _interopRequireDefault(_api);

var _immutable = __webpack_require__(23);

var _immutable2 = _interopRequireDefault(_immutable);

var _bcxjsWs = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// import counterpart from "counterpart";
var AccountUtils = function () {
    function AccountUtils() {
        (0, _classCallCheck3.default)(this, AccountUtils);
    }

    (0, _createClass3.default)(AccountUtils, null, [{
        key: "checkFeePool",

        /**
         *  takes asset as immutable object or id, fee as integer amount
         *  @return undefined if asset is undefined
         *  @return false if fee pool has insufficient balance
         *  @return true if the fee pool has sufficient balance
         */
        value: function checkFeePool(asset, fee) {
            var dynamicObject, feePool;
            return _regenerator2.default.async(function checkFeePool$(_context) {
                while (1) {
                    switch (_context.prev = _context.next) {
                        case 0:
                            asset = asset.toJS ? asset : _bcxjsCores.ChainStore.getAsset(asset);

                            if (asset) {
                                _context.next = 3;
                                break;
                            }

                            return _context.abrupt("return", undefined);

                        case 3:
                            dynamicObject = _bcxjsCores.ChainStore.getObject(asset.get("dynamic_asset_data_id"));

                            if (dynamicObject) {
                                _context.next = 9;
                                break;
                            }

                            _context.next = 7;
                            return _regenerator2.default.awrap(_bcxjsWs.Apis.instance().db_api().exec('get_objects', [[asset.get("dynamic_asset_data_id")]]));

                        case 7:
                            dynamicObject = _context.sent;

                            if (dynamicObject && dynamicObject[0]) {
                                dynamicObject = dynamicObject[0];
                            }

                        case 9:
                            if (dynamicObject) {
                                _context.next = 11;
                                break;
                            }

                            return _context.abrupt("return", undefined);

                        case 11:
                            feePool = parseInt(dynamicObject.toJS ? dynamicObject.get("fee_pool") : dynamicObject.fee_pool, 10);
                            return _context.abrupt("return", feePool >= fee);

                        case 13:
                        case "end":
                            return _context.stop();
                    }
                }
            }, null, this);
        }
    }, {
        key: "getPossibleFees",
        value: function getPossibleFees(account, operation) {
            var _this = this;

            var core, assets, fees, globalObject, fee, accountBalances;
            return _regenerator2.default.async(function getPossibleFees$(_context3) {
                while (1) {
                    switch (_context3.prev = _context3.next) {
                        case 0:
                            _context3.t0 = _immutable2.default;
                            _context3.next = 3;
                            return _regenerator2.default.awrap(_api2.default.Assets.fetch(["1.3.0"], true));

                        case 3:
                            _context3.t1 = _context3.sent;
                            core = _context3.t0.fromJS.call(_context3.t0, _context3.t1);

                            account = !account || account.toJS ? account : _bcxjsCores.ChainStore.getAccount(account);

                            if (!(!account || !core)) {
                                _context3.next = 8;
                                break;
                            }

                            return _context3.abrupt("return", { assets: ["1.3.0"], fees: { "1.3.0": 0 } });

                        case 8:
                            assets = [], fees = {};
                            globalObject = _bcxjsCores.ChainStore.getObject("2.0.0");
                            fee = (0, _trxHelper.estimateFee)(operation, null, globalObject);
                            accountBalances = account.get("balances");

                            if (accountBalances) {
                                _context3.next = 14;
                                break;
                            }

                            return _context3.abrupt("return", { assets: ["1.3.0"], fees: { "1.3.0": 0 } });

                        case 14:
                            _context3.next = 16;
                            return _regenerator2.default.awrap(_promise2.default.all(accountBalances.toArray().map(function _callee(balanceID) {
                                var assetID, balanceObject, balance, hasBalance, eqFee, asset, price;
                                return _regenerator2.default.async(function _callee$(_context2) {
                                    while (1) {
                                        switch (_context2.prev = _context2.next) {
                                            case 0:
                                                //balanceID
                                                assetID = balanceID.get("asset_type");
                                                balanceObject = balanceID; //ChainStore.getObject(balanceID);

                                                balance = balanceObject ? parseInt(balanceObject.get("balance"), 10) : 0;
                                                hasBalance = false, eqFee = void 0;

                                                if (!(assetID === "1.3.0" && balance >= fee)) {
                                                    _context2.next = 8;
                                                    break;
                                                }

                                                hasBalance = true;
                                                _context2.next = 24;
                                                break;

                                            case 8:
                                                if (!balance) {
                                                    _context2.next = 24;
                                                    break;
                                                }

                                                _context2.next = 11;
                                                return _regenerator2.default.awrap(_api2.default.Assets.fetch([assetID], true));

                                            case 11:
                                                asset = _context2.sent;

                                                if (!asset) {
                                                    _context2.next = 24;
                                                    break;
                                                }

                                                asset = _immutable2.default.fromJS(asset);
                                                price = _utils2.default.convertPrice(core, asset, null, asset.get("id"));

                                                eqFee = parseInt(_utils2.default.convertValue(price, fee, core, asset), 10);
                                                if (parseInt(eqFee, 10) !== eqFee) {
                                                    eqFee += 1; // Add 1 to round up;
                                                }
                                                _context2.t0 = balance >= eqFee;

                                                if (!_context2.t0) {
                                                    _context2.next = 22;
                                                    break;
                                                }

                                                _context2.next = 21;
                                                return _regenerator2.default.awrap(_this.checkFeePool(asset, fee));

                                            case 21:
                                                _context2.t0 = _context2.sent;

                                            case 22:
                                                if (!_context2.t0) {
                                                    _context2.next = 24;
                                                    break;
                                                }

                                                hasBalance = true;

                                            case 24:

                                                if (hasBalance) {
                                                    assets.push(assetID);
                                                    fees[assetID] = eqFee ? eqFee : fee;
                                                }

                                            case 25:
                                            case "end":
                                                return _context2.stop();
                                        }
                                    }
                                }, null, _this);
                            })));

                        case 16:
                            return _context3.abrupt("return", { assets: assets, fees: fees });

                        case 17:
                        case "end":
                            return _context3.stop();
                    }
                }
            }, null, this);
        }
    }, {
        key: "getFinalFeeAsset",
        value: function getFinalFeeAsset(account, operation) {
            var fee_asset_id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "1.3.0";

            var _ref, feeAssets;

            return _regenerator2.default.async(function getFinalFeeAsset$(_context4) {
                while (1) {
                    switch (_context4.prev = _context4.next) {
                        case 0:
                            _context4.next = 2;
                            return _regenerator2.default.awrap(this.getPossibleFees(account, operation));

                        case 2:
                            _ref = _context4.sent;
                            feeAssets = _ref.assets;

                            if (!(feeAssets.length === 1)) {
                                _context4.next = 9;
                                break;
                            }

                            fee_asset_id = feeAssets[0];
                            return _context4.abrupt("return", fee_asset_id);

                        case 9:
                            if (!(feeAssets.length > 0 && feeAssets.indexOf(fee_asset_id) !== -1)) {
                                _context4.next = 11;
                                break;
                            }

                            return _context4.abrupt("return", fee_asset_id);

                        case 11:
                            return _context4.abrupt("return", "1.3.0");

                        case 12:
                        case "end":
                            return _context4.stop();
                    }
                }
            }, null, this);
        }
    }]);
    return AccountUtils;
}();

exports.default = AccountUtils;

/***/ }),
/* 496 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(497), __esModule: true };

/***/ }),
/* 497 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(498);
module.exports = __webpack_require__(6).Number.parseInt;


/***/ }),
/* 498 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(16);
var $parseInt = __webpack_require__(499);
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });


/***/ }),
/* 499 */
/***/ (function(module, exports, __webpack_require__) {

var $parseInt = __webpack_require__(13).parseInt;
var $trim = __webpack_require__(500).trim;
var ws = __webpack_require__(389);
var hex = /^[-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;


/***/ }),
/* 500 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(16);
var defined = __webpack_require__(94);
var fails = __webpack_require__(47);
var spaces = __webpack_require__(389);
var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;


/***/ }),
/* 501 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! @preserve
 * numeral.js
 * version : 2.0.6
 * author : Adam Draper
 * license : MIT
 * http://adamwdraper.github.com/Numeral-js/
 */

(function (global, factory) {
    if (true) {
        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof module === 'object' && module.exports) {
        module.exports = factory();
    } else {
        global.numeral = factory();
    }
}(this, function () {
    /************************************
        Variables
    ************************************/

    var numeral,
        _,
        VERSION = '2.0.6',
        formats = {},
        locales = {},
        defaults = {
            currentLocale: 'en',
            zeroFormat: null,
            nullFormat: null,
            defaultFormat: '0,0',
            scalePercentBy100: true
        },
        options = {
            currentLocale: defaults.currentLocale,
            zeroFormat: defaults.zeroFormat,
            nullFormat: defaults.nullFormat,
            defaultFormat: defaults.defaultFormat,
            scalePercentBy100: defaults.scalePercentBy100
        };


    /************************************
        Constructors
    ************************************/

    // Numeral prototype object
    function Numeral(input, number) {
        this._input = input;

        this._value = number;
    }

    numeral = function(input) {
        var value,
            kind,
            unformatFunction,
            regexp;

        if (numeral.isNumeral(input)) {
            value = input.value();
        } else if (input === 0 || typeof input === 'undefined') {
            value = 0;
        } else if (input === null || _.isNaN(input)) {
            value = null;
        } else if (typeof input === 'string') {
            if (options.zeroFormat && input === options.zeroFormat) {
                value = 0;
            } else if (options.nullFormat && input === options.nullFormat || !input.replace(/[^0-9]+/g, '').length) {
                value = null;
            } else {
                for (kind in formats) {
                    regexp = typeof formats[kind].regexps.unformat === 'function' ? formats[kind].regexps.unformat() : formats[kind].regexps.unformat;

                    if (regexp && input.match(regexp)) {
                        unformatFunction = formats[kind].unformat;

                        break;
                    }
                }

                unformatFunction = unformatFunction || numeral._.stringToNumber;

                value = unformatFunction(input);
            }
        } else {
            value = Number(input)|| null;
        }

        return new Numeral(input, value);
    };

    // version number
    numeral.version = VERSION;

    // compare numeral object
    numeral.isNumeral = function(obj) {
        return obj instanceof Numeral;
    };

    // helper functions
    numeral._ = _ = {
        // formats numbers separators, decimals places, signs, abbreviations
        numberToFormat: function(value, format, roundingFunction) {
            var locale = locales[numeral.options.currentLocale],
                negP = false,
                optDec = false,
                leadingCount = 0,
                abbr = '',
                trillion = 1000000000000,
                billion = 1000000000,
                million = 1000000,
                thousand = 1000,
                decimal = '',
                neg = false,
                abbrForce, // force abbreviation
                abs,
                min,
                max,
                power,
                int,
                precision,
                signed,
                thousands,
                output;

            // make sure we never format a null value
            value = value || 0;

            abs = Math.abs(value);

            // see if we should use parentheses for negative number or if we should prefix with a sign
            // if both are present we default to parentheses
            if (numeral._.includes(format, '(')) {
                negP = true;
                format = format.replace(/[\(|\)]/g, '');
            } else if (numeral._.includes(format, '+') || numeral._.includes(format, '-')) {
                signed = numeral._.includes(format, '+') ? format.indexOf('+') : value < 0 ? format.indexOf('-') : -1;
                format = format.replace(/[\+|\-]/g, '');
            }

            // see if abbreviation is wanted
            if (numeral._.includes(format, 'a')) {
                abbrForce = format.match(/a(k|m|b|t)?/);

                abbrForce = abbrForce ? abbrForce[1] : false;

                // check for space before abbreviation
                if (numeral._.includes(format, ' a')) {
                    abbr = ' ';
                }

                format = format.replace(new RegExp(abbr + 'a[kmbt]?'), '');

                if (abs >= trillion && !abbrForce || abbrForce === 't') {
                    // trillion
                    abbr += locale.abbreviations.trillion;
                    value = value / trillion;
                } else if (abs < trillion && abs >= billion && !abbrForce || abbrForce === 'b') {
                    // billion
                    abbr += locale.abbreviations.billion;
                    value = value / billion;
                } else if (abs < billion && abs >= million && !abbrForce || abbrForce === 'm') {
                    // million
                    abbr += locale.abbreviations.million;
                    value = value / million;
                } else if (abs < million && abs >= thousand && !abbrForce || abbrForce === 'k') {
                    // thousand
                    abbr += locale.abbreviations.thousand;
                    value = value / thousand;
                }
            }

            // check for optional decimals
            if (numeral._.includes(format, '[.]')) {
                optDec = true;
                format = format.replace('[.]', '.');
            }

            // break number and format
            int = value.toString().split('.')[0];
            precision = format.split('.')[1];
            thousands = format.indexOf(',');
            leadingCount = (format.split('.')[0].split(',')[0].match(/0/g) || []).length;

            if (precision) {
                if (numeral._.includes(precision, '[')) {
                    precision = precision.replace(']', '');
                    precision = precision.split('[');
                    decimal = numeral._.toFixed(value, (precision[0].length + precision[1].length), roundingFunction, precision[1].length);
                } else {
                    decimal = numeral._.toFixed(value, precision.length, roundingFunction);
                }

                int = decimal.split('.')[0];

                if (numeral._.includes(decimal, '.')) {
                    decimal = locale.delimiters.decimal + decimal.split('.')[1];
                } else {
                    decimal = '';
                }

                if (optDec && Number(decimal.slice(1)) === 0) {
                    decimal = '';
                }
            } else {
                int = numeral._.toFixed(value, 0, roundingFunction);
            }

            // check abbreviation again after rounding
            if (abbr && !abbrForce && Number(int) >= 1000 && abbr !== locale.abbreviations.trillion) {
                int = String(Number(int) / 1000);

                switch (abbr) {
                    case locale.abbreviations.thousand:
                        abbr = locale.abbreviations.million;
                        break;
                    case locale.abbreviations.million:
                        abbr = locale.abbreviations.billion;
                        break;
                    case locale.abbreviations.billion:
                        abbr = locale.abbreviations.trillion;
                        break;
                }
            }


            // format number
            if (numeral._.includes(int, '-')) {
                int = int.slice(1);
                neg = true;
            }

            if (int.length < leadingCount) {
                for (var i = leadingCount - int.length; i > 0; i--) {
                    int = '0' + int;
                }
            }

            if (thousands > -1) {
                int = int.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1' + locale.delimiters.thousands);
            }

            if (format.indexOf('.') === 0) {
                int = '';
            }

            output = int + decimal + (abbr ? abbr : '');

            if (negP) {
                output = (negP && neg ? '(' : '') + output + (negP && neg ? ')' : '');
            } else {
                if (signed >= 0) {
                    output = signed === 0 ? (neg ? '-' : '+') + output : output + (neg ? '-' : '+');
                } else if (neg) {
                    output = '-' + output;
                }
            }

            return output;
        },
        // unformats numbers separators, decimals places, signs, abbreviations
        stringToNumber: function(string) {
            var locale = locales[options.currentLocale],
                stringOriginal = string,
                abbreviations = {
                    thousand: 3,
                    million: 6,
                    billion: 9,
                    trillion: 12
                },
                abbreviation,
                value,
                i,
                regexp;

            if (options.zeroFormat && string === options.zeroFormat) {
                value = 0;
            } else if (options.nullFormat && string === options.nullFormat || !string.replace(/[^0-9]+/g, '').length) {
                value = null;
            } else {
                value = 1;

                if (locale.delimiters.decimal !== '.') {
                    string = string.replace(/\./g, '').replace(locale.delimiters.decimal, '.');
                }

                for (abbreviation in abbreviations) {
                    regexp = new RegExp('[^a-zA-Z]' + locale.abbreviations[abbreviation] + '(?:\\)|(\\' + locale.currency.symbol + ')?(?:\\))?)?$');

                    if (stringOriginal.match(regexp)) {
                        value *= Math.pow(10, abbreviations[abbreviation]);
                        break;
                    }
                }

                // check for negative number
                value *= (string.split('-').length + Math.min(string.split('(').length - 1, string.split(')').length - 1)) % 2 ? 1 : -1;

                // remove non numbers
                string = string.replace(/[^0-9\.]+/g, '');

                value *= Number(string);
            }

            return value;
        },
        isNaN: function(value) {
            return typeof value === 'number' && isNaN(value);
        },
        includes: function(string, search) {
            return string.indexOf(search) !== -1;
        },
        insert: function(string, subString, start) {
            return string.slice(0, start) + subString + string.slice(start);
        },
        reduce: function(array, callback /*, initialValue*/) {
            if (this === null) {
                throw new TypeError('Array.prototype.reduce called on null or undefined');
            }

            if (typeof callback !== 'function') {
                throw new TypeError(callback + ' is not a function');
            }

            var t = Object(array),
                len = t.length >>> 0,
                k = 0,
                value;

            if (arguments.length === 3) {
                value = arguments[2];
            } else {
                while (k < len && !(k in t)) {
                    k++;
                }

                if (k >= len) {
                    throw new TypeError('Reduce of empty array with no initial value');
                }

                value = t[k++];
            }
            for (; k < len; k++) {
                if (k in t) {
                    value = callback(value, t[k], k, t);
                }
            }
            return value;
        },
        /**
         * Computes the multiplier necessary to make x >= 1,
         * effectively eliminating miscalculations caused by
         * finite precision.
         */
        multiplier: function (x) {
            var parts = x.toString().split('.');

            return parts.length < 2 ? 1 : Math.pow(10, parts[1].length);
        },
        /**
         * Given a variable number of arguments, returns the maximum
         * multiplier that must be used to normalize an operation involving
         * all of them.
         */
        correctionFactor: function () {
            var args = Array.prototype.slice.call(arguments);

            return args.reduce(function(accum, next) {
                var mn = _.multiplier(next);
                return accum > mn ? accum : mn;
            }, 1);
        },
        /**
         * Implementation of toFixed() that treats floats more like decimals
         *
         * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present
         * problems for accounting- and finance-related software.
         */
        toFixed: function(value, maxDecimals, roundingFunction, optionals) {
            var splitValue = value.toString().split('.'),
                minDecimals = maxDecimals - (optionals || 0),
                boundedPrecision,
                optionalsRegExp,
                power,
                output;

            // Use the smallest precision value possible to avoid errors from floating point representation
            if (splitValue.length === 2) {
              boundedPrecision = Math.min(Math.max(splitValue[1].length, minDecimals), maxDecimals);
            } else {
              boundedPrecision = minDecimals;
            }

            power = Math.pow(10, boundedPrecision);

            // Multiply up by precision, round accurately, then divide and use native toFixed():
            output = (roundingFunction(value + 'e+' + boundedPrecision) / power).toFixed(boundedPrecision);

            if (optionals > maxDecimals - boundedPrecision) {
                optionalsRegExp = new RegExp('\\.?0{1,' + (optionals - (maxDecimals - boundedPrecision)) + '}$');
                output = output.replace(optionalsRegExp, '');
            }

            return output;
        }
    };

    // avaliable options
    numeral.options = options;

    // avaliable formats
    numeral.formats = formats;

    // avaliable formats
    numeral.locales = locales;

    // This function sets the current locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    numeral.locale = function(key) {
        if (key) {
            options.currentLocale = key.toLowerCase();
        }

        return options.currentLocale;
    };

    // This function provides access to the loaded locale data.  If
    // no arguments are passed in, it will simply return the current
    // global locale object.
    numeral.localeData = function(key) {
        if (!key) {
            return locales[options.currentLocale];
        }

        key = key.toLowerCase();

        if (!locales[key]) {
            throw new Error('Unknown locale : ' + key);
        }

        return locales[key];
    };

    numeral.reset = function() {
        for (var property in defaults) {
            options[property] = defaults[property];
        }
    };

    numeral.zeroFormat = function(format) {
        options.zeroFormat = typeof(format) === 'string' ? format : null;
    };

    numeral.nullFormat = function (format) {
        options.nullFormat = typeof(format) === 'string' ? format : null;
    };

    numeral.defaultFormat = function(format) {
        options.defaultFormat = typeof(format) === 'string' ? format : '0.0';
    };

    numeral.register = function(type, name, format) {
        name = name.toLowerCase();

        if (this[type + 's'][name]) {
            throw new TypeError(name + ' ' + type + ' already registered.');
        }

        this[type + 's'][name] = format;

        return format;
    };


    numeral.validate = function(val, culture) {
        var _decimalSep,
            _thousandSep,
            _currSymbol,
            _valArray,
            _abbrObj,
            _thousandRegEx,
            localeData,
            temp;

        //coerce val to string
        if (typeof val !== 'string') {
            val += '';

            if (console.warn) {
                console.warn('Numeral.js: Value is not string. It has been co-erced to: ', val);
            }
        }

        //trim whitespaces from either sides
        val = val.trim();

        //if val is just digits return true
        if (!!val.match(/^\d+$/)) {
            return true;
        }

        //if val is empty return false
        if (val === '') {
            return false;
        }

        //get the decimal and thousands separator from numeral.localeData
        try {
            //check if the culture is understood by numeral. if not, default it to current locale
            localeData = numeral.localeData(culture);
        } catch (e) {
            localeData = numeral.localeData(numeral.locale());
        }

        //setup the delimiters and currency symbol based on culture/locale
        _currSymbol = localeData.currency.symbol;
        _abbrObj = localeData.abbreviations;
        _decimalSep = localeData.delimiters.decimal;
        if (localeData.delimiters.thousands === '.') {
            _thousandSep = '\\.';
        } else {
            _thousandSep = localeData.delimiters.thousands;
        }

        // validating currency symbol
        temp = val.match(/^[^\d]+/);
        if (temp !== null) {
            val = val.substr(1);
            if (temp[0] !== _currSymbol) {
                return false;
            }
        }

        //validating abbreviation symbol
        temp = val.match(/[^\d]+$/);
        if (temp !== null) {
            val = val.slice(0, -1);
            if (temp[0] !== _abbrObj.thousand && temp[0] !== _abbrObj.million && temp[0] !== _abbrObj.billion && temp[0] !== _abbrObj.trillion) {
                return false;
            }
        }

        _thousandRegEx = new RegExp(_thousandSep + '{2}');

        if (!val.match(/[^\d.,]/g)) {
            _valArray = val.split(_decimalSep);
            if (_valArray.length > 2) {
                return false;
            } else {
                if (_valArray.length < 2) {
                    return ( !! _valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx));
                } else {
                    if (_valArray[0].length === 1) {
                        return ( !! _valArray[0].match(/^\d+$/) && !_valArray[0].match(_thousandRegEx) && !! _valArray[1].match(/^\d+$/));
                    } else {
                        return ( !! _valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx) && !! _valArray[1].match(/^\d+$/));
                    }
                }
            }
        }

        return false;
    };


    /************************************
        Numeral Prototype
    ************************************/

    numeral.fn = Numeral.prototype = {
        clone: function() {
            return numeral(this);
        },
        format: function(inputString, roundingFunction) {
            var value = this._value,
                format = inputString || options.defaultFormat,
                kind,
                output,
                formatFunction;

            // make sure we have a roundingFunction
            roundingFunction = roundingFunction || Math.round;

            // format based on value
            if (value === 0 && options.zeroFormat !== null) {
                output = options.zeroFormat;
            } else if (value === null && options.nullFormat !== null) {
                output = options.nullFormat;
            } else {
                for (kind in formats) {
                    if (format.match(formats[kind].regexps.format)) {
                        formatFunction = formats[kind].format;

                        break;
                    }
                }

                formatFunction = formatFunction || numeral._.numberToFormat;

                output = formatFunction(value, format, roundingFunction);
            }

            return output;
        },
        value: function() {
            return this._value;
        },
        input: function() {
            return this._input;
        },
        set: function(value) {
            this._value = Number(value);

            return this;
        },
        add: function(value) {
            var corrFactor = _.correctionFactor.call(null, this._value, value);

            function cback(accum, curr, currI, O) {
                return accum + Math.round(corrFactor * curr);
            }

            this._value = _.reduce([this._value, value], cback, 0) / corrFactor;

            return this;
        },
        subtract: function(value) {
            var corrFactor = _.correctionFactor.call(null, this._value, value);

            function cback(accum, curr, currI, O) {
                return accum - Math.round(corrFactor * curr);
            }

            this._value = _.reduce([value], cback, Math.round(this._value * corrFactor)) / corrFactor;

            return this;
        },
        multiply: function(value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = _.correctionFactor(accum, curr);
                return Math.round(accum * corrFactor) * Math.round(curr * corrFactor) / Math.round(corrFactor * corrFactor);
            }

            this._value = _.reduce([this._value, value], cback, 1);

            return this;
        },
        divide: function(value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = _.correctionFactor(accum, curr);
                return Math.round(accum * corrFactor) / Math.round(curr * corrFactor);
            }

            this._value = _.reduce([this._value, value], cback);

            return this;
        },
        difference: function(value) {
            return Math.abs(numeral(this._value).subtract(value).value());
        }
    };

    /************************************
        Default Locale && Format
    ************************************/

    numeral.register('locale', 'en', {
        delimiters: {
            thousands: ',',
            decimal: '.'
        },
        abbreviations: {
            thousand: 'k',
            million: 'm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function(number) {
            var b = number % 10;
            return (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
        },
        currency: {
            symbol: '$'
        }
    });

    

(function() {
        numeral.register('format', 'bps', {
            regexps: {
                format: /(BPS)/,
                unformat: /(BPS)/
            },
            format: function(value, format, roundingFunction) {
                var space = numeral._.includes(format, ' BPS') ? ' ' : '',
                    output;

                value = value * 10000;

                // check for space before BPS
                format = format.replace(/\s?BPS/, '');

                output = numeral._.numberToFormat(value, format, roundingFunction);

                if (numeral._.includes(output, ')')) {
                    output = output.split('');

                    output.splice(-1, 0, space + 'BPS');

                    output = output.join('');
                } else {
                    output = output + space + 'BPS';
                }

                return output;
            },
            unformat: function(string) {
                return +(numeral._.stringToNumber(string) * 0.0001).toFixed(15);
            }
        });
})();


(function() {
        var decimal = {
            base: 1000,
            suffixes: ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
        },
        binary = {
            base: 1024,
            suffixes: ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']
        };

    var allSuffixes =  decimal.suffixes.concat(binary.suffixes.filter(function (item) {
            return decimal.suffixes.indexOf(item) < 0;
        }));
        var unformatRegex = allSuffixes.join('|');
        // Allow support for BPS (http://www.investopedia.com/terms/b/basispoint.asp)
        unformatRegex = '(' + unformatRegex.replace('B', 'B(?!PS)') + ')';

    numeral.register('format', 'bytes', {
        regexps: {
            format: /([0\s]i?b)/,
            unformat: new RegExp(unformatRegex)
        },
        format: function(value, format, roundingFunction) {
            var output,
                bytes = numeral._.includes(format, 'ib') ? binary : decimal,
                suffix = numeral._.includes(format, ' b') || numeral._.includes(format, ' ib') ? ' ' : '',
                power,
                min,
                max;

            // check for space before
            format = format.replace(/\s?i?b/, '');

            for (power = 0; power <= bytes.suffixes.length; power++) {
                min = Math.pow(bytes.base, power);
                max = Math.pow(bytes.base, power + 1);

                if (value === null || value === 0 || value >= min && value < max) {
                    suffix += bytes.suffixes[power];

                    if (min > 0) {
                        value = value / min;
                    }

                    break;
                }
            }

            output = numeral._.numberToFormat(value, format, roundingFunction);

            return output + suffix;
        },
        unformat: function(string) {
            var value = numeral._.stringToNumber(string),
                power,
                bytesMultiplier;

            if (value) {
                for (power = decimal.suffixes.length - 1; power >= 0; power--) {
                    if (numeral._.includes(string, decimal.suffixes[power])) {
                        bytesMultiplier = Math.pow(decimal.base, power);

                        break;
                    }

                    if (numeral._.includes(string, binary.suffixes[power])) {
                        bytesMultiplier = Math.pow(binary.base, power);

                        break;
                    }
                }

                value *= (bytesMultiplier || 1);
            }

            return value;
        }
    });
})();


(function() {
        numeral.register('format', 'currency', {
        regexps: {
            format: /(\$)/
        },
        format: function(value, format, roundingFunction) {
            var locale = numeral.locales[numeral.options.currentLocale],
                symbols = {
                    before: format.match(/^([\+|\-|\(|\s|\$]*)/)[0],
                    after: format.match(/([\+|\-|\)|\s|\$]*)$/)[0]
                },
                output,
                symbol,
                i;

            // strip format of spaces and $
            format = format.replace(/\s?\$\s?/, '');

            // format the number
            output = numeral._.numberToFormat(value, format, roundingFunction);

            // update the before and after based on value
            if (value >= 0) {
                symbols.before = symbols.before.replace(/[\-\(]/, '');
                symbols.after = symbols.after.replace(/[\-\)]/, '');
            } else if (value < 0 && (!numeral._.includes(symbols.before, '-') && !numeral._.includes(symbols.before, '('))) {
                symbols.before = '-' + symbols.before;
            }

            // loop through each before symbol
            for (i = 0; i < symbols.before.length; i++) {
                symbol = symbols.before[i];

                switch (symbol) {
                    case '$':
                        output = numeral._.insert(output, locale.currency.symbol, i);
                        break;
                    case ' ':
                        output = numeral._.insert(output, ' ', i + locale.currency.symbol.length - 1);
                        break;
                }
            }

            // loop through each after symbol
            for (i = symbols.after.length - 1; i >= 0; i--) {
                symbol = symbols.after[i];

                switch (symbol) {
                    case '$':
                        output = i === symbols.after.length - 1 ? output + locale.currency.symbol : numeral._.insert(output, locale.currency.symbol, -(symbols.after.length - (1 + i)));
                        break;
                    case ' ':
                        output = i === symbols.after.length - 1 ? output + ' ' : numeral._.insert(output, ' ', -(symbols.after.length - (1 + i) + locale.currency.symbol.length - 1));
                        break;
                }
            }


            return output;
        }
    });
})();


(function() {
        numeral.register('format', 'exponential', {
        regexps: {
            format: /(e\+|e-)/,
            unformat: /(e\+|e-)/
        },
        format: function(value, format, roundingFunction) {
            var output,
                exponential = typeof value === 'number' && !numeral._.isNaN(value) ? value.toExponential() : '0e+0',
                parts = exponential.split('e');

            format = format.replace(/e[\+|\-]{1}0/, '');

            output = numeral._.numberToFormat(Number(parts[0]), format, roundingFunction);

            return output + 'e' + parts[1];
        },
        unformat: function(string) {
            var parts = numeral._.includes(string, 'e+') ? string.split('e+') : string.split('e-'),
                value = Number(parts[0]),
                power = Number(parts[1]);

            power = numeral._.includes(string, 'e-') ? power *= -1 : power;

            function cback(accum, curr, currI, O) {
                var corrFactor = numeral._.correctionFactor(accum, curr),
                    num = (accum * corrFactor) * (curr * corrFactor) / (corrFactor * corrFactor);
                return num;
            }

            return numeral._.reduce([value, Math.pow(10, power)], cback, 1);
        }
    });
})();


(function() {
        numeral.register('format', 'ordinal', {
        regexps: {
            format: /(o)/
        },
        format: function(value, format, roundingFunction) {
            var locale = numeral.locales[numeral.options.currentLocale],
                output,
                ordinal = numeral._.includes(format, ' o') ? ' ' : '';

            // check for space before
            format = format.replace(/\s?o/, '');

            ordinal += locale.ordinal(value);

            output = numeral._.numberToFormat(value, format, roundingFunction);

            return output + ordinal;
        }
    });
})();


(function() {
        numeral.register('format', 'percentage', {
        regexps: {
            format: /(%)/,
            unformat: /(%)/
        },
        format: function(value, format, roundingFunction) {
            var space = numeral._.includes(format, ' %') ? ' ' : '',
                output;

            if (numeral.options.scalePercentBy100) {
                value = value * 100;
            }

            // check for space before %
            format = format.replace(/\s?\%/, '');

            output = numeral._.numberToFormat(value, format, roundingFunction);

            if (numeral._.includes(output, ')')) {
                output = output.split('');

                output.splice(-1, 0, space + '%');

                output = output.join('');
            } else {
                output = output + space + '%';
            }

            return output;
        },
        unformat: function(string) {
            var number = numeral._.stringToNumber(string);
            if (numeral.options.scalePercentBy100) {
                return number * 0.01;
            }
            return number;
        }
    });
})();


(function() {
        numeral.register('format', 'time', {
        regexps: {
            format: /(:)/,
            unformat: /(:)/
        },
        format: function(value, format, roundingFunction) {
            var hours = Math.floor(value / 60 / 60),
                minutes = Math.floor((value - (hours * 60 * 60)) / 60),
                seconds = Math.round(value - (hours * 60 * 60) - (minutes * 60));

            return hours + ':' + (minutes < 10 ? '0' + minutes : minutes) + ':' + (seconds < 10 ? '0' + seconds : seconds);
        },
        unformat: function(string) {
            var timeArray = string.split(':'),
                seconds = 0;

            // turn hours and minutes into seconds and add them all up
            if (timeArray.length === 3) {
                // hours
                seconds = seconds + (Number(timeArray[0]) * 60 * 60);
                // minutes
                seconds = seconds + (Number(timeArray[1]) * 60);
                // seconds
                seconds = seconds + Number(timeArray[2]);
            } else if (timeArray.length === 2) {
                // minutes
                seconds = seconds + (Number(timeArray[0]) * 60);
                // seconds
                seconds = seconds + Number(timeArray[1]);
            }
            return Number(seconds);
        }
    });
})();

return numeral;
}));


/***/ }),
/* 502 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(503);
module.exports = __webpack_require__(6).Object.getPrototypeOf;


/***/ }),
/* 503 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = __webpack_require__(51);
var $getPrototypeOf = __webpack_require__(208);

__webpack_require__(366)('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});


/***/ }),
/* 504 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(505), __esModule: true };

/***/ }),
/* 505 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(506);
module.exports = __webpack_require__(6).Object.setPrototypeOf;


/***/ }),
/* 506 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(16);
$export($export.S, 'Object', { setPrototypeOf: __webpack_require__(507).set });


/***/ }),
/* 507 */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(25);
var anObject = __webpack_require__(33);
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = __webpack_require__(41)(Function.call, __webpack_require__(212).f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};


/***/ }),
/* 508 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(509), __esModule: true };

/***/ }),
/* 509 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(510);
var $Object = __webpack_require__(6).Object;
module.exports = function create(P, D) {
  return $Object.create(P, D);
};


/***/ }),
/* 510 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(16);
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: __webpack_require__(99) });


/***/ }),
/* 511 */
/***/ (function(module, exports) {

/*
fraction.js
A Javascript fraction library.

Copyright (c) 2009  Erik Garrison <erik@hypervolu.me>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/


/* Fractions */
/* 
 *
 * Fraction objects are comprised of a numerator and a denomenator.  These
 * values can be accessed at fraction.numerator and fraction.denomenator.
 *
 * Fractions are always returned and stored in lowest-form normalized format.
 * This is accomplished via Fraction.normalize.
 *
 * The following mathematical operations on fractions are supported:
 *
 * Fraction.equals
 * Fraction.add
 * Fraction.subtract
 * Fraction.multiply
 * Fraction.divide
 *
 * These operations accept both numbers and fraction objects.  (Best results
 * are guaranteed when the input is a fraction object.)  They all return a new
 * Fraction object.
 *
 * Usage:
 *
 * TODO
 *
 */

/*
 * The Fraction constructor takes one of:
 *   an explicit numerator (integer) and denominator (integer),
 *   a string representation of the fraction (string),
 *   or a floating-point number (float)
 *
 * These initialization methods are provided for convenience.  Because of
 * rounding issues the best results will be given when the fraction is
 * constructed from an explicit integer numerator and denomenator, and not a
 * decimal number.
 *
 *
 * e.g. new Fraction(1, 2) --> 1/2
 *      new Fraction('1/2') --> 1/2
 *      new Fraction('2 3/4') --> 11/4  (prints as 2 3/4)
 *
 */
Fraction = function(numerator, denominator)
{
    /* double argument invocation */
    if (typeof numerator !== 'undefined' && denominator) {
        if (typeof(numerator) === 'number' && typeof(denominator) === 'number') {
            this.numerator = numerator;
            this.denominator = denominator;
        } else if (typeof(numerator) === 'string' && typeof(denominator) === 'string') {
            // what are they?
            // hmm....
            // assume they are ints?
            this.numerator = parseInt(numerator);
            this.denominator = parseInt(denominator);
        }
    /* single-argument invocation */
    } else if (typeof denominator === 'undefined') {
        num = numerator; // swap variable names for legibility
        if (typeof(num) === 'number') {  // just a straight number init
            this.numerator = num;
            this.denominator = 1;
        } else if (typeof(num) === 'string') {
            var a, b;  // hold the first and second part of the fraction, e.g. a = '1' and b = '2/3' in 1 2/3
                       // or a = '2/3' and b = undefined if we are just passed a single-part number
            var arr = num.split(' ')
            if (arr[0]) a = arr[0]
            if (arr[1]) b = arr[1]
            /* compound fraction e.g. 'A B/C' */
            //  if a is an integer ...
            if (a % 1 === 0 && b && b.match('/')) {
                return (new Fraction(a)).add(new Fraction(b));
            } else if (a && !b) {
                /* simple fraction e.g. 'A/B' */
                if (typeof(a) === 'string' && a.match('/')) {
                    // it's not a whole number... it's actually a fraction without a whole part written
                    var f = a.split('/');
                    this.numerator = f[0]; this.denominator = f[1];
                /* string floating point */
                } else if (typeof(a) === 'string' && a.match('\.')) {
                    return new Fraction(parseFloat(a));
                /* whole number e.g. 'A' */
                } else { // just passed a whole number as a string
                    this.numerator = parseInt(a);
                    this.denominator = 1;
                }
            } else {
                return undefined; // could not parse
            }
        }
    }
    this.normalize();
}


Fraction.prototype.clone = function()
{
    return new Fraction(this.numerator, this.denominator);
}


/* pretty-printer, converts fractions into whole numbers and fractions */
Fraction.prototype.toString = function()
{
    if (this.denominator==='NaN') return 'NaN'
    var wholepart = (this.numerator/this.denominator>0) ?
      Math.floor(this.numerator / this.denominator) :
      Math.ceil(this.numerator / this.denominator)
    var numerator = this.numerator % this.denominator 
    var denominator = this.denominator;
    var result = []; 
    if (wholepart != 0)  
        result.push(wholepart);
    if (numerator != 0)  
        result.push(((wholepart===0) ? numerator : Math.abs(numerator)) + '/' + denominator);
    return result.length > 0 ? result.join(' ') : 0;
}


/* destructively rescale the fraction by some integral factor */
Fraction.prototype.rescale = function(factor)
{
    this.numerator *= factor;
    this.denominator *= factor;
    return this;
}


Fraction.prototype.add = function(b)
{
    var a = this.clone();
    if (b instanceof Fraction) {
        b = b.clone();
    } else {
        b = new Fraction(b);
    }
    td = a.denominator;
    a.rescale(b.denominator);
    b.rescale(td);

    a.numerator += b.numerator;

    return a.normalize();
}


Fraction.prototype.subtract = function(b)
{
    var a = this.clone();
    if (b instanceof Fraction) {
        b = b.clone();  // we scale our argument destructively, so clone
    } else {
        b = new Fraction(b);
    }
    td = a.denominator;
    a.rescale(b.denominator);
    b.rescale(td);

    a.numerator -= b.numerator;

    return a.normalize();
}


Fraction.prototype.multiply = function(b)
{
    var a = this.clone();
    if (b instanceof Fraction)
    {
        a.numerator *= b.numerator;
        a.denominator *= b.denominator;
    } else if (typeof b === 'number') {
        a.numerator *= b;
    } else {
        return a.multiply(new Fraction(b));
    }
    return a.normalize();
}

Fraction.prototype.divide = function(b)
{
    var a = this.clone();
    if (b instanceof Fraction)
    {
        a.numerator *= b.denominator;
        a.denominator *= b.numerator;
    } else if (typeof b === 'number') {
        a.denominator *= b;
    } else {
        return a.divide(new Fraction(b));
    }
    return a.normalize();
}

Fraction.prototype.equals = function(b)
{
    if (!(b instanceof Fraction)) {
        b = new Fraction(b);
    }
    // fractions that are equal should have equal normalized forms
    var a = this.clone().normalize();
    var b = b.clone().normalize();
    return (a.numerator === b.numerator && a.denominator === b.denominator);
}


/* Utility functions */

/* Destructively normalize the fraction to its smallest representation. 
 * e.g. 4/16 -> 1/4, 14/28 -> 1/2, etc.
 * This is called after all math ops.
 */
Fraction.prototype.normalize = (function()
{

    var isFloat = function(n)
    {
        return (typeof(n) === 'number' && 
                ((n > 0 && n % 1 > 0 && n % 1 < 1) || 
                 (n < 0 && n % -1 < 0 && n % -1 > -1))
               );
    }

    var roundToPlaces = function(n, places) 
    {
        if (!places) {
            return Math.round(n);
        } else {
            var scalar = Math.pow(10, places);
            return Math.round(n*scalar)/scalar;
        }
    }
        
    return (function() {

        // XXX hackish.  Is there a better way to address this issue?
        //
        /* first check if we have decimals, and if we do eliminate them
         * multiply by the 10 ^ number of decimal places in the number
         * round the number to nine decimal places
         * to avoid js floating point funnies
         */
        if (isFloat(this.denominator)) {
            var rounded = roundToPlaces(this.denominator, 9);
            var scaleup = Math.pow(10, rounded.toString().split('.')[1].length);
            this.denominator = Math.round(this.denominator * scaleup); // this !!! should be a whole number
            //this.numerator *= scaleup;
            this.numerator *= scaleup;
        } 
        if (isFloat(this.numerator)) {
            var rounded = roundToPlaces(this.numerator, 9);
            var scaleup = Math.pow(10, rounded.toString().split('.')[1].length);
            this.numerator = Math.round(this.numerator * scaleup); // this !!! should be a whole number
            //this.numerator *= scaleup;
            this.denominator *= scaleup;
        }
        var gcf = Fraction.gcf(this.numerator, this.denominator);
        this.numerator /= gcf;
        this.denominator /= gcf;
        if ((this.numerator < 0 && this.denominator < 0) || (this.numerator > 0 && this.denominator < 0)) {
            this.numerator *= -1;
            this.denominator *= -1;
        }
        return this;
    });

})();


/* Takes two numbers and returns their greatest common factor.
 */
Fraction.gcf = function(a, b)
{

    var common_factors = [];
    var fa = Fraction.primeFactors(a);
    var fb = Fraction.primeFactors(b);
    // for each factor in fa
    // if it's also in fb
    // put it into the common factors
    fa.forEach(function (factor) 
    { 
        var i = fb.indexOf(factor);
        if (i >= 0) {
            common_factors.push(factor);
            fb.splice(i,1); // remove from fb
        }
    });

    if (common_factors.length === 0)
        return 1;

    var gcf = (function() {
        var r = common_factors[0];
        var i;
        for (i=1;i<common_factors.length;i++)
        {
            r = r * common_factors[i];
        }
        return r;
    })();

    return gcf;

};


// Adapted from: 
// http://www.btinternet.com/~se16/js/factor.htm
Fraction.primeFactors = function(n) 
{

    var num = Math.abs(n);
    var factors = [];
    var _factor = 2;  // first potential prime factor

    while (_factor * _factor <= num)  // should we keep looking for factors?
    {      
      if (num % _factor === 0)  // this is a factor
        { 
            factors.push(_factor);  // so keep it
            num = num/_factor;  // and divide our search point by it
        }
        else
        {
            _factor++;  // and increment
        }
    }

    if (num != 1)                    // If there is anything left at the end...
    {                                // ...this must be the last prime factor
        factors.push(num);           //    so it too should be recorded
    }

    return factors;                  // Return the prime factors
}

module.exports.Fraction = Fraction


/***/ }),
/* 512 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.shouldPayFeeWithAssetAsync = exports.checkBalance = exports.checkFeeStatusAsync = exports.checkFeePoolAsync = exports.estimateFeeAsync = exports.estimateFee = undefined;

var _getIterator2 = __webpack_require__(52);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _stringify = __webpack_require__(18);

var _stringify2 = _interopRequireDefault(_stringify);

var _slicedToArray2 = __webpack_require__(90);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _promise = __webpack_require__(4);

var _promise2 = _interopRequireDefault(_promise);

var _bcxjsCores = __webpack_require__(7);

var _MarketClasses = __webpack_require__(148);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var operations = _bcxjsCores.ChainTypes.operations;


function estimateFeeAsync(type) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    return new _promise2.default(function (res, rej) {
        (0, _bcxjsCores.FetchChain)("getObject", "2.0.0").then(function (obj) {
            res(estimateFee(type, options, obj, data));
        }).catch(rej);
    });
}

function checkFeePoolAsync() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        assetID = _ref.assetID,
        _ref$type = _ref.type,
        type = _ref$type === undefined ? "transfer" : _ref$type,
        _ref$options = _ref.options,
        options = _ref$options === undefined ? null : _ref$options,
        data = _ref.data;

    return new _promise2.default(function (res) {
        if (assetID === "1.3.0") {
            res(true);
        } else {
            _promise2.default.all([estimateFeeAsync(type, options, data), (0, _bcxjsCores.FetchChain)("getAsset", assetID)]).then(function (result) {
                var _result = (0, _slicedToArray3.default)(result, 2),
                    fee = _result[0],
                    feeAsset = _result[1];

                (0, _bcxjsCores.FetchChain)("getObject", feeAsset.get("dynamic_asset_data_id")).then(function (dynamicObject) {
                    res(parseInt(dynamicObject.get("fee_pool"), 10) >= fee);
                });
            });
        }
    });
}

var asyncCache = {};
var feeStatusTTL = 60000; // 1 minute

function checkFeeStatusAsync() {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        accountID = _ref2.accountID,
        _ref2$feeID = _ref2.feeID,
        feeID = _ref2$feeID === undefined ? "1.3.0" : _ref2$feeID,
        _ref2$type = _ref2.type,
        type = _ref2$type === undefined ? "transfer" : _ref2$type,
        _ref2$options = _ref2.options,
        options = _ref2$options === undefined ? null : _ref2$options,
        data = _ref2.data;

    var key = accountID + feeID + type + (0, _stringify2.default)(options) + (0, _stringify2.default)(data);
    if (asyncCache[key]) {
        if (asyncCache[key].result) {
            return _promise2.default.resolve(asyncCache[key].result);
        }
        return new _promise2.default(function (res, rej) {
            asyncCache[key].queue.push({ res: res, rej: rej });
        });
    }

    return new _promise2.default(function (res, rej) {
        asyncCache[key] = { queue: [{ res: res, rej: rej }], result: null };
        _promise2.default.all([estimateFeeAsync(type, options, data), checkFeePoolAsync({ assetID: feeID, type: type, options: options, data: data }), (0, _bcxjsCores.FetchChain)("getAccount", accountID), (0, _bcxjsCores.FetchChain)("getAsset", "1.3.0"), feeID !== "1.3.0" ? (0, _bcxjsCores.FetchChain)("getAsset", feeID) : null]).then(function (result) {
            var _result2 = (0, _slicedToArray3.default)(result, 5),
                coreFee = _result2[0],
                hasPoolBalance = _result2[1],
                account = _result2[2],
                coreAsset = _result2[3],
                feeAsset = _result2[4];

            var hasBalance = false;
            if (feeID === "1.3.0") feeAsset = coreAsset;
            var coreBalanceID = account.getIn(["balances", "1.3.0"]),
                feeBalanceID = account.getIn(["balances", feeID]);

            if (feeID === "1.3.0" && !coreBalanceID) return res({
                fee: new _MarketClasses.Asset({ amount: coreFee }),
                hasBalance: hasBalance,
                hasPoolBalance: hasPoolBalance
            });

            _promise2.default.all([coreBalanceID ? (0, _bcxjsCores.FetchChain)("getObject", coreBalanceID) : null, feeBalanceID ? (0, _bcxjsCores.FetchChain)("getObject", feeBalanceID) : null]).then(function (balances) {
                var _balances = (0, _slicedToArray3.default)(balances, 2),
                    coreBalance = _balances[0],
                    feeBalance = _balances[1];

                var fee = new _MarketClasses.Asset({ amount: coreFee });
                var hasValidCER = true;

                /*
                ** If the fee is to be paid in a non-core asset, check the fee
                ** pool and convert the amount using the CER
                */
                if (feeID !== "1.3.0") {
                    // Convert the amount using the CER
                    var cer = feeAsset.getIn(["options", "core_exchange_rate"]);
                    var b = cer.get("base").toJS();
                    b.precision = b.asset_id === feeID ? feeAsset.get("precision") : coreAsset.get("precision");
                    var base = new _MarketClasses.Asset(b);

                    var q = cer.get("quote").toJS();
                    q.precision = q.asset_id === feeID ? feeAsset.get("precision") : coreAsset.get("precision");
                    var quote = new _MarketClasses.Asset(q);

                    /*
                    ** If the CER is incorrectly configured, the multiplication
                    ** will fail, so catch the error and default to core
                    */
                    try {
                        var price = new _MarketClasses.Price({ base: base, quote: quote });
                        fee = fee.times(price, true);
                    } catch (err) {
                        feeBalance = coreBalance;
                        hasValidCER = false;
                        hasPoolBalance = false;
                    }
                }

                if (feeBalance && feeBalance.get("balance") >= fee.getAmount()) hasBalance = true;
                asyncCache[key].queue.forEach(function (promise) {
                    promise.res({
                        fee: fee,
                        hasBalance: hasBalance,
                        hasPoolBalance: hasPoolBalance,
                        hasValidCER: hasValidCER
                    });
                });
                asyncCache[key] = {
                    result: { fee: fee, hasBalance: hasBalance, hasPoolBalance: hasPoolBalance, hasValidCER: hasValidCER }
                };
                setTimeout(function () {
                    delete asyncCache[key];
                }, feeStatusTTL);
            });
        }).catch(function () {
            asyncCache[key].forEach(function (promise) {
                promise.rej();
            });
        });
    });
}

var privKey = "5KikQ23YhcM7jdfHbFBQg1G7Do5y6SgD9sdBZq7BqQWXmNH7gqo";
var nonce = _bcxjsCores.TransactionHelper.unique_nonce_uint64();
var _privKey = void 0;
var _cachedMessage = void 0,
    _prevContent = void 0;

var _feeCache = {};
function estimateFee(op_type, options, globalObject) {
    var data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    // console.time("estimateFee");
    /*
    * The actual content doesn't matter, only the length of it, so we use a
    * string of equal length to improve caching
    */
    if (!!data.content) data.content = new Array(data.content.length + 1).join("a");
    if (!globalObject) return 0;
    var cacheKey = op_type + (0, _stringify2.default)(options) + (0, _stringify2.default)(data);
    if (_feeCache[cacheKey]) {
        // console.timeEnd("estimateFee");
        return _feeCache[cacheKey];
    }
    var op_code = operations[op_type];
    var currentFees = globalObject.getIn(["parameters", "current_fees", "parameters", op_code, 1]).toJS();

    var fee = 0;
    if (currentFees.fee) {
        fee += currentFees.fee;
    }

    if (options) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = (0, _getIterator3.default)(options), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var option = _step.value;

                var optionFee = currentFees[option];

                if (option === "price_per_kbyte") {
                    if (data.type === "memo" && !!data.content) {
                        /* Dummy priv key */
                        var pKey = _privKey || _bcxjsCores.PrivateKey.fromWif(privKey);
                        if (_privKey) _privKey = pKey;
                        var memoFromKey = "COCOS6B1taKXkDojuC1qECjvC7g186d8AdeGtz8wnqWAsoRGC6RY8Rp";

                        // Memos are optional, but if you have one you need to encrypt it
                        var memoToKey = "COCOS8eLeqSZZtB1YHdw7KjQxRSRmaKAseCxhUSqaLxUdqvdGpp6nck";

                        /* Encryption is very expensive so we cache the result for reuse */
                        var message = void 0;
                        if (data.content === _prevContent && _cachedMessage) {
                            message = _cachedMessage;
                        } else {
                            message = _cachedMessage = _bcxjsCores.Aes.encrypt_with_checksum(pKey, memoToKey, nonce, data.content);
                        }

                        var memo_object = {
                            from: memoFromKey,
                            to: memoToKey,
                            nonce: nonce,
                            message: message
                        };

                        var serialized = _bcxjsCores.ops.memo_data.fromObject(memo_object);
                        var stringified = (0, _stringify2.default)(_bcxjsCores.ops.memo_data.toHex(serialized));
                        var byteLength = Buffer.byteLength(stringified, "hex");
                        fee += optionFee * byteLength / 1024;

                        _prevContent = data.content;
                    }
                } else if (optionFee) {
                    fee += optionFee;
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    }
    // console.timeEnd("estimateFee");
    fee = fee * globalObject.getIn(["parameters", "current_fees", "scale"]) / 10000;
    _feeCache[cacheKey] = fee;
    setTimeout(function () {
        delete _feeCache[cacheKey];
    }, 1000 * 60 * 5); // Five minute cache clear timeout
    return fee;
}

function checkBalance(amount, sendAsset, feeAmount, balance) {
    if (!amount) return null;
    if (typeof amount === "string") amount = parseFloat(String.prototype.replace.call(amount, /,/g, ""));

    if (!balance || balance.get("balance") === 0) return false;

    var sendAmount = new _MarketClasses.Asset({
        asset_id: sendAsset.get("id"),
        precision: sendAsset.get("precision"),
        real: amount
    });
    var balanceAmount = sendAmount.clone(balance.get("balance"));

    /* Insufficient balance */
    if (balanceAmount.lt(sendAmount)) {
        return false;
    }

    /* Check if enough remains to pay the fee */
    if (sendAmount.asset_id === feeAmount.asset_id) {
        sendAmount.plus(feeAmount);
        if (balanceAmount.lt(sendAmount)) {
            return false;
        }
    }

    return true;
}

function shouldPayFeeWithAssetAsync(fromAccount, feeAmount) {
    if (fromAccount && feeAmount && feeAmount.asset_id === "1.3.0") {
        var balanceID = fromAccount.getIn(["balances", feeAmount.asset_id]);
        return (0, _bcxjsCores.FetchChain)("getObject", balanceID).then(function (balanceObject) {
            var balance = balanceObject.get("balance");
            if (balance <= feeAmount.amount) return true;
        });
    }
    return new _promise2.default(function (resolve) {
        return resolve(false);
    });
}

exports.estimateFee = estimateFee;
exports.estimateFeeAsync = estimateFeeAsync;
exports.checkFeePoolAsync = checkFeePoolAsync;
exports.checkFeeStatusAsync = checkFeeStatusAsync;
exports.checkBalance = checkBalance;
exports.shouldPayFeeWithAssetAsync = shouldPayFeeWithAssetAsync;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),
/* 513 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = function() {
	return new Worker(__webpack_require__.p + "bcxWorker.js");
};

/***/ }),
/* 514 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = __webpack_require__(26);

var _typeof3 = _interopRequireDefault(_typeof2);

var _extends2 = __webpack_require__(76);

var _extends3 = _interopRequireDefault(_extends2);

var _stringify = __webpack_require__(18);

var _stringify2 = _interopRequireDefault(_stringify);

var _slicedToArray2 = __webpack_require__(90);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _regenerator = __webpack_require__(3);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _keys = __webpack_require__(24);

var _keys2 = _interopRequireDefault(_keys);

var _bcxjsCores = __webpack_require__(7);

var _bcxjsWs = __webpack_require__(8);

var _api = __webpack_require__(10);

var _api2 = _interopRequireDefault(_api);

var _zh = __webpack_require__(515);

var _zh2 = _interopRequireDefault(_zh);

var _en = __webpack_require__(516);

var _en2 = _interopRequireDefault(_en);

var _utils = __webpack_require__(59);

var _utils2 = _interopRequireDefault(_utils);

var _helper = __webpack_require__(34);

var _helper2 = _interopRequireDefault(_helper);

var _market_utils = __webpack_require__(226);

var _market_utils2 = _interopRequireDefault(_market_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _locales = {
  en: _en2.default,
  zh: _zh2.default
};

var _store = void 0;
var _cacheBlocks = {};
var reqBlockOK = true;
// Service for dealing with operations (transactions)
var Operations = {
  _operationTypes: {
    300: "contract_affecteds_asset",
    3010: "contract_affecteds_nh_transfer_from",
    3011: "contract_affecteds_nh_transfer_to",
    3012: "contract_affecteds_nh_modifined",
    303: "contract_affecteds_log"
  },

  results: ["error_result", "void_result", "object_id_result", "asset_result", "contract_result", "logger_result"],
  // Prepares object with code : operation's name format
  prepareOperationTypes: function prepareOperationTypes() {
    (0, _keys2.default)(_bcxjsCores.ChainTypes.operations).forEach(function (name) {
      var code = _bcxjsCores.ChainTypes.operations[name];
      Operations._operationTypes[code] = name;
    });
  },

  // Gets operation's data based on it's block number
  _getOperationDate: function _getOperationDate(operation, ApiObject, ApiObjectDyn) {
    var blockInterval = ApiObject[0].parameters.block_interval;
    var headBlock = ApiObjectDyn[0].head_block_number;
    var headBlockTime = new Date(ApiObjectDyn[0].time + 'Z');
    var secondsBelow = (headBlock - operation.block_num) * blockInterval;
    var date = new Date(headBlockTime - secondsBelow * 1000).format("yyyy/MM/dd HH:mm:ss");
    return date;
  },

  // Used for place order and fill order operations. Determines if user is a seller or buyer
  _checkIfBidOperation: function _checkIfBidOperation(operation) {
    var ApiInstance, blockNum, trxInBlock, transaction, amountAssetId, feeAssetId;
    return _regenerator2.default.async(function _checkIfBidOperation$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            ApiInstance = _bcxjsWs.Apis.instance();
            blockNum = operation.block_num;
            trxInBlock = operation.trx_in_block;
            _context.next = 5;
            return _regenerator2.default.awrap(ApiInstance.db_api().exec('get_transaction', [blockNum, trxInBlock]));

          case 5:
            transaction = _context.sent;
            amountAssetId = transaction.operations[0][1].amount_to_sell.asset_id;
            feeAssetId = transaction.operations[0][1].fee.asset_id;
            return _context.abrupt('return', amountAssetId === feeAssetId);

          case 9:
          case 'end':
            return _context.stop();
        }
      }
    }, null, undefined);
  },

  // Parses operation for improved format
  _parseOperation: function _parseOperation(operation, ApiObject, ApiObjectDyn) {
    var isReqDate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

    var _operation$op, type, payload, operationType, date, block_res, isBid, otherUserName, res, op_id, _operations, additional_cost, amount, _asset_id;

    return _regenerator2.default.async(function _parseOperation$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _operation$op = (0, _slicedToArray3.default)(operation.op, 2), type = _operation$op[0], payload = _operation$op[1];
            operationType = Operations._operationTypes[type];
            date = "";

            if (!operation.date) {
              _context2.next = 7;
              break;
            }

            date = operation.date;
            _context2.next = 13;
            break;

          case 7:
            if (!isReqDate) {
              _context2.next = 13;
              break;
            }

            if (ApiObjectDyn.code == 1) date = Operations._getOperationDate(operation, ApiObject, ApiObjectDyn);
            _context2.next = 11;
            return _regenerator2.default.awrap(_api2.default.Operations.get_block_header(operation.block_num));

          case 11:
            block_res = _context2.sent;

            if (block_res.code == 1) {
              date = new Date(block_res.data.timestamp + "Z").format("yyyy/MM/dd HH:mm:ss");
            }

          case 13:
            isBid = false;
            otherUserName = null;
            res = {
              block_num: operation.block_num,
              type: operationType,
              payload: payload,
              date: date
            };
            op_id = operation.id;

            if (op_id) {
              res.id = op_id;
            }
            // if (operationType === 'fill_order' || operationType === 'limit_order_create') {
            //   isBid = await Operations._checkIfBidOperation(operation);
            //   res.buyer=isBid;
            // }

            if (!operation.result) {
              _context2.next = 34;
              break;
            }

            res.result = operation.result[1];
            res.result.type = _store.rootGetters["setting/trx_results"][operation.result[0]];
            if (operationType == "create_nh_asset") {
              res.payload.item_id = operation.result[1].result;
            }
            if (operationType == "create_world_view") {
              res.payload.version_id = operation.result[1];
            }

            if (!(operationType == "call_contract_function")) {
              _context2.next = 34;
              break;
            }

            _operations = operation.result[1].contract_affecteds.map(function (item) {
              var op_num = item[0] + 300;
              if (item[0] == 1) {
                op_num = op_num + "" + item[1].action;
              }
              return {
                block_num: operation.block_num,
                id: operation.id,
                op: [Number(op_num), item[1]]
              };
            });
            _context2.next = 27;
            return _regenerator2.default.awrap(Operations.parseOperations({
              operations: _operations,
              store: _store,
              isContract: true,
              isReqDate: false
            }));

          case 27:
            res.result.contract_affecteds = _context2.sent;
            additional_cost = res.result.additional_cost;

            if (!additional_cost) {
              _context2.next = 34;
              break;
            }

            amount = additional_cost.amount, _asset_id = additional_cost.asset_id;
            _context2.next = 33;
            return _regenerator2.default.awrap(Operations.FormattedAsset(amount, _asset_id, 0));

          case 33:
            res.result.additional_cost_text = _context2.sent;

          case 34:
            return _context2.abrupt('return', res);

          case 35:
          case 'end':
            return _context2.stop();
        }
      }
    }, null, undefined);
  },

  // Parses array of operations, return array of parsed operations and array of assets ids
  // that were user in it. United Labs of BCTech.
  parseOperations: function parseOperations(_ref) {
    var operations = _ref.operations,
        store = _ref.store,
        _ref$isContract = _ref.isContract,
        isContract = _ref$isContract === undefined ? false : _ref$isContract,
        _ref$isReqDate = _ref.isReqDate,
        isReqDate = _ref$isReqDate === undefined ? true : _ref$isReqDate;

    var ApiInstance, ApiObject, ApiObjectDyn, operationTypes, filteredOperations, parsedOperations, j, item, i, parseOpObj, fees, _i, feeObj, feeAsset, trxType;

    return _regenerator2.default.async(function parseOperations$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            // console.info("operations",operations);
            _store = store;
            ApiInstance = _bcxjsWs.Apis.instance();

            if (!isReqDate) {
              _context3.next = 9;
              break;
            }

            _context3.next = 5;
            return _regenerator2.default.awrap(_api2.default.Explorer.getGlobalObject(true));

          case 5:
            _context3.t1 = _context3.sent.data;
            _context3.t0 = [_context3.t1];
            _context3.next = 10;
            break;

          case 9:
            _context3.t0 = null;

          case 10:
            ApiObject = _context3.t0;

            if (!isReqDate) {
              _context3.next = 18;
              break;
            }

            _context3.next = 14;
            return _regenerator2.default.awrap(_api2.default.Explorer.getDynGlobalObject(false));

          case 14:
            _context3.t3 = _context3.sent.data;
            _context3.t2 = [_context3.t3];
            _context3.next = 19;
            break;

          case 18:
            _context3.t2 = null;

          case 19:
            ApiObjectDyn = _context3.t2;
            operationTypes = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 23, 24, 26, 27, 30, 31, 34, 35, 37, 38, 39, 40, 41, 42, 43, 44, 45, 50, 54, 300, 301, 303, 3010, 3011, 3012]; //,53,54.55,56,57,58

            filteredOperations = operations.filter(function (op) {
              return operationTypes.includes(op.op[0]);
            });
            parsedOperations = [];
            j = 0;

          case 24:
            if (!(j < filteredOperations.length)) {
              _context3.next = 33;
              break;
            }

            _context3.t4 = parsedOperations;
            _context3.next = 28;
            return _regenerator2.default.awrap(Operations._parseOperation(filteredOperations[j], ApiObject, ApiObjectDyn, isReqDate));

          case 28:
            _context3.t5 = _context3.sent;

            _context3.t4.push.call(_context3.t4, _context3.t5);

          case 30:
            j++;
            _context3.next = 24;
            break;

          case 33:
            // const assetsIds = Operations._getOperationsAssetsIds(parsedOperations);

            item = void 0;
            i = 0;

          case 35:
            if (!(i < parsedOperations.length)) {
              _context3.next = 62;
              break;
            }

            item = parsedOperations[i];

            if (isContract) {
              delete item.id;
              delete item.date;
            }
            _context3.next = 40;
            return _regenerator2.default.awrap(Operations.getParseOperations(item));

          case 40:
            parseOpObj = _context3.sent;

            item.parseOperationsText = parseOpObj.opText.join("");
            item.parseOperations = parseOpObj.opObj;
            item.parseOperations.fees = [];

            if (!item.result) {
              _context3.next = 57;
              break;
            }

            fees = item.result.fees;

            if (!fees) {
              _context3.next = 57;
              break;
            }

            _i = 0;

          case 48:
            if (!(_i < fees.length)) {
              _context3.next = 57;
              break;
            }

            feeObj = fees[_i];
            _context3.next = 52;
            return _regenerator2.default.awrap(_api2.default.Assets.fetch([feeObj.asset_id], true));

          case 52:
            feeAsset = _context3.sent;

            if (feeAsset) item.parseOperations.fees.push(_helper2.default.getFullNum(feeObj.amount / Math.pow(10, feeAsset.precision)) + " " + feeAsset.symbol);

          case 54:
            _i++;
            _context3.next = 48;
            break;

          case 57:

            // let feeObj=item.payload.fee;
            // if(feeObj){
            //   let feeAsset=await API.Assets.fetch([feeObj.asset_id],true);
            //   if(feeAsset)
            //   item.parseOperations.fee=helper.getFullNum(feeObj.amount/Math.pow(10,feeAsset.precision))+" "+feeAsset.symbol;
            // }

            trxType = "trxTypes_" + item.type;

            if (trxType in _zh2.default) {
              item.typeName = _locales[_store.rootGetters["setting/defaultSettings"].locale][trxType];
            }

          case 59:
            i++;
            _context3.next = 35;
            break;

          case 62:
            if (!isContract) {
              _context3.next = 66;
              break;
            }

            delete parsedOperations.id;
            delete parsedOperations.date;
            return _context3.abrupt('return', parsedOperations.map(function (item) {
              item.parse_operations = item.parseOperations;
              item.parse_operations_text = item.parseOperationsText;
              item.raw_data = item.payload;
              item.type_name = item.typeName;

              delete item.parseOperations;
              delete item.parseOperationsText;
              delete item.payload;
              delete item.typeName;
              return item;
            }));

          case 66:
            return _context3.abrupt('return', {
              operations: parsedOperations.map(function (item) {
                item.parse_operations = item.parseOperations;
                // item.parse_operations.fees=JSON.parse(item.parse_operations.fees);
                item.parse_operations_text = item.parseOperationsText;
                item.raw_data = item.payload;
                item.type_name = item.typeName;

                delete item.parseOperations;
                delete item.parseOperationsText;
                delete item.payload;
                delete item.typeName;
                return item;
              })
              // ,
              // assetsIds
            });

          case 67:
          case 'end':
            return _context3.stop();
        }
      }
    }, null, undefined);
  },

  getParseOperations: function getParseOperations(op) {
    var o, base2, quote2, _market_utils$getMark, first2, second2, isBid2, priceBase, priceQuote, amount, receivedAmount, base, quote, _market_utils$getMark2, first, second, isBid, contract, action, value_list_jsons, v, types, proposal_create, proposalOp, proposal_content, restricted_type_text, start_time, crontab_create, crontabOp, crontab_content, restart_time;

    return _regenerator2.default.async(function getParseOperations$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            o = void 0;
            _context4.t0 = op.type;
            _context4.next = _context4.t0 === "transfer" ? 4 : _context4.t0 === "account_create" ? 8 : _context4.t0 === "account_update" ? 12 : _context4.t0 === "account_upgrade" ? 16 : _context4.t0 === "witness_create" ? 20 : _context4.t0 === "committee_member_create" ? 24 : _context4.t0 === "witness_update" ? 28 : _context4.t0 === "committee_member_update" ? 32 : _context4.t0 === "fill_order" ? 36 : _context4.t0 === "limit_order_create" ? 49 : _context4.t0 === "limit_order_cancel" ? 58 : _context4.t0 === "call_order_update" ? 62 : _context4.t0 === "vesting_balance_withdraw" ? 66 : _context4.t0 === "call_contract_function" ? 70 : _context4.t0 === "contract_create" ? 82 : _context4.t0 === "revise_contract" ? 86 : _context4.t0 === "register_nh_asset_creator" ? 90 : _context4.t0 === "create_world_view" ? 94 : _context4.t0 === "create_nh_asset" ? 98 : _context4.t0 === "delete_nh_asset" ? 104 : _context4.t0 === "transfer_nh_asset" ? 108 : _context4.t0 === "relate_nh_asset" ? 112 : _context4.t0 === "create_nh_asset_order" ? 116 : _context4.t0 === "cancel_nh_asset_order" ? 120 : _context4.t0 === "fill_nh_asset_order" ? 124 : _context4.t0 === "relate_world_view" ? 128 : _context4.t0 === "proposal_create" ? 132 : _context4.t0 === "committee_member_update_global_parameters" ? 142 : _context4.t0 === "proposal_update" ? 146 : _context4.t0 === "contract_affecteds_nh_transfer_from" ? 150 : _context4.t0 === "contract_affecteds_nh_transfer_to" ? 154 : _context4.t0 === "contract_affecteds_nh_modifined" ? 158 : _context4.t0 === "contract_affecteds_asset" ? 162 : _context4.t0 === "contract_affecteds_log" ? 166 : _context4.t0 === "asset_create" ? 170 : _context4.t0 === "asset_update_bitasset" ? 174 : _context4.t0 === "asset_update" ? 174 : _context4.t0 === "asset_update_restricted" ? 178 : _context4.t0 === "asset_issue" ? 183 : _context4.t0 === "asset_reserve" ? 187 : _context4.t0 === "asset_fund_fee_pool" ? 191 : _context4.t0 === "asset_publish_feed" ? 195 : _context4.t0 === "asset_global_settle" ? 199 : _context4.t0 === "asset_settle" ? 203 : _context4.t0 === "asset_settle_cancel" ? 207 : _context4.t0 === "vesting_balance_create" ? 211 : _context4.t0 === "asset_update_feed_producers" ? 215 : _context4.t0 === "asset_claim_fees" ? 219 : _context4.t0 === "crontab_create" ? 223 : _context4.t0 === "crontab_cancel" ? 237 : _context4.t0 === "crontab_recover" ? 241 : _context4.t0 === "update_collateral_for_gas" ? 247 : 251;
            break;

          case 4:
            _context4.next = 6;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_transfer", [{ type: "account", value: op.payload.from, arg: "from" }, {
              type: "amount",
              value: op.payload.amount,
              arg: "amount",
              decimalOffset: op.payload.amount.asset_id === "1.3.0" ? 0 : null
            }, { type: "account", value: op.payload.to, arg: "to" }]));

          case 6:
            return _context4.abrupt('return', _context4.sent);

          case 8:
            _context4.next = 10;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_reg_account", [{ type: "account", value: op.payload.registrar, arg: "registrar" }, { type: "account", value: op.payload.name, arg: "new_account" }]));

          case 10:
            return _context4.abrupt('return', _context4.sent);

          case 12:
            _context4.next = 14;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_update_account", [{ type: "account", value: op.payload.account, arg: "account" }]));

          case 14:
            return _context4.abrupt('return', _context4.sent);

          case 16:
            _context4.next = 18;
            return _regenerator2.default.awrap(Operations.getTranslateInfo(op.payload.upgrade_to_lifetime_member ? "operation_lifetime_upgrade_account" : "operation_annual_upgrade_account", [{ type: "account", value: op.payload.account_to_upgrade, arg: "account" }]));

          case 18:
            return _context4.abrupt('return', _context4.sent);

          case 20:
            _context4.next = 22;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_witness_create", [{ type: "account", value: op.payload.witness_account, arg: "account" }]));

          case 22:
            return _context4.abrupt('return', _context4.sent);

          case 24:
            _context4.next = 26;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_committee_member_create", [{ type: "account", value: op.payload.committee_member_account, arg: "account" }]));

          case 26:
            return _context4.abrupt('return', _context4.sent);

          case 28:
            _context4.next = 30;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_witness_update", [{ type: "account", value: op.payload.witness_account, arg: "account" }]));

          case 30:
            return _context4.abrupt('return', _context4.sent);

          case 32:
            _context4.next = 34;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_committee_member_update", [{ type: "account", value: op.payload.committee_member_account, arg: "account" }]));

          case 34:
            return _context4.abrupt('return', _context4.sent);

          case 36:
            o = op.payload;
            // let receivedAmount = o.fee.asset_id === o.receives.asset_id ? o.receives.amount - o.fee.amount : o.receives.amount;
            base2 = o.receives.asset_id;
            quote2 = o.pays.asset_id;
            _market_utils$getMark = _market_utils2.default.getMarketName(base2, quote2), first2 = _market_utils$getMark.first2, second2 = _market_utils$getMark.second2;
            isBid2 = o.pays.asset_id === second2;
            priceBase = isBid2 ? o.receives : o.pays;
            priceQuote = isBid2 ? o.pays : o.receives;
            amount = isBid2 ? o.pays : o.receives;
            receivedAmount = amount.amount;
            // o.fee.asset_id === amount.asset_id
            //     ? amount.amount - o.fee.amount
            //     : amount.amount;

            _context4.next = 47;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_fill_order", [{ type: "account", value: o.account_id, arg: "account" }, {
              type: "amount",
              value: { amount: receivedAmount, asset_id: amount.asset_id },
              arg: "received",
              decimalOffset: o.receives.asset_id === "1.3.0" ? 3 : null
            }, { type: "price", value: { base: priceBase, quote: priceQuote }, arg: "price" }]));

          case 47:
            return _context4.abrupt('return', _context4.sent);

          case 49:
            o = op.payload;
            // let isAsk = market_utils.isAskOp(o);
            base = o.min_to_receive.asset_id;
            quote = o.amount_to_sell.asset_id;
            _market_utils$getMark2 = _market_utils2.default.getMarketName(base, quote), first = _market_utils$getMark2.first, second = _market_utils$getMark2.second;
            isBid = o.amount_to_sell.asset_id === second;
            _context4.next = 56;
            return _regenerator2.default.awrap(Operations.getTranslateInfo(isBid ? "operation_limit_order_buy" : "operation_limit_order_sell", [{ type: "account", value: o.seller, arg: "account" }, {
              type: "amount",
              value: isBid ? o.min_to_receive : o.amount_to_sell,
              arg: "amount"
            }, {
              type: "price",
              value: {
                base: isBid ? o.amount_to_sell : o.min_to_receive,
                quote: isBid ? o.min_to_receive : o.amount_to_sell
              },
              arg: "price"
            }]));

          case 56:
            return _context4.abrupt('return', _context4.sent);

          case 58:
            _context4.next = 60;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_limit_order_cancel", [{ type: "account", value: op.payload.fee_paying_account, arg: "account" }, { type: 'order', value: op.payload.order.substring(4), arg: 'order' }]));

          case 60:
            return _context4.abrupt('return', _context4.sent);

          case 62:
            _context4.next = 64;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_call_order_update", [{ type: "account", value: op.payload.funding_account, arg: "account" }, { type: "asset", value: op.payload.delta_debt.asset_id, arg: "debtSymbol" }, { type: "amount", value: op.payload.delta_debt, arg: "debt" }, { type: "amount", value: op.payload.delta_collateral, arg: "collateral" }]));

          case 64:
            return _context4.abrupt('return', _context4.sent);

          case 66:
            _context4.next = 68;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_vesting_balance_withdraw", [{ type: "account", value: op.payload.owner, arg: "account" }, { type: "amount", value: op.payload.amount, arg: "amount" }, { type: "vesting_balance", value: op.payload.vesting_balance, arg: "vesting_balance_id" }]));

          case 68:
            return _context4.abrupt('return', _context4.sent);

          case 70:
            _context4.next = 72;
            return _regenerator2.default.awrap(_store.dispatch("contract/getContract", { nameOrId: op.payload.contract_id, isCache: true }, { root: true }));

          case 72:
            contract = _context4.sent.data;
            action = contract ? contract.abi_actions.find(function (item) {
              return item.name == op.payload.function_name;
            }) : null;
            value_list_jsons = {}; //use parameters as keyname and merge values into a Json string

            v = "";

            if (action) {
              action.arglist.forEach(function (arg, index) {
                var v_l_item = op.payload.value_list[index];
                if (v_l_item) {
                  v = v_l_item[1].v;
                  if (Array.isArray(v)) {
                    v = _helper2.default.formatTable(v);
                  }
                  value_list_jsons[arg] = v;
                }
              });
            } else {
              value_list_jsons = op.payload.value_list.map(function (item) {
                return item[1].v;
              });
            }

            value_list_jsons = (0, _stringify2.default)(value_list_jsons);

            _context4.next = 80;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_call_contract_function", [{ type: "account", value: op.payload.caller, arg: "caller" }, { type: "contract_name", value: contract.contract_name, arg: "contract_name" }, { type: "function_name", value: op.payload.function_name, arg: "function_name" }, { type: "value_list", value: value_list_jsons, arg: "arg_list" }]));

          case 80:
            return _context4.abrupt('return', _context4.sent);

          case 82:
            _context4.next = 84;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_contract_create", [{ type: "account", value: op.payload.owner, arg: "owner" }, { type: "contract_name", value: op.payload.name, arg: "contract_name"
              // ,
              // {type: "contract_data", value: op.payload.data, arg: "contract_data"}
            }]));

          case 84:
            return _context4.abrupt('return', _context4.sent);

          case 86:
            _context4.next = 88;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_revise_contract", [{ type: "account", value: op.payload.reviser, arg: "reviser" }, { type: "contract_id", value: op.payload.contract_id, arg: "contract_name" }]));

          case 88:
            return _context4.abrupt('return', _context4.sent);

          case 90:
            _context4.next = 92;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_register_nh_asset_creator", [{ type: "account", value: op.payload.fee_paying_account, arg: "fee_paying_account" }]));

          case 92:
            return _context4.abrupt('return', _context4.sent);

          case 94:
            _context4.next = 96;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_create_world_view", [{ type: "account", value: op.payload.fee_paying_account, arg: "fee_paying_account" }, { type: "world_view", value: op.payload.world_view, arg: "world_view" }]));

          case 96:
            return _context4.abrupt('return', _context4.sent);

          case 98:
            types = [{ type: "account", value: op.payload.fee_paying_account, arg: "fee_paying_account" }, { type: "account", value: op.payload.owner, arg: "owner" }];

            if (op.result) {
              types.push({ type: "nh_asset", value: op.result.result, arg: "nh_asset" });
            }
            _context4.next = 102;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_create_nh_asset", types));

          case 102:
            return _context4.abrupt('return', _context4.sent);

          case 104:
            _context4.next = 106;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_delete_nh_asset", [{ type: "account", value: op.payload.fee_paying_account, arg: "fee_paying_account" }, { type: "nh_asset", value: op.payload.nh_asset, arg: "nh_asset" }]));

          case 106:
            return _context4.abrupt('return', _context4.sent);

          case 108:
            _context4.next = 110;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_transfer_nh_asset", [{ type: "account", value: op.payload.from, arg: "from" }, { type: "account", value: op.payload.to, arg: "to" }, { type: "nh_asset", value: op.payload.nh_asset, arg: "nh_asset" }]));

          case 110:
            return _context4.abrupt('return', _context4.sent);

          case 112:
            _context4.next = 114;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_relate_nh_asset", [{ type: "account", value: op.payload.nh_asset_creator, arg: "nh_asset_creator" }, { type: "relate", value: op.payload.relate ? "å°†" : "å–æ¶ˆ", arg: "relate" }, { type: "nh_asset", value: op.payload.parent, arg: "nh_asset" }, { type: "nh_asset", value: op.payload.child, arg: "nh_asset" }]));

          case 114:
            return _context4.abrupt('return', _context4.sent);

          case 116:
            _context4.next = 118;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_create_nh_asset_order", [{ type: "account", value: op.payload.seller, arg: "seller" }, { type: "nh_asset", value: op.payload.nh_asset, arg: "nh_asset" }, {
              type: "amount",
              value: op.payload.price,
              arg: "amount"
            }, {
              type: "amount",
              value: op.payload.pending_orders_fee,
              arg: "pending_orders_fee"
            }]));

          case 118:
            return _context4.abrupt('return', _context4.sent);

          case 120:
            _context4.next = 122;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_cancel_nh_asset_order", [{ type: "account", value: op.payload.fee_paying_account, arg: "fee_paying_account" }, { type: "order", value: op.payload.order, arg: "order" }]));

          case 122:
            return _context4.abrupt('return', _context4.sent);

          case 124:
            _context4.next = 126;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_fill_nh_asset_order", [{ type: "account", value: op.payload.fee_paying_account, arg: "fee_paying_account" }, { type: "price_amount", value: op.payload.price_amount, arg: "price_amount" }, { type: "price_asset_symbol", value: op.payload.price_asset_symbol, arg: "price_asset_symbol" }, { type: "account", value: op.payload.seller, arg: "seller" }, { type: "nh_asset", value: op.payload.nh_asset, arg: "nh_asset" }]));

          case 126:
            return _context4.abrupt('return', _context4.sent);

          case 128:
            _context4.next = 130;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_relate_world_view", [{ type: "account", value: op.payload.related_account, arg: "related_account" }, { type: "account", value: op.payload.view_owner, arg: "view_owner" }, { type: "world_view", value: op.payload.world_view, arg: "world_view" }]));

          case 130:
            return _context4.abrupt('return', _context4.sent);

          case 132:
            _context4.next = 134;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_proposal_create", [{ type: "account", value: op.payload.fee_paying_account, arg: "fee_paying_account" }, { type: "result", value: op.result.result, arg: "result" }]));

          case 134:
            proposal_create = _context4.sent;
            proposalOp = op.payload.proposed_ops[0].op;

            proposalOp = {
              account: op.payload.fee_paying_account,
              payload: proposalOp[1],
              type: Operations._operationTypes[proposalOp[0]]
            };

            _context4.next = 139;
            return _regenerator2.default.awrap(Operations.getParseOperations(proposalOp));

          case 139:
            proposal_content = _context4.sent;
            return _context4.abrupt('return', {
              opText: proposal_create.opText.concat(proposal_content.opText),
              opObj: (0, _extends3.default)({}, proposal_create.opObj, proposal_content.opObj)
            });

          case 142:
            _context4.next = 144;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_committee_member_update_global_parameters", [{ type: "account", value: op.account, arg: "account" }]));

          case 144:
            return _context4.abrupt('return', _context4.sent);

          case 146:
            _context4.next = 148;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_proposal_update", [{ type: "account", value: op.payload.fee_paying_account, arg: "fee_paying_account" }, { type: "proposal", value: op.payload.proposal, arg: "proposal" }]));

          case 148:
            return _context4.abrupt('return', _context4.sent);

          case 150:
            _context4.next = 152;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("contract_affecteds_nh_transfer_from", [{ type: "account", value: op.payload.affected_account, arg: "affected_account" }, { type: "affected_item", value: op.payload.affected_item, arg: "affected_item" }]));

          case 152:
            return _context4.abrupt('return', _context4.sent);

          case 154:
            _context4.next = 156;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("contract_affecteds_nh_transfer_to", [{ type: "account", value: op.payload.affected_account, arg: "affected_account" }, { type: "affected_item", value: op.payload.affected_item, arg: "affected_item" }]));

          case 156:
            return _context4.abrupt('return', _context4.sent);

          case 158:
            _context4.next = 160;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("contract_affecteds_nh_modifined", [{ type: "account", value: op.payload.affected_account, arg: "affected_account" }, { type: "affected_item", value: op.payload.affected_item, arg: "affected_item" }, { type: "modified", value: op.payload.modified, arg: "modified" }]));

          case 160:
            return _context4.abrupt('return', _context4.sent);

          case 162:
            _context4.next = 164;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("contract_affecteds_asset", [{ type: "account", value: op.payload.affected_account, arg: "affected_account" }, {
              type: "amount",
              value: op.payload.affected_asset,
              arg: "aseet_amount",
              decimalOffset: op.payload.affected_asset.asset_id === "1.3.0" ? 0 : null
            }]));

          case 164:
            return _context4.abrupt('return', _context4.sent);

          case 166:
            _context4.next = 168;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("contract_affecteds_log", [{ type: "account", value: op.payload.affected_account, arg: "affected_account" }, {
              type: "message",
              value: op.payload.message,
              arg: "message"
            }]));

          case 168:
            return _context4.abrupt('return', _context4.sent);

          case 170:
            _context4.next = 172;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_asset_create", [{ type: "account", value: op.payload.issuer, arg: "account" }, { type: "symbol", value: op.payload.symbol, arg: "asset" }]));

          case 172:
            return _context4.abrupt('return', _context4.sent);

          case 174:
            _context4.next = 176;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_asset_update", [{ type: "account", value: op.payload.issuer, arg: "account" }, { type: "asset", value: op.payload.asset_to_update, arg: "asset" }]));

          case 176:
            return _context4.abrupt('return', _context4.sent);

          case 178:
            restricted_type_text = _locales[_store.rootGetters["setting/defaultSettings"].locale]["restricted_type_" + op.payload.restricted_type];
            _context4.next = 181;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_asset_update_restricted", [{ type: "account", value: op.payload.payer, arg: "payer" }, { type: "asset", value: op.payload.target_asset, arg: "target_asset" }, { type: "restricted_type", value: restricted_type_text, arg: "restricted_type_text" }]));

          case 181:
            return _context4.abrupt('return', _context4.sent);

          case 183:
            _context4.next = 185;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_asset_issue", [{ type: "account", value: op.payload.issuer, arg: "account" }, {
              type: "amount",
              value: op.payload.asset_to_issue,
              arg: "amount",
              decimalOffset: op.payload.asset_to_issue.asset_id === "1.3.0" ? 0 : null
            }, { type: "account", value: op.payload.issue_to_account, arg: "to" }]));

          case 185:
            return _context4.abrupt('return', _context4.sent);

          case 187:
            _context4.next = 189;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_asset_reserve", [{ type: "account", value: op.payload.payer, arg: "account" }, {
              type: "amount",
              value: op.payload.amount_to_reserve,
              arg: "amount"
            }]));

          case 189:
            return _context4.abrupt('return', _context4.sent);

          case 191:
            _context4.next = 193;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_asset_fund_fee_pool", [{ type: "account", value: op.payload.from_account, arg: "account" }, {
              type: "amount",
              value: { amount: op.payload.amount, asset_id: "1.3.0" },
              arg: "amount"
            }, { type: "asset", value: op.payload.asset_id, arg: "asset" }]));

          case 193:
            return _context4.abrupt('return', _context4.sent);

          case 195:
            _context4.next = 197;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_asset_publish_feed", [{ type: "account", value: op.payload.publisher, arg: "account" }, { type: "price", value: op.payload.feed.settlement_price, arg: "price" }]));

          case 197:
            return _context4.abrupt('return', _context4.sent);

          case 199:
            _context4.next = 201;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_asset_global_settle", [{ type: "account", value: op.payload.issuer, arg: "account" }, { type: "price", value: op.payload.settle_price, arg: "price" }, { type: "asset", value: op.payload.asset_to_settle, arg: "asset" }]));

          case 201:
            return _context4.abrupt('return', _context4.sent);

          case 203:
            _context4.next = 205;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_asset_settle", [{ type: "account", value: op.payload.account, arg: "account" }, { type: "amount", value: op.payload.amount, arg: "amount" }]));

          case 205:
            return _context4.abrupt('return', _context4.sent);

          case 207:
            _context4.next = 209;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_asset_settle_cancel", [{ type: "account", value: op.payload.creator, arg: "account" }, { type: "amount", value: op.payload.amount, arg: "amount" }]));

          case 209:
            return _context4.abrupt('return', _context4.sent);

          case 211:
            _context4.next = 213;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_vesting_balance_create", [{ type: "account", value: op.payload.creator, arg: "account" }, { type: "amount", value: op.payload.amount, arg: "amount" }]));

          case 213:
            return _context4.abrupt('return', _context4.sent);

          case 215:
            _context4.next = 217;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_asset_update_feed_producers", [{ type: "account", value: op.payload.issuer, arg: "account" }, { type: "asset", value: op.payload.asset_to_update, arg: "asset" }]));

          case 217:
            return _context4.abrupt('return', _context4.sent);

          case 219:
            _context4.next = 221;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_asset_claim_fees", [{ type: "account", value: op.payload.issuer, arg: "account" }, {
              type: "amount",
              value: op.payload.amount_to_claim,
              arg: "balance_amount"
            }, { type: "asset", value: op.payload.amount_to_claim.asset_id, arg: "asset" }]));

          case 221:
            return _context4.abrupt('return', _context4.sent);

          case 223:
            start_time = op.payload.start_time;

            start_time = new Date(start_time + "Z").format("yyyy/MM/dd HH:mm:ss");
            if (op.type == "void_result") {
              op.result = {
                result: "void_result"
              };
            }
            if (!op.result) {
              op.result = {
                result: "***"
              };
            }
            _context4.next = 229;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_crontab_create", [{ type: "account", value: op.payload.crontab_creator, arg: "crontab_creator" }, { type: "start_time", value: start_time, arg: "start_time" }, { type: "execute_interval", value: op.payload.execute_interval, arg: "execute_interval" }, { type: "execute_times", value: op.payload.scheduled_execute_times, arg: "execute_times" }, { type: "result", value: op.result.result, arg: "result" }]));

          case 229:
            crontab_create = _context4.sent;
            crontabOp = op.payload.crontab_ops[0].op;

            crontabOp = {
              payload: crontabOp[1],
              type: Operations._operationTypes[crontabOp[0]]
            };

            _context4.next = 234;
            return _regenerator2.default.awrap(Operations.getParseOperations(crontabOp));

          case 234:
            crontab_content = _context4.sent;
            return _context4.abrupt('return', {
              opText: crontab_create.opText.concat(crontab_content.opText),
              opObj: (0, _extends3.default)({}, crontab_create.opObj, crontab_content.opObj)
            });

          case 237:
            _context4.next = 239;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_crontab_cancel", [{ type: "account", value: op.payload.fee_paying_account, arg: "fee_paying_account" }, { type: "task", value: op.payload.task, arg: "task" }]));

          case 239:
            return _context4.abrupt('return', _context4.sent);

          case 241:
            restart_time = op.payload.restart_time;

            restart_time = new Date(restart_time + "Z").format("yyyy/MM/dd HH:mm:ss");
            _context4.next = 245;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_crontab_recover", [{ type: "account", value: op.payload.crontab_owner, arg: "crontab_owner" }, { type: "crontab", value: op.payload.crontab, arg: "crontab" }, { type: "restart_time", value: restart_time, arg: "restart_time" }]));

          case 245:
            return _context4.abrupt('return', _context4.sent);

          case 247:
            _context4.next = 249;
            return _regenerator2.default.awrap(Operations.getTranslateInfo("operation_update_collateral_for_gas", [{ type: "account", value: op.payload.mortgager, arg: "mortgager" }, { type: "account", value: op.payload.beneficiary, arg: "beneficiary" }, {
              type: "amount",
              value: {
                amount: op.payload.collateral,
                asset_id: "1.3.0"
              },
              arg: "collateral"
            }]));

          case 249:
            return _context4.abrupt('return', _context4.sent);

          case 251:
          case 'end':
            return _context4.stop();
        }
      }
    }, null, undefined);
  },
  getTranslateInfo: function getTranslateInfo(localId, keys) {
    var lang, text, splitText, key, opObj, i, value;
    return _regenerator2.default.async(function getTranslateInfo$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            lang = _store.rootGetters["setting/defaultSettings"].locale;
            text = _locales[lang][localId];

            if (localId == "operation_create_nh_asset" && keys.length == 2) {
              text = lang == 'en' ? '(fee_paying_account) Create NH assets with ownership account (owner)' : "(fee_paying_account) åˆ›å»ºNHèµ„äº§ï¼Œæ‰€æœ‰æƒè´¦æˆ·ä¸º (owner)";
            }
            splitText = _utils2.default.get_translation_parts(text);
            key = void 0;
            opObj = {};
            i = 0;

          case 7:
            if (!(i < keys.length)) {
              _context6.next = 19;
              break;
            }

            key = keys[i];

            if (!splitText.indexOf(key.arg)) {
              _context6.next = 16;
              break;
            }

            value = key.value;
            _context6.next = 13;
            return _regenerator2.default.awrap(function _callee() {
              var acc_res, asset, amount, response, item_data;
              return _regenerator2.default.async(function _callee$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      _context5.t0 = key.type;
                      _context5.next = _context5.t0 === "account" ? 3 : _context5.t0 === "asset" ? 9 : _context5.t0 === "amount" ? 15 : _context5.t0 === "price" ? 20 : _context5.t0 === "contract_id" ? 24 : _context5.t0 === "modified" ? 29 : 34;
                      break;

                    case 3:
                      if (!/^1.2.\d+/.test(key.value)) {
                        _context5.next = 8;
                        break;
                      }

                      _context5.next = 6;
                      return _regenerator2.default.awrap(_api2.default.Account.getAccount(key.value, true));

                    case 6:
                      acc_res = _context5.sent;

                      if (acc_res.success) {
                        value = acc_res.data.account.name;
                      }

                    case 8:
                      return _context5.abrupt('break', 36);

                    case 9:
                      _context5.next = 11;
                      return _regenerator2.default.awrap(_api2.default.Assets.fetch([key.value], true));

                    case 11:
                      asset = _context5.sent;

                      if (!asset) {
                        console.log("é“¾ä¸Šä¸å­˜åœ¨èµ„äº§" + asset_id);
                      }
                      value = asset ? asset.symbol : asset;
                      return _context5.abrupt('break', 36);

                    case 15:
                      _context5.next = 17;
                      return _regenerator2.default.awrap(Operations.FormattedAsset(key.value.amount, key.value.asset_id, key.decimalOffset));

                    case 17:
                      value = _context5.sent;

                      if (localId == "contract_affecteds_asset") {
                        amount = Number(value.split(" ")[0]);

                        if (amount > 0) {
                          value = "+" + value;
                        }
                      }
                      return _context5.abrupt('break', 36);

                    case 20:
                      _context5.next = 22;
                      return _regenerator2.default.awrap(Operations.FormattedPrice({
                        base_asset: key.value.base.asset_id,
                        base_amount: key.value.base.amount,
                        quote_asset: key.value.quote.asset_id,
                        quote_amount: key.value.quote.amount
                      }));

                    case 22:
                      value = _context5.sent;
                      return _context5.abrupt('break', 36);

                    case 24:
                      _context5.next = 26;
                      return _regenerator2.default.awrap(_api2.default.Contract.getContract(key.value, true));

                    case 26:
                      response = _context5.sent;

                      if (response.code == 1) {
                        value = response.data.name;
                      } else {
                        value = key.value;
                      }
                      return _context5.abrupt('break', 36);

                    case 29:
                      item_data = {};

                      value = [value];
                      value.forEach(function (keyValue) {
                        item_data[keyValue[0]] = keyValue[1];
                      });
                      value = (0, _stringify2.default)(item_data);
                      return _context5.abrupt('break', 36);

                    case 34:
                      value = key.value;
                      return _context5.abrupt('break', 36);

                    case 36:
                    case 'end':
                      return _context5.stop();
                  }
                }
              }, null, undefined);
            }());

          case 13:

            splitText[splitText.indexOf(key.arg)] = value;
            opObj[key.arg] = value;
            if (key.type == "value_list") {
              opObj[key.arg] = JSON.parse(value);
            }

          case 16:
            i++;
            _context6.next = 7;
            break;

          case 19:
            return _context6.abrupt('return', {
              opText: splitText,
              opObj: opObj
              //return splitText;
            });

          case 20:
          case 'end':
            return _context6.stop();
        }
      }
    }, null, undefined);
  },
  FormattedPrice: function FormattedPrice(_ref2) {
    var base_asset = _ref2.base_asset,
        base_amount = _ref2.base_amount,
        quote_asset = _ref2.quote_asset,
        quote_amount = _ref2.quote_amount;
    var assets, base_precision, quote_precision, value;
    return _regenerator2.default.async(function FormattedPrice$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            // let marketId=quote_asset+"_"+base_asset;
            assets = _store.rootGetters["assets/getAssets"];

            if (!(assets && assets[base_asset] && assets[quote_asset])) {
              _context7.next = 6;
              break;
            }

            base_asset = assets[base_asset];
            quote_asset = assets[quote_asset];
            _context7.next = 22;
            break;

          case 6:
            if (!_api2.default.Assets.fetch_asset_by_cache(base_asset)) {
              _context7.next = 10;
              break;
            }

            base_asset = _api2.default.Assets.fetch_asset_by_cache(base_asset);
            _context7.next = 14;
            break;

          case 10:
            _context7.next = 12;
            return _regenerator2.default.awrap(_api2.default.Assets.fetch([base_asset], true));

          case 12:
            base_asset = _context7.sent;

            if (!base_asset) {
              base_asset = { precision: 8, symbol: "1.3.0" };
            }

          case 14:
            if (!_api2.default.Assets.fetch_asset_by_cache(quote_asset)) {
              _context7.next = 18;
              break;
            }

            quote_asset = _api2.default.Assets.fetch_asset_by_cache(quote_asset);
            _context7.next = 22;
            break;

          case 18:
            _context7.next = 20;
            return _regenerator2.default.awrap(_api2.default.Assets.fetch([quote_asset], true));

          case 20:
            quote_asset = _context7.sent;

            if (!quote_asset) {
              quote_asset = { precision: 8, symbol: "1.3.0" };
            }

          case 22:
            base_precision = _utils2.default.get_asset_precision(base_asset.precision);
            quote_precision = _utils2.default.get_asset_precision(quote_asset.precision);
            value = base_amount / base_precision / (quote_amount / quote_precision);

            value = Number(value.toFixed(base_asset.precision));
            return _context7.abrupt('return', value + " " + base_asset.symbol + "/" + quote_asset.symbol);

          case 27:
          case 'end':
            return _context7.stop();
        }
      }
    }, null, undefined);
  },
  FormattedAsset: function FormattedAsset(amount, asset_id, decimalOffset) {
    var asset;
    return _regenerator2.default.async(function FormattedAsset$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            _context8.next = 2;
            return _regenerator2.default.awrap(_api2.default.Assets.fetch([asset_id], true));

          case 2:
            asset = _context8.sent;

            if (!asset) {
              asset = { precision: 5, symbol: "1.3.0" };
            }
            return _context8.abrupt('return', _helper2.default.getFullNum(amount / Math.pow(10, asset.precision)) + " " + asset.symbol);

          case 5:
          case 'end':
            return _context8.stop();
        }
      }
    }, null, undefined);
  },
  // retrieves array of assets ids that were used in operations


  // fetches user's operations
  getUserOperations: function getUserOperations(_ref3) {
    var userId = _ref3.userId,
        _ref3$startId = _ref3.startId,
        startId = _ref3$startId === undefined ? "1.11.0" : _ref3$startId,
        _ref3$endId = _ref3.endId,
        endId = _ref3$endId === undefined ? "1.11.0" : _ref3$endId,
        limit = _ref3.limit,
        store = _ref3.store;
    var response, parsedOperations;
    return _regenerator2.default.async(function getUserOperations$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            _context9.prev = 0;
            _context9.next = 3;
            return _regenerator2.default.awrap(_bcxjsWs.Apis.instance().history_api().exec('get_account_history', [userId, startId, limit, endId]));

          case 3:
            response = _context9.sent;

            if (!(response && (typeof response === 'undefined' ? 'undefined' : (0, _typeof3.default)(response)) === 'object')) {
              _context9.next = 9;
              break;
            }

            _context9.next = 7;
            return _regenerator2.default.awrap(Operations.parseOperations({ operations: response, store: store }));

          case 7:
            parsedOperations = _context9.sent;
            return _context9.abrupt('return', {
              code: 1,
              data: parsedOperations
            });

          case 9:
            return _context9.abrupt('return', {
              code: 120,
              message: 'Error fetching account record',
              error: 'Error fetching account record'
            });

          case 12:
            _context9.prev = 12;
            _context9.t0 = _context9['catch'](0);
            return _context9.abrupt('return', {
              code: 0,
              message: _context9.t0.message,
              error: _context9.t0
            });

          case 15:
          case 'end':
            return _context9.stop();
        }
      }
    }, null, undefined, [[0, 12]]);
  },
  get_block_header: function get_block_header(block_num) {
    var response, res;
    return _regenerator2.default.async(function get_block_header$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            _context10.prev = 0;

            if (!(block_num in _cacheBlocks)) {
              _context10.next = 5;
              break;
            }

            if (!_cacheBlocks[block_num]) {
              _context10.next = 4;
              break;
            }

            return _context10.abrupt('return', _cacheBlocks[block_num]);

          case 4:
            return _context10.abrupt('return', { code: 0 });

          case 5:
            _cacheBlocks[block_num] = "";
            _context10.next = 8;
            return _regenerator2.default.awrap(_bcxjsWs.Apis.instance().db_api().exec("get_block_header", [block_num]));

          case 8:
            response = _context10.sent;

            if (!(response && (typeof response === 'undefined' ? 'undefined' : (0, _typeof3.default)(response)) === 'object')) {
              _context10.next = 13;
              break;
            }

            res = {
              code: 1,
              data: response
            };

            _cacheBlocks[block_num] = res;
            return _context10.abrupt('return', res);

          case 13:
            return _context10.abrupt('return', {
              code: 121,
              message: 'block and transaction information cannot be found'
            });

          case 16:
            _context10.prev = 16;
            _context10.t0 = _context10['catch'](0);
            return _context10.abrupt('return', {
              code: 0,
              message: _context10.t0.message,
              error: _context10.t0
            });

          case 19:
          case 'end':
            return _context10.stop();
        }
      }
    }, null, undefined, [[0, 16]]);
  },
  getBlock: function getBlock(block_num) {
    var response;
    return _regenerator2.default.async(function getBlock$(_context11) {
      while (1) {
        switch (_context11.prev = _context11.next) {
          case 0:
            _context11.prev = 0;
            _context11.next = 3;
            return _regenerator2.default.awrap(_bcxjsWs.Apis.instance().db_api().exec("get_block", [block_num]));

          case 3:
            response = _context11.sent;

            if (!(response && (typeof response === 'undefined' ? 'undefined' : (0, _typeof3.default)(response)) === 'object')) {
              _context11.next = 6;
              break;
            }

            return _context11.abrupt('return', {
              code: 1,
              data: response
            });

          case 6:
            return _context11.abrupt('return', {
              code: 121,
              message: 'block and transaction information cannot be found'
            });

          case 9:
            _context11.prev = 9;
            _context11.t0 = _context11['catch'](0);
            return _context11.abrupt('return', {
              code: 0,
              message: _context11.t0.message,
              error: _context11.t0
            });

          case 12:
          case 'end':
            return _context11.stop();
        }
      }
    }, null, undefined, [[0, 9]]);
  }
};

Operations.prepareOperationTypes();

exports.default = Operations;

/***/ }),
/* 515 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});

var _defineProperty2 = __webpack_require__(27);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _zh_CN;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var zh_CN = (_zh_CN = {
   trxTypes_transfer: "è½¬è´¦",
   trxTypes_limit_order_create: "é™ä»·å•",
   trxTypes_limit_order_cancel: "å–æ¶ˆé™ä»·å•",
   trxTypes_call_order_update: "æ›´æ–°è®¢å•",
   trxTypes_account_create: "åˆ›å»ºè´¦æˆ·",
   trxTypes_account_update: "æ›´æ–°è´¦æˆ·",
   trxTypes_account_whitelist: "è´¦æˆ·ç™½åå•",
   trxTypes_account_upgrade: "å‡çº§è´¦æˆ·",
   trxTypes_account_transfer: "è´¦æˆ·è½¬ç§»",
   trxTypes_asset_create: "åˆ›å»ºèµ„äº§",
   trxTypes_asset_update: "æ›´æ–°èµ„äº§",
   trxTypes_asset_update_restricted: "æ›´æ–°èµ„äº§å—é™åå•",
   trxTypes_asset_update_bitasset: "æ›´æ–°æ™ºèƒ½å¸",
   trxTypes_asset_update_feed_producers: "æ›´æ–°èµ„äº§å–‚ä»·è€…",
   trxTypes_asset_issue: "èµ„äº§å‘è¡Œ",
   trxTypes_asset_reserve: "é”€æ¯èµ„äº§",
   trxTypes_asset_fund_fee_pool: "ç§¯å­˜èµ„äº§è´¹ç”¨æ± ",
   trxTypes_asset_settle: "èµ„äº§ç»“ç®—",
   trxTypes_asset_global_settle: "å…¨å±€èµ„äº§æ¸…ç®—",
   trxTypes_asset_publish_feed: "å‘å¸ƒèµ„äº§å–‚ä»·",
   trxTypes_committee_member_create: "åˆ›å»ºç†äº‹ä¼šæˆå‘˜",
   trxTypes_witness_create: "åˆ›å»ºè§è¯äºº",
   trxTypes_witness_withdraw_pay: "é¢†å–è§è¯äººæŠ¥é…¬",
   trxTypes_proposal_create: "åˆ›å»ºæè®®",
   trxTypes_proposal_update: "æ›´æ–°æè®®",
   trxTypes_proposal_delete: "åˆ é™¤ææ¡ˆ",
   trxTypes_withdraw_permission_create: "åˆ›å»ºæå–æƒé™",
   trxTypes_withdraw_permission_update: "æ›´æ–°æå–æƒé™",
   trxTypes_withdraw_permission_claim: "ä¸»å¼ æå–æƒé™",
   trxTypes_withdraw_permission_delete: "åˆ é™¤æå–æƒé™",
   trxTypes_fill_order: "è®¢å•æ’®åˆ",
   trxTypes_delegate_update_global_parameters: "å…¨å±€å‚æ•°æ›´æ–°",
   trxTypes_vesting_balance_create: "åˆ›å»ºå†»ç»“è´¦ç›®ä½™é¢",
   trxTypes_vesting_balance_withdraw: "æå–è§£å†»è´¦æˆ·ä½™é¢",
   trxTypes_worker_create: "åˆ›å»ºé›‡å‘˜",
   trxTypes_custom: "è‡ªå®šä¹‰",
   trxTypes_assert: "æ–­è¨€æ“ä½œ",
   trxTypes_balance_claim: "é¢†å–ä½™é¢",
   trxTypes_override_transfer: "ä¼˜å…ˆè¦†ç›–è½¬è´¦",
   trxTypes_witness_update: "æ›´æ–°è§è¯äºº",
   trxTypes_committee_member_update_global_parameters: "å…¨å±€å‚æ•°æ›´æ–°",
   trxTypes_transfer_to_blind: "å‘éšç§è´¦æˆ·è½¬è´¦",
   trxTypes_blind_transfer: "éšç§è½¬è´¦",
   trxTypes_transfer_from_blind: "ä»Žéšç§è´¦æˆ·è½¬å‡º",
   trxTypes_committee_member_update: "æ›´æ–°ç†äº‹ä¼šæˆå‘˜",
   trxTypes_asset_claim_fees: "é¢†å–èµ„äº§æ‰‹ç»­è´¹"
}, (0, _defineProperty3.default)(_zh_CN, "trxTypes_asset_fund_fee_pool", "æ³¨èµ„èµ„äº§æ‰‹ç»­è´¹æ± "), (0, _defineProperty3.default)(_zh_CN, "trxTypes_call_contract_function", "åˆçº¦äº¤æ˜“"), (0, _defineProperty3.default)(_zh_CN, "trxTypes_contract_create", "åˆ›å»ºåˆçº¦"), (0, _defineProperty3.default)(_zh_CN, "trxTypes_revise_contract", "æ›´æ–°åˆçº¦"), (0, _defineProperty3.default)(_zh_CN, "trxTypes_register_nh_asset_creator", "æ³¨å†Œå¼€å‘è€…"), (0, _defineProperty3.default)(_zh_CN, "trxTypes_create_world_view", "åˆ›å»ºä¸–ç•Œè§‚"), (0, _defineProperty3.default)(_zh_CN, "trxTypes_create_nh_asset", "NHèµ„äº§åˆ›é€ "), (0, _defineProperty3.default)(_zh_CN, "trxTypes_delete_nh_asset", "NHèµ„äº§åˆ é™¤"), (0, _defineProperty3.default)(_zh_CN, "trxTypes_transfer_nh_asset", "NHèµ„äº§è½¬ç§»"), (0, _defineProperty3.default)(_zh_CN, "trxTypes_create_nh_asset_order", "NHèµ„äº§æŒ‚å–å•"), (0, _defineProperty3.default)(_zh_CN, "trxTypes_cancel_nh_asset_order", "NHèµ„äº§æŒ‚å–å•å–æ¶ˆ"), (0, _defineProperty3.default)(_zh_CN, "trxTypes_fill_nh_asset_order", "NHèµ„äº§è®¢å•æ’®åˆ"), (0, _defineProperty3.default)(_zh_CN, "trxTypes_relate_nh_asset", "NHèµ„äº§å…³è”"), (0, _defineProperty3.default)(_zh_CN, "trxTypes_relate_world_view", "å…³è”ä¸–ç•Œè§‚"), (0, _defineProperty3.default)(_zh_CN, "trxTypes_update_collateral_for_gas", "GASè°ƒæ•´è´¨æŠ¼ç‰©"), (0, _defineProperty3.default)(_zh_CN, "trxTypes_asset_settle_cancel", "èµ„äº§æ¸…ç®—å–æ¶ˆ"), (0, _defineProperty3.default)(_zh_CN, "trxTypes_contract_affecteds_asset", "èµ„äº§"), (0, _defineProperty3.default)(_zh_CN, "trxTypes_contract_affecteds_nh_transfer_from", "NHèµ„äº§è½¬å‡º"), (0, _defineProperty3.default)(_zh_CN, "trxTypes_contract_affecteds_nh_transfer_to", "NHèµ„äº§è½¬å…¥"), (0, _defineProperty3.default)(_zh_CN, "trxTypes_contract_affecteds_nh_modifined", "NHèµ„äº§æ•°æ®ä¿®æ”¹"), (0, _defineProperty3.default)(_zh_CN, "trxTypes_contract_affecteds_log", "æ—¥å¿—"), (0, _defineProperty3.default)(_zh_CN, "operation_set_proxy", "(account) è®¾ç½® (proxy) ä¸ºä»–çš„æŠ•ç¥¨ä»£ç†"), (0, _defineProperty3.default)(_zh_CN, "operation_annual_upgrade_account", "(account) å‡çº§åˆ°å¹´åº¦ä¼šå‘˜"), (0, _defineProperty3.default)(_zh_CN, "operation_unlisted_by", "(lister) å°† (listee) ç§»å‡ºæ¸…å•"), (0, _defineProperty3.default)(_zh_CN, "operation_whitelisted_by", "(lister) å°† (listee) åŠ å…¥ç™½åå•"), (0, _defineProperty3.default)(_zh_CN, "operation_blacklisted_by", "(lister) å°† (listee) åŠ å…¥é»‘åå•"), (0, _defineProperty3.default)(_zh_CN, "operation_asset_update_feed_producers", "(account) æ›´æ–°äº†èµ„äº§ (asset) çš„å–‚ä»·è€…"), (0, _defineProperty3.default)(_zh_CN, "operation_asset_settle", "(account) è¯·æ±‚æ¸…ç®— (amount)"), (0, _defineProperty3.default)(_zh_CN, "operation_asset_global_settle", "(account) è¯·æ±‚ä»¥ (price) çš„ä»·æ ¼è¿›è¡Œå…¨å±€æ¸…ç®— (asset)"), (0, _defineProperty3.default)(_zh_CN, "operation_witness_create", "(account) å‡çº§åˆ°è§è¯äºº"), (0, _defineProperty3.default)(_zh_CN, "operation_witness_update", "(account) æ›´æ–°äº†è§è¯äººä¿¡æ¯"), (0, _defineProperty3.default)(_zh_CN, "operation_committee_member_create", "(account) å‡çº§åˆ°ç†äº‹ä¼šæˆå‘˜"), (0, _defineProperty3.default)(_zh_CN, "operation_committee_member_update", "(account) æ›´æ–°äº†ç†äº‹ä¼šæˆå‘˜ä¿¡æ¯"), (0, _defineProperty3.default)(_zh_CN, "operation_witness_pay", "æå–è§è¯äººæ”¶å…¥åˆ°è´¦æˆ·"), (0, _defineProperty3.default)(_zh_CN, "operation_witness_receive", "Received witness from witness"), (0, _defineProperty3.default)(_zh_CN, "operation_worker_create", "(account) åˆ›å»ºäº†é¢„ç®—ææ¡ˆï¼Œè¯·æ±‚æ¯æ—¥æ”¯ä»˜ (pay)"), (0, _defineProperty3.default)(_zh_CN, "operation_committee_member_update_global_parameters", "(account) æ›´æ–°äº†å…¨å±€ç†äº‹ä¼šå‚æ•°"), (0, _defineProperty3.default)(_zh_CN, "operation_reg_account", "(registrar) åˆ›å»ºè´¦æˆ· (new_account)"), (0, _defineProperty3.default)(_zh_CN, "operation_transfer", "(from) è½¬è´¦ (amount) åˆ° (to)"), (0, _defineProperty3.default)(_zh_CN, "operation_vesting_balance_withdraw", "(account) æå–äº† (vesting_balance_id) è§£å†»é‡‘é¢ (amount)"), (0, _defineProperty3.default)(_zh_CN, "operation_balance_claim", "(account) é¢†å–äº†ä½™é¢ (amount)"), (0, _defineProperty3.default)(_zh_CN, "operation_asset_publish_feed", "(account) å‘å¸ƒäº†å–‚ä»· (price)"), (0, _defineProperty3.default)(_zh_CN, "operation_update_account", "(account) æ›´æ–°äº†å®ƒçš„è´¦æˆ·ä¿¡æ¯"), (0, _defineProperty3.default)(_zh_CN, "operation_limit_order_sell", "(account) æäº¤å–å•ï¼Œä»¥ (price) çš„ä»·æ ¼å–å‡º (amount) "), (0, _defineProperty3.default)(_zh_CN, "operation_limit_order_buy", "(account) æäº¤ä¹°å•ï¼Œä»¥ (price) çš„ä»·æ ¼ä¹°å…¥ (amount) "), (0, _defineProperty3.default)(_zh_CN, "operation_call_order_update", "(account) è°ƒæ•´äº† (debtSymbol) å€ºåŠ¡ (debt) ï¼Œä»¥åŠæŠµæŠ¼ (collateral)"), (0, _defineProperty3.default)(_zh_CN, "operation_fill_order", "(account) ä»¥ (price) çš„ä»·æ ¼è´­ä¹°äº† (received)"), (0, _defineProperty3.default)(_zh_CN, "operation_limit_order_cancel", "(account) å–æ¶ˆäº†è®¢å• #(order)"), (0, _defineProperty3.default)(_zh_CN, "operation_asset_issue", "(account) å‘è¡Œäº† (amount) åˆ° (to)"), (0, _defineProperty3.default)(_zh_CN, "operation_asset_create", "(account) åˆ›å»ºäº†èµ„äº§ (asset)"), (0, _defineProperty3.default)(_zh_CN, "operation_asset_update", "(account) æ›´æ–°äº†èµ„äº§ (asset)"), (0, _defineProperty3.default)(_zh_CN, "operation_asset_update_restricted", "(payer) æ›´æ–°èµ„äº§ (target_asset) (restricted_type_text)"), (0, _defineProperty3.default)(_zh_CN, "operation_asset_reserve", "(account) é”€æ¯äº† (amount)"), (0, _defineProperty3.default)(_zh_CN, "operation_lifetime_upgrade_account", "(account) å‡çº§åˆ°ç»ˆèº«ä¼šå‘˜"), (0, _defineProperty3.default)(_zh_CN, "operation_asset_fund_fee_pool", "(account) å‘ (asset) æ‰‹ç»­è´¹æ± æ³¨å…¥ (amount)"), (0, _defineProperty3.default)(_zh_CN, "operation_asset_claim_fees", "(account) ä»Ž (asset) èµ„äº§æ‰‹ç»­è´¹æ± ä¸­é¢†å– (balance_amount) èµ„äº§æ‰‹ç»­è´¹"), (0, _defineProperty3.default)(_zh_CN, "operation_call_contract_function", "æŽˆæƒäºº: (caller) ï¼Œåˆçº¦: (contract_name) ï¼ŒåŠ¨ä½œ: (function_name) ï¼Œæ•°æ®: (arg_list)"), (0, _defineProperty3.default)(_zh_CN, "operation_contract_create", "(owner) åˆ›å»ºåˆçº¦ (contract_name)"), (0, _defineProperty3.default)(_zh_CN, "operation_revise_contract", "(reviser) æ›´æ–°åˆçº¦ (contract_name)"), (0, _defineProperty3.default)(_zh_CN, "operation_register_nh_asset_creator", "(fee_paying_account) æ³¨å†Œæˆä¸ºå¼€å‘è€…"), (0, _defineProperty3.default)(_zh_CN, "operation_create_world_view", "(fee_paying_account) åˆ›å»ºä¸–ç•Œè§‚ (world_view)"), (0, _defineProperty3.default)(_zh_CN, "operation_create_nh_asset", "(fee_paying_account) åˆ›å»ºNHèµ„äº§ (nh_asset) ï¼Œæ‰€æœ‰æƒè´¦æˆ·ä¸º (owner)"), (0, _defineProperty3.default)(_zh_CN, "operation_delete_nh_asset", "(fee_paying_account) åˆ é™¤NHèµ„äº§ (nh_asset)"), (0, _defineProperty3.default)(_zh_CN, "operation_transfer_nh_asset", "(from) çš„NHèµ„äº§ (nh_asset) æ‰€æœ‰æƒè½¬ç§»åˆ° (to)"), (0, _defineProperty3.default)(_zh_CN, "operation_create_nh_asset_order", "(seller) æäº¤å–å•ï¼Œä»¥ (amount) çš„ä»·æ ¼æŒ‚å–æ•°æ®èµ„äº§ (nh_asset) ï¼Œotcæ‰‹ç»­è´¹: (pending_orders_fee)"), (0, _defineProperty3.default)(_zh_CN, "operation_cancel_nh_asset_order", "(fee_paying_account) å–æ¶ˆäº†NHèµ„äº§å‡ºå”®å• (order)"), (0, _defineProperty3.default)(_zh_CN, "operation_fill_nh_asset_order", "(fee_paying_account) ä»¥ (price_amount) (price_asset_symbol) çš„ä»·æ ¼è´­ä¹° (seller) çš„NHèµ„äº§ (nh_asset)"), (0, _defineProperty3.default)(_zh_CN, "operation_proposal_create", "(fee_paying_account) åˆ›å»ºæè®® (result) ï¼š "), (0, _defineProperty3.default)(_zh_CN, "operation_proposal_update", "(fee_paying_account) æ›´æ–°æè®® (proposal)"), (0, _defineProperty3.default)(_zh_CN, "operation_proposal_delete", "(account) åˆ é™¤æè®®"), (0, _defineProperty3.default)(_zh_CN, "operation_relate_world_view", "(related_account) å…³è” (view_owner) çš„ä¸–ç•Œè§‚ (world_view)"), (0, _defineProperty3.default)(_zh_CN, "operation_relate_nh_asset", "(nh_asset_creator) (relate)çˆ¶çº§NHèµ„äº§ (nh_asset) å’Œå­çº§NHèµ„äº§ (nh_asset) å…³è”"), (0, _defineProperty3.default)(_zh_CN, "operation_update_collateral_for_gas", "(mortgager) å°† (beneficiary) æŠµæŠ¼ç‰©è°ƒæ•´ä¸º (collateral)"), (0, _defineProperty3.default)(_zh_CN, "operation_vesting_balance_create", "(account) åˆ›å»ºå†»ç»“è´¦ç›®ä½™é¢ (amount)"), (0, _defineProperty3.default)(_zh_CN, "operation_asset_settle_cancel", "(account) å–æ¶ˆèµ„äº§æ¸…ç®— (amount)"), (0, _defineProperty3.default)(_zh_CN, "contract_affecteds_nh_modifined", "(affected_account) çš„NHèµ„äº§ (affected_item) ä¿®æ”¹æ•°æ® (modified)"), (0, _defineProperty3.default)(_zh_CN, "contract_affecteds_nh_transfer_to", "NHèµ„äº§ (affected_item) è½¬å…¥ (affected_account)"), (0, _defineProperty3.default)(_zh_CN, "contract_affecteds_nh_transfer_from", "(affected_account) çš„NHèµ„äº§ (affected_item) è½¬å‡º"), (0, _defineProperty3.default)(_zh_CN, "contract_affecteds_asset", "(affected_account) (aseet_amount)"), (0, _defineProperty3.default)(_zh_CN, "contract_affecteds_log", "(affected_account) (message)"), (0, _defineProperty3.default)(_zh_CN, "restricted_type_1", "èµ„äº§æƒé™è´¦æˆ·ç™½åå•"), (0, _defineProperty3.default)(_zh_CN, "restricted_type_2", "èµ„äº§æƒé™è´¦æˆ·é»‘åå•"), (0, _defineProperty3.default)(_zh_CN, "restricted_type_3", "å¸‚åœºäº¤æ˜“èµ„äº§ç™½åå•"), (0, _defineProperty3.default)(_zh_CN, "restricted_type_4", "å¸‚åœºäº¤æ˜“èµ„äº§é»‘åå•"), _zh_CN);

exports.default = zh_CN;

/***/ }),
/* 516 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
var en_US = {
   languages_zh: "ç®€ä½“ä¸­æ–‡",
   languages_en: "English",
   //trxTypes
   trxTypes_transfer: "Transfer",
   trxTypes_limit_order_create: "Place order",
   trxTypes_limit_order_cancel: "Cancel order",
   trxTypes_call_order_update: "Update margin",
   trxTypes_account_create: "Create account",
   trxTypes_account_update: "Update account",
   trxTypes_account_whitelist: "Account whitelist",
   trxTypes_account_upgrade: "Upgrade Account",
   trxTypes_account_transfer: "Transfer Account",
   trxTypes_asset_create: "Create asset",
   trxTypes_asset_update: "Update asset",
   trxTypes_asset_update_restricted: "Update the list of limited assets",
   trxTypes_asset_update_bitasset: "Update SmartCoin",
   trxTypes_asset_update_feed_producers: "Update asset feed producers",
   trxTypes_asset_issue: "Issue asset",
   trxTypes_asset_reserve: "Reserve asset",
   trxTypes_asset_fund_fee_pool: "Fund asset fee pool",
   trxTypes_asset_settle: "Asset settlement",
   trxTypes_asset_global_settle: "Global asset settlement",
   trxTypes_asset_publish_feed: "Publish feed",
   trxTypes_committee_member_create: "Create committee member",
   trxTypes_committee_member_update: "Update committee member",
   trxTypes_witness_create: "Create witness",
   trxTypes_witness_update: "Update witness",
   trxTypes_witness_withdraw_pay: "Witness pay withdrawal",
   trxTypes_proposal_create: "Create proposal",
   trxTypes_proposal_update: "Update proposal",
   trxTypes_proposal_delete: "Delete proposal",
   trxTypes_withdraw_permission_create: "Create withdrawal permission",
   trxTypes_withdraw_permission_update: "Update withdrawal permission",
   trxTypes_withdraw_permission_claim: "Claim withdrawal permission",
   trxTypes_withdraw_permission_delete: "Delete withdrawal permission",
   trxTypes_fill_order: "Fill order",
   trxTypes_committee_member_update_global_parameters: "Global parameters update",
   trxTypes_vesting_balance_create: "Create vesting balance",
   trxTypes_vesting_balance_withdraw: "Withdraw vesting balance",
   trxTypes_worker_create: "Create budget item",
   trxTypes_custom: "Custom",
   trxTypes_assert: "Assert operation",
   trxTypes_balance_claim: "Claim balance",
   trxTypes_override_transfer: "Override transfer",
   trxTypes_transfer_to_blind: "Transfer to blinded account",
   trxTypes_blind_transfer: "Blinded transfer",
   trxTypes_transfer_from_blind: "Transfer from blinded account",
   trxTypes_asset_claim_fees: "Claim asset fees",

   trxTypes_call_contract_function: "Contract transaction",
   trxTypes_contract_create: "Create contract",
   trxTypes_revise_contract: "Upate contract",

   trxTypes_register_nh_asset_creator: "Register Developer",
   trxTypes_create_world_view: "Create worldview",
   trxTypes_create_nh_asset: "NH asset creation",

   trxTypes_delete_nh_asset: "NH asset deletion",
   trxTypes_transfer_nh_asset: "NH Asset Transfer",
   trxTypes_create_nh_asset_order: "NH Asset Certificate of Sale",
   trxTypes_cancel_nh_asset_order: "NH Asset Certificate Cancellation",
   trxTypes_fill_nh_asset_order: "NH Asset Order Matching",
   trxTypes_relate_nh_asset: "NH asset Association",
   trxTypes_relate_world_view: "Relevant worldview",
   trxTypes_update_collateral_for_gas: "GAS Adjustment Pledge",

   trxTypes_contract_affecteds_asset: "Assets",

   trxTypes_contract_affecteds_nh_transfer_from: "NH asset send",
   trxTypes_contract_affecteds_nh_transfer_to: "NH asset receive",
   trxTypes_contract_affecteds_nh_modifined: "NH asset data modification",
   trxTypes_contract_affecteds_log: "log",

   //operation
   operation_pending: "pending {blocks} blocks",
   operation_no_recent: "No recent transactions",
   operation_reg_account: "(registrar) registered an account (new_account)",
   operation_transfer: "(from) sent (amount) to (to)",

   operation_fill_order: "(account) bought (received) at (price)",
   operation_vesting_balance_withdraw: "(account) withdrew vesting balance of (amount)",
   operation_balance_claim: "(account) claimed a balance of (amount)",
   operation_asset_publish_feed: "(account) published feed price of (price)",
   operation_set_proxy: "(account) set (proxy) as their voting proxy",
   operation_update_account: "(account) updated their account data",
   operation_limit_order_sell: "(account) placed an order to sell (amount) at (price)",
   operation_limit_order_buy: "(account) placed an order to buy (amount) at (price)",
   operation_limit_order_cancel: "(account) cancelled order #{order}",
   operation_call_order_update: "(account) changed (debtSymbol) debt by (debt) and collateral by (collateral)",
   operation_asset_reserve: "(account) reserved (burnt) (amount)",
   operation_asset_issue: "(account) issued (amount) to (to)",
   operation_asset_fund_fee_pool: "(account) funded (asset) fee pool with (amount)",
   operation_asset_create: "(account) created the asset (asset)",
   operation_asset_update: "(account) updated the asset (asset)",
   operation_asset_update_restricted: "(payer) updated the asset (target_asset) (restricted_type_text)",
   operation_lifetime_upgrade_account: "(account) upgraded to lifetime member",
   operation_annual_upgrade_account: "(account) upgraded to annual member",
   operation_unlisted_by: "(lister) unlisted the account (listee)",
   operation_whitelisted_by: "(lister) whitelisted the account (listee)",
   operation_blacklisted_by: "(lister) blacklisted the account (listee)",
   operation_transfer_account: "(account) ownership transferred to (to)",
   operation_asset_update_feed_producers: "(account) updated the feed producers for the asset (asset)",
   operation_asset_settle: "(account) requested settlement of (amount)",
   operation_asset_global_settle: "(account) requested global settlement of (asset) at (price)",
   operation_witness_create: "(account) upgraded to become a witness",
   operation_witness_update: "(account) update its witness info",
   operation_committee_member_create: "(account) Promotion to council members",
   operation_committee_member_update: "(account) Updated Council member information",
   operation_witness_pay: "Withdrew witness pay to account",
   operation_witness_receive: "Received witness from witness",
   operation_committee_member_update_global_parameters: "(account) updated the global committee parameters",
   operation_worker_create: "(account) created a worker proposal with daily pay of (pay)",
   operation_override_transfer: "(issuer) transferred (amount) from (from) to (to)",

   operation_call_contract_function: "Author: (caller) ,Contract: (contract_name) , Action: (function_name) ,Data: (arg_list)",
   operation_contract_create: "(owner) Create Contract (contract_name)",
   operation_revise_contract: "(reviser) Update Contract (contract_name)",
   operation_register_nh_asset_creator: "(fee_paying_account) Registed as a developer",
   operation_create_world_view: "(fee_paying_account) Create a worldview",
   operation_create_nh_asset: "(fee_paying_account) Creates NH assets with ownership account (owner)",
   operation_delete_nh_asset: "(fee_paying_account) Delete NH Asset (nh_asset)",
   operation_transfer_nh_asset: "Transfer of ownership of (from) NH assets (nh_asset) to (to)",
   operation_create_nh_asset_order: "(seller) submits a sales order to sell NH asset (nh_asset) at (amount) price otc fee: (pending_orders_fee)",
   operation_cancel_nh_asset_order: "(fee_paying_account) cancelled NH asset sale order (order)",
   operation_fill_nh_asset_order: "(fee_paying_account) buys NH assets of (nh_asset) at a price of (price_amount) (price_asset_symbol)",
   operation_proposal_create: "(fee_paying_account) created a proposed transaction (result) : ",
   operation_proposal_update: "(fee_paying_account) updated a proposed transaction (proposal)",
   operation_proposal_delete: "(account) deleted a proposed transaction",

   operation_relate_world_view: "(related_account) relation (view_owner) worldview (world_view)",
   operation_relate_nh_asset: "(nh_asset_creator) (related) parent NH asset (nh_asset) and child NH asset (nh_asset) Association",
   operation_update_collateral_for_gas: "(mortgager) adjust (beneficiary) collateral to (collateral)",

   contract_affecteds_nh_modifined: "(affected_account) NH assets (affected_item) modify data (modified)",
   contract_affecteds_nh_transfer_to: "NH asset (affected_item) transfer (affected_account)",
   contract_affecteds_nh_transfer_from: "(affected_account) NH Asset (affected_item) Transfer",
   contract_affecteds_asset: "(affected_account) (aseet_amount)",
   contract_affecteds_log: "(affected_account) (message)",

   restricted_type_1: "White List of Asset Accounts",
   restricted_type_2: "Blacklist of Asset Accounts",
   restricted_type_3: "White List of Market Transacted Assets",
   restricted_type_4: "Black List of Market Transacted Assets"
};

exports.default = en_US;

/***/ }),
/* 517 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAccountContractData = exports.getContract = undefined;

var _regenerator = __webpack_require__(3);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _stringify = __webpack_require__(18);

var _stringify2 = _interopRequireDefault(_stringify);

var _bcxjsWs = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var contract_cache = {};
var getContract = exports.getContract = function _callee(nameOrId) {
  var isCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var response, chainInfo, result, message;
  return _regenerator2.default.async(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          if (!(isCache && contract_cache[nameOrId])) {
            _context.next = 2;
            break;
          }

          return _context.abrupt('return', JSON.parse((0, _stringify2.default)(contract_cache[nameOrId])));

        case 2:
          _context.prev = 2;
          _context.next = 5;
          return _regenerator2.default.awrap(_bcxjsWs.Apis.instance().db_api().exec('get_contract', [nameOrId]));

        case 5:
          response = _context.sent;

          if (!response) {
            _context.next = 20;
            break;
          }

          if (!(response.current_version == "0000000000000000000000000000000000000000000000000000000000000000")) {
            _context.next = 14;
            break;
          }

          _context.next = 10;
          return _regenerator2.default.awrap(_bcxjsWs.Apis.instance().db_api().exec('get_objects', [["2.11.0"]]));

        case 10:
          chainInfo = _context.sent;

          response.lua_code = chainInfo[0].base_contract;
          _context.next = 17;
          break;

        case 14:
          _context.next = 16;
          return _regenerator2.default.awrap(_bcxjsWs.Apis.instance().db_api().exec('get_transaction_by_id', [response.current_version]));

        case 16:
          response.lua_code = _context.sent.operations[0][1].data;

        case 17:
          result = {
            code: 1,
            data: response
          };

          if (isCache) {
            contract_cache[nameOrId] = result;
          }
          return _context.abrupt('return', JSON.parse((0, _stringify2.default)(result)));

        case 20:
          return _context.abrupt('return', {
            code: 145,
            message: nameOrId + ' contract not found'
          });

        case 23:
          _context.prev = 23;
          _context.t0 = _context['catch'](2);

          // console.log(error);
          message = _context.t0.message;

          if (_context.t0.message.indexOf("does not exist") >= 0) {
            message = 'The contract (' + nameOrId + ') does not exist';
          }
          return _context.abrupt('return', {
            code: 145,
            message: message,
            error: _context.t0
          });

        case 28:
        case 'end':
          return _context.stop();
      }
    }
  }, null, undefined, [[2, 23]]);
};

var getAccountContractData = exports.getAccountContractData = function _callee2(accountId, contractId) {
  var response;
  return _regenerator2.default.async(function _callee2$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          _context2.prev = 0;
          _context2.next = 3;
          return _regenerator2.default.awrap(_bcxjsWs.Apis.instance().db_api().exec('get_account_contract_data', [accountId, contractId]));

        case 3:
          response = _context2.sent;

          if (!response) {
            _context2.next = 6;
            break;
          }

          return _context2.abrupt('return', {
            code: 1,
            data: response
          });

        case 6:
          return _context2.abrupt('return', {
            code: 146,
            message: "The account does not contain information about the contract"
          });

        case 9:
          _context2.prev = 9;
          _context2.t0 = _context2['catch'](0);
          return _context2.abrupt('return', {
            code: 0,
            message: _context2.t0.message,
            error: _context2.t0
          });

        case 12:
        case 'end':
          return _context2.stop();
      }
    }
  }, null, undefined, [[0, 9]]);
};

exports.default = {
  getContract: getContract,
  getAccountContractData: getAccountContractData
};

/***/ }),
/* 518 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.formatVotes = exports._getVoteObjects = exports.publishVotes = undefined;

var _stringify = __webpack_require__(18);

var _stringify2 = _interopRequireDefault(_stringify);

var _slicedToArray2 = __webpack_require__(90);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _promise = __webpack_require__(4);

var _promise2 = _interopRequireDefault(_promise);

var _regenerator = __webpack_require__(3);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _bcxjsWs = __webpack_require__(8);

var _immutable = __webpack_require__(23);

var _immutable2 = _interopRequireDefault(_immutable);

var _mutations = __webpack_require__(14);

var types = _interopRequireWildcard(_mutations);

var _api = __webpack_require__(10);

var _api2 = _interopRequireDefault(_api);

var _helper = __webpack_require__(34);

var _helper2 = _interopRequireDefault(_helper);

var _bcxjsCores = __webpack_require__(7);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _state = {
    all_witnesses: _immutable2.default.List(),
    all_committee: _immutable2.default.List()
};

var publishVotes = exports.publishVotes = function _callee(store, ids, votes, type, callback) {
    var rootGetters, getters, dispatch, updated_account, core_asset, updateObject, new_options;
    return _regenerator2.default.async(function _callee$(_context) {
        while (1) {
            switch (_context.prev = _context.next) {
                case 0:
                    rootGetters = store.rootGetters, getters = store.getters, dispatch = store.dispatch;
                    updated_account = rootGetters["user/getAccountObject"];
                    _context.next = 4;
                    return _regenerator2.default.awrap(_api2.default.Assets.fetch(["1.3.0"], true));

                case 4:
                    core_asset = _context.sent;
                    _context.t0 = updated_account.id;
                    _context.t1 = type == "witnesses" ? 1 : 0;
                    _context.next = 9;
                    return _regenerator2.default.awrap(_helper2.default.toOpAmount(votes, core_asset));

                case 9:
                    _context.t2 = _context.sent.data;
                    _context.t3 = [_context.t1, _context.t2];
                    updateObject = {
                        account: _context.t0,
                        lock_with_vote: _context.t3
                    };
                    new_options = { memo_key: updated_account.options.memo_key };


                    updateObject.new_options = new_options;
                    // Set fee asset

                    // Submit votes
                    (0, _bcxjsCores.FetchChainObjects)(type == "witnesses" ? _bcxjsCores.ChainStore.getWitnessById : _bcxjsCores.ChainStore.getCommitteeMemberById, ids, 4000).then(function (res) {
                        updateObject.new_options.votes = res.map(function (o) {
                            return o.get("vote_id");
                        }).sort(function (a, b) {
                            var a_split = a.split(":");
                            var b_split = b.split(":");
                            return parseInt(a_split[1], 10) - parseInt(b_split[1], 10);
                        });
                        dispatch("transactions/_transactionOperations", {
                            operations: [{
                                op_type: 6,
                                type: "account_update",
                                params: {
                                    updateObject: updateObject
                                }
                            }],
                            callback: callback
                        }, { root: true }).then(function (res) {
                            callback && callback(res);
                        });
                    });

                case 15:
                case 'end':
                    return _context.stop();
            }
        }
    }, null, undefined);
};

var _getVoteObjects = exports._getVoteObjects = function _callee2(store) {
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "witnesses";
    var vote_ids = arguments[2];
    var isCache = arguments[3];
    var current, isWitness, lastIdx, globalObject, getVoteObjects_callback, active, lastActive, i;
    return _regenerator2.default.async(function _callee2$(_context2) {
        while (1) {
            switch (_context2.prev = _context2.next) {
                case 0:
                    current = _state['all_' + type] = _immutable2.default.List();
                    isWitness = type === "witnesses";
                    lastIdx = void 0;

                    if (vote_ids) {
                        _context2.next = 23;
                        break;
                    }

                    vote_ids = [];
                    globalObject = store.rootGetters["vote/globalObject"];

                    if (!(!globalObject || isCache == false)) {
                        _context2.next = 15;
                        break;
                    }

                    _context2.next = 9;
                    return _regenerator2.default.awrap(_api2.default.Explorer.getGlobalObject(isCache));

                case 9:
                    globalObject = _context2.sent;

                    if (!(globalObject.code != 1)) {
                        _context2.next = 14;
                        break;
                    }

                    getVoteObjects_callback = store.state.getVoteObjects_callback;

                    getVoteObjects_callback && getVoteObjects_callback(globalObject);
                    return _context2.abrupt('return');

                case 14:
                    globalObject = globalObject.data;

                case 15:

                    globalObject = _immutable2.default.fromJS(globalObject);
                    store.commit(types.SET_GLOBAL_OBJECT, globalObject);
                    active = globalObject.get(isWitness ? "active_witnesses" : "active_committee_members").sort(function (a, b) {
                        return parseInt(a.split(".")[2], 10) - parseInt(b.split(".")[2], 10);
                    });
                    lastActive = active.last() || '1.' + (isWitness ? "6" : "5") + '.1';


                    lastIdx = parseInt(lastActive.split(".")[2], 10);
                    for (i = isWitness ? 1 : 0; i <= lastIdx + 10; i++) {
                        vote_ids.push('1.' + (isWitness ? "6" : "5") + '.' + i);
                    }
                    _context2.next = 24;
                    break;

                case 23:
                    lastIdx = parseInt(vote_ids[vote_ids.length - 1].split(".")[2], 10);

                case 24:
                    (0, _bcxjsCores.FetchChainObjects)(_bcxjsCores.ChainStore.getObject, vote_ids, 5000, {}, isCache).then(function (vote_objs) {
                        var vote_ids_obj = {};
                        vote_objs = vote_objs.filter(function (a) {
                            if (!!a) {
                                vote_ids.push(a.id);
                                return true;
                            }
                        });
                        if (vote_objs.length) {
                            store.commit(types.SET_VOTE_IDS, vote_ids);
                            _state['all_' + type] = current.concat(_immutable2.default.List(vote_objs.map(function (a) {
                                var acc_id = a.get(isWitness ? "witness_account" : "committee_member_account");
                                vote_ids_obj[acc_id] = a;
                                return acc_id;
                            })));

                            store.commit(types.SET_VOTE_IDS_OBJ, vote_ids_obj);
                            store.commit(types.SET_ALL_WITNESSES_COMMITTEE, _state);
                        }

                        // store.dispatch("formatVotes",type);
                        if (!!vote_objs[vote_objs.length - 1]) {
                            // there are more valid vote objs, fetch 10 more
                            vote_ids = [];
                            for (var i = lastIdx + 11; i <= lastIdx + 20; i++) {
                                vote_ids.push('1.' + (isWitness ? "6" : "5") + '.' + i);
                            }
                            return _getVoteObjects(store, type, vote_ids, false);
                        } else {
                            updateAccountData(store, type);
                        }
                    });

                case 25:
                case 'end':
                    return _context2.stop();
            }
        }
    }, null, undefined);
};

var updateAccountData = function _callee3(store, type) {
    var commit, rootGetters, query_account, loginUserName, account, proxyId, proxy_account_id, proxy, options, proxyOptions, current_proxy_input, votes, reg, vote_ids, vids, proxyPromise, proxy_vids, hasProxy, proxy_votes, proxy_vote_ids;
    return _regenerator2.default.async(function _callee3$(_context3) {
        while (1) {
            switch (_context3.prev = _context3.next) {
                case 0:
                    commit = store.commit, rootGetters = store.rootGetters;
                    query_account = rootGetters["vote/queryAccount"];
                    loginUserName = rootGetters["user/getUserName"];

                    if (!(!loginUserName && !query_account || rootGetters["vote/isExplorer"])) {
                        _context3.next = 6;
                        break;
                    }

                    formatVotes(store, "");
                    return _context3.abrupt('return');

                case 6:
                    _context3.next = 8;
                    return _regenerator2.default.awrap(_api2.default.Account.getUser(query_account ? query_account : loginUserName, false));

                case 8:
                    account = _context3.sent;

                    if (!(account.code != 1)) {
                        _context3.next = 12;
                        break;
                    }

                    store.state.getVoteObjects_callback && store.state.getVoteObjects_callback(account);
                    return _context3.abrupt('return');

                case 12:

                    account = account.data.account;
                    account = _immutable2.default.fromJS(account);
                    proxyId = account.getIn(["options", "voting_account"]);
                    proxy_account_id = proxyId === "1.2.2" ? "" : proxyId;
                    proxy = null;

                    if (!proxy_account_id) {
                        _context3.next = 23;
                        break;
                    }

                    _context3.next = 20;
                    return _regenerator2.default.awrap(_api2.default.Account.getUser(proxy_account_id, false));

                case 20:
                    proxy = _context3.sent;

                    if (proxy.success) {
                        proxy = proxy.data.account;
                    }
                    if (proxy) {
                        proxy = _immutable2.default.fromJS(proxy);
                    }

                case 23:
                    options = account.get("options");
                    proxyOptions = proxy ? proxy.get("options") : null;
                    current_proxy_input = proxy ? proxy.get("name") : "";


                    if (proxy_account_id === "1.2.2") {
                        proxy_account_id = "";
                        current_proxy_input = "";
                    }

                    votes = options.get("votes");
                    reg = new RegExp(type == "witnesses" ? /^1:\d+$/ : /^0:\d+$/);
                    vote_ids = votes.toArray().filter(function (vote_id) {
                        return vote_id.match(reg);
                    });
                    vids = _immutable2.default.Set(vote_ids);
                    proxyPromise = null, proxy_vids = _immutable2.default.Set([]);
                    hasProxy = proxy_account_id !== "1.2.2";

                    if (hasProxy && proxyOptions) {
                        proxy_votes = proxyOptions.get("votes");
                        proxy_vote_ids = proxy_votes.toArray();

                        proxy_vids = _immutable2.default.Set(proxy_vote_ids);
                        _bcxjsCores.ChainStore.getObjectsByVoteIds(proxy_vote_ids);
                        proxyPromise = (0, _bcxjsCores.FetchChainObjects)(_bcxjsCores.ChainStore.getObjectByVoteID, proxy_vote_ids, 10000);
                    } else {
                        _bcxjsCores.ChainStore.getObjectsByVoteIds(vote_ids);
                    }

                    _promise2.default.all([(0, _bcxjsCores.FetchChainObjects)(_bcxjsCores.ChainStore.getObjectByVoteID, vote_ids, 10000, {}, false)]
                    // proxyPromise
                    ).then(function (res) {
                        var _res = (0, _slicedToArray3.default)(res, 2),
                            vote_objs = _res[0],
                            proxy_vote_objs = _res[1];

                        function sortVoteObjects(objects) {
                            var witnesses = new _immutable2.default.List();
                            var committee = new _immutable2.default.List();
                            var workers = new _immutable2.default.Set();
                            objects.forEach(function (obj) {
                                var account_id = obj.get("committee_member_account");
                                if (account_id) {
                                    committee = committee.push(account_id);
                                } else if (account_id = obj.get("worker_account")) {
                                    // console.log( "worker: ", obj );
                                    //     workers = workers.add(obj.get("id"));
                                } else if (account_id = obj.get("witness_account")) {
                                    witnesses = witnesses.push(account_id);
                                }
                            });

                            return { witnesses: witnesses, committee: committee, workers: workers };
                        }

                        var _sortVoteObjects = sortVoteObjects(vote_objs),
                            witnesses = _sortVoteObjects.witnesses,
                            committee = _sortVoteObjects.committee,
                            workers = _sortVoteObjects.workers;

                        var _sortVoteObjects2 = sortVoteObjects(proxy_vote_objs || []),
                            proxy_witnesses = _sortVoteObjects2.witnesses,
                            proxy_committee = _sortVoteObjects2.committee,
                            proxy_workers = _sortVoteObjects2.workers;

                        var state = {
                            proxy_account_id: proxy_account_id,
                            current_proxy_input: current_proxy_input,
                            witnesses: witnesses,
                            committee: committee,
                            workers: workers,
                            proxy_witnesses: proxy_witnesses,
                            proxy_committee: proxy_committee,
                            proxy_workers: proxy_workers,
                            vote_ids: vids,
                            proxy_vote_ids: proxy_vids,
                            prev_witnesses: witnesses,
                            prev_committee: committee,
                            prev_workers: workers,
                            prev_vote_ids: vids,
                            vote_for_witness: type == "witnesses" ? account.getIn(["asset_locked", "vote_for_witness"]) : account.getIn(["asset_locked", "vote_for_committee"])
                        };
                        commit(types.SET_VOTES_STATE, state);

                        formatVotes(store, proxy_account_id);
                    }).catch(function (e) {
                        var getVoteObjects_callback = store.state.getVoteObjects_callback;

                        getVoteObjects_callback && getVoteObjects_callback({ code: 148, message: "Request timeout, please try to unlock the account or login the account" });
                    });

                case 35:
                case 'end':
                    return _context3.stop();
            }
        }
    }, null, undefined);
};

//process formatted voting data
var formatVotes = exports.formatVotes = function _callee4(store, proxy_account_id) {
    var state, rootGetters, getters, dispatch, core_asset, type, items;
    return _regenerator2.default.async(function _callee4$(_context4) {
        while (1) {
            switch (_context4.prev = _context4.next) {
                case 0:
                    state = store.state, rootGetters = store.rootGetters, getters = store.getters, dispatch = store.dispatch;
                    _context4.next = 3;
                    return _regenerator2.default.awrap(dispatch("assets/fetchAssets", { assets: ["1.3.0"], isOne: true }, { root: true }));

                case 3:
                    core_asset = _context4.sent;
                    type = getters["all_type"];
                    items = getters["alls"]["all_" + type].filter(function (i) {
                        if (!i) return false;
                        //if (this.state.item_name_input) return i.get("name").indexOf(this.state.item_name_input) !== -1;
                        return true;
                    });

                    items = items.map(function (account) {
                        return store.dispatch("user/getUserInfo", { account: account, isCache: true, isSubscribe: true }, { root: true });
                    });
                    _promise2.default.all(items).then(function (respDataArr) {

                        respDataArr = respDataArr.filter(function (acc_res) {
                            return acc_res.code == 1;
                        });
                        respDataArr = respDataArr.map(function (acc_res) {
                            return acc_res.data.account;
                        });

                        items = _immutable2.default.fromJS(respDataArr);
                        var vote_ids_obj = getters["vote_ids_obj"];
                        items = items.sort(function (a, b) {
                            var _getWitnessOrCommitte = getWitnessOrCommittee(type, a),
                                a_votes = _getWitnessOrCommitte.votes;

                            var _getWitnessOrCommitte2 = getWitnessOrCommittee(type, b),
                                b_votes = _getWitnessOrCommitte2.votes;

                            if (a_votes !== b_votes) {
                                return parseInt(b_votes, 10) - parseInt(a_votes, 10);
                            } else if (a.get("name") > b.get("name")) {
                                return 1;
                            } else if (a.get("name") < b.get("name")) {
                                return -1;
                            } else {
                                return 0;
                            }
                        }).map(function (account, idx) {
                            var supporteds = getters["getVotesState"] ? getters["getVotesState"][(proxy_account_id ? "proxy_" : "") + type] : null;
                            var action = supporteds && supporteds.includes(account.get("id"));
                            // ? "remove"
                            // : "add";

                            var _getWitnessOrCommitte3 = getWitnessOrCommittee(type, account, core_asset),
                                url = _getWitnessOrCommitte3.url,
                                votes = _getWitnessOrCommitte3.votes,
                                id = _getWitnessOrCommitte3.id,
                                supporters = _getWitnessOrCommitte3.supporters,
                                work_status = _getWitnessOrCommitte3.work_status;

                            var link = url && url.length > 0 && url.indexOf("http") === -1 ? "http://" + url : url;
                            var isActive = getters["globalObject"] ? getters["globalObject"].get("active_" + type + (type == "committee" ? "_members" : "")).includes(id) : false;

                            votes = _helper2.default.getFullNum(votes / Math.pow(10, core_asset.precision));
                            votes = votes.toFixed(3);

                            var account_id = account.get("id");
                            var owner_votes = 0;
                            if (getters["getVotesState"] && action) {
                                owner_votes = _helper2.default.getFullNum(getters["getVotesState"].vote_for_witness.get("amount"), core_asset.precision);
                            }
                            // console.info("owner_votes",getters["getVotesState"].vote_for_witness.get("amount"),owner_votes);

                            var vote_obj = vote_ids_obj[account_id];

                            var _vote_obj$toJS = vote_obj.toJS(),
                                vote_id = _vote_obj$toJS.vote_id,
                                total_missed = _vote_obj$toJS.total_missed,
                                last_confirmed_block_num = _vote_obj$toJS.last_confirmed_block_num,
                                last_aslot = _vote_obj$toJS.last_aslot;

                            var vote_account = {
                                account_name: account.get("name"),
                                url: url,
                                votes: votes,
                                owner_votes: owner_votes,
                                active: isActive,
                                supported: !!action,
                                supporters: supporters,
                                account_id: account_id,
                                type: type,
                                vote_id: vote_id,
                                work_status: work_status
                            };
                            if (type == "witnesses") {
                                vote_account.total_missed = total_missed;
                                vote_account.last_confirmed_block_num = last_confirmed_block_num;
                                vote_account.last_aslot = last_aslot;
                                vote_account.witness_id = vote_obj.get("id");
                            } else if (type == "committee") {
                                vote_account.committee_id = vote_obj.get("id");
                            }
                            return vote_account;
                        });

                        var getVoteObjects_callback = store.state.getVoteObjects_callback;


                        getVoteObjects_callback && getVoteObjects_callback({ code: 1, data: items.toJS() });
                    });

                case 8:
                case 'end':
                    return _context4.stop();
            }
        }
    }, null, undefined);
};

function getWitnessOrCommittee(type, acct, c_asset) {
    var url = "",
        votes = 0,
        supporters = [],
        account = void 0,
        work_status = false;
    if (_bcxjsWs.Apis.instance().db_api()) {
        if (type === "witnesses") {
            account = _bcxjsCores.ChainStore.getWitnessById(acct.get("id"));
        } else if (type === "committee") {
            account = _bcxjsCores.ChainStore.getCommitteeMemberById(acct.get("id"));
        }
    }
    // console.info("account",JSON.parse(JSON.stringify(account)));
    url = account ? account.get("url") : url;
    votes = account ? account.get("total_votes") : votes;
    work_status = account ? account.get("work_status") : work_status;

    // console.info("account",JSON.parse(JSON.stringify(account)));
    if (c_asset) {
        supporters = account ? account.get("supporters") : supporters;
        if (supporters) supporters = supporters.map(function (item) {
            item = item.toArray();
            return {
                account_id: item[0],
                amount_raw: item[1],
                amount_text: item[1].toJS().amount / Math.pow(10, c_asset.precision) + " " + c_asset.symbol
            };
        });
    }
    if (supporters) supporters = JSON.parse((0, _stringify2.default)(supporters));
    return {
        url: url,
        votes: votes,
        supporters: supporters,
        work_status: work_status,
        id: account ? account.get("id") : ""
    };
}

exports.default = {
    _getVoteObjects: _getVoteObjects,
    formatVotes: formatVotes,
    publishVotes: publishVotes
};

/***/ }),
/* 519 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.queryOrderDetail = exports.listNHAssetsByCreator = exports.getNHCreator = exports.lookupWorldViews = exports.listAccountNHAssetOrders = exports.listNHAssetOrders = exports.lookupNHAssets = exports.listAccountNHAssets = undefined;

var _regenerator = __webpack_require__(3);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _promise = __webpack_require__(4);

var _promise2 = _interopRequireDefault(_promise);

var _keys = __webpack_require__(24);

var _keys2 = _interopRequireDefault(_keys);

var _bcxjsWs = __webpack_require__(8);

var _api = __webpack_require__(10);

var _api2 = _interopRequireDefault(_api);

var _helper = __webpack_require__(34);

var _helper2 = _interopRequireDefault(_helper);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var formatItems = function _callee(items, total) {
    var i, describe_with_contracts, c_id, contract_name, req_accounts, accounts_res, j, ii, result;
    return _regenerator2.default.async(function _callee$(_context) {
        while (1) {
            switch (_context.prev = _context.next) {
                case 0:
                    items = items.map(function (item) {
                        item.create_time = new Date(item.create_time + 'Z').format("yyyy/MM/dd HH:mm:ss");
                        var describe_with_contract = {};
                        var item_data = void 0;

                        item.describe_with_contract.forEach(function (wv_item) {
                            item_data = {};
                            wv_item[1].forEach(function (prop) {
                                if (prop) item_data[prop[0]] = prop[1];
                            });
                            describe_with_contract[wv_item[0]] = item_data;
                        });
                        item["describe_with_contract"] = describe_with_contract;
                        return item;
                    });
                    i = 0;

                case 2:
                    if (!(i < items.length)) {
                        _context.next = 36;
                        break;
                    }

                    describe_with_contracts = (0, _keys2.default)(items[i].describe_with_contract);
                    c_id = "";
                    contract_name = "";
                    req_accounts = [_api2.default.Account.getUser(items[i].nh_asset_creator, true), _api2.default.Account.getUser(items[i].nh_asset_owner, true)];

                    if (items[i].nh_asset_active) {
                        req_accounts.push(_api2.default.Account.getUser(items[i].nh_asset_active, true));
                    }
                    if (items[i].dealership) {
                        req_accounts.push(_api2.default.Account.getUser(items[i].dealership, true));
                    }
                    _context.next = 11;
                    return _regenerator2.default.awrap(_promise2.default.all(req_accounts));

                case 11:
                    accounts_res = _context.sent;
                    j = 0;

                case 13:
                    if (!(j < accounts_res.length)) {
                        _context.next = 19;
                        break;
                    }

                    if (!(accounts_res[j].code != 1)) {
                        _context.next = 16;
                        break;
                    }

                    return _context.abrupt('return', accounts_res[j]);

                case 16:
                    j++;
                    _context.next = 13;
                    break;

                case 19:
                    items[i].nh_asset_creator_name = accounts_res[0].data.account.name;
                    items[i].nh_asset_owner_name = accounts_res[1].data.account.name;
                    if (req_accounts.length > 2) {
                        items[i].nh_asset_active_name = accounts_res[2].data.account.name;
                        items[i].dealership_name = accounts_res[3].data.account.name;
                    }

                    ii = 0;

                case 23:
                    if (!(ii < describe_with_contracts.length)) {
                        _context.next = 33;
                        break;
                    }

                    c_id = describe_with_contracts[ii];
                    _context.next = 27;
                    return _regenerator2.default.awrap(_api2.default.Contract.getContract(c_id, true));

                case 27:
                    contract_name = _context.sent.data.name;

                    items[i].describe_with_contract[contract_name] = items[i].describe_with_contract[c_id];
                    delete items[i].describe_with_contract[c_id];

                case 30:
                    ii++;
                    _context.next = 23;
                    break;

                case 33:
                    i++;
                    _context.next = 2;
                    break;

                case 36:
                    result = { code: 1, data: items };

                    if (total) {
                        result.total = total;
                    }
                    return _context.abrupt('return', result);

                case 39:
                case 'end':
                    return _context.stop();
            }
        }
    }, null, undefined);
};

var listAccountNHAssets = exports.listAccountNHAssets = function _callee2(_ref) {
    var account_id = _ref.account_id,
        _ref$worldViews = _ref.worldViews,
        worldViews = _ref$worldViews === undefined ? [] : _ref$worldViews,
        _ref$page = _ref.page,
        page = _ref$page === undefined ? 1 : _ref$page,
        _ref$pageSize = _ref.pageSize,
        pageSize = _ref$pageSize === undefined ? 10 : _ref$pageSize,
        _ref$type = _ref.type,
        type = _ref$type === undefined ? 4 : _ref$type;
    var response, message;
    return _regenerator2.default.async(function _callee2$(_context2) {
        while (1) {
            switch (_context2.prev = _context2.next) {
                case 0:
                    _context2.prev = 0;
                    _context2.next = 3;
                    return _regenerator2.default.awrap(_bcxjsWs.Apis.instance().db_api().exec('list_account_nh_asset', [account_id, worldViews, pageSize, page, type]));

                case 3:
                    response = _context2.sent;

                    if (!response) {
                        _context2.next = 8;
                        break;
                    }

                    _context2.next = 7;
                    return _regenerator2.default.awrap(formatItems(response[0], response[1]));

                case 7:
                    return _context2.abrupt('return', _context2.sent);

                case 8:
                    return _context2.abrupt('return', {
                        code: 104,
                        message: worldViews + ' not found'
                    });

                case 11:
                    _context2.prev = 11;
                    _context2.t0 = _context2['catch'](0);
                    message = _context2.t0.message;
                    return _context2.abrupt('return', {
                        code: 0,
                        message: message,
                        error: _context2.t0
                    });

                case 15:
                case 'end':
                    return _context2.stop();
            }
        }
    }, null, undefined, [[0, 11]]);
};

var lookupNHAssets = exports.lookupNHAssets = function _callee3(nh_asset_hash_or_ids) {
    var owner = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var account_id = arguments[2];
    var response, message;
    return _regenerator2.default.async(function _callee3$(_context3) {
        while (1) {
            switch (_context3.prev = _context3.next) {
                case 0:
                    _context3.prev = 0;
                    _context3.next = 3;
                    return _regenerator2.default.awrap(_bcxjsWs.Apis.instance().db_api().exec('lookup_nh_asset', [nh_asset_hash_or_ids]));

                case 3:
                    response = _context3.sent;

                    if (!response) {
                        _context3.next = 15;
                        break;
                    }

                    response = response.filter(function (item) {
                        return item != null;
                    });

                    if (!(owner && response.length)) {
                        _context3.next = 10;
                        break;
                    }

                    response = response.filter(function (item) {
                        return item.nh_asset_owner == account_id;
                    });

                    if (response.length) {
                        _context3.next = 10;
                        break;
                    }

                    return _context3.abrupt('return', { code: 176, message: "You are not the owner of " + nh_asset_hash_or_ids });

                case 10:
                    ;

                    if (!response.length) {
                        _context3.next = 15;
                        break;
                    }

                    _context3.next = 14;
                    return _regenerator2.default.awrap(formatItems(response));

                case 14:
                    return _context3.abrupt('return', _context3.sent);

                case 15:
                    return _context3.abrupt('return', {
                        code: 147,
                        message: nh_asset_hash_or_ids + ' NHAsset do not exist'
                    });

                case 18:
                    _context3.prev = 18;
                    _context3.t0 = _context3['catch'](0);
                    message = _context3.t0.message;

                    if (message.indexOf("Invalid hex character") != -1) {
                        message = "è¯·è¾“å…¥æ­£ç¡®çš„NHèµ„äº§idæˆ–hash";
                    }

                    return _context3.abrupt('return', {
                        code: 0,
                        message: message,
                        error: _context3.t0
                    });

                case 23:
                case 'end':
                    return _context3.stop();
            }
        }
    }, null, undefined, [[0, 18]]);
};

var listNHAssetOrders = exports.listNHAssetOrders = function _callee4(_ref2) {
    var assetIds = _ref2.assetIds,
        worldViews = _ref2.worldViews,
        _ref2$baseDescribe = _ref2.baseDescribe,
        baseDescribe = _ref2$baseDescribe === undefined ? "" : _ref2$baseDescribe,
        _ref2$pageSize = _ref2.pageSize,
        pageSize = _ref2$pageSize === undefined ? 10 : _ref2$pageSize,
        _ref2$page = _ref2.page,
        page = _ref2$page === undefined ? 1 : _ref2$page,
        _ref2$isAscendingOrde = _ref2.isAscendingOrder,
        isAscendingOrder = _ref2$isAscendingOrde === undefined ? true : _ref2$isAscendingOrde;
    var response, orders;
    return _regenerator2.default.async(function _callee4$(_context4) {
        while (1) {
            switch (_context4.prev = _context4.next) {
                case 0:
                    _context4.prev = 0;
                    _context4.next = 3;
                    return _regenerator2.default.awrap(_bcxjsWs.Apis.instance().db_api().exec('list_nh_asset_order', [assetIds, worldViews, baseDescribe, Number(pageSize), Number(page), isAscendingOrder]));

                case 3:
                    response = _context4.sent;

                    if (!response) {
                        _context4.next = 9;
                        break;
                    }

                    _context4.next = 7;
                    return _regenerator2.default.awrap(fomatOrders(response[0]));

                case 7:
                    orders = _context4.sent;
                    return _context4.abrupt('return', {
                        code: 1,
                        data: orders,
                        total: response[1]
                    });

                case 9:
                    _context4.next = 14;
                    break;

                case 11:
                    _context4.prev = 11;
                    _context4.t0 = _context4['catch'](0);
                    return _context4.abrupt('return', {
                        code: 0,
                        message: _context4.t0.message,
                        error: _context4.t0
                    });

                case 14:
                case 'end':
                    return _context4.stop();
            }
        }
    }, null, undefined, [[0, 11]]);
};

var listAccountNHAssetOrders = exports.listAccountNHAssetOrders = function _callee5(_ref3) {
    var account_id = _ref3.account_id,
        _ref3$pageSize = _ref3.pageSize,
        pageSize = _ref3$pageSize === undefined ? 10 : _ref3$pageSize,
        _ref3$page = _ref3.page,
        page = _ref3$page === undefined ? 1 : _ref3$page;
    var response, orders;
    return _regenerator2.default.async(function _callee5$(_context5) {
        while (1) {
            switch (_context5.prev = _context5.next) {
                case 0:
                    _context5.prev = 0;
                    _context5.next = 3;
                    return _regenerator2.default.awrap(_bcxjsWs.Apis.instance().db_api().exec('list_account_nh_asset_order', [account_id, Number(pageSize), Number(page)]));

                case 3:
                    response = _context5.sent;

                    if (!response) {
                        _context5.next = 9;
                        break;
                    }

                    _context5.next = 7;
                    return _regenerator2.default.awrap(fomatOrders(response[0]));

                case 7:
                    orders = _context5.sent;
                    return _context5.abrupt('return', {
                        code: 1,
                        data: orders,
                        total: response[1]
                    });

                case 9:
                    _context5.next = 14;
                    break;

                case 11:
                    _context5.prev = 11;
                    _context5.t0 = _context5['catch'](0);
                    return _context5.abrupt('return', {
                        code: 0,
                        message: _context5.t0.message,
                        error: _context5.t0
                    });

                case 14:
                case 'end':
                    return _context5.stop();
            }
        }
    }, null, undefined, [[0, 11]]);
};

var lookupWorldViews = exports.lookupWorldViews = function _callee6(world_view_name_or_ids) {
    var response, versions, i, wv_item, developers, j, account;
    return _regenerator2.default.async(function _callee6$(_context6) {
        while (1) {
            switch (_context6.prev = _context6.next) {
                case 0:
                    _context6.prev = 0;
                    _context6.next = 3;
                    return _regenerator2.default.awrap(_bcxjsWs.Apis.instance().db_api().exec('lookup_world_view', [world_view_name_or_ids]));

                case 3:
                    response = _context6.sent;

                    if (!(response && response[0])) {
                        _context6.next = 28;
                        break;
                    }

                    versions = [];
                    i = 0;

                case 7:
                    if (!(i < response.length)) {
                        _context6.next = 27;
                        break;
                    }

                    wv_item = response[i];
                    _context6.next = 11;
                    return _regenerator2.default.awrap(_bcxjsWs.Apis.instance().db_api().exec('get_objects', [wv_item.related_nht_creator]));

                case 11:
                    developers = _context6.sent;
                    j = 0;

                case 13:
                    if (!(j < developers.length)) {
                        _context6.next = 21;
                        break;
                    }

                    _context6.next = 16;
                    return _regenerator2.default.awrap(_api2.default.Account.getUser(developers[j].creator, true));

                case 16:
                    account = _context6.sent;

                    developers[j].developer_name = account.data.account.name;

                case 18:
                    j++;
                    _context6.next = 13;
                    break;

                case 21:
                    wv_item.creators = developers;
                    delete wv_item.related_nht_creator;
                    versions.push(wv_item);

                case 24:
                    i++;
                    _context6.next = 7;
                    break;

                case 27:
                    return _context6.abrupt('return', { code: 1, data: versions });

                case 28:
                    return _context6.abrupt('return', { code: 164, message: world_view_name_or_ids + " do not exist" });

                case 31:
                    _context6.prev = 31;
                    _context6.t0 = _context6['catch'](0);
                    return _context6.abrupt('return', {
                        code: 0,
                        message: _context6.t0.message,
                        error: _context6.t0
                    });

                case 34:
                case 'end':
                    return _context6.stop();
            }
        }
    }, null, undefined, [[0, 31]]);
};

var getNHCreator = exports.getNHCreator = function _callee7(nh_asset_creator_account_id) {
    var response, message, item_error_index;
    return _regenerator2.default.async(function _callee7$(_context7) {
        while (1) {
            switch (_context7.prev = _context7.next) {
                case 0:
                    _context7.prev = 0;
                    _context7.next = 3;
                    return _regenerator2.default.awrap(_bcxjsWs.Apis.instance().db_api().exec('get_nh_creator', [nh_asset_creator_account_id]));

                case 3:
                    response = _context7.sent;

                    if (!response) {
                        _context7.next = 9;
                        break;
                    }

                    _context7.next = 7;
                    return _regenerator2.default.awrap(_api2.default.Account.getUser(response.creator, true));

                case 7:
                    response.creator_name = _context7.sent.data.account.name;
                    return _context7.abrupt('return', {
                        code: 1,
                        data: response
                    });

                case 9:
                    _context7.next = 17;
                    break;

                case 11:
                    _context7.prev = 11;
                    _context7.t0 = _context7['catch'](0);

                    console.info("error", _context7.t0);
                    message = _context7.t0.message;

                    try {
                        item_error_index = message.indexOf('end():');

                        if (item_error_index != -1) {
                            message = message.substring(item_error_index + 6);
                        }
                    } catch (e) {}
                    return _context7.abrupt('return', {
                        code: 0,
                        message: message,
                        error: _context7.t0
                    });

                case 17:
                case 'end':
                    return _context7.stop();
            }
        }
    }, null, undefined, [[0, 11]]);
};

var listNHAssetsByCreator = exports.listNHAssetsByCreator = function _callee8(_ref4) {
    var account_id = _ref4.account_id,
        _ref4$worldView = _ref4.worldView,
        worldView = _ref4$worldView === undefined ? "" : _ref4$worldView,
        _ref4$pageSize = _ref4.pageSize,
        pageSize = _ref4$pageSize === undefined ? 10 : _ref4$pageSize,
        _ref4$page = _ref4.page,
        page = _ref4$page === undefined ? 1 : _ref4$page;
    var response;
    return _regenerator2.default.async(function _callee8$(_context8) {
        while (1) {
            switch (_context8.prev = _context8.next) {
                case 0:
                    _context8.prev = 0;
                    _context8.next = 3;
                    return _regenerator2.default.awrap(_bcxjsWs.Apis.instance().db_api().exec('list_nh_asset_by_creator', [account_id, worldView, pageSize, page]));

                case 3:
                    response = _context8.sent;

                    if (!response) {
                        _context8.next = 8;
                        break;
                    }

                    _context8.next = 7;
                    return _regenerator2.default.awrap(formatItems(response[0], response[1]));

                case 7:
                    return _context8.abrupt('return', _context8.sent);

                case 8:
                    return _context8.abrupt('return', {
                        code: 104,
                        message: 'not found'
                    });

                case 11:
                    _context8.prev = 11;
                    _context8.t0 = _context8['catch'](0);
                    return _context8.abrupt('return', {
                        code: 0,
                        message: _context8.t0.message,
                        error: _context8.t0
                    });

                case 14:
                case 'end':
                    return _context8.stop();
            }
        }
    }, null, undefined, [[0, 11]]);
};

var queryOrderDetail = exports.queryOrderDetail = function _callee9(orderId) {
    var order, asset;
    return _regenerator2.default.async(function _callee9$(_context9) {
        while (1) {
            switch (_context9.prev = _context9.next) {
                case 0:
                    _context9.prev = 0;
                    _context9.next = 3;
                    return _regenerator2.default.awrap(_bcxjsWs.Apis.instance().db_api().exec('get_objects', [[orderId]]));

                case 3:
                    order = _context9.sent;

                    if (!(order && order[0])) {
                        _context9.next = 14;
                        break;
                    }

                    order = order[0];
                    _context9.next = 8;
                    return _regenerator2.default.awrap(_api2.default.Assets.fetch([order.price.asset_id], true));

                case 8:
                    asset = _context9.sent;

                    if (!asset) {
                        console.log("é“¾ä¸Šä¸å­˜åœ¨èµ„äº§" + asset_id);
                        asset = {
                            id: "1.3.0",
                            symbol: "COCOS",
                            precision: 5
                        };
                    }
                    order.price_amount = _helper2.default.formatAmount(order.price.amount, asset.precision);
                    order.price_asset_symbol = asset.symbol;
                    order.price_asset_id = asset.id;

                    return _context9.abrupt('return', {
                        code: 1,
                        data: order
                    });

                case 14:
                    return _context9.abrupt('return', { code: 161, message: "Orders do not exist" });

                case 17:
                    _context9.prev = 17;
                    _context9.t0 = _context9['catch'](0);
                    return _context9.abrupt('return', {
                        code: 0,
                        message: _context9.t0.message,
                        error: _context9.t0
                    });

                case 20:
                case 'end':
                    return _context9.stop();
            }
        }
    }, null, undefined, [[0, 17]]);
};

exports.default = {
    listAccountNHAssets: listAccountNHAssets,
    lookupNHAssets: lookupNHAssets,
    listNHAssetOrders: listNHAssetOrders,
    listAccountNHAssetOrders: listAccountNHAssetOrders,
    lookupWorldViews: lookupWorldViews,
    getNHCreator: getNHCreator,
    listNHAssetsByCreator: listNHAssetsByCreator,
    queryOrderDetail: queryOrderDetail
};


var fomatOrders = function _callee11(orders) {
    var nh_asset_ids, items;
    return _regenerator2.default.async(function _callee11$(_context11) {
        while (1) {
            switch (_context11.prev = _context11.next) {
                case 0:
                    orders = orders.sort(function (a, b) {
                        var a_split = a.id.split(".");
                        var b_split = b.id.split(".");
                        return parseInt(b_split[2], 10) - parseInt(a_split[2], 10);
                    }).map(function (item) {
                        item.expiration = new Date(item.expiration + "Z").format("yyyy/MM/dd HH:mm:ss");
                        return item;
                    });

                    if (!orders.length) {
                        _context11.next = 11;
                        break;
                    }

                    nh_asset_ids = orders.map(function (order) {
                        return order.nh_asset_id;
                    });
                    items = {};
                    _context11.next = 6;
                    return _regenerator2.default.awrap(lookupNHAssets(nh_asset_ids));

                case 6:
                    _context11.t0 = function (item) {
                        items[item.id] = item;
                    };

                    _context11.sent.data.forEach(_context11.t0);

                    _context11.next = 10;
                    return _regenerator2.default.awrap(_promise2.default.all(orders.map(function _callee10(order, index) {
                        var asset;
                        return _regenerator2.default.async(function _callee10$(_context10) {
                            while (1) {
                                switch (_context10.prev = _context10.next) {
                                    case 0:
                                        if (items[order.nh_asset_id] && items[order.nh_asset_id].describe_with_contract) order.describe_with_contract = items[order.nh_asset_id].describe_with_contract;
                                        _context10.next = 3;
                                        return _regenerator2.default.awrap(_api2.default.Assets.fetch([order.price.asset_id], true));

                                    case 3:
                                        asset = _context10.sent;

                                        if (asset) {
                                            order.price_amount = _helper2.default.formatAmount(order.price.amount, asset.precision);
                                            order.price_asset_symbol = asset.symbol;
                                            order.price_asset_id = asset.id;
                                        } else {
                                            console.log("é“¾ä¸Šä¸å­˜åœ¨èµ„äº§" + asset_id);
                                        }
                                        _context10.next = 7;
                                        return _regenerator2.default.awrap(_api2.default.Account.getUser(order.seller, true));

                                    case 7:
                                        order.seller_name = _context10.sent.data.account.name;
                                        return _context10.abrupt('return', order);

                                    case 9:
                                    case 'end':
                                        return _context10.stop();
                                }
                            }
                        }, null, undefined);
                    })));

                case 10:
                    orders = _context11.sent;

                case 11:
                    return _context11.abrupt('return', orders);

                case 12:
                case 'end':
                    return _context11.stop();
            }
        }
    }, null, undefined);
};

/***/ }),
/* 520 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getTransactionById = exports.getDataByIds = exports.getWitnessName = exports.getDynGlobalObject = exports.getGlobalObject = undefined;

var _regenerator = __webpack_require__(3);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _bcxjsWs = __webpack_require__(8);

var _bcxjsCores = __webpack_require__(7);

var _api = __webpack_require__(10);

var _api2 = _interopRequireDefault(_api);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var getGlobalObject = exports.getGlobalObject = function _callee() {
    var isCache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var response;
    return _regenerator2.default.async(function _callee$(_context) {
        while (1) {
            switch (_context.prev = _context.next) {
                case 0:
                    _context.prev = 0;
                    response = _bcxjsCores.ChainStore.getObject("2.0.0");

                    if (!(response && isCache)) {
                        _context.next = 6;
                        break;
                    }

                    response = response.toJS();
                    _context.next = 10;
                    break;

                case 6:
                    _context.next = 8;
                    return _regenerator2.default.awrap(_bcxjsWs.Apis.instance().db_api().exec('get_objects', [["2.0.0"]]));

                case 8:
                    response = _context.sent;

                    if (response.length) response = response[0];

                case 10:
                    if (!response) {
                        _context.next = 12;
                        break;
                    }

                    return _context.abrupt('return', {
                        code: 1,
                        data: response
                    });

                case 12:
                    return _context.abrupt('return', {
                        code: 102,
                        message: "Getting 'GlobalObject' failedï¼ŒThe network is busy, please check your network connection"
                    });

                case 15:
                    _context.prev = 15;
                    _context.t0 = _context['catch'](0);
                    return _context.abrupt('return', {
                        code: 0,
                        message: _context.t0.message
                    });

                case 18:
                case 'end':
                    return _context.stop();
            }
        }
    }, null, undefined, [[0, 15]]);
};
var _reqOk = true;
var getDynGlobalObject = exports.getDynGlobalObject = function _callee2() {
    var isExec = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var isReqWitness = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var response;
    return _regenerator2.default.async(function _callee2$(_context2) {
        while (1) {
            switch (_context2.prev = _context2.next) {
                case 0:
                    _context2.prev = 0;

                    if (!(_reqOk || isExec)) {
                        _context2.next = 19;
                        break;
                    }

                    _reqOk = false;
                    response = _bcxjsCores.ChainStore.getObject("2.1.0", false, true, false, false);

                    if (response) {
                        try {
                            response = response.toJS();
                        } catch (e) {}
                    }

                    if (!(!response || isExec)) {
                        _context2.next = 11;
                        break;
                    }

                    _context2.next = 8;
                    return _regenerator2.default.awrap(_bcxjsWs.Apis.instance().db_api().exec('get_objects', [["2.1.0"]]));

                case 8:
                    response = _context2.sent;

                    response = response[0];
                    response.chainTimeOffset = _bcxjsCores.ChainStore.getEstimatedChainTimeOffset();

                case 11:
                    if (!isReqWitness) {
                        _context2.next = 15;
                        break;
                    }

                    _context2.next = 14;
                    return _regenerator2.default.awrap(getWitnessName(response.current_witness));

                case 14:
                    response.current_witness_name = _context2.sent;

                case 15:
                    _reqOk = true;
                    return _context2.abrupt('return', { code: 1, data: response });

                case 19:
                    return _context2.abrupt('return', { code: 0 });

                case 20:
                    _context2.next = 25;
                    break;

                case 22:
                    _context2.prev = 22;
                    _context2.t0 = _context2['catch'](0);
                    return _context2.abrupt('return', {
                        code: 0,
                        message: _context2.t0.message
                    });

                case 25:
                case 'end':
                    return _context2.stop();
            }
        }
    }, null, undefined, [[0, 22]]);
};

var getWitnessName = exports.getWitnessName = function _callee3(witness_id) {
    var current, witness_account, bp_acc_res;
    return _regenerator2.default.async(function _callee3$(_context3) {
        while (1) {
            switch (_context3.prev = _context3.next) {
                case 0:
                    current = _bcxjsCores.ChainStore.getObject(witness_id);
                    witness_account = "";

                    if (!current) {
                        _context3.next = 6;
                        break;
                    }

                    witness_account = current.get("witness_account");
                    _context3.next = 10;
                    break;

                case 6:
                    _context3.next = 8;
                    return _regenerator2.default.awrap(_bcxjsWs.Apis.instance().db_api().exec('get_objects', [[witness_id]]));

                case 8:
                    current = _context3.sent;

                    if (current && current[0]) {
                        witness_account = current[0].witness_account;
                    }

                case 10:
                    if (!witness_account) {
                        _context3.next = 16;
                        break;
                    }

                    _context3.next = 13;
                    return _regenerator2.default.awrap(_api2.default.Account.getAccount(witness_account, true));

                case 13:
                    bp_acc_res = _context3.sent;

                    if (!(bp_acc_res.code == 1)) {
                        _context3.next = 16;
                        break;
                    }

                    return _context3.abrupt('return', bp_acc_res.data.account.name);

                case 16:
                    return _context3.abrupt('return', witness_id);

                case 17:
                case 'end':
                    return _context3.stop();
            }
        }
    }, null, undefined);
};

var getDataByIds = exports.getDataByIds = function _callee4(ids) {
    var response;
    return _regenerator2.default.async(function _callee4$(_context4) {
        while (1) {
            switch (_context4.prev = _context4.next) {
                case 0:
                    _context4.prev = 0;
                    _context4.next = 3;
                    return _regenerator2.default.awrap(_bcxjsWs.Apis.instance().db_api().exec('get_objects', [ids]));

                case 3:
                    response = _context4.sent;

                    if (response) {
                        response = response.filter(function (res) {
                            return res != null;
                        });
                    } else {
                        response = [];
                    }
                    return _context4.abrupt('return', { code: 1, data: response });

                case 8:
                    _context4.prev = 8;
                    _context4.t0 = _context4['catch'](0);
                    return _context4.abrupt('return', {
                        code: 0,
                        message: _context4.t0.message,
                        error: _context4.t0
                    });

                case 11:
                case 'end':
                    return _context4.stop();
            }
        }
    }, null, undefined, [[0, 8]]);
};

var getTransactionById = exports.getTransactionById = function _callee5(trx_id) {
    var response, block, message;
    return _regenerator2.default.async(function _callee5$(_context5) {
        while (1) {
            switch (_context5.prev = _context5.next) {
                case 0:
                    _context5.prev = 0;
                    _context5.next = 3;
                    return _regenerator2.default.awrap(_bcxjsWs.Apis.instance().db_api().exec('get_transaction_by_id', [trx_id]));

                case 3:
                    response = _context5.sent;

                    if (!response) {
                        _context5.next = 10;
                        break;
                    }

                    _context5.next = 7;
                    return _regenerator2.default.awrap(_bcxjsWs.Apis.instance().db_api().exec("get_transaction_in_block_info", [trx_id]));

                case 7:
                    block = _context5.sent;

                    response.block_num = block.block_num;
                    return _context5.abrupt('return', {
                        code: 1,
                        data: response
                    });

                case 10:
                    return _context5.abrupt('return', {
                        code: 104,
                        message: trx_id + ' not found'
                    });

                case 13:
                    _context5.prev = 13;
                    _context5.t0 = _context5['catch'](0);
                    message = _context5.t0.message;
                    return _context5.abrupt('return', {
                        code: 0,
                        message: message,
                        error: _context5.t0
                    });

                case 17:
                case 'end':
                    return _context5.stop();
            }
        }
    }, null, undefined, [[0, 13]]);
};

exports.default = {
    getGlobalObject: getGlobalObject,
    getDynGlobalObject: getDynGlobalObject,
    getTransactionById: getTransactionById,
    getWitnessName: getWitnessName,
    getDataByIds: getDataByIds
};

/***/ }),
/* 521 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(27);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _mutations;

var _account = __webpack_require__(522);

var actions = _interopRequireWildcard(_account);

var _mutations2 = __webpack_require__(14);

var types = _interopRequireWildcard(_mutations2);

var _account2 = __webpack_require__(524);

var getters = _interopRequireWildcard(_account2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var initialState = {
  passwordPubkey: null,
  encryptedBrainkey: null,
  encrypted_key: null,
  brainkeyBackupDate: null,
  encryptionKey: null,
  created: null,
  aesPrivate: null,
  userId: null,
  error: null,
  pending: false,
  keys: null,
  callback: null,
  userData: null,
  userFetching: false,
  userError: false,
  imported_keys_public: {},
  keys_to_account: {}
};

var mutations = (_mutations = {}, (0, _defineProperty3.default)(_mutations, types.ACCOUNT_SIGNUP_REQUEST, function (state) {
  state.pending = true;
}), (0, _defineProperty3.default)(_mutations, types.ACCOUNT_SIGNUP_COMPLETE, function (state, _ref) {
  var wallet = _ref.wallet,
      userId = _ref.userId;

  state.pending = false;
  state.passwordPubkey = wallet.passwordPubkey;
  state.encrypted_key = wallet.encrypted_key;
  state.encryptionKey = wallet.encryptionKey;
  // state.aesPrivate = wallet.aesPrivate;
  state.brainkeyBackupDate = null;
  state.created = new Date();
  state.userId = userId;
}), (0, _defineProperty3.default)(_mutations, types.ACCOUNT_SIGNUP_ERROR, function (state, _ref2) {
  var error = _ref2.error;

  state.pending = false;
  state.error = error;
}), (0, _defineProperty3.default)(_mutations, types.ACCOUNT_LOGIN_REQUEST, function (state) {
  state.pending = true;
}), (0, _defineProperty3.default)(_mutations, types.ACCOUNT_LOGIN_COMPLETE, function (state, _ref3) {
  var wallet = _ref3.wallet,
      userId = _ref3.userId;

  state.pending = false;
  state.userId = userId;
  if (wallet) {
    state.passwordPubkey = wallet.passwordPubkey;
    state.encrypted_key = wallet.encrypted_key;
    state.encryptionKey = wallet.encryptionKey;
    // state.aesPrivate = wallet.aesPrivate;
    state.wallet = wallet;
  }
}), (0, _defineProperty3.default)(_mutations, types.ACCOUNT_LOGIN_ERROR, function (state, _ref4) {
  var error = _ref4.error;

  state.pending = false;
  state.error = error;
}), (0, _defineProperty3.default)(_mutations, types.ACCOUNT_BRAINKEY_BACKUP, function (state) {
  state.brainkeyBackupDate = Date();
}), (0, _defineProperty3.default)(_mutations, types.ACCOUNT_LOCK_WALLET, function (state) {
  state.aesPrivate = null;
}), (0, _defineProperty3.default)(_mutations, types.ACCOUNT_UNLOCK_WALLET, function (state, aesPrivate) {
  state.aesPrivate = aesPrivate;
}), (0, _defineProperty3.default)(_mutations, types.SET_ACCOUNT_USER_DATA, function (state, _ref5) {
  var userId = _ref5.userId,
      encryptedBrainkey = _ref5.encryptedBrainkey,
      encryptionKey = _ref5.encryptionKey,
      backupDate = _ref5.backupDate,
      passwordPubkey = _ref5.passwordPubkey;

  //state.userId = userId;
  // state.encryptedBrainkey = encryptedBrainkey; 
  // state.encryptionKey = encryptionKey;
  state.brainkeyBackupDate = backupDate;
  //state.passwordPubkey = passwordPubkey;
}), (0, _defineProperty3.default)(_mutations, types.ACCOUNT_LOGOUT, function (state) {
  state.passwordPubkey = null;
  state.encryptedBrainkey = null;
  state.brainkeyBackupDate = null;
  state.encryptionKey = null;
  state.created = null;
  state.aesPrivate = null;
  state.userId = null;
  state.error = null;
  state.pending = false;
}), (0, _defineProperty3.default)(_mutations, types.FETCH_CURRENT_USER_REQUEST, function (state) {
  state.userFetching = true;
}), (0, _defineProperty3.default)(_mutations, types.FETCH_CURRENT_USER_COMPLETE, function (state, _ref6) {
  var data = _ref6.data;

  state.userFetching = false;
  state.userData = data;
}), (0, _defineProperty3.default)(_mutations, types.FETCH_CURRENT_USER_ERROR, function (state) {
  state.userFetching = false;
  state.userError = false;
}), (0, _defineProperty3.default)(_mutations, types.SET_PASSWORD_LONGIN_KEY, function (state, keys) {
  state.keys = keys;
}), (0, _defineProperty3.default)(_mutations, types.SET_CALLBACK, function (state, callback) {

  state.callback = callback;
}), _mutations);

exports.default = {
  state: initialState,
  mutations: mutations,
  actions: actions,
  getters: getters,
  namespaced: true
};

/***/ }),
/* 522 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAccountInfo = exports.claimVestingBalance = exports.queryVestingBalance = exports.setAccountUserId = exports.fetchCurrentUser = exports._validateAccount = exports._psdChangePrivateKey = exports._accountOpt = exports.accountOpt = exports._getPrivateKey = exports.checkIfUsernameFree = exports.checkCachedUserData = exports._logout = exports.logout = exports.changePassword = exports.upgradeAccount = exports.passwordLogin = exports.getInitialState = exports.saveImport = exports.importWIFKey = exports.importPrivateKey = exports.keyLogin = exports.account_signup_complete = exports.application_api_create_account = exports.createAccountWithWallet = exports.createAccountWithPublicKey = exports.createAccountWithPassword = exports.lockWallet = exports.unlockWallet = undefined;

var _getIterator2 = __webpack_require__(52);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _keys = __webpack_require__(24);

var _keys2 = _interopRequireDefault(_keys);

var _slicedToArray2 = __webpack_require__(90);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _regenerator = __webpack_require__(3);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _promise = __webpack_require__(4);

var _promise2 = _interopRequireDefault(_promise);

var _bcxjsCores = __webpack_require__(7);

var _immutable = __webpack_require__(23);

var _immutable2 = _interopRequireDefault(_immutable);

var _mutations = __webpack_require__(14);

var types = _interopRequireWildcard(_mutations);

var _api = __webpack_require__(10);

var _api2 = _interopRequireDefault(_api);

var _persistentStorage = __webpack_require__(147);

var _persistentStorage2 = _interopRequireDefault(_persistentStorage);

var _WalletDb = __webpack_require__(227);

var WalletDbS = _interopRequireWildcard(_WalletDb);

var _utils = __webpack_require__(59);

var _utils2 = _interopRequireDefault(_utils);

var _helper = __webpack_require__(34);

var _helper2 = _interopRequireDefault(_helper);

var _regular = __webpack_require__(523);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _passwordKey = null;
var OWNER_KEY_INDEX = 1;
var ACTIVE_KEY_INDEX = 0;

// helper fync
var createWallet = function createWallet(_ref) {
  var password = _ref.password,
      wif = _ref.wif;

  var passwordAes = _bcxjsCores.Aes.fromSeed(password);
  var encryptionBuffer = _bcxjsCores.key.get_random_key().toBuffer();
  var encryptionKey = passwordAes.encryptToHex(encryptionBuffer);
  var aesPrivate = _bcxjsCores.Aes.fromSeed(encryptionBuffer);

  var private_key = _bcxjsCores.PrivateKey.fromWif(wif); //could throw and error
  var private_plainhex = private_key.toBuffer().toString('hex');

  var encrypted_key = aesPrivate.encryptHex(private_plainhex);

  var passwordPrivate = _bcxjsCores.PrivateKey.fromSeed(password);
  var passwordPubkey = passwordPrivate.toPublicKey().toPublicKeyString();

  var result = {
    passwordPubkey: passwordPubkey,
    encryptionKey: encryptionKey,
    encrypted_key: encrypted_key,
    aesPrivate: aesPrivate
  };

  return result;
};

/**
 * Unlocks user's wallet via provided password
 * @param {string} password - user password
 */
var unlockWallet = exports.unlockWallet = function unlockWallet(_ref2, password) {
  var commit = _ref2.commit,
      state = _ref2.state;

  var passwordAes = _bcxjsCores.Aes.fromSeed(password);
  var encryptionPlainbuffer = passwordAes.decryptHexToBuffer(state.encryptionKey);
  var aesPrivate = _bcxjsCores.Aes.fromSeed(encryptionPlainbuffer);
  commit(types.ACCOUNT_UNLOCK_WALLET, aesPrivate);
};

/**
 * Locks user's wallet
 */
var lockWallet = exports.lockWallet = function lockWallet(_ref3) {
  var commit = _ref3.commit;

  commit(types.ACCOUNT_LOCK_WALLET);
};

/**
 * Creates account & wallet for user
 * @param {string} name - user name
 * @param {string} password - user password
 * @param {string} dictionary - string to generate brainkey from
 */
var createAccountWithPassword = exports.createAccountWithPassword = function _callee(store, params) {
  var account, password, _params$autoLogin, autoLogin, _params$onlyGetFee, onlyGetFee, commit, dispatch, rootGetters, getters, acc_res, _WalletDbS$generateKe, owner_private, _WalletDbS$generateKe2, active_private, result, exist_account_id, settingsAPIs;

  return _regenerator2.default.async(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          if (_helper2.default.trimParams(params)) {
            _context.next = 2;
            break;
          }

          return _context.abrupt('return', { code: 101, message: "Parameter is missing" });

        case 2:
          account = params.account, password = params.password, _params$autoLogin = params.autoLogin, autoLogin = _params$autoLogin === undefined ? false : _params$autoLogin, _params$onlyGetFee = params.onlyGetFee, onlyGetFee = _params$onlyGetFee === undefined ? false : _params$onlyGetFee;

          if (/^[a-z]([a-z0-9\.-]){4,62}$/.test(account)) {
            _context.next = 5;
            break;
          }

          return _context.abrupt('return', { code: 103, message: "Please enter the correct account name(/^[a-z]([a-z0-9\.-]){4,62}$/)" });

        case 5:
          if (_regular.NewPassword.test(password)) {
            _context.next = 7;
            break;
          }

          return _context.abrupt('return', {
            code: 311,
            //Please confirm that account is registered through account mode, accounts registered in wallet mode cannot login here.
            message: 'password format error'
          });

        case 7:
          commit = store.commit, dispatch = store.dispatch, rootGetters = store.rootGetters, getters = store.getters;
          _context.next = 10;
          return _regenerator2.default.awrap(dispatch("user/getUserInfo", { account: account, isCache: true }, { root: true }));

        case 10:
          acc_res = _context.sent;

          if (!(acc_res.code == 1)) {
            _context.next = 13;
            break;
          }

          return _context.abrupt('return', { code: 159, message: "Account exists" });

        case 13:

          commit(types.ACCOUNT_SIGNUP_REQUEST);
          //generate owner and active keys
          _WalletDbS$generateKe = WalletDbS.generateKeyFromPassword(account, "owner", password), owner_private = _WalletDbS$generateKe.privKey;
          _WalletDbS$generateKe2 = WalletDbS.generateKeyFromPassword(account, "active", password), active_private = _WalletDbS$generateKe2.privKey;
          // getAccountUserId

          result = void 0;
          exist_account_id = getters.getAccountUserId;

          if (!exist_account_id) {
            _context.next = 24;
            break;
          }

          _context.next = 21;
          return _regenerator2.default.awrap(dispatch("application_api_create_account", {
            owner_pubkey: owner_private.toPublicKey().toPublicKeyString(),
            active_pubkey: active_private.toPublicKey().toPublicKeyString(),
            new_account_name: account,
            registrar: exist_account_id,
            referrer: exist_account_id,
            referrer_percent: 0,
            onlyGetFee: onlyGetFee
          }));

        case 21:
          return _context.abrupt('return', _context.sent);

        case 24:
          settingsAPIs = rootGetters["setting/g_settingsAPIs"];
          //faucet account registration

          _context.next = 27;
          return _regenerator2.default.awrap(_api2.default.Account.createAccount({
            name: account,
            activePubkey: active_private.toPublicKey().toPublicKeyString(),
            ownerPubkey: owner_private.toPublicKey().toPublicKeyString(),
            referrer: settingsAPIs.referrer || ''
          }, settingsAPIs.default_faucet));

        case 27:
          result = _context.sent;

        case 28:

          console.log('Account created : ', result.success);

          if (!result.success) {
            _context.next = 32;
            break;
          }

          return _context.abrupt('return', new _promise2.default(function (resolve) {
            setTimeout(function () {
              if (autoLogin) {
                resolve(dispatch("account/passwordLogin", {
                  account: account,
                  password: password
                }, { root: true }));
              } else {
                _api2.default.Account.getAccountIdByOwnerPubkey(result.data.account.owner_key).then(function (userId) {
                  var id = userId && userId[0];
                  if (id) id = userId[0];
                  resolve({ code: 1, data: { account_id: id, account_name: account } });
                });
              }
            }, 2000);
          }));

        case 32:

          commit(types.ACCOUNT_SIGNUP_ERROR, { error: result.error });
          return _context.abrupt('return', { code: result.code, message: result.error, error: result.error });

        case 34:
        case 'end':
          return _context.stop();
      }
    }
  }, null, undefined);
};

var createAccountWithPublicKey = exports.createAccountWithPublicKey = function _callee2(store, params) {
  var account, ownerPubkey, activePubkey, commit, dispatch, rootGetters, getters, acc_res, result, exist_account_id, settingsAPIs, userId, id;
  return _regenerator2.default.async(function _callee2$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          if (_helper2.default.trimParams(params)) {
            _context2.next = 2;
            break;
          }

          return _context2.abrupt('return', { code: 101, message: "Parameter is missing" });

        case 2:
          account = params.account, ownerPubkey = params.ownerPubkey, activePubkey = params.activePubkey;

          if (/^[a-z]([a-z0-9\.-]){4,62}$/.test(account)) {
            _context2.next = 5;
            break;
          }

          return _context2.abrupt('return', { code: 103, message: "Please enter the correct account name(/^[a-z]([a-z0-9\.-]){4,62}$/)" });

        case 5:
          commit = store.commit, dispatch = store.dispatch, rootGetters = store.rootGetters, getters = store.getters;
          _context2.next = 8;
          return _regenerator2.default.awrap(dispatch("user/getUserInfo", { account: account, isCache: true }, { root: true }));

        case 8:
          acc_res = _context2.sent;

          if (!(acc_res.code == 1)) {
            _context2.next = 11;
            break;
          }

          return _context2.abrupt('return', { code: 159, message: "Account exists" });

        case 11:

          commit(types.ACCOUNT_SIGNUP_REQUEST);
          result = void 0;
          exist_account_id = getters.getAccountUserId;

          if (!exist_account_id) {
            _context2.next = 20;
            break;
          }

          _context2.next = 17;
          return _regenerator2.default.awrap(dispatch("application_api_create_account", {
            owner_pubkey: ownerPubkey,
            active_pubkey: activePubkey,
            new_account_name: account,
            registrar: exist_account_id,
            referrer: exist_account_id,
            referrer_percent: 0
          }));

        case 17:
          return _context2.abrupt('return', _context2.sent);

        case 20:
          settingsAPIs = rootGetters["setting/g_settingsAPIs"];
          //faucet account registration

          _context2.next = 23;
          return _regenerator2.default.awrap(_api2.default.Account.createAccount({
            name: account,
            activePubkey: activePubkey,
            ownerPubkey: ownerPubkey,
            referrer: settingsAPIs.referrer || ''
          }, settingsAPIs.default_faucet));

        case 23:
          result = _context2.sent;

        case 24:

          console.log('Account created : ', result.success);

          if (!result.success) {
            _context2.next = 32;
            break;
          }

          _context2.next = 28;
          return _regenerator2.default.awrap(_api2.default.Account.getAccountIdByOwnerPubkey(result.data.account.owner_key));

        case 28:
          userId = _context2.sent;
          id = userId && userId[0];

          if (id) id = userId[0];
          // console.info("id",id,result);
          return _context2.abrupt('return', { code: 1, data: {
              "account_id": id,
              account_name: account,
              active_public_key: activePubkey,
              owner_public_key: ownerPubkey
            } });

        case 32:

          commit(types.ACCOUNT_SIGNUP_ERROR, { error: result.error });
          return _context2.abrupt('return', { code: result.code, message: result.error, error: result.error });

        case 34:
        case 'end':
          return _context2.stop();
      }
    }
  }, null, undefined);
};

var createAccountWithWallet = exports.createAccountWithWallet = function _callee3(_ref4, params) {
  var dispatch = _ref4.dispatch,
      rootGetters = _ref4.rootGetters;

  var callback, account, password, _params$onlyGetFee2, onlyGetFee, acc_res;

  return _regenerator2.default.async(function _callee3$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          if (_helper2.default.trimParams(params)) {
            _context3.next = 2;
            break;
          }

          return _context3.abrupt('return', { code: 101, message: "Parameter is missing" });

        case 2:
          callback = params.callback, account = params.account, password = params.password, _params$onlyGetFee2 = params.onlyGetFee, onlyGetFee = _params$onlyGetFee2 === undefined ? false : _params$onlyGetFee2;

          dispatch("transactions/setOnlyGetOPFee", onlyGetFee, { root: true });

          if (_regular.NewPassword.test(password)) {
            _context3.next = 6;
            break;
          }

          return _context3.abrupt('return', {
            code: 311,
            //Please confirm that account is registered through account mode, accounts registered in wallet mode cannot login here.
            message: 'password format error'
          });

        case 6:
          if (/^[a-z]([a-z0-9\.-]){4,62}/.test(account)) {
            _context3.next = 8;
            break;
          }

          return _context3.abrupt('return', { code: 103, message: "Please enter the correct account name(/^[a-z]([a-z0-9\.-]){4,62}/)" });

        case 8:
          if (rootGetters["WalletDb/wallet"]) {
            _context3.next = 11;
            break;
          }

          _context3.next = 11;
          return _regenerator2.default.awrap(dispatch("account/_logout", null, { root: true }));

        case 11:
          _context3.next = 13;
          return _regenerator2.default.awrap(dispatch("user/getUserInfo", { account: account, isCache: true }, { root: true }));

        case 13:
          acc_res = _context3.sent;

          if (!(acc_res.code == 1)) {
            _context3.next = 16;
            break;
          }

          return _context3.abrupt('return', { code: 159, message: "Account exists" });

        case 16:
          if (!rootGetters["WalletDb/wallet"]) {
            _context3.next = 22;
            break;
          }

          if (!rootGetters["WalletDb/isLocked"]) {
            _context3.next = 19;
            break;
          }

          return _context3.abrupt('return', { code: 149, message: "Please unlock your wallet first" });

        case 19:
          return _context3.abrupt('return', dispatch("WalletDb/createAccount", {
            account_name: account,
            registrar: rootGetters["account/getAccountUserId"],
            referrer: rootGetters["account/getAccountUserId"]
          }, { root: true }).then(function (res) {
            if (res.code != 1) {
              dispatch("WalletManagerStore/deleteWallet", null, { root: true });
            }
            return res;
          }).catch(function (error) {
            return { code: 0, message: error.message, error: error };
          }));

        case 22:
          return _context3.abrupt('return', dispatch("WalletDb/createWallet", { password: password, account: account }, { root: true }));

        case 23:
        case 'end':
          return _context3.stop();
      }
    }
  }, null, undefined);
};

var application_api_create_account = exports.application_api_create_account = function application_api_create_account(_ref5, _ref6) {
  var dispatch = _ref5.dispatch;
  var owner_pubkey = _ref6.owner_pubkey,
      active_pubkey = _ref6.active_pubkey,
      new_account_name = _ref6.new_account_name,
      registrar = _ref6.registrar,
      referrer = _ref6.referrer,
      _ref6$onlyGetFee = _ref6.onlyGetFee,
      onlyGetFee = _ref6$onlyGetFee === undefined ? false : _ref6$onlyGetFee,
      _ref6$referrer_percen = _ref6.referrer_percent,
      referrer_percent = _ref6$referrer_percen === undefined ? 0 : _ref6$referrer_percen;


  _bcxjsCores.ChainValidation.required(registrar, "registrar_id");
  _bcxjsCores.ChainValidation.required(referrer, "referrer_id");

  return _promise2.default.all([(0, _bcxjsCores.FetchChain)("getAccount", registrar), (0, _bcxjsCores.FetchChain)("getAccount", referrer)]).then(function (res) {
    var _res = (0, _slicedToArray3.default)(res, 2),
        chain_registrar = _res[0],
        chain_referrer = _res[1];

    var ca_res = dispatch('transactions/_transactionOperations', {
      operations: [{
        op_type: 5,
        type: "account_create",
        params: {
          fee: {
            amount: 0,
            asset_id: 0
          },
          "registrar": chain_registrar.get("id"),
          // "referrer": chain_referrer.get("id"),
          // "referrer_percent": referrer_percent,
          "name": new_account_name,
          "owner": {
            "weight_threshold": 1,
            "account_auths": [],
            "key_auths": [[owner_pubkey, 1]],
            "address_auths": []
          },
          "active": {
            "weight_threshold": 1,
            "account_auths": [],
            "key_auths": [[active_pubkey, 1]],
            "address_auths": []
          },
          "options": {
            "memo_key": active_pubkey,
            // "voting_account": "1.2.5",
            // "num_witness": 0,
            // "num_committee": 0,
            "votes": []
          }
        }
      }],
      onlyGetFee: onlyGetFee
    }, { root: true });
    return ca_res;
  });
};

var account_signup_complete = exports.account_signup_complete = function account_signup_complete(_ref7, _ref8) {
  var commit = _ref7.commit;
  var wallet = _ref8.wallet,
      userId = _ref8.userId;

  commit(types.ACCOUNT_LOGIN_COMPLETE, { wallet: wallet, userId: userId });
};

var keyLogin = exports.keyLogin = function _callee4(store, params) {
  var _params$password, password, wif, commit, dispatch, rootGetters, private_key, activePubkey, userId, id, wallet;

  return _regenerator2.default.async(function _callee4$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          if (_helper2.default.trimParams(params)) {
            _context4.next = 2;
            break;
          }

          return _context4.abrupt('return', { code: 101, message: "Parameter is missing" });

        case 2:
          _params$password = params.password, password = _params$password === undefined ? "" : _params$password, wif = params.wif;

          if (/^5[HJK][1-9A-Za-z]{49}$/.test(wif)) {
            _context4.next = 5;
            break;
          }

          return _context4.abrupt('return', { code: 109, message: "Please enter the correct private key" });

        case 5:
          commit = store.commit, dispatch = store.dispatch, rootGetters = store.rootGetters;

          if (!rootGetters["WalletDb/wallet"]) {
            _context4.next = 9;
            break;
          }

          _context4.next = 9;
          return _regenerator2.default.awrap(dispatch("WalletManagerStore/deleteWallet", null, { root: true }));

        case 9:
          private_key = _bcxjsCores.PrivateKey.fromWif(wif); //could throw and error

          activePubkey = private_key.toPublicKey().toPublicKeyString();
          _context4.next = 13;
          return _regenerator2.default.awrap(_api2.default.Account.getAccountIdByOwnerPubkey(activePubkey));

        case 13:
          userId = _context4.sent;
          id = userId && userId[0];

          if (!id) {
            _context4.next = 26;
            break;
          }

          _context4.next = 18;
          return _regenerator2.default.awrap(dispatch("_logout"));

        case 18:
          wallet = createWallet({ password: password, wif: wif });

          commit(types.ACCOUNT_LOGIN_COMPLETE, { wallet: wallet, userId: id });
          _persistentStorage2.default.saveUserData({
            id: id,
            encrypted_key: wallet.encrypted_key,
            encryptionKey: wallet.encryptionKey,
            passwordPubkey: wallet.passwordPubkey,
            activePubkey: activePubkey
          });

          dispatch("PrivateKeyStore/setKeys", {
            import_account_names: [id],
            encrypted_key: wallet.encrypted_key,
            pubkey: activePubkey
          }, { root: true });
          dispatch('WalletDb/validatePassword', { password: password, unlock: true }, { root: true });

          _context4.next = 25;
          return _regenerator2.default.awrap(dispatch("user/fetchUser", id, { root: true }));

        case 25:
          return _context4.abrupt('return', dispatch("getAccountInfo"));

        case 26:
          commit(types.ACCOUNT_LOGIN_ERROR, { error: 'Login error' });
          return _context4.abrupt('return', {
            code: 110,
            message: 'The private key has no account information'
          });

        case 28:
        case 'end':
          return _context4.stop();
      }
    }
  }, null, undefined);
};

var importPrivateKey = exports.importPrivateKey = function _callee5(_ref9, params) {
  var rootGetters = _ref9.rootGetters,
      state = _ref9.state,
      dispatch = _ref9.dispatch;

  var _params$password2, password, privateKey, accounts, vp_res, private_key, private_plainhex, public_key, public_key_string, userId, id, acc_res, account_name;

  return _regenerator2.default.async(function _callee5$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          if (_helper2.default.trimParams(params)) {
            _context5.next = 2;
            break;
          }

          return _context5.abrupt('return', { code: 101, message: "Parameter is missing" });

        case 2:
          _params$password2 = params.password, password = _params$password2 === undefined ? "" : _params$password2, privateKey = params.privateKey;

          if (_regular.NewPassword.test(password)) {
            _context5.next = 5;
            break;
          }

          return _context5.abrupt('return', {
            code: 311,
            //Please confirm that account is registered through account mode, accounts registered in wallet mode cannot login here.
            message: 'password format error'
          });

        case 5:
          accounts = rootGetters["AccountStore/linkedAccounts"].toJS();

          if (!accounts.length) {
            _context5.next = 12;
            break;
          }

          _context5.next = 9;
          return _regenerator2.default.awrap(dispatch("WalletDb/validatePassword", { password: password, unlock: true }, { root: true }));

        case 9:
          vp_res = _context5.sent;

          if (!(vp_res.code != 1)) {
            _context5.next = 12;
            break;
          }

          return _context5.abrupt('return', vp_res);

        case 12:
          if (rootGetters["WalletDb/wallet"]) {
            _context5.next = 15;
            break;
          }

          _context5.next = 15;
          return _regenerator2.default.awrap(dispatch("account/_logout", null, { root: true }));

        case 15:
          private_key = _bcxjsCores.PrivateKey.fromWif(privateKey); //could throw and error

          private_plainhex = private_key.toBuffer().toString('hex');
          public_key = private_key.toPublicKey(); // S L O W

          public_key_string = public_key.toPublicKeyString();

          state.imported_keys_public[public_key_string] = true;

          if (!rootGetters["PrivateKeyStore/keys"][public_key_string]) {
            _context5.next = 22;
            break;
          }

          return _context5.abrupt('return', { code: 160, message: "The private key has been imported into the wallet" });

        case 22:
          _context5.next = 24;
          return _regenerator2.default.awrap(_api2.default.Account.getAccountIdByOwnerPubkey(public_key_string));

        case 24:
          userId = _context5.sent;
          id = userId && userId[0];
          acc_res = void 0, account_name = "";

          if (!id) {
            _context5.next = 40;
            break;
          }

          _context5.next = 30;
          return _regenerator2.default.awrap(dispatch("user/fetchUserForIsSave", { nameOrId: id, isSave: true }, { root: true }));

        case 30:
          acc_res = _context5.sent;

          if (!acc_res.success) {
            _context5.next = 37;
            break;
          }

          account_name = acc_res.data.account.name;
          _context5.next = 35;
          return _regenerator2.default.awrap(dispatch("AccountStore/setCurrentAccount", account_name, { root: true }));

        case 35:
          _context5.next = 38;
          break;

        case 37:
          return _context5.abrupt('return', acc_res);

        case 38:
          _context5.next = 41;
          break;

        case 40:
          return _context5.abrupt('return', { code: 110, message: "The private key has no account information" });

        case 41:

          state.keys_to_account[private_plainhex] = {
            account_names: [account_name], public_key_string: public_key_string
          };

          if (!rootGetters["WalletDb/wallet"]) {
            _context5.next = 46;
            break;
          }

          return _context5.abrupt('return', dispatch("importWIFKey", { password: password, public_key_string: public_key_string }));

        case 46:
          return _context5.abrupt('return', dispatch("WalletDb/createWallet", { password: password, isCreateAccount: false }, { root: true }).then(function () {
            return dispatch("importWIFKey", { password: password, p_public_key_string: public_key_string });
          }));

        case 47:
        case 'end':
          return _context5.stop();
      }
    }
  }, null, undefined);
};

var importWIFKey = exports.importWIFKey = function _callee6(_ref10, _ref11) {
  var rootGetters = _ref10.rootGetters,
      state = _ref10.state,
      dispatch = _ref10.dispatch;
  var password = _ref11.password,
      p_public_key_string = _ref11.p_public_key_string;

  var keys, dups, _public_key_string, keys_to_account, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, private_plainhex, _keys_to_account$priv, account_names, public_key_string;

  return _regenerator2.default.async(function _callee6$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          keys = rootGetters["PrivateKeyStore/keys"];
          dups = {};
          _context6.t0 = _regenerator2.default.keys(state.imported_keys_public);

        case 3:
          if ((_context6.t1 = _context6.t0()).done) {
            _context6.next = 11;
            break;
          }

          _public_key_string = _context6.t1.value;

          if (keys[_public_key_string]) {
            _context6.next = 7;
            break;
          }

          return _context6.abrupt('continue', 3);

        case 7:
          delete state.imported_keys_public[_public_key_string];
          dups[_public_key_string] = true;
          _context6.next = 3;
          break;

        case 11:
          if (!((0, _keys2.default)(state.imported_keys_public).length === 0)) {
            _context6.next = 13;
            break;
          }

          return _context6.abrupt('return', { code: 149, message: "This wallet has already been imported" });

        case 13:
          keys_to_account = state.keys_to_account;
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          _context6.prev = 17;

          for (_iterator = (0, _getIterator3.default)((0, _keys2.default)(keys_to_account)); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            private_plainhex = _step.value;
            _keys_to_account$priv = keys_to_account[private_plainhex], account_names = _keys_to_account$priv.account_names, public_key_string = _keys_to_account$priv.public_key_string;

            if (dups[public_key_string]) delete keys_to_account[private_plainhex];
          }

          _context6.next = 25;
          break;

        case 21:
          _context6.prev = 21;
          _context6.t2 = _context6['catch'](17);
          _didIteratorError = true;
          _iteratorError = _context6.t2;

        case 25:
          _context6.prev = 25;
          _context6.prev = 26;

          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }

        case 28:
          _context6.prev = 28;

          if (!_didIteratorError) {
            _context6.next = 31;
            break;
          }

          throw _iteratorError;

        case 31:
          return _context6.finish(28);

        case 32:
          return _context6.finish(25);

        case 33:
          return _context6.abrupt('return', dispatch('WalletDb/validatePassword', { password: password, unlock: true }, { root: true }).then(function (res) {
            if (res.code == 1) {
              return dispatch("saveImport");
            } else {
              return res;
            }
          }));

        case 34:
        case 'end':
          return _context6.stop();
      }
    }
  }, null, undefined, [[17, 21, 25, 33], [26,, 28, 32]]);
};

var saveImport = exports.saveImport = function saveImport(_ref12) {
  var state = _ref12.state,
      dispatch = _ref12.dispatch,
      rootGetters = _ref12.rootGetters;

  var keys_to_account = state.keys_to_account;
  var private_key_objs = [];
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = (0, _getIterator3.default)((0, _keys2.default)(keys_to_account)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var private_plainhex = _step2.value;
      var _keys_to_account$priv2 = keys_to_account[private_plainhex],
          account_names = _keys_to_account$priv2.account_names,
          public_key_string = _keys_to_account$priv2.public_key_string;

      private_key_objs.push({
        private_plainhex: private_plainhex,
        import_account_names: account_names,
        public_key_string: public_key_string
      });
    }
    // this.reset()
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  dispatch("getInitialState");
  return dispatch("WalletDb/importKeysWorker", private_key_objs, { root: true }).then(function (result) {

    var import_count = private_key_objs.length;
    console.log('Successfully imported ' + import_count + ' keys.');
    // this.onCancel() // back to claim balances.
    return dispatch("AccountRefsStore/checkPrivateKeyStore", null, { root: true }).then(function () {
      return dispatch("AccountStore/onCreateAccount", { name_or_account: private_key_objs[0].import_account_names[0] }, { root: true }).then(function () {
        var names = rootGetters["AccountStore/linkedAccounts"].toArray().sort();
        return dispatch("getAccountInfo");
      });
    });
  }).catch(function (error) {
    console.error("error:", error);
    var message = error;
    try {
      message = error.target.error.message;
    } catch (e) {}
    return { code: 150, message: 'Key import error: ' + message, error: error };
  });
};

var getInitialState = exports.getInitialState = function getInitialState(_ref13) {
  var state = _ref13.state;
  var keep_file_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  state.keys_to_account = {};
  state.no_file = true;
  state.account_keys = [];
  state.reset_file_name = keep_file_name ? undefined.state.reset_file_name : Date.now();
  state.reset_password = Date.now();
  state.password_checksum = null;
  state.import_file_message = null;
  state.import_password_message = null;
  state.imported_keys_public = {};
  state.key_text_message = null;
  state.validPassword = false;
  state.error_message = null;
  state.wif = "";
  state.encrypt_wif = false;
};

var passwordLogin = exports.passwordLogin = function _callee7(store, params) {
  var account, password, commit, rootGetters, dispatch, _ref14, ownerKey, _ref15, activeKey, ownerPubkey, userId, id, vp_result;

  return _regenerator2.default.async(function _callee7$(_context7) {
    while (1) {
      switch (_context7.prev = _context7.next) {
        case 0:
          if (_helper2.default.trimParams(params)) {
            _context7.next = 2;
            break;
          }

          return _context7.abrupt('return', { code: 101, message: "Parameter is missing" });

        case 2:
          account = params.account, password = params.password;
          commit = store.commit, rootGetters = store.rootGetters, dispatch = store.dispatch;

          commit(types.ACCOUNT_LOGIN_REQUEST);

          _context7.next = 7;
          return _regenerator2.default.awrap(dispatch("WalletDb/generateKeyFromPassword", {
            account: account,
            role: "owner",
            password: password
          }, { root: true }));

        case 7:
          _ref14 = _context7.sent;
          ownerKey = _ref14.privKey;
          _context7.next = 11;
          return _regenerator2.default.awrap(dispatch("WalletDb/generateKeyFromPassword", {
            account: account,
            role: "active",
            password: password
          }, { root: true }));

        case 11:
          _ref15 = _context7.sent;
          activeKey = _ref15.privKey;
          ownerPubkey = ownerKey.toPublicKey().toPublicKeyString();
          _context7.next = 16;
          return _regenerator2.default.awrap(_api2.default.Account.getAccountIdByOwnerPubkey(ownerPubkey));

        case 16:
          userId = _context7.sent;
          id = userId && userId[0];

          if (!id) {
            _context7.next = 41;
            break;
          }

          if (!rootGetters["AccountStore/linkedAccounts"].size) {
            _context7.next = 24;
            break;
          }

          _context7.next = 22;
          return _regenerator2.default.awrap(dispatch("WalletManagerStore/deleteWallet", null, { root: true }));

        case 22:
          _context7.next = 26;
          break;

        case 24:
          _context7.next = 26;
          return _regenerator2.default.awrap(dispatch("_logout"));

        case 26:
          _context7.next = 28;
          return _regenerator2.default.awrap(dispatch("WalletDb/validatePassword", {
            password: password,
            unlock: true,
            account: account,
            roles: ["active", "owner", "memo"]
          }, { root: true }));

        case 28:
          vp_result = _context7.sent;


          delete vp_result.cloudMode;
          delete vp_result.success;

          if (!(vp_result.code != 1)) {
            _context7.next = 33;
            break;
          }

          return _context7.abrupt('return', vp_result);

        case 33:

          id = userId[0];

          commit(types.ACCOUNT_LOGIN_COMPLETE, { userId: id });
          _persistentStorage2.default.saveUserData({ id: id });

          _context7.next = 38;
          return _regenerator2.default.awrap(dispatch("getAccountInfo"));

        case 38:
          return _context7.abrupt('return', _context7.sent);

        case 41:
          commit(types.ACCOUNT_LOGIN_ERROR, { error: 'Login error' });
          return _context7.abrupt('return', {
            code: 108,
            //Please confirm that account is registered through account mode, accounts registered in wallet mode cannot login here.
            message: 'User name or password error (please confirm that your account is registered in account mode)'
          });

        case 43:
        case 'end':
          return _context7.stop();
      }
    }
  }, null, undefined);
};

var upgradeAccount = exports.upgradeAccount = function upgradeAccount(_ref16, _ref17) {
  var dispatch = _ref16.dispatch,
      getters = _ref16.getters;
  var onlyGetFee = _ref17.onlyGetFee,
      feeAssetId = _ref17.feeAssetId;

  return dispatch('transactions/_transactionOperations', {
    operations: [{
      op_type: 7,
      type: "account_upgrade",
      params: {
        account_to_upgrade: getters.getAccountUserId,
        upgrade_to_lifetime_member: true,
        fee_asset_id: feeAssetId
      }
    }],
    onlyGetFee: onlyGetFee
  }, { root: true });
};

var changePassword = exports.changePassword = function _callee8(_ref18, params) {
  var dispatch = _ref18.dispatch,
      rootGetters = _ref18.rootGetters;

  var account, oldPassword, newPassword, _params$onlyGetFee3, onlyGetFee, _passwordKey, aes_private, account_name, validatePasswordParams, vp_result, _ref19, ownerKey, _ref20, activeKey;

  return _regenerator2.default.async(function _callee8$(_context8) {
    while (1) {
      switch (_context8.prev = _context8.next) {
        case 0:
          if (_helper2.default.trimParams(params)) {
            _context8.next = 2;
            break;
          }

          return _context8.abrupt('return', { code: 101, message: "Parameter is missing" });

        case 2:
          account = params.account, oldPassword = params.oldPassword, newPassword = params.newPassword, _params$onlyGetFee3 = params.onlyGetFee, onlyGetFee = _params$onlyGetFee3 === undefined ? false : _params$onlyGetFee3;
          _passwordKey = rootGetters["WalletDb/_passwordKey"];
          aes_private = rootGetters["WalletDb/aes_private"];
          account_name = account.name;
          validatePasswordParams = {
            password: oldPassword,
            unlock: true,
            isChangePassword: true
          };

          if (!_passwordKey) {
            _context8.next = 12;
            break;
          }

          validatePasswordParams.account = account_name;
          validatePasswordParams.roles = ["active", "owner", "memo"];
          _context8.next = 15;
          break;

        case 12:
          if (!aes_private) {
            _context8.next = 15;
            break;
          }

          if (rootGetters["PrivateKeyStore/getTcomb_byPubkey"](account.owner.key_auths[0][0])) {
            _context8.next = 15;
            break;
          }

          return _context8.abrupt('return', { code: 112, message: "Must have owner permission to change the password, please confirm that you imported the ownerPrivateKey" });

        case 15:
          _context8.next = 17;
          return _regenerator2.default.awrap(dispatch("WalletDb/validatePassword", validatePasswordParams, { root: true }));

        case 17:
          vp_result = _context8.sent;

          if (!(vp_result.code != 1)) {
            _context8.next = 20;
            break;
          }

          return _context8.abrupt('return', { code: 113, message: "Please enter the correct " + (_passwordKey ? "original" : "temporary") + " password" });

        case 20:
          _context8.next = 22;
          return _regenerator2.default.awrap(dispatch("WalletDb/generateKeyFromPassword", {
            account: account_name,
            role: "owner",
            password: newPassword
          }, { root: true }));

        case 22:
          _ref19 = _context8.sent;
          ownerKey = _ref19.privKey;
          _context8.next = 26;
          return _regenerator2.default.awrap(dispatch("WalletDb/generateKeyFromPassword", {
            account: account_name,
            role: "active",
            password: newPassword
          }, { root: true }));

        case 26:
          _ref20 = _context8.sent;
          activeKey = _ref20.privKey;
          return _context8.abrupt('return', dispatch("transactions/_transactionOperations", {
            operations: [{
              type: "account_update",
              params: {
                action: "changePassword",
                activePubkey: activeKey.toPublicKey().toPublicKeyString(),
                ownerPubkey: ownerKey.toPublicKey().toPublicKeyString()
              }
            }],
            onlyGetFee: onlyGetFee
          }, { root: true }));

        case 29:
        case 'end':
          return _context8.stop();
      }
    }
  }, null, undefined);
};

var logout = exports.logout = function logout(_ref21) {
  var commit = _ref21.commit;

  commit(types.ACCOUNT_LOGOUT);
};

var _logout = exports._logout = function _callee9(_ref22) {
  var commit = _ref22.commit,
      dispatch = _ref22.dispatch;
  return _regenerator2.default.async(function _callee9$(_context9) {
    while (1) {
      switch (_context9.prev = _context9.next) {
        case 0:
          commit(types.ACCOUNT_LOGOUT);
          _context9.next = 3;
          return _regenerator2.default.awrap(dispatch("user/clearAccountCache", null, { root: true }));

        case 3:
          _context9.next = 5;
          return _regenerator2.default.awrap(dispatch("WalletDb/clearKeys", null, { root: true }));

        case 5:
          _context9.next = 7;
          return _regenerator2.default.awrap(dispatch("PrivateKeyStore/clearKeys", null, { root: true }));

        case 7:

          _persistentStorage2.default.clearUserData();
          return _context9.abrupt('return', { code: 1 });

        case 9:
        case 'end':
          return _context9.stop();
      }
    }
  }, null, undefined);
};

//cache of userId and privateKey login in account mode
var checkCachedUserData = exports.checkCachedUserData = function _callee10(_ref23) {
  var commit = _ref23.commit,
      dispatch = _ref23.dispatch,
      rootGetters = _ref23.rootGetters;
  var data, cacheAccount;
  return _regenerator2.default.async(function _callee10$(_context10) {
    while (1) {
      switch (_context10.prev = _context10.next) {
        case 0:
          data = _persistentStorage2.default.getSavedUserData();

          if (!data) {
            _context10.next = 10;
            break;
          }

          if (!rootGetters["connection/isWsConnected"]) {
            _context10.next = 10;
            break;
          }

          _context10.next = 5;
          return _regenerator2.default.awrap(dispatch("user/fetchUserForIsSave", {
            nameOrId: data.userId,
            isSave: true,
            activePubkey: data.activePubkey
          }, { root: true }));

        case 5:
          cacheAccount = _context10.sent;

          if (!(cacheAccount.code == 1 && data.activePubkey && cacheAccount.data.account.active.key_auths[0][0] == data.activePubkey)) {
            _context10.next = 10;
            break;
          }

          _context10.next = 9;
          return _regenerator2.default.awrap(dispatch("PrivateKeyStore/setKeys", {
            import_account_names: [data.userId],
            encrypted_key: data.encrypted_key,
            pubkey: data.activePubkey || "activePubkey"
          }, { root: true }));

        case 9:
          commit(types.ACCOUNT_LOGIN_COMPLETE, {
            userId: data.userId,
            wallet: {
              encrypted_key: data.encrypted_key,
              encryptionKey: data.encryptionKey,
              passwordPubkey: data.passwordPubkey
            }
          });

        case 10:
        case 'end':
          return _context10.stop();
      }
    }
  }, null, undefined);
};
/**
 * Checks username for existance
 * @param {string} username - name of user to fetch
 */
var checkIfUsernameFree = exports.checkIfUsernameFree = function _callee11(state, _ref24) {
  var username = _ref24.username;
  var result;
  return _regenerator2.default.async(function _callee11$(_context11) {
    while (1) {
      switch (_context11.prev = _context11.next) {
        case 0:
          _context11.next = 2;
          return _regenerator2.default.awrap(_api2.default.Account.getUser(username));

        case 2:
          result = _context11.sent;
          return _context11.abrupt('return', !result.success);

        case 4:
        case 'end':
          return _context11.stop();
      }
    }
  }, null, undefined);
};

var _getPrivateKey = exports._getPrivateKey = function _callee14(_ref25, _ref26) {
  var dispatch = _ref25.dispatch;
  var account = _ref26.account;
  var result, active, owner, activePrivateKeys, ownerPrivateKeys, activePrivateKey, ownerPrivateKey;
  return _regenerator2.default.async(function _callee14$(_context14) {
    while (1) {
      switch (_context14.prev = _context14.next) {
        case 0:
          result = void 0;
          active = account.active;
          owner = account.owner;
          // let activePublicKey = (active.key_auths && active.key_auths.length > 0) ? active.key_auths[0][0] : '';
          // let ownerPublicKey = (owner.key_auths && owner.key_auths.length > 0) ? owner.key_auths[0][0] : '';

          activePrivateKeys = [];
          ownerPrivateKeys = [];
          activePrivateKey = "";
          ownerPrivateKey = "";
          _context14.next = 9;
          return _regenerator2.default.awrap(_promise2.default.all(active.key_auths.map(function _callee12(item) {
            return _regenerator2.default.async(function _callee12$(_context12) {
              while (1) {
                switch (_context12.prev = _context12.next) {
                  case 0:
                    _context12.next = 2;
                    return _regenerator2.default.awrap(dispatch("WalletDb/getPrivateKey", item[0], { root: true }));

                  case 2:
                    activePrivateKey = _context12.sent;

                    if (!!activePrivateKey) activePrivateKeys.push(activePrivateKey.toWif());
                    return _context12.abrupt('return', true);

                  case 5:
                  case 'end':
                    return _context12.stop();
                }
              }
            }, null, undefined);
          })));

        case 9:
          _context14.next = 11;
          return _regenerator2.default.awrap(_promise2.default.all(owner.key_auths.map(function _callee13(item) {
            return _regenerator2.default.async(function _callee13$(_context13) {
              while (1) {
                switch (_context13.prev = _context13.next) {
                  case 0:
                    _context13.next = 2;
                    return _regenerator2.default.awrap(dispatch("WalletDb/getPrivateKey", item[0], { root: true }));

                  case 2:
                    ownerPrivateKey = _context13.sent;

                    if (ownerPrivateKey) ownerPrivateKeys.push(ownerPrivateKey.toWif());
                    return _context13.abrupt('return', true);

                  case 5:
                  case 'end':
                    return _context13.stop();
                }
              }
            }, null, undefined);
          })));

        case 11:
          if (!(activePrivateKeys.length || ownerPrivateKeys.length)) {
            _context14.next = 15;
            break;
          }

          return _context14.abrupt('return', {
            code: 1,
            data: {
              active_private_keys: activePrivateKeys,
              owner_private_keys: ownerPrivateKeys
            }
          });

        case 15:
          return _context14.abrupt('return', {
            code: 114,
            message: "Account is locked or not logged in"
          });

        case 16:
        case 'end':
          return _context14.stop();
      }
    }
  }, null, undefined);
};

var accountOpt = exports.accountOpt = function _callee15(_ref27, _ref28) {
  var commit = _ref27.commit,
      rootGetters = _ref27.rootGetters,
      dispatch = _ref27.dispatch;
  var method = _ref28.method,
      params = _ref28.params;
  var account, userId, user_result;
  return _regenerator2.default.async(function _callee15$(_context15) {
    while (1) {
      switch (_context15.prev = _context15.next) {
        case 0:
          _helper2.default.trimParams(params);

          account = rootGetters["user/getAccountObject"];

          if (account) {
            _context15.next = 9;
            break;
          }

          userId = rootGetters["account/getAccountUserId"];

          if (!userId) {
            _context15.next = 9;
            break;
          }

          _context15.next = 7;
          return _regenerator2.default.awrap(dispatch("user/fetchUser", userId, { root: true }));

        case 7:
          user_result = _context15.sent;

          if (user_result.success) account = user_result.data.account;

        case 9:
          if (account) {
            params.account = account;
            dispatch(method, params, { root: true });
          } else {
            params.callback && params.callback({ code: -11, message: "Please login first" });
          }

        case 10:
        case 'end':
          return _context15.stop();
      }
    }
  }, null, undefined);
};

//accountOpt will check login status and trim params
var _accountOpt = exports._accountOpt = function _callee16(_ref29, _ref30) {
  var commit = _ref29.commit,
      rootGetters = _ref29.rootGetters,
      dispatch = _ref29.dispatch;
  var method = _ref30.method,
      _ref30$params = _ref30.params,
      params = _ref30$params === undefined ? {} : _ref30$params;
  var account, userId, user_result;
  return _regenerator2.default.async(function _callee16$(_context16) {
    while (1) {
      switch (_context16.prev = _context16.next) {
        case 0:

          _helper2.default.trimParams(params);
          // params.crontab=params.crontab||null;
          // dispatch("crontab/setCrontab",params.crontab,{root:true});

          account = rootGetters["user/getAccountObject"];

          if (account) {
            _context16.next = 9;
            break;
          }

          userId = rootGetters["account/getAccountUserId"];

          if (!userId) {
            _context16.next = 9;
            break;
          }

          _context16.next = 7;
          return _regenerator2.default.awrap(dispatch("user/fetchUser", userId, { root: true }));

        case 7:
          user_result = _context16.sent;

          if (user_result.success) account = user_result.data.account;

        case 9:
          if (!account) {
            _context16.next = 14;
            break;
          }

          if (!params.account) params.account = account;
          return _context16.abrupt('return', dispatch(method, params, { root: true }));

        case 14:
          return _context16.abrupt('return', { code: -11, message: "Please login first" });

        case 15:
        case 'end':
          return _context16.stop();
      }
    }
  }, null, undefined);
};

var _psdChangePrivateKey = exports._psdChangePrivateKey = function _callee17(_ref31, _ref32) {
  var dispatch = _ref31.dispatch;
  var account = _ref32.account,
      password = _ref32.password;
  var active_private;
  return _regenerator2.default.async(function _callee17$(_context17) {
    while (1) {
      switch (_context17.prev = _context17.next) {
        case 0:
          // let owner_private = WalletDbS.generateKeyFromPassword(account, "owner", password);
          active_private = WalletDbS.generateKeyFromPassword(account, "active", password);
          return _context17.abrupt('return', active_private);

        case 2:
        case 'end':
          return _context17.stop();
      }
    }
  }, null, undefined);
};

//_validateAccount will check the incoming parameters of account to determine whether the account exists.
var _validateAccount = exports._validateAccount = function _callee18(_ref33, _ref34) {
  var dispatch = _ref33.dispatch;
  var method = _ref34.method,
      params = _ref34.params,
      account = _ref34.account,
      _ref34$accountFieldNa = _ref34.accountFieldName,
      accountFieldName = _ref34$accountFieldNa === undefined ? "account_id" : _ref34$accountFieldNa;
  var acc_res;
  return _regenerator2.default.async(function _callee18$(_context18) {
    while (1) {
      switch (_context18.prev = _context18.next) {
        case 0:
          _helper2.default.trimParams(params);

          if (account) {
            _context18.next = 7;
            break;
          }

          if (!(accountFieldName == "to_account_id")) {
            _context18.next = 4;
            break;
          }

          return _context18.abrupt('return', { code: 133, message: "Parameter 'toAccount' can not be empty" });

        case 4:
          return _context18.abrupt('return', { code: 101, message: "Parameter is missing" });

        case 7:
          _context18.next = 9;
          return _regenerator2.default.awrap(dispatch("user/getUserInfo", { account: account, isCache: true }, { root: true }));

        case 9:
          acc_res = _context18.sent;

          if (!(acc_res.code != 1)) {
            _context18.next = 12;
            break;
          }

          return _context18.abrupt('return', acc_res);

        case 12:
          params[accountFieldName] = acc_res.data.account.id;

        case 13:
          return _context18.abrupt('return', dispatch(method, params, { root: true }));

        case 14:
        case 'end':
          return _context18.stop();
      }
    }
  }, null, undefined);
};

var fetchCurrentUser = exports.fetchCurrentUser = function _callee19(store) {
  var commit, getters, userId, result, user;
  return _regenerator2.default.async(function _callee19$(_context19) {
    while (1) {
      switch (_context19.prev = _context19.next) {
        case 0:
          commit = store.commit, getters = store.getters;
          userId = getters.getAccountUserId;

          if (userId) {
            _context19.next = 4;
            break;
          }

          return _context19.abrupt('return');

        case 4:
          commit(types.FETCH_CURRENT_USER_REQUEST);
          _context19.next = 7;
          return _regenerator2.default.awrap(_api2.default.Account.getUser(userId));

        case 7:
          result = _context19.sent;

          if (result.success) {
            user = result.data;

            result.data.balances = balancesToObject(user.balances);
            commit(types.FETCH_CURRENT_USER_COMPLETE, { data: user });
          } else {
            commit(types.FETCH_CURRENT_USER_ERROR);
          }

        case 9:
        case 'end':
          return _context19.stop();
      }
    }
  }, null, undefined);
};

var setAccountUserId = exports.setAccountUserId = function setAccountUserId(_ref35, userId) {
  var commit = _ref35.commit;

  commit(types.ACCOUNT_LOGIN_COMPLETE, { userId: userId });
};

var queryVestingBalance = exports.queryVestingBalance = function _callee20(_ref36, _ref37) {
  var dispatch = _ref36.dispatch,
      rootGetters = _ref36.rootGetters;
  var account_id = _ref37.account_id,
      type = _ref37.type,
      vid = _ref37.vid,
      _ref37$isLimit = _ref37.isLimit,
      isLimit = _ref37$isLimit === undefined ? false : _ref37$isLimit;

  var vbs, cvbAsset, vestingPeriod, earned, old_earned, new_earned, total_earned, past_sconds, coin_seconds_earned_last_update, secondsPerDay, availablePercent, new_vbs, i, _vbs$i, id, balance, policy, describe, remaining_hours, require_coindays, precision_value, available_balance_amount, min_interval, res;

  return _regenerator2.default.async(function _callee20$(_context20) {
    while (1) {
      switch (_context20.prev = _context20.next) {
        case 0:
          _context20.next = 2;
          return _regenerator2.default.awrap(_api2.default.Account.getVestingBalances(account_id));

        case 2:
          vbs = _context20.sent;
          cvbAsset = void 0, vestingPeriod = void 0, earned = void 0, old_earned = void 0, new_earned = void 0, total_earned = void 0, past_sconds = void 0, coin_seconds_earned_last_update = void 0, secondsPerDay = 60 * 60 * 24, availablePercent = void 0;
          new_vbs = [];
          i = 0;

        case 6:
          if (!(i < vbs.length)) {
            _context20.next = 40;
            break;
          }

          _vbs$i = vbs[i], id = _vbs$i.id, balance = _vbs$i.balance, policy = _vbs$i.policy, describe = _vbs$i.describe;
          _context20.next = 10;
          return _regenerator2.default.awrap(dispatch("assets/fetchAssets", { assets: [balance.asset_id], isOne: true }, { root: true }));

        case 10:
          cvbAsset = _context20.sent;

          coin_seconds_earned_last_update = policy[1].coin_seconds_earned_last_update;
          vestingPeriod = policy[1].vesting_seconds;
          past_sconds = Math.floor((new Date() - new Date(coin_seconds_earned_last_update + "Z")) / 1000);
          if (past_sconds > vestingPeriod) past_sconds = vestingPeriod;

          if (/^1\.6\.\d+/.test(describe)) {
            describe = "cashback_block";
          }

          if (!(vid && vid != id)) {
            _context20.next = 18;
            break;
          }

          return _context20.abrupt('continue', 37);

        case 18:
          if (!(type && type != describe)) {
            _context20.next = 20;
            break;
          }

          return _context20.abrupt('continue', 37);

        case 20:

          total_earned = vestingPeriod * balance.amount;
          new_earned = past_sconds / vestingPeriod * total_earned;
          old_earned = Number(policy[1].coin_seconds_earned);

          earned = old_earned + new_earned;
          if (earned >= total_earned) earned = total_earned;

          availablePercent = vestingPeriod === 0 ? 1 : earned / (vestingPeriod * balance.amount);

          remaining_hours = _utils2.default.format_number(vestingPeriod * (1 - availablePercent) / 3600 || 0, 2);
          require_coindays = _utils2.default.format_number(_utils2.default.get_asset_amount(balance.amount * vestingPeriod / secondsPerDay, cvbAsset), 0);

          earned = _utils2.default.format_number(_utils2.default.get_asset_amount(earned / secondsPerDay, cvbAsset), 0);

          precision_value = Math.pow(10, cvbAsset.precision);
          available_balance_amount = _utils2.default.format_number(availablePercent * balance.amount / precision_value, cvbAsset.precision);

          if (describe == "cashback_block") {
            available_balance_amount = Math.floor(available_balance_amount);
          } else {
            available_balance_amount = Math.floor(available_balance_amount * 1000) / 1000;
          }

          if (!isLimit) {
            _context20.next = 36;
            break;
          }

          min_interval = 10;
          // if(describe=="cashback_block") min_interval=5;

          if (!(Number(old_earned) > 0 && past_sconds < min_interval && describe != "cashback_block")) {
            _context20.next = 36;
            break;
          }

          return _context20.abrupt('return', { code: 181, message: 'Please try again in ' + (min_interval - past_sconds) + ' seconds' });

        case 36:

          new_vbs.push({
            id: id,
            type: describe,
            return_cash: balance.amount / precision_value,
            remaining_hours: remaining_hours,
            available_percent: _utils2.default.format_number(availablePercent * 100, 2),
            available_balance: {
              amount: available_balance_amount,
              asset_id: cvbAsset.id,
              symbol: cvbAsset.symbol,
              precision: cvbAsset.precision
            }
          });

        case 37:
          i++;
          _context20.next = 6;
          break;

        case 40:
          res = { code: 1, data: new_vbs };

          if (!new_vbs) {
            res = { code: 127, message: "No reward available" };
          }
          return _context20.abrupt('return', res);

        case 43:
        case 'end':
          return _context20.stop();
      }
    }
  }, null, undefined);
};

var claimVestingBalance = exports.claimVestingBalance = function _callee21(_ref38, _ref39) {
  var dispatch = _ref38.dispatch;
  var id = _ref39.id,
      account = _ref39.account,
      amount = _ref39.amount;

  var res, rewards, _rewards$0$available_, precision, asset_id, max_amount;

  return _regenerator2.default.async(function _callee21$(_context21) {
    while (1) {
      switch (_context21.prev = _context21.next) {
        case 0:
          if (!(!id || !amount)) {
            _context21.next = 2;
            break;
          }

          return _context21.abrupt('return', { code: 101, message: "Parameter is missing" });

        case 2:
          id = id.trim();

          if (!isNaN(Number(amount))) {
            _context21.next = 5;
            break;
          }

          return _context21.abrupt('return', { code: 135, message: "Please check parameter data type" });

        case 5:
          _context21.next = 7;
          return _regenerator2.default.awrap(dispatch("_validateAccount", {
            method: "account/queryVestingBalance",
            params: { type: '', vid: id, isLimit: true },
            account: account.id
          }));

        case 7:
          res = _context21.sent;

          if (!(res.code != 1)) {
            _context21.next = 10;
            break;
          }

          return _context21.abrupt('return', res);

        case 10:
          rewards = res.data.filter(function (item) {
            return item.id == id;
          });

          if (!rewards.length) {
            _context21.next = 20;
            break;
          }

          _rewards$0$available_ = rewards[0].available_balance, precision = _rewards$0$available_.precision, asset_id = _rewards$0$available_.asset_id;
          max_amount = rewards[0].available_balance.amount;

          if (!(amount > max_amount)) {
            _context21.next = 16;
            break;
          }

          return _context21.abrupt('return', { code: 183, message: 'Up to ' + max_amount });

        case 16:
          amount = Math.floor(amount * Math.pow(10, precision));

          return _context21.abrupt('return', dispatch('transactions/_transactionOperations', {
            operations: [{
              op_type: 27,
              type: "vesting_balance_withdraw",
              params: {
                vesting_balance: id,
                amount: {
                  amount: amount,
                  asset_id: asset_id
                }
              }
            }]
          }, { root: true }));

        case 20:
          return _context21.abrupt('return', { code: 127, message: "No reward available" });

        case 21:
        case 'end':
          return _context21.stop();
      }
    }
  }, null, undefined);
};

var balancesToObject = function balancesToObject(balancesArr) {
  var obj = {};
  balancesArr.forEach(function (item) {
    obj[item.asset_type] = item;
  });
  return obj;
};

var getAccountInfo = exports.getAccountInfo = function getAccountInfo(_ref40) {
  var rootGetters = _ref40.rootGetters;

  var accountObject = rootGetters["user/getAccountObject"];
  var res = {
    account_id: rootGetters["account/getAccountUserId"] || "",
    locked: rootGetters["WalletDb/isLocked"]
  };
  res.account_name = accountObject ? accountObject.name : "";
  res.mode = rootGetters["WalletDb/wallet"] ? "wallet" : "account";
  return {
    code: 1,
    data: res
  };
};

/***/ }),
/* 523 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
// é‚®ç®±
var MailReg = exports.MailReg = /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(.[a-zA-Z0-9_-])+/;
// åŒ…å«0 æ­£æ•´æ•°
var IntReg = exports.IntReg = /^([1-9]\d*|[0]{1,1})$/;
// ä¸åŒ…å«0 æ­£æ•´æ•°
var IntExclude0Reg = exports.IntExclude0Reg = /^[1-9]+\d*$/;

// åªèƒ½æ•°å­—æˆ–å°æ•° åªèƒ½æœ‰ä¸€ä¸ªå°æ•°ç‚¹å¹¶ä¸”ç¬¬ä¸€ä½ä¸èƒ½ä¸ºå°æ•°ç‚¹
var IntegerOrDecimalReg = exports.IntegerOrDecimalReg = /^\d*\.{0,1}\d{0,1}$/;

// å¯¹äºŽå¤šä½æ•°å­—ç¬¬ä¸€ä½ä¸èƒ½ä¸º0, å•ä¸ªæ•°å­—å¯ä»¥ä¸º0
var IntExclude0Reg1 = exports.IntExclude0Reg1 = /(^[1-9]([0-9]*)$|^[0-9]$)/;

// å¯¹äºŽå¤šä½æ•°å­—ç¬¬ä¸€ä½ä¸èƒ½ä¸º0
var IntExclude0Reg2 = exports.IntExclude0Reg2 = /(^[1-9]([0-9]*)$)/;

// å¯¹äºŽå¤šä½æ•°å­—ç¬¬ä¸€ä½ä¸èƒ½ä¸º0  å°æ•°ç‚¹åŽ5ä½
var IntegerOrDecimalReg1 = exports.IntegerOrDecimalReg1 = /^[1-9][0-9]*\.{0,1}\d{0,5}$/;

// å¯¹äºŽå¤šä½æ•°å­—ç¬¬ä¸€ä½å¯ä»¥ä¸º0  å°æ•°ç‚¹åŽ5ä½
var IntegerOrDecimalReg2 = exports.IntegerOrDecimalReg2 = /^[0-9]*\.{0,1}\d{0,5}$/;

var GithubAddrReg = exports.GithubAddrReg = /^https:\/\/github.com/;

// åŒ…å«æ•°å­—ï¼Œå¤§å°å†™ï¼Œç‰¹æ®Šç¬¦å·
var AllReg = exports.AllReg = /^(?=.*?[a-z])(?=.*?[A-Z])(?=.*?\d)(?=.*?[#@*&.]).*$/;

var NewPassword = exports.NewPassword = /^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*.-]).{12,}$/;

/***/ }),
/* 524 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getWallet = exports.getAccountPendingState = exports.getAccountUserId = exports.getAccountError = exports.isValidPassword = exports.getKeys = exports.getBrainkey = undefined;

var _bcxjsCores = __webpack_require__(7);

var _WalletDb = __webpack_require__(227);

var WalletDb = _interopRequireWildcard(_WalletDb);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var ACTIVE_KEY_INDEX = 0;
var OWNER_KEY_INDEX = 1;

var getBrainkey = exports.getBrainkey = function getBrainkey(state) {
  if (!state.aesPrivate) return null;
  return state.aesPrivate.decryptHexToText(state.encryptedBrainkey);
};

var getKeys = exports.getKeys = function getKeys(state) {
  var brainkey = getBrainkey(state);
  return null;
  if (!brainkey) return null;
  // return {
  //   active: key.get_brainPrivateKey(brainkey, ACTIVE_KEY_INDEX),
  //   owner: key.get_brainPrivateKey(brainkey, OWNER_KEY_INDEX)
  // };
  var keys = state.keys;
  if (keys && keys[_passwordKey]) {
    return keys._passwordKey;
  } else {
    return null;
  }
};

var isValidPassword = exports.isValidPassword = function isValidPassword(state) {
  return function (password) {
    var passwordPrivate = _bcxjsCores.PrivateKey.fromSeed(password);
    var passwordPubkey = passwordPrivate.toPublicKey().toPublicKeyString();
    return passwordPubkey === state.passwordPubkey;
  };
};

// export const isLocked = state => {
//   return state.aesPrivate == null;
// };

var getAccountError = exports.getAccountError = function getAccountError(state) {
  return state.error;
};

var getAccountUserId = exports.getAccountUserId = function getAccountUserId(state) {
  return state.userId;
};

var getAccountPendingState = exports.getAccountPendingState = function getAccountPendingState(state) {
  return state.pending;
};

var getWallet = exports.getWallet = function getWallet(state) {
  return {
    passwordPubkey: state.passwordPubkey,
    encryptedBrainkey: state.encryptedBrainkey,
    encryptionKey: state.encryptionKey,
    encrypted_key: state.encrypted_key
  };
};

/***/ }),
/* 525 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(27);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _mutations;

var _mutations2 = __webpack_require__(14);

var types = _interopRequireWildcard(_mutations2);

var _connection = __webpack_require__(526);

var actions = _interopRequireWildcard(_connection);

var _connection2 = __webpack_require__(528);

var getters = _interopRequireWildcard(_connection2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var initialState = {
  wsConnected: false,
  rpcStatus: null,
  wsConnecting: false,
  rpcStatusCallback: null, //listener of RPC connection status callback
  reconnectCounter: 0
};

var mutations = (_mutations = {}, (0, _defineProperty3.default)(_mutations, types.WS_CONNECTED, function (state) {
  state.wsConnected = true;
}), (0, _defineProperty3.default)(_mutations, types.WS_DISCONNECTED, function (state) {
  state.wsConnected = false;
}), (0, _defineProperty3.default)(_mutations, types.SET_WS_CONNECTING, function (state, status) {
  state.wsConnecting = status;
}), (0, _defineProperty3.default)(_mutations, types.RPC_STATUS_UPDATE, function (state, _ref) {
  var status = _ref.status,
      _ref$url = _ref.url,
      url = _ref$url === undefined ? "" : _ref$url;

  if (state.rpcStatus == status) return;
  state.rpcStatus = status;
  var res = {
    code: 1,
    data: { status: status, url: url }
  };

  if (status == "error" && url == "") {
    res = {
      code: 168,
      message: "No available nodes or check your network."
    };
  }
  state.rpcStatusCallback && state.rpcStatusCallback(res);
}), (0, _defineProperty3.default)(_mutations, types.SET_RPC_STATUS_CALLBACK, function (state, callback) {
  state.rpcStatusCallback = callback;
}), _mutations);

exports.default = {
  state: initialState,
  getters: getters,
  actions: actions,
  mutations: mutations,
  namespaced: true
};

/***/ }),
/* 526 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.lookupWSNodeList = exports.IDB_INIT = exports.initConnection = exports.setSubscribeToRpcConnectionStatusCallback = exports.disconnect = exports.switchNode = exports.deleteAPINode = exports.addAPINode = exports.testNodesPings = undefined;

var _keys = __webpack_require__(24);

var _keys2 = _interopRequireDefault(_keys);

var _promise = __webpack_require__(4);

var _promise2 = _interopRequireDefault(_promise);

var _typeof2 = __webpack_require__(26);

var _typeof3 = _interopRequireDefault(_typeof2);

var _regenerator = __webpack_require__(3);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _api = __webpack_require__(10);

var _api2 = _interopRequireDefault(_api);

var _mutations = __webpack_require__(14);

var types = _interopRequireWildcard(_mutations);

var _bcxjsCores = __webpack_require__(7);

var _bcxjsWs = __webpack_require__(8);

var _idbInstance = __webpack_require__(60);

var _idbInstance2 = _interopRequireDefault(_idbInstance);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _new_node_connecting = false; //if here is new incoming node connection.
/**
 * Initializes connection to WS
 */
var testNodesPings = exports.testNodesPings = function testNodesPings(store, refresh) {
  return _api2.default.Connection.testNodesPings(refresh);
};

var addAPINode = exports.addAPINode = function addAPINode(store, node) {
  return _api2.default.Connection.addAPINode(node);
};

var deleteAPINode = exports.deleteAPINode = function deleteAPINode(store, _ref) {
  var url = _ref.url;

  if (!url) {
    return { code: 138, message: "Parameter 'url' can not be empty" };
  }
  url = url.trim();
  _api2.default.Connection.deleteAPINode(url);
  return { code: 1 };
};
var _startConnectTimer = 0;

var switchNode = exports.switchNode = function _callee(_ref2, _ref3) {
  var commit = _ref2.commit,
      dispatch = _ref2.dispatch,
      rootGetters = _ref2.rootGetters;
  var url = _ref3.url,
      callback = _ref3.callback;
  return _regenerator2.default.async(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          clearTimeout(_startConnectTimer);
          if (!url) {
            url = rootGetters["setting/ws_node_list"][0].url;
            //callback&&callback({code:138,message:"Parameter 'url' can not be empty"});
            //return;
          }
          //clear all the cache created by current chain to avoid a chain switch.
          dispatch("vote/setGlobalObject", null, { root: true });
          dispatch("explorer/set_last_current_aslot", null, { root: true });
          dispatch("assets/set_assets", {}, { root: true });

          _new_node_connecting = true;
          _bcxjsCores.ChainStore.clearCache();
          _bcxjsCores.ChainStore.subscribed = false;

          _context.next = 10;
          return _regenerator2.default.awrap(_api2.default.Connection.disconnect());

        case 10:
          _new_node_connecting = false;
          commit(types.WS_DISCONNECTED);
          dispatch("initConnection", { callback: callback, url: url });

        case 13:
        case 'end':
          return _context.stop();
      }
    }
  }, null, undefined);
};

var disconnect = exports.disconnect = function _callee2(_ref4) {
  var dispatch = _ref4.dispatch,
      commit = _ref4.commit;
  return _regenerator2.default.async(function _callee2$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          _context2.prev = 0;

          commit(types.SET_WS_CONNECTING, false);
          dispatch("setting/setAutoReconnect", false, { root: true });
          _context2.next = 5;
          return _regenerator2.default.awrap(_api2.default.Connection.disconnect());

        case 5:
          return _context2.abrupt('return', { code: 1 });

        case 8:
          _context2.prev = 8;
          _context2.t0 = _context2['catch'](0);
          return _context2.abrupt('return', { code: 0, message: _context2.t0.message });

        case 11:
        case 'end':
          return _context2.stop();
      }
    }
  }, null, undefined, [[0, 8]]);
};
//Set RPC connection status change callback
var setSubscribeToRpcConnectionStatusCallback = exports.setSubscribeToRpcConnectionStatusCallback = function setSubscribeToRpcConnectionStatusCallback(_ref5, _ref6) {
  var commit = _ref5.commit;
  var callback = _ref6.callback;

  commit(types.SET_RPC_STATUS_CALLBACK, callback);
};

var _callbacks = []; //Collection of callback functions to prevent functions from being called without initialization.
var initConnection = exports.initConnection = function initConnection(store, params) {
  var dispatch = store.dispatch,
      commit = store.commit,
      getters = store.getters,
      rootGetters = store.rootGetters,
      state = store.state;

  if (getters.wsConnecting) {
    //The incoming callbacks while RPC is initializing will be pushed in _callbacks
    _callbacks.push(typeof params == "function" ? params : params.callback);
    return;
  };
  var connect_url = rootGetters["setting/g_settingsAPIs"].default_ws_node;
  if (params) {
    //Here is the compatible with old version directly callback or object parameter.
    if ((typeof params === 'undefined' ? 'undefined' : (0, _typeof3.default)(params)) == "object") {
      var callback = params.callback,
          subscribeToRpcConnectionStatusCallback = params.subscribeToRpcConnectionStatusCallback,
          autoReconnect = params.autoReconnect,
          url = params.url;

      if (callback) _callbacks = [callback];
      if (subscribeToRpcConnectionStatusCallback) commit(types.SET_RPC_STATUS_CALLBACK, subscribeToRpcConnectionStatusCallback);
      if (autoReconnect) commit(types.SET_AUTO_RECONNECT, !!autoReconnect);
      if (url) connect_url = url;
    } else if (typeof params == "function") {
      _callbacks = [params];
    }
  } else if (!params || params.clearCallback) {
    _callbacks = [];
  }
  //If the RPC connected, then execute the callback 
  if (getters.isWsConnected && params && !params.refresh) {
    _callbacks.length && _callbacks[0]({ code: 1 });
    return;
  }

  //RPC status changed callback
  var updateConnectionStatus = function _callee3(status) {
    var selectedNodeUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
    var store_autoReconnect;
    return _regenerator2.default.async(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            console.log('Connection status : ', status, selectedNodeUrl);
            commit(types.RPC_STATUS_UPDATE, { status: status, url: selectedNodeUrl });
            dispatch("setting/set_SELECT_WS_NODE", selectedNodeUrl, { root: true });

            store_autoReconnect = rootGetters["setting/autoReconnect"];

            if (!(status === 'error' || status === 'closed')) {
              _context3.next = 13;
              break;
            }

            //connection error
            commit(types.WS_DISCONNECTED);
            if (_startConnectTimer) {
              clearTimeout(_startConnectTimer);
            }
            _bcxjsCores.ChainStore.subscribed = false;

            if (!(_new_node_connecting == false && store_autoReconnect)) {
              _context3.next = 13;
              break;
            }

            _context3.next = 11;
            return _regenerator2.default.awrap(_api2.default.Connection.disconnect());

          case 11:
            _startConnectTimer = setTimeout(function () {
              startConnect(selectedNodeUrl);
            }, 3000);
            return _context3.abrupt('return');

          case 13:

            //RPC connected
            if (status === 'realopen') {
              commit(types.SET_WS_CONNECTING, false);
              if (process.browser || true) {
                dispatch("IDB_INIT");
              } else {
                _bcxjsCores.ChainStore.init(rootGetters["setting/g_settingsAPIs"].real_sub).then(function () {
                  commit(types.WS_CONNECTED);
                  state.reconnectCounter = 3;
                  _api2.default.ChainListener.enable();
                  _api2.default.ChainListener.store = store;
                  _promise2.default.all([rootGetters["setting/g_settingsAPIs"].isCheckCachedUserData ? dispatch("account/checkCachedUserData", null, { root: true }) : true, _api2.default.Explorer.getGlobalObject()]).then(function (res) {
                    _callbacks.forEach(function (callback_item) {
                      callback_item({ code: 1 });
                    });
                    _callbacks.length = 1;
                  });
                }).catch(function (error) {
                  if (state.reconnectCounter > 5) {
                    _callbacks.forEach(function (callback) {
                      callback({ code: 300, message: "ChainStore sync error, please check your system clock" });
                    });
                  } else {
                    commit(types.WS_DISCONNECTED);
                    state.reconnectCounter++;
                    dispatch("initConnection", { refresh: false, clearCallback: false });
                  }
                });
              }

              // ChainStore.init().then(()=>{
              //   API.ChainListener.enable();
              //   Promise.all([
              //     rootGetters["setting/g_settingsAPIs"].check_cached_account_data? dispatch("account/checkCachedUserData",null,{root:true}):true,
              //     API.Explorer.getGlobalObject()
              //   ]).then((res)=>{
              //      _callbacks.forEach(callback_item=>{ callback_item({code:1}); });
              //      _callbacks.length=1;    
              //   })
              // }).catch(error=>{
              //   _callbacks.forEach(callback=>{ callback({code:300,message:"ChainStore sync error, please check your system clock"}); });
              // })
            } else if (!store_autoReconnect) {
              //if auto reconnection isn't configured, execute callback
              !_new_node_connecting && _callbacks.length && _callbacks.forEach(function (callback) {
                callback({ code: 301, message: "RPC connection failed. Please check your network" });
              });
            }

          case 14:
          case 'end':
            return _context3.stop();
        }
      }
    }, null, undefined);
  };

  var startConnect = function startConnect() {
    var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    var refresh = arguments[1];

    commit(types.SET_WS_CONNECTING, true);
    _api2.default.Connection.connect({
      statusCallback: updateConnectionStatus,
      changeNodeUrl: refresh ? "" : url,
      store: store,
      refresh: refresh
    });
  };
  startConnect(connect_url || rootGetters["setting/g_settingsAPIs"].default_ws_node, params ? !!params.refresh : false);
};

var IDB_INIT = exports.IDB_INIT = function IDB_INIT(store) {
  var dispatch = store.dispatch,
      rootGetters = store.rootGetters,
      commit = store.commit,
      state = store.state;

  var db;
  try {
    //install indexeddbshim 2.2.1 other version may cause problems
    db = _idbInstance2.default.init_instance(window.openDatabase ? shimIndexedDB || indexedDB : indexedDB).init_promise;
  } catch (err) {
    console.log("db init error:", err);
  }
  //Init websql
  return _promise2.default.all([db]).then(function () {
    console.log("db init done");
    return _promise2.default.all([dispatch("PrivateKeyStore/loadDbData", null, { root: true }).then(function () {
      dispatch("AccountRefsStore/loadDbData", null, { root: true });
    }), dispatch("WalletDb/loadDbData", null, { root: true }).then(function () {}).catch(function (error) {
      console.error("----- WalletDb.willTransitionTo error ----->", error);
    }), dispatch("WalletManagerStore/init", null, { root: true })]).then(function () {
      var _rootGetters$setting = rootGetters["setting/g_settingsAPIs"],
          check_cached_account_data = _rootGetters$setting.check_cached_account_data,
          real_sub = _rootGetters$setting.real_sub,
          select_ws_node = _rootGetters$setting.select_ws_node;

      // ChainStore.clearCache();
      // ChainStore.subscribed=false;

      _bcxjsCores.ChainStore.init(!!real_sub).then(function () {
        commit(types.WS_CONNECTED);
        state.reconnectCounter = 3;
        _api2.default.ChainListener.enable(rootGetters["setting/g_settingsAPIs"].sub_max_ops);
        _api2.default.ChainListener.store = store;

        //whether check local User Info Cache and use its data
        if (check_cached_account_data) dispatch("account/checkCachedUserData", null, { root: true });

        dispatch("AccountStore/loadDbData", null, { root: true }).then(function () {

          _promise2.default.all([_api2.default.Explorer.getGlobalObject() //,
          //  dispatch("explorer/getExplorerWitnesses",null,{root:true})
          ]).then(function (res) {
            console.log("bcxjs init ok");
            _callbacks.forEach(function (callback_item) {
              callback_item({ code: 1, data: { selectedNodeUrl: select_ws_node } });
            });
            _callbacks.length = 1;
            select_ws_node = "";
          });
        }).catch(function (error) {
          console.log("[Root.js] ----- ERROR ----->", error);
        });
      }).catch(function (error) {
        if (state.reconnectCounter > 1) {
          _callbacks.forEach(function (callback) {
            callback({ code: 300, message: "ChainStore sync error, please check your system clock" });
          });
        } else {
          commit(types.WS_DISCONNECTED);
          state.reconnectCounter++;
          dispatch("initConnection", { refresh: false, clearCallback: false });
        }
      });
    });
  });
};

//Get API server list
var lookupWSNodeList = exports.lookupWSNodeList = function _callee4(_ref7, _ref8) {
  var dispatch = _ref7.dispatch,
      rootGetters = _ref7.rootGetters;
  var _ref8$refresh = _ref8.refresh,
      refresh = _ref8$refresh === undefined ? false : _ref8$refresh;
  var settingsAPIs, nodes;
  return _regenerator2.default.async(function _callee4$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          settingsAPIs = rootGetters["setting/g_settingsAPIs"];
          _context4.next = 3;
          return _regenerator2.default.awrap(dispatch("testNodesPings", refresh));

        case 3:
          nodes = _context4.sent;

          nodes = (0, _keys2.default)(nodes).map(function (key) {
            var _nodes$key = nodes[key],
                location = _nodes$key.location,
                ping = _nodes$key.ping;

            return {
              url: key,
              name: location,
              ping: ping
            };
          });
          return _context4.abrupt('return', {
            code: 1,
            data: {
              nodes: nodes,
              selectedNodeUrl: settingsAPIs.select_ws_node
            }
          });

        case 6:
        case 'end':
          return _context4.stop();
      }
    }
  }, null, undefined);
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9)))

/***/ }),
/* 527 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _promise = __webpack_require__(4);

var _promise2 = _interopRequireDefault(_promise);

var _classCallCheck2 = __webpack_require__(11);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(15);

var _createClass3 = _interopRequireDefault(_createClass2);

var _idbHelper = __webpack_require__(149);

var _idbHelper2 = _interopRequireDefault(_idbHelper);

var _bcxjsWs = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DB_VERSION_MAIN = 1;
var DB_PREFIX = "gph_db";

/** Usage: openIndexDB.then( db => ... */

var iDBRoot = function () {
    function iDBRoot(impl) {
        (0, _classCallCheck3.default)(this, iDBRoot);

        this.impl = impl;
    }

    (0, _createClass3.default)(iDBRoot, [{
        key: "setDbSuffix",
        value: function setDbSuffix(db_suffix) {
            // "graphene_db_06f667"
            this.database_name = DB_PREFIX + db_suffix;
        }

        /** @return promise */

    }, {
        key: "openIndexedDB",
        value: function openIndexedDB() {
            var _this = this;

            if (this.db) return _promise2.default.resolve(this.db);
            return new _promise2.default(function (resolve, reject) {
                var openRequest = _this.impl.open(_this.database_name, DB_VERSION_MAIN);
                openRequest.onupgradeneeded = function (e) {
                    _this.db = e.target.result;
                    _this.db.createObjectStore("properties", { keyPath: "name" });
                };
                openRequest.onsuccess = function (e) {
                    _this.db = e.target.result;
                    resolve(_this.db);
                };
                openRequest.onerror = function (e) {
                    reject(e.target.error);
                };
            });
        }

        /** @return promise */

    }, {
        key: "getProperty",
        value: function getProperty(name, default_value) {
            return this.openIndexedDB().then(function (db) {
                var transaction = db.transaction(["properties"], "readonly");
                var store = transaction.objectStore("properties");
                return _idbHelper2.default.on_request_end(store.get(name)).then(function (event) {
                    var result = event.target.result;
                    return result ? result.value : default_value;
                });
            }).catch(function (error) {
                console.error(error);throw error;
            });
        }

        /** @return promise */

    }, {
        key: "setProperty",
        value: function setProperty(name, value) {
            return this.openIndexedDB().then(function (db) {
                var transaction = db.transaction(["properties"], "readwrite");
                var store = transaction.objectStore("properties");
                if (value && value["toJS"]) value = value.toJS(); //Immutable-js
                return _idbHelper2.default.on_request_end(store.put({ name: name, value: value }));
            }).catch(function (error) {
                console.error(error);throw error;
            });
        }
    }, {
        key: "deleteDatabase",
        value: function deleteDatabase() {
            var are_you_sure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

            if (!are_you_sure) return "Are you sure?";
            console.log("deleting", this.database_name);
            var req = iDB.impl.deleteDatabase(this.database_name);
            return req.result;
        }
    }, {
        key: "close",
        value: function close() {
            this.db.close();
            this.db = null;
        }
    }]);
    return iDBRoot;
}();

exports.default = iDBRoot;

/***/ }),
/* 528 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isWsConnected = isWsConnected;
exports.wsConnecting = wsConnecting;
function isWsConnected(state) {
  return state.wsConnected;
}

function wsConnecting(state) {
  return state.wsConnecting;
}

/***/ }),
/* 529 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(27);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _stringify = __webpack_require__(18);

var _stringify2 = _interopRequireDefault(_stringify);

var _set = __webpack_require__(245);

var _set2 = _interopRequireDefault(_set);

var _mutations;

var _mutations2 = __webpack_require__(14);

var types = _interopRequireWildcard(_mutations2);

var _transactions = __webpack_require__(540);

var actions = _interopRequireWildcard(_transactions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var initialState = {
  pending: false,
  error: null,
  callback: null,
  orderData: null,
  trxData: null,
  callbacks: new _set2.default(),
  onlyGetOPFee: false
};
var getters = {
  onlyGetOPFee: function onlyGetOPFee(state) {
    return state.onlyGetOPFee;
  }
};
var mutations = (_mutations = {}, (0, _defineProperty3.default)(_mutations, types.SET_ONLY_GET_OP_FEE, function (state, b) {
  state.onlyGetOPFee = b;
}), (0, _defineProperty3.default)(_mutations, types.TRANSFER_ASSET_REQUEST, function (state) {
  state.pending = true;
}), (0, _defineProperty3.default)(_mutations, types.TRANSFER_ASSET_ERROR, function (state, _ref) {
  var error = _ref.error,
      callback = _ref.callback,
      code = _ref.code;

  if (typeof error == "string") {
    error = {
      message: error
    };
  }

  state.pending = false;
  var message = error.message;

  if (typeof error.message == "string") {
    if (error.message.indexOf("o.issuer == a.issuer") != -1) {
      code = 160;
      message = "You are not the creator of assets";
    }
  }

  callback && callback({
    code: code,
    message: message,
    error: error
  });
}), (0, _defineProperty3.default)(_mutations, types.TRANSFER_ASSET_COMPLETE, function (state, _ref2) {
  var callback = _ref2.callback,
      trxData = _ref2.trxData,
      _ref2$data = _ref2.data,
      data = _ref2$data === undefined ? null : _ref2$data;

  state.pending = false;
  var res = { code: 1 };
  if (data) {
    res.data = data;
  }
  if (trxData) {
    res.trxData = JSON.parse((0, _stringify2.default)(trxData));
    var result_id = trxData.result_id,
        result_ids = trxData.result_ids;

    if (result_ids && result_ids.length && result_ids[0]) {
      res.data = {
        result_id: result_id,
        result_ids: result_ids
      };
    }
  }
  callback && callback(res);
}), (0, _defineProperty3.default)(_mutations, types.SET_OP_CALLBACK, function (state, _ref3) {
  var callback = _ref3.callback,
      type = _ref3.type;

  if (type == "+") {
    state.callbacks.add(callback);
  } else if (type == "-") {
    if (state.callbacks.has(callback)) {
      state.callbacks.delete(callback);
    }
  }
}), (0, _defineProperty3.default)(_mutations, types.SET_ORDER_DATA, function (state, orderData) {
  state.orderData = orderData;
}), (0, _defineProperty3.default)(_mutations, types.SET_TRX_DATA, function (state, trxData) {
  state.trxData = trxData;
}), _mutations);

exports.default = {
  state: initialState,
  getters: getters,
  actions: actions,
  mutations: mutations,
  namespaced: true
};

/***/ }),
/* 530 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(103);
__webpack_require__(75);
__webpack_require__(82);
__webpack_require__(531);
__webpack_require__(535);
__webpack_require__(538);
__webpack_require__(539);
module.exports = __webpack_require__(6).Set;


/***/ }),
/* 531 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(532);
var validate = __webpack_require__(155);
var SET = 'Set';

// 23.2 Set Objects
module.exports = __webpack_require__(409)(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);


/***/ }),
/* 532 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var dP = __webpack_require__(31).f;
var create = __webpack_require__(99);
var redefineAll = __webpack_require__(135);
var ctx = __webpack_require__(41);
var anInstance = __webpack_require__(134);
var forOf = __webpack_require__(91);
var $iterDefine = __webpack_require__(138);
var step = __webpack_require__(209);
var setSpecies = __webpack_require__(210);
var DESCRIPTORS = __webpack_require__(30);
var fastKey = __webpack_require__(102).fastKey;
var validate = __webpack_require__(155);
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};


/***/ }),
/* 533 */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(534);

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};


/***/ }),
/* 534 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(25);
var isArray = __webpack_require__(211);
var SPECIES = __webpack_require__(17)('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};


/***/ }),
/* 535 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(16);

$export($export.P + $export.R, 'Set', { toJSON: __webpack_require__(536)('Set') });


/***/ }),
/* 536 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = __webpack_require__(98);
var from = __webpack_require__(537);
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};


/***/ }),
/* 537 */
/***/ (function(module, exports, __webpack_require__) {

var forOf = __webpack_require__(91);

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};


/***/ }),
/* 538 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
__webpack_require__(410)('Set');


/***/ }),
/* 539 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
__webpack_require__(411)('Set');


/***/ }),
/* 540 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setOrderData = exports._transactionOperations = exports._encryptionOneMomeOperations = exports.setOnlyGetOPFee = exports.transferAsset = exports.encryptionOneMome = exports._decodeOneMemo = exports._checkingSignString = exports._signString = undefined;

var _typeof2 = __webpack_require__(26);

var _typeof3 = _interopRequireDefault(_typeof2);

var _keys = __webpack_require__(24);

var _keys2 = _interopRequireDefault(_keys);

var _regenerator = __webpack_require__(3);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _mutations = __webpack_require__(14);

var types = _interopRequireWildcard(_mutations);

var _api = __webpack_require__(10);

var _api2 = _interopRequireDefault(_api);

var _helper = __webpack_require__(34);

var _helper2 = _interopRequireDefault(_helper);

var _bcxjsCores = __webpack_require__(7);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// 2020-03-05  xulin_add  ç­¾å
var _signString = exports._signString = function _callee(store, params) {
  var signContent, fromId, fromAccount, result;
  return _regenerator2.default.async(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          signContent = params.signContent;

          if (!store.rootGetters['WalletDb/isLocked']) {
            _context.next = 3;
            break;
          }

          return _context.abrupt('return', { code: 114, message: "Account is locked or not logged in" });

        case 3:
          fromId = store.rootGetters['account/getAccountUserId'];
          _context.next = 6;
          return _regenerator2.default.awrap(store.dispatch("user/fetchUser", fromId, { root: true }));

        case 6:
          fromAccount = _context.sent.data;
          _context.next = 9;
          return _regenerator2.default.awrap(_api2.default.Transactions.signString(fromAccount, store, signContent));

        case 9:
          result = _context.sent;

          if (!result) {
            _context.next = 12;
            break;
          }

          return _context.abrupt('return', result);

        case 12:
        case 'end':
          return _context.stop();
      }
    }
  }, null, undefined);
};

// 2020-03-05  xulin_add éªŒç­¾
var _checkingSignString = exports._checkingSignString = function _callee2(store, checkingSignParams) {
  var result;
  return _regenerator2.default.async(function _callee2$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          if (!store.rootGetters['WalletDb/isLocked']) {
            _context2.next = 2;
            break;
          }

          return _context2.abrupt('return', { code: 114, message: "Account is locked or not logged in" });

        case 2:
          _context2.next = 4;
          return _regenerator2.default.awrap(_api2.default.Transactions.checkingSignString(checkingSignParams));

        case 4:
          result = _context2.sent;

          if (!result) {
            _context2.next = 7;
            break;
          }

          return _context2.abrupt('return', result);

        case 7:
        case 'end':
          return _context2.stop();
      }
    }
  }, null, undefined);
};

// 4-29 è§£ç å•ä¸ªå¤‡æ³¨
var _decodeOneMemo = exports._decodeOneMemo = function _callee3(store, memo_con, storeApi) {
  var memo, fromId, fromAccount, activepubkey, private_key, pubkey, public_key, memo_text, result;
  return _regenerator2.default.async(function _callee3$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          memo = memo_con;

          if (!store.rootGetters['WalletDb/isLocked']) {
            _context3.next = 3;
            break;
          }

          return _context3.abrupt('return', { code: 114, message: "Account is locked or not logged in" });

        case 3:
          if (!(!memo.from || !memo.to || !memo.nonce || !memo.message)) {
            _context3.next = 5;
            break;
          }

          return _context3.abrupt('return', { code: 101, message: "Parameter is missing" });

        case 5:
          fromId = store.rootGetters['account/getAccountUserId'];
          _context3.next = 8;
          return _regenerator2.default.awrap(store.dispatch("user/fetchUser", fromId, { root: true }));

        case 8:
          fromAccount = _context3.sent.data;
          activepubkey = fromAccount.account.active.key_auths[0][0];
          _context3.next = 12;
          return _regenerator2.default.awrap(store.dispatch("WalletDb/getPrivateKey", activepubkey, { root: true }));

        case 12:
          private_key = _context3.sent;
          pubkey = memo.from == activepubkey ? memo.to : memo.from;
          public_key = _bcxjsCores.PublicKey.fromPublicKeyString(pubkey);
          memo_text = private_key ? _bcxjsCores.Aes.decrypt_with_checksum(private_key, public_key, memo.nonce, memo.message).toString("utf-8") : null;
          result = {
            code: 1,
            data: {
              text: memo_text, isMine: memo.from == activepubkey
            }
          };
          return _context3.abrupt('return', result);

        case 18:
        case 'end':
          return _context3.stop();
      }
    }
  }, null, undefined);
};

// 2020-05-13  xulin add  åŠ å¯†memo
var encryptionOneMome = exports.encryptionOneMome = function _callee4(_ref, params) {
  var dispatch = _ref.dispatch,
      rootGetters = _ref.rootGetters;

  var fromId, _params$fromAccount, fromAccount, toAccount, _params$amount, amount, memo, _params$assetId, assetId, _params$isEncryption, isEncryption, _params$onlyGetFee, onlyGetFee, _params$proposeAccoun, proposeAccount, isPropose;

  return _regenerator2.default.async(function _callee4$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          if (!rootGetters['WalletDb/isLocked']) {
            _context4.next = 2;
            break;
          }

          return _context4.abrupt('return', { code: 114, message: "Account is locked or not logged in" });

        case 2:
          if (!(!params.memo || !params.toAccount)) {
            _context4.next = 4;
            break;
          }

          return _context4.abrupt('return', { code: 101, message: "Parameter is missing" });

        case 4:
          _helper2.default.trimParams(params);
          fromId = rootGetters['account/getAccountUserId'];
          _params$fromAccount = params.fromAccount, fromAccount = _params$fromAccount === undefined ? "" : _params$fromAccount, toAccount = params.toAccount, _params$amount = params.amount, amount = _params$amount === undefined ? 0 : _params$amount, memo = params.memo, _params$assetId = params.assetId, assetId = _params$assetId === undefined ? "1.3.0" : _params$assetId, _params$isEncryption = params.isEncryption, isEncryption = _params$isEncryption === undefined ? true : _params$isEncryption, _params$onlyGetFee = params.onlyGetFee, onlyGetFee = _params$onlyGetFee === undefined ? false : _params$onlyGetFee, _params$proposeAccoun = params.proposeAccount, proposeAccount = _params$proposeAccoun === undefined ? "" : _params$proposeAccoun, isPropose = params.isPropose;

          if (toAccount) {
            _context4.next = 9;
            break;
          }

          return _context4.abrupt('return', { code: 124, message: "Receivables account name can not be empty" });

        case 9:

          if (isPropose) {
            proposeAccount = fromAccount;
          }

          assetId = assetId || "1.3.0";
          assetId = assetId.toUpperCase();

          return _context4.abrupt('return', dispatch('_encryptionOneMomeOperations', {
            operations: [{
              op_type: 0,
              type: "transfer",
              params: {
                to: toAccount,
                amount: amount,
                asset_id: assetId,
                memo: memo,
                isEncryption: isEncryption
              }
            }],
            proposeAccount: proposeAccount,
            onlyGetFee: onlyGetFee
          }));

        case 13:
        case 'end':
          return _context4.stop();
      }
    }
  }, null, undefined);
};

var transferAsset = exports.transferAsset = function _callee5(_ref2, params) {
  var dispatch = _ref2.dispatch,
      rootGetters = _ref2.rootGetters;

  var _params$fromAccount2, fromAccount, toAccount, _params$amount2, amount, memo, _params$assetId2, assetId, _params$isEncryption2, isEncryption, _params$onlyGetFee2, onlyGetFee, _params$proposeAccoun2, proposeAccount, isPropose;

  return _regenerator2.default.async(function _callee5$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          _helper2.default.trimParams(params);
          _params$fromAccount2 = params.fromAccount, fromAccount = _params$fromAccount2 === undefined ? "" : _params$fromAccount2, toAccount = params.toAccount, _params$amount2 = params.amount, amount = _params$amount2 === undefined ? 0 : _params$amount2, memo = params.memo, _params$assetId2 = params.assetId, assetId = _params$assetId2 === undefined ? "1.3.0" : _params$assetId2, _params$isEncryption2 = params.isEncryption, isEncryption = _params$isEncryption2 === undefined ? true : _params$isEncryption2, _params$onlyGetFee2 = params.onlyGetFee, onlyGetFee = _params$onlyGetFee2 === undefined ? false : _params$onlyGetFee2, _params$proposeAccoun2 = params.proposeAccount, proposeAccount = _params$proposeAccoun2 === undefined ? "" : _params$proposeAccoun2, isPropose = params.isPropose;

          if (toAccount) {
            _context5.next = 4;
            break;
          }

          return _context5.abrupt('return', { code: 124, message: "Receivables account name can not be empty" });

        case 4:

          if (isPropose) {
            proposeAccount = fromAccount;
          }

          assetId = assetId || "1.3.0";
          assetId = assetId.toUpperCase();

          return _context5.abrupt('return', dispatch('_transactionOperations', {
            operations: [{
              op_type: 0,
              type: "transfer",
              params: {
                to: toAccount,
                amount: amount,
                asset_id: assetId,
                memo: memo,
                isEncryption: isEncryption
              }
            }],
            proposeAccount: proposeAccount,
            onlyGetFee: onlyGetFee
          }));

        case 8:
        case 'end':
          return _context5.stop();
      }
    }
  }, null, undefined);
};

var setOnlyGetOPFee = exports.setOnlyGetOPFee = function setOnlyGetOPFee(_ref3, b) {
  var commit = _ref3.commit;

  commit(types.SET_ONLY_GET_OP_FEE, b);
};

// 2020-05-13 xulin add åŠ å¯†memo
var _encryptionOneMomeOperations = exports._encryptionOneMomeOperations = function _callee6(store, _ref4) {
  var operations = _ref4.operations,
      _ref4$proposeAccount = _ref4.proposeAccount,
      proposeAccount = _ref4$proposeAccount === undefined ? "" : _ref4$proposeAccount,
      _ref4$onlyGetFee = _ref4.onlyGetFee,
      onlyGetFee = _ref4$onlyGetFee === undefined ? false : _ref4$onlyGetFee;
  var commit, rootGetters, dispatch, fromId, pAcc, fromAccount, res;
  return _regenerator2.default.async(function _callee6$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          commit = store.commit, rootGetters = store.rootGetters, dispatch = store.dispatch;

          dispatch("setOnlyGetOPFee", onlyGetFee);
          commit(types.TRANSFER_ASSET_REQUEST);
          commit(types.SET_TRX_DATA, null); //clear last SET_TRX_DATA
          fromId = rootGetters['account/getAccountUserId'];

          if (!proposeAccount) {
            _context6.next = 12;
            break;
          }

          _context6.next = 8;
          return _regenerator2.default.awrap(_api2.default.Account.getUser(proposeAccount, true));

        case 8:
          pAcc = _context6.sent;

          if (!(pAcc.code != 1)) {
            _context6.next = 11;
            break;
          }

          return _context6.abrupt('return', pAcc);

        case 11:
          proposeAccount = pAcc.data.account.id;

        case 12:
          _context6.next = 14;
          return _regenerator2.default.awrap(dispatch("user/fetchUser", fromId, { root: true }));

        case 14:
          fromAccount = _context6.sent.data;

          if (!rootGetters['WalletDb/isLocked']) {
            _context6.next = 17;
            break;
          }

          return _context6.abrupt('return', { code: 114, message: "Account is locked or not logged in" });

        case 17:
          _context6.next = 19;
          return _regenerator2.default.awrap(_api2.default.Transactions.oneMomeOp(fromId, operations, fromAccount, proposeAccount, store));

        case 19:
          res = _context6.sent;
          return _context6.abrupt('return', res);

        case 21:
        case 'end':
          return _context6.stop();
      }
    }
  }, null, undefined);
};

var _transactionOperations = exports._transactionOperations = function _callee8(store, _ref5) {
  var operations = _ref5.operations,
      _ref5$proposeAccount = _ref5.proposeAccount,
      proposeAccount = _ref5$proposeAccount === undefined ? "" : _ref5$proposeAccount,
      _ref5$onlyGetFee = _ref5.onlyGetFee,
      onlyGetFee = _ref5$onlyGetFee === undefined ? false : _ref5$onlyGetFee;

  var commit, rootGetters, dispatch, fromId, pAcc, fromAccount, worker, res, _ret;

  return _regenerator2.default.async(function _callee8$(_context8) {
    while (1) {
      switch (_context8.prev = _context8.next) {
        case 0:
          commit = store.commit, rootGetters = store.rootGetters, dispatch = store.dispatch;

          dispatch("setOnlyGetOPFee", onlyGetFee);
          commit(types.TRANSFER_ASSET_REQUEST);
          commit(types.SET_TRX_DATA, null); //clear last SET_TRX_DATA
          fromId = rootGetters['account/getAccountUserId'];

          if (!proposeAccount) {
            _context8.next = 12;
            break;
          }

          _context8.next = 8;
          return _regenerator2.default.awrap(_api2.default.Account.getUser(proposeAccount, true));

        case 8:
          pAcc = _context8.sent;

          if (!(pAcc.code != 1)) {
            _context8.next = 11;
            break;
          }

          return _context8.abrupt('return', pAcc);

        case 11:
          proposeAccount = pAcc.data.account.id;

        case 12:
          _context8.next = 14;
          return _regenerator2.default.awrap(dispatch("user/fetchUser", fromId, { root: true }));

        case 14:
          fromAccount = _context8.sent.data;

          if (!rootGetters['WalletDb/isLocked']) {
            _context8.next = 17;
            break;
          }

          return _context8.abrupt('return', { code: 114, message: "Account is locked or not logged in" });

        case 17:
          worker = rootGetters["setting/g_settingsAPIs"].worker;
          // console.info("worker",worker,rootGetters["setting/g_settingsAPIs"]);

          _context8.next = 20;
          return _regenerator2.default.awrap(_api2.default.Transactions[worker ? "transactionOpWorker" : "transactionOp"](fromId, operations, fromAccount, proposeAccount, store));

        case 20:
          res = _context8.sent;

          if (!res.success) {
            _context8.next = 29;
            break;
          }

          _context8.next = 24;
          return _regenerator2.default.awrap(function _callee7() {
            var _res$data$, id, block_num, trx, results, op_result, i, _operations, params;

            return _regenerator2.default.async(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:

                    // if(onlyGetFee) return {code:1,data:res.data}

                    _res$data$ = res.data[0], id = _res$data$.id, block_num = _res$data$.block_num, trx = _res$data$.trx;
                    results = [];
                    op_result = void 0;
                    i = 0;

                  case 4:
                    if (!(i < trx.operation_results.length)) {
                      _context7.next = 16;
                      break;
                    }

                    op_result = trx.operation_results[i][1];

                    if (!op_result.contract_affecteds) {
                      _context7.next = 12;
                      break;
                    }

                    _operations = op_result.contract_affecteds.map(function (item) {
                      var op_num = item[0] + 300;
                      if (item[0] == 1) {
                        op_num = op_num + "" + item[1].action;
                      }
                      return {
                        block_num: block_num,
                        id: "",
                        op: [Number(op_num), item[1]]
                      };
                    });
                    _context7.next = 10;
                    return _regenerator2.default.awrap(_api2.default.Operations.parseOperations({
                      operations: _operations,
                      store: store,
                      isContract: true
                    }));

                  case 10:
                    _context7.t0 = function (item) {
                      item.result = item.parse_operations;
                      item.result_text = item.parse_operations_text;

                      delete item.payload;
                      delete item.parse_operations;
                      delete item.parse_operations_text;

                      return item;
                    };

                    op_result.contract_affecteds = _context7.sent.map(_context7.t0);

                  case 12:

                    if ((0, _keys2.default)(op_result).length) results.push(op_result);

                  case 13:
                    i++;
                    _context7.next = 4;
                    break;

                  case 16:
                    params = operations[0].params;

                    if ("action" in params && params.action == "changePassword") {
                      dispatch("account/_logout", null, { root: true });
                    }

                    return _context7.abrupt('return', {
                      v: {
                        code: 1,
                        data: results,
                        trx_data: {
                          trx_id: id,
                          block_num: block_num
                        }
                      }
                    });

                  case 19:
                  case 'end':
                    return _context7.stop();
                }
              }
            }, null, undefined);
          }());

        case 24:
          _ret = _context8.sent;

          if (!((typeof _ret === 'undefined' ? 'undefined' : (0, _typeof3.default)(_ret)) === "object")) {
            _context8.next = 27;
            break;
          }

          return _context8.abrupt('return', _ret.v);

        case 27:
          _context8.next = 30;
          break;

        case 29:
          return _context8.abrupt('return', TRANSFER_ASSET_ERROR({ error: res.error, code: res.code }));

        case 30:
        case 'end':
          return _context8.stop();
      }
    }
  }, null, undefined);
};

var TRANSFER_ASSET_ERROR = function TRANSFER_ASSET_ERROR(_ref6) {
  var error = _ref6.error,
      code = _ref6.code;

  if (typeof error == "string") {
    error = {
      message: error
    };
  }

  var message = error.message;
  if (typeof error.message == "string") {
    if (error.message.indexOf("o.issuer == a.issuer") != -1) {
      code = 160;
      message = "You are not the creator of assets";
    }
  }

  return {
    code: code,
    message: message,
    error: error
  };
};

var setOrderData = exports.setOrderData = function setOrderData(_ref7, params) {
  var commit = _ref7.commit;

  commit(types.SET_ORDER_DATA, params);
};

/***/ }),
/* 541 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(27);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _mutations;

var _mutations2 = __webpack_require__(14);

var types = _interopRequireWildcard(_mutations2);

var _user = __webpack_require__(542);

var actions = _interopRequireWildcard(_user);

var _user2 = __webpack_require__(543);

var getters = _interopRequireWildcard(_user2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var initialState = {
  account: null,
  allAccount: null,
  balances: [],
  fetching: false,
  error: false
};

var mutations = (_mutations = {}, (0, _defineProperty3.default)(_mutations, types.FETCH_USER_REQUEST, function (state) {
  state.fetching = true;
  state.error = false;
}), (0, _defineProperty3.default)(_mutations, types.FETCH_USER_COMPLETE, function (state, result) {
  state.account = result.account;
  state.balances = result.balances;
  state.allAccount = result;
  state.fetching = false;
}), (0, _defineProperty3.default)(_mutations, types.FETCH_USER_ERROR, function (state) {
  state.fetching = false;
  state.error = true;
}), (0, _defineProperty3.default)(_mutations, types.CLEAR_ACCOUNT, function (state) {
  state.account = null;
  state.balances = [];
}), _mutations);

exports.default = {
  state: initialState,
  actions: actions,
  getters: getters,
  mutations: mutations,
  namespaced: true
};

/***/ }),
/* 542 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getUserInfo = exports.clearAccountCache = exports.getUserAllBalance = exports.getAccountBalances = exports.getUserNameByUserId = exports.fetchUserForIsSave = exports.fetchUser = undefined;

var _defineProperty2 = __webpack_require__(27);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _slicedToArray2 = __webpack_require__(90);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _promise = __webpack_require__(4);

var _promise2 = _interopRequireDefault(_promise);

var _keys = __webpack_require__(24);

var _keys2 = _interopRequireDefault(_keys);

var _stringify = __webpack_require__(18);

var _stringify2 = _interopRequireDefault(_stringify);

var _regenerator = __webpack_require__(3);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _mutations = __webpack_require__(14);

var types = _interopRequireWildcard(_mutations);

var _api = __webpack_require__(10);

var _api2 = _interopRequireDefault(_api);

var _index = __webpack_require__(96);

var _utils = _interopRequireWildcard(_index);

var _persistentStorage = __webpack_require__(147);

var _persistentStorage2 = _interopRequireDefault(_persistentStorage);

var _immutable = __webpack_require__(23);

var _immutable2 = _interopRequireDefault(_immutable);

var _utils2 = __webpack_require__(59);

var _utils3 = _interopRequireDefault(_utils2);

var _helper = __webpack_require__(34);

var _helper2 = _interopRequireDefault(_helper);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CORE_ASSET_ID = "1.3.0";

/**
 * Function to convert array of balances to object with keys as assets ids United Labs of BCTech.
 * @param {Array} balancesArr - array of balance objects
 */
var balancesToObject = function balancesToObject(balancesArr) {
  var obj = {};
  balancesArr.forEach(function (item) {
    obj[item.asset_type] = item;
  });
  return obj;
};

/**
 * Fetches users objects from bcxjs-ws
 * @param {string} username - name of user to fetch
 */
var fetchUser = exports.fetchUser = function _callee(_ref, nameOrId) {
  var commit = _ref.commit,
      dispatch = _ref.dispatch;
  var result, user;
  return _regenerator2.default.async(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          commit(types.FETCH_USER_REQUEST);
          _context.next = 3;
          return _regenerator2.default.awrap(_api2.default.Account.getUser(nameOrId));

        case 3:
          result = _context.sent;

          if (result.success) {
            user = result.data;

            user.balances = balancesToObject(user.balances);
            commit(types.FETCH_USER_COMPLETE, user);
            // dispatch("account/updateAccountData",user,{root:true}United Labs of BCTech.);
          } else {
            commit(types.FETCH_USER_ERROR);
          }

          return _context.abrupt('return', result);

        case 6:
        case 'end':
          return _context.stop();
      }
    }
  }, null, undefined);
};

var fetchUserForIsSave = exports.fetchUserForIsSave = function _callee2(_ref2, _ref3) {
  var commit = _ref2.commit,
      dispatch = _ref2.dispatch;
  var nameOrId = _ref3.nameOrId,
      _ref3$isSave = _ref3.isSave,
      isSave = _ref3$isSave === undefined ? false : _ref3$isSave,
      pubkey = _ref3.pubkey;
  var result, user;
  return _regenerator2.default.async(function _callee2$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          if (isSave) commit(types.FETCH_USER_REQUEST);

          _context2.next = 3;
          return _regenerator2.default.awrap(_api2.default.Account.getUser(nameOrId));

        case 3:
          result = _context2.sent;

          if (!isSave) {
            _context2.next = 15;
            break;
          }

          if (!result.success) {
            _context2.next = 14;
            break;
          }

          user = result.data;

          if (!(pubkey && user.account.active.key_auths[0] != pubkey)) {
            _context2.next = 9;
            break;
          }

          return _context2.abrupt('return');

        case 9:
          dispatch("account/setAccountUserId", user.account.id, { root: true });
          user.balances = balancesToObject(user.balances);
          commit(types.FETCH_USER_COMPLETE, user);
          _context2.next = 15;
          break;

        case 14:
          commit(types.FETCH_USER_ERROR);

        case 15:
          return _context2.abrupt('return', result);

        case 16:
        case 'end':
          return _context2.stop();
      }
    }
  }, null, undefined);
};

var getUserNameByUserId = exports.getUserNameByUserId = function _callee3(_ref4, nameOrId) {
  var commit = _ref4.commit;
  var result;
  return _regenerator2.default.async(function _callee3$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return _regenerator2.default.awrap(_api2.default.Account.getUser(nameOrId));

        case 2:
          result = _context3.sent;

          if (!result.success) {
            _context3.next = 5;
            break;
          }

          return _context3.abrupt('return', result.data.account.name);

        case 5:
          return _context3.abrupt('return', "");

        case 6:
        case 'end':
          return _context3.stop();
      }
    }
  }, null, undefined);
};

var getAccountBalances = exports.getAccountBalances = function _callee4(store, params) {
  var dispatch, rootGetters, _params$assetId_or_sy, assetId_or_symbol, _params$assetId, assetId, _params$account, account, _params$callback, callback, result, accountBalances, assetIds, reqBalances, reqBalanceItem, accountBalanceItem, asset_id;

  return _regenerator2.default.async(function _callee4$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          dispatch = store.dispatch, rootGetters = store.rootGetters;

          _helper2.default.trimParams(params);
          _params$assetId_or_sy = params.assetId_or_symbol, assetId_or_symbol = _params$assetId_or_sy === undefined ? "" : _params$assetId_or_sy, _params$assetId = params.assetId, assetId = _params$assetId === undefined ? "" : _params$assetId, _params$account = params.account, account = _params$account === undefined ? "" : _params$account, _params$callback = params.callback, callback = _params$callback === undefined ? null : _params$callback;

          assetId_or_symbol = assetId_or_symbol || assetId;

          if (account) {
            _context4.next = 6;
            break;
          }

          return _context4.abrupt('return', { code: 123, message: 'Parameter "account" can not be empty' });

        case 6:
          _context4.next = 8;
          return _regenerator2.default.awrap(getBalances(account, store));

        case 8:
          result = _context4.sent;

          if (!(result.code == 1)) {
            _context4.next = 35;
            break;
          }

          accountBalances = JSON.parse((0, _stringify2.default)(result.data));

          result.data = {};
          if (assetId_or_symbol) {
            assetId_or_symbol = assetId_or_symbol.toUpperCase();
          }
          assetIds = assetId_or_symbol ? [assetId_or_symbol] : (0, _keys2.default)(accountBalances);

          if (!assetIds.length) {
            _context4.next = 35;
            break;
          }

          _context4.next = 17;
          return _regenerator2.default.awrap(dispatch("assets/fetchAssets", { assets: assetIds }, { root: true }));

        case 17:
          reqBalances = _context4.sent;

          if (!reqBalances) {
            _context4.next = 33;
            break;
          }

          reqBalanceItem = void 0, accountBalanceItem = void 0;
          _context4.t0 = _regenerator2.default.keys(accountBalances);

        case 21:
          if ((_context4.t1 = _context4.t0()).done) {
            _context4.next = 30;
            break;
          }

          asset_id = _context4.t1.value;

          reqBalanceItem = reqBalances[asset_id];

          if (reqBalanceItem) {
            _context4.next = 26;
            break;
          }

          return _context4.abrupt('continue', 21);

        case 26:
          accountBalanceItem = accountBalances[asset_id];
          result.data[reqBalanceItem.symbol] = _helper2.default.getFullNum(accountBalanceItem.balance / Math.pow(10, reqBalanceItem.precision));
          _context4.next = 21;
          break;

        case 30:
          if (!(0, _keys2.default)(result.data).length) {
            result.code = 125;
            result.message = "Users do not own " + (assetId_or_symbol || "") + "assets";
          }
          _context4.next = 35;
          break;

        case 33:
          result.code = 115;
          result.message = "There is no asset " + assetId_or_symbol + " in the block chain";

        case 35:
          return _context4.abrupt('return', result);

        case 36:
        case 'end':
          return _context4.stop();
      }
    }
  }, null, undefined);
};

var getBalances = function _callee5(account, store) {
  var rootGetters, result, accountBalances, userId, full_account, account_res;
  return _regenerator2.default.async(function _callee5$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          rootGetters = store.rootGetters;
          result = {
            code: 1
          };
          accountBalances = null; //

          userId = rootGetters['account/getAccountUserId'];

          if (!account && userId) {
            account = userId;
          }
          full_account = void 0;

          if (!account) {
            _context5.next = 13;
            break;
          }

          _context5.next = 9;
          return _regenerator2.default.awrap(_api2.default.Account.getUser(account));

        case 9:
          account_res = _context5.sent;

          if (account_res.success) {
            full_account = account_res.data;
            accountBalances = _utils.balancesToObject(full_account.balances);
            // if(account.data.account.contract_asset_locked)
            //    result.contract_asset_locked=format_contract_asset_locked(account.data.account.contract_asset_locked);
          } else {
            result.code = account_res.code;
            result.message = account_res.error.message;
          }
          _context5.next = 14;
          break;

        case 13:
          if (rootGetters['user/getAccountObject']) {
            full_account = rootGetters['user/getAccountObject'];
            accountBalances = rootGetters['user/getBalances'];
          } else {
            result.code = 111;
            result.message = "Please login first";
          }

        case 14:
          if (!(result.code == 1)) {
            _context5.next = 19;
            break;
          }

          result.data = accountBalances;
          _context5.next = 18;
          return _regenerator2.default.awrap(format_asset_locked(full_account, store));

        case 18:
          result.asset_locked = _context5.sent;

        case 19:
          return _context5.abrupt('return', result);

        case 20:
        case 'end':
          return _context5.stop();
      }
    }
  }, null, undefined);
};

var format_asset_locked = function _callee8(full_account, store) {
  var _full_account$account, locked_total, witness_freeze, vote_for_witness, contract_lock_details, _ref5, precision, symbol, _witness_freeze, vote_freeze, contract_freeze, _locked_total, locked_total_assets, assets, contract_name;

  return _regenerator2.default.async(function _callee8$(_context8) {
    while (1) {
      switch (_context8.prev = _context8.next) {
        case 0:
          _full_account$account = full_account.account.asset_locked, locked_total = _full_account$account.locked_total, witness_freeze = _full_account$account.witness_freeze, vote_for_witness = _full_account$account.vote_for_witness, contract_lock_details = _full_account$account.contract_lock_details;
          _context8.next = 3;
          return _regenerator2.default.awrap(_api2.default.Assets.fetch(["1.3.0"], true));

        case 3:
          _ref5 = _context8.sent;
          precision = _ref5.precision;
          symbol = _ref5.symbol;
          _witness_freeze = {
            amount: 0,
            symbol: symbol
          };
          vote_freeze = {
            amount: 0,
            symbol: symbol,
            details: []
          };
          contract_freeze = {
            amount: 0,
            symbol: symbol,
            details: [],
            contracts: []
          };


          if (witness_freeze) _witness_freeze.amount = _helper2.default.getFullNum(witness_freeze.amount, precision);

          if (!vote_for_witness) {
            _context8.next = 15;
            break;
          }

          vote_freeze.amount = _helper2.default.getFullNum(vote_for_witness.amount, precision);
          _context8.next = 14;
          return _regenerator2.default.awrap(_promise2.default.all(full_account.votes.map(function _callee6(vote) {
            var vote_acc_name, acc_res;
            return _regenerator2.default.async(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    vote_acc_name = vote.witness_account;
                    _context6.next = 3;
                    return _regenerator2.default.awrap(_api2.default.Account.getAccount(vote_acc_name, true));

                  case 3:
                    acc_res = _context6.sent;

                    if (acc_res.success) {
                      vote_acc_name = acc_res.data.account.name;
                    }
                    return _context6.abrupt('return', vote_acc_name);

                  case 6:
                  case 'end':
                    return _context6.stop();
                }
              }
            }, null, undefined);
          })));

        case 14:
          vote_freeze.details = _context8.sent;

        case 15:
          _locked_total = {};
          locked_total_assets = locked_total.map(function (item) {
            return item[0];
          });

          if (!locked_total_assets.length) {
            _context8.next = 26;
            break;
          }

          _context8.next = 20;
          return _regenerator2.default.awrap(store.dispatch("assets/fetchAssets", {
            assets: locked_total_assets,
            isCache: true
          }, { root: true }));

        case 20:
          assets = _context8.sent;

          locked_total.forEach(function (item) {
            _locked_total[item[0]] = _helper2.default.getFullNum(item[1], assets[item[0]].precision);
          });

          contract_name = "";

          if (!contract_lock_details) {
            _context8.next = 26;
            break;
          }

          _context8.next = 26;
          return _regenerator2.default.awrap(_promise2.default.all(contract_lock_details.map(function _callee7(item) {
            var c_res;
            return _regenerator2.default.async(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    contract_name = item[0];
                    _context7.next = 3;
                    return _regenerator2.default.awrap(_api2.default.Contract.getContract(item[0], true));

                  case 3:
                    c_res = _context7.sent;

                    if (c_res.code == 1) contract_name = c_res.data.name;
                    contract_freeze.contracts.push(contract_name);
                    item[1].forEach(function (asset) {
                      var amount = _helper2.default.getFullNum(asset[1], precision);
                      if (asset[0] == "1.3.0") contract_freeze.amount += amount;
                      contract_freeze.details.push({
                        contract_name: contract_name,
                        amount: amount,
                        symbol: assets[asset[0]].symbol
                      });
                    });

                    return _context7.abrupt('return', item);

                  case 8:
                  case 'end':
                    return _context7.stop();
                }
              }
            }, null, undefined);
          })));

        case 26:
          return _context8.abrupt('return', {
            locked_total: _locked_total,
            lock_details: {
              vote_freeze: vote_freeze,
              contract_freeze: contract_freeze,
              witness_freeze: _witness_freeze
            }
          });

        case 27:
        case 'end':
          return _context8.stop();
      }
    }
  }, null, undefined);
};

var format_contract_asset_locked = function format_contract_asset_locked(_ref6) {
  var locked_total = _ref6.locked_total,
      lock_details = _ref6.lock_details;

  var _locked_total = {};
  locked_total.forEach(function (item) {
    _locked_total[item[0]] = item[1];
  });
  var _lock_details = {};
  for (var i = 0; i < lock_details.length; i++) {
    var _lock_details$i = (0, _slicedToArray3.default)(lock_details[i], 2),
        contract_id = _lock_details$i[0],
        contract_assets_locked = _lock_details$i[1];

    for (var j = 0; j < contract_assets_locked.length; j++) {
      var _contract_assets_lock = (0, _slicedToArray3.default)(contract_assets_locked[j], 2),
          asset_id = _contract_assets_lock[0],
          amount = _contract_assets_lock[1];

      if (_lock_details[asset_id]) {
        _lock_details[asset_id][contract_id] = amount;
      } else {
        _lock_details[asset_id] = (0, _defineProperty3.default)({}, contract_id, amount);
      }
    }
  }

  return {
    _locked_total: _locked_total,
    _lock_details: _lock_details
  };
};

var getUserAllBalance = exports.getUserAllBalance = function _callee9(store, params) {
  var dispatch, rootGetters, account, unit, contract_asset_locked, asset_locked, accountBalances, toAsset_symbol, toAssets, toAsset, assetId, assetsIds, reqBalances, quoteAssets, marketStats, balances, amount, fromAsset, id, eqValue, fromSymbol, price, fromAssetPrecision, locked_total, balance, core_asset, symbol, precision;
  return _regenerator2.default.async(function _callee9$(_context9) {
    while (1) {
      switch (_context9.prev = _context9.next) {
        case 0:
          dispatch = store.dispatch, rootGetters = store.rootGetters;

          _helper2.default.trimParams(params);
          account = params.account, unit = params.unit;

          if (account) {
            _context9.next = 5;
            break;
          }

          return _context9.abrupt('return', { code: 123, message: 'Parameter "account" can not be empty' });

        case 5:
          contract_asset_locked = void 0;
          asset_locked = void 0;
          _context9.next = 9;
          return _regenerator2.default.awrap(getBalances(account, store));

        case 9:
          accountBalances = _context9.sent;

          if (!(accountBalances.code == 1)) {
            _context9.next = 15;
            break;
          }

          // if(accountBalances.contract_asset_locked)
          //   contract_asset_locked=JSON.parse(JSON.stringify(accountBalances.contract_asset_locked));
          if (accountBalances.asset_locked) asset_locked = JSON.parse((0, _stringify2.default)(accountBalances.asset_locked));

          accountBalances = JSON.parse((0, _stringify2.default)(accountBalances.data));
          _context9.next = 16;
          break;

        case 15:
          return _context9.abrupt('return', accountBalances);

        case 16:
          toAsset_symbol = unit || rootGetters["setting/defaultSettings"].unit;
          _context9.next = 19;
          return _regenerator2.default.awrap(dispatch("assets/fetchAssets", { assets: [toAsset_symbol], isOne: false }, { root: true }));

        case 19:
          toAssets = _context9.sent;

          if (toAssets) {
            _context9.next = 22;
            break;
          }

          return _context9.abrupt('return', { code: 126, message: "There is no asset " + toAsset_symbol + " in the block chain" });

        case 22:

          if (/1.3.\d+/.test(toAsset_symbol)) {
            //transformation when incoming unit is an asset ID
            toAsset_symbol = toAssets[toAsset_symbol].symbol;
          }

          toAsset = void 0;

          for (assetId in toAssets) {
            if (toAssets[assetId].symbol == toAsset_symbol) {
              toAsset = toAssets[assetId];
            }
          }

          assetsIds = (0, _keys2.default)(accountBalances);

          if (!accountBalances.toAssetId) assetsIds.push(toAsset.id);
          _context9.next = 29;
          return _regenerator2.default.awrap(dispatch("assets/fetchAssets", { assets: assetsIds }, { root: true }));

        case 29:
          reqBalances = _context9.sent;
          //queried assets info
          quoteAssets = (0, _keys2.default)(reqBalances).filter(function (key) {
            return (/^[a-zA-Z]+$/.test(key)
            );
          });

          reqBalances = _immutable2.default.fromJS(reqBalances);

          //get queried assets' market info
          marketStats = {};
          _context9.next = 35;
          return _regenerator2.default.awrap(dispatch("market/getMarketStats", {
            baseAsset: toAsset_symbol,
            quoteAssets: quoteAssets
          }, { root: true }));

        case 35:
          _context9.t0 = function (asset) {
            marketStats[asset.quote_symbol] = asset;
          };

          _context9.sent.data.forEach(_context9.t0);

          // console.info("marketStats",marketStats);
          balances = [];
          amount = 0;
          fromAsset = void 0;


          for (id in accountBalances) {
            amount = accountBalances[id].balance;
            fromAsset = reqBalances.get(id);

            eqValue = amount;
            fromSymbol = fromAsset.get("symbol");

            if (fromSymbol != toAsset.symbol) {
              price = marketStats[fromSymbol].latest_price;

              eqValue = eqValue * price;
            }

            fromAssetPrecision = fromAsset.get("precision");
            locked_total = asset_locked.locked_total[id] || 0;
            balance = _helper2.default.getFullNum(amount, fromAssetPrecision);
            // let locked_total=asset_locked._locked_total;
            // if(id in locked_total){

            // }
            // let lock_details;
            // if(contract_asset_locked){
            //    lock_details=contract_asset_locked._lock_details[id]||{};
            //   for(let key in lock_details){
            //     lock_details[key]=helper.getFullNum(lock_details[key],fromAssetPrecision);
            //   }
            // }

            balances.push({
              id: id,
              balance: balance,
              available_balance: Number((balance - locked_total).toFixed(fromAssetPrecision)),
              symbol: fromSymbol,
              precision: fromAssetPrecision,
              eq_value: id != "1.3.1" ? _helper2.default.getFullNum(eqValue, fromAssetPrecision) : 0,
              eq_unit: toAsset.symbol,
              eq_precision: toAsset.precision,
              locked_total: locked_total
              //locked_total:contract_asset_locked?helper.getFullNum(contract_asset_locked._locked_total[id]||0,fromAssetPrecision):0,
              //lock_details:lock_details||{}
            });
          }

          if (balances.length) {
            _context9.next = 46;
            break;
          }

          _context9.next = 44;
          return _regenerator2.default.awrap(_api2.default.Assets.fetch(["1.3.0"], true));

        case 44:
          core_asset = _context9.sent;

          if (core_asset) {
            symbol = core_asset.symbol, precision = core_asset.precision;

            balances = [{
              id: "1.3.0",
              balance: 0,
              available_balance: 0,
              symbol: symbol,
              precision: precision,
              eq_value: 0,
              eq_unit: toAsset_symbol,
              eq_precision: toAsset.precision,
              locked_total: 0 //,
              //lock_details:{}
            }];
          }

        case 46:
          return _context9.abrupt('return', { code: 1, data: balances, asset_locked: asset_locked });

        case 47:
        case 'end':
          return _context9.stop();
      }
    }
  }, null, undefined);
};

var clearAccountCache = exports.clearAccountCache = function clearAccountCache(_ref7) {
  var commit = _ref7.commit;

  _api2.default.Account.clear_accs();
  commit(types.CLEAR_ACCOUNT);
};

var getUserInfo = exports.getUserInfo = function _callee10(_ref8, _ref9) {
  var dispatch = _ref8.dispatch;
  var _ref9$account = _ref9.account,
      account = _ref9$account === undefined ? "" : _ref9$account,
      _ref9$isCache = _ref9.isCache,
      isCache = _ref9$isCache === undefined ? false : _ref9$isCache,
      _ref9$isSubscribe = _ref9.isSubscribe,
      isSubscribe = _ref9$isSubscribe === undefined ? false : _ref9$isSubscribe;
  var acc, error;
  return _regenerator2.default.async(function _callee10$(_context10) {
    while (1) {
      switch (_context10.prev = _context10.next) {
        case 0:
          account = account.trim();

          if (account) {
            _context10.next = 8;
            break;
          }

          account = _persistentStorage2.default.getSavedUserData();

          if (!account) {
            _context10.next = 7;
            break;
          }

          account = account.userId;
          _context10.next = 8;
          break;

        case 7:
          return _context10.abrupt('return', { code: 123, message: "Parameter account can not be empty" });

        case 8:
          _context10.next = 10;
          return _regenerator2.default.awrap(_api2.default.Account.getUser(account, isCache, isSubscribe));

        case 10:
          acc = _context10.sent;

          if (!acc.success) {
            _context10.next = 15;
            break;
          }

          return _context10.abrupt('return', { code: 1, data: acc.data });

        case 15:
          error = acc.error;
          return _context10.abrupt('return', { code: acc.code, message: error.message, error: error });

        case 17:
        case 'end':
          return _context10.stop();
      }
    }
  }, null, undefined);
};

/***/ }),
/* 543 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getUserName = getUserName;
exports.getAccountObject = getAccountObject;
exports.getAllAccountObject = getAllAccountObject;
exports.getBalances = getBalances;
exports.isFetching = isFetching;
exports.getAccountExtensions = getAccountExtensions;
exports.proxy_account_id = proxy_account_id;
/**
 * Returns current user's name string
 */
function getUserName(_ref) {
  var account = _ref.account;

  return account && account.name;
}

/**
 * Returns current user's account object
 */
function getAccountObject(_ref2) {
  var account = _ref2.account;

  return account;
}

function getAllAccountObject(_ref3) {
  var allAccount = _ref3.allAccount;

  return allAccount;
}

var getCurrentUserBalances = exports.getCurrentUserBalances = function getCurrentUserBalances(state) {
  return state.allAccount && state.allAccount.balances || {};
};
/**
 * Returns current users's balances object
 */
function getBalances(_ref4) {
  var balances = _ref4.balances;

  return balances;
}

/**
 * User fetching in progress indicator
 */
function isFetching(state) {
  return state.fetching;
}

function getAccountExtensions(state) {
  return state.account.options.extensions;
}

function proxy_account_id(_ref5) {
  var account = _ref5.account;

  var proxyId = account.options.voting_account;
  var proxy_account_id = proxyId === "1.2.5" ? "" : proxyId;
  return proxy_account_id;
}

/***/ }),
/* 544 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(27);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _keys = __webpack_require__(24);

var _keys2 = _interopRequireDefault(_keys);

var _typeof2 = __webpack_require__(26);

var _typeof3 = _interopRequireDefault(_typeof2);

var _mutations;

var _vue = __webpack_require__(19);

var _vue2 = _interopRequireDefault(_vue);

var _mutations2 = __webpack_require__(14);

var types = _interopRequireWildcard(_mutations2);

var _assets = __webpack_require__(545);

var actions = _interopRequireWildcard(_assets);

var _assets2 = __webpack_require__(548);

var getters = _interopRequireWildcard(_assets2);

var _immutable = __webpack_require__(23);

var _immutable2 = _interopRequireDefault(_immutable);

var _localStorage = __webpack_require__(395);

var _localStorage2 = _interopRequireDefault(_localStorage);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var STORAGE_KEY = "__gph__";

var accountStorage = null;
try {
  accountStorage = new _localStorage2.default(STORAGE_KEY);
} catch (e) {}
var initialState = {
  defaultAssetsIds: [],
  assets: _immutable2.default.fromJS({}),
  assets_arr: [],
  asset_symbol_to_id: {},
  cache_assets: {},
  pending: false,
  assetsFetched: 0,
  totalAssets: process.browser || true ? accountStorage && (0, _typeof3.default)(accountStorage.get("totalAssets")) != "object" ? accountStorage.get("totalAssets") : 3000 : 300
};

var mutations = (_mutations = {}, (0, _defineProperty3.default)(_mutations, types.FETCH_ASSETS_REQUEST, function (state) {
  state.pending = true;
}), (0, _defineProperty3.default)(_mutations, types.FETCH_ASSETS_COMPLETE, function (state, _ref) {
  var assets = _ref.assets;

  (0, _keys2.default)(assets).forEach(function (id) {
    _vue2.default.set(state.cache_assets, id, assets[id]);
  });
  // state.pending = false;
}), (0, _defineProperty3.default)(_mutations, types.FETCH_ASSETS_ERROR, function (state) {
  state.pending = false;
}), (0, _defineProperty3.default)(_mutations, types.SAVE_DEFAULT_ASSETS_IDS, function (state, _ref2) {
  var ids = _ref2.ids;

  state.defaultAssetsIds = ids;
}), (0, _defineProperty3.default)(_mutations, types.SET_ASSETS, function (state, assets) {
  state.cache_assets = assets;
}), _mutations);

exports.default = {
  state: initialState,
  actions: actions,
  mutations: mutations,
  getters: getters,
  namespaced: true
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9)))

/***/ }),
/* 545 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateCollateralForGas = exports.assetSettle = exports.assetGlobalSettle = exports.assetUpdateFeedProducers = exports.assetPublishFeed = exports.queryAssetRestricted = exports.onGetAssetList = exports.formatAssets = exports.queryAssets = exports.assetUpdateRestricted = exports.issueAsset = exports._createAsset = exports.createAsset = exports.reserveAsset = exports.assetFundFeePool = exports.assetClaimFees = exports._updateAsset = exports.updateAsset = exports.queryFees = exports.getTransactionBaseFee = exports.set_assets = exports.fetchDefaultAssets = exports.fetchAssets = exports.estimationGas = undefined;

var _promise = __webpack_require__(4);

var _promise2 = _interopRequireDefault(_promise);

var _stringify = __webpack_require__(18);

var _stringify2 = _interopRequireDefault(_stringify);

var _keys = __webpack_require__(24);

var _keys2 = _interopRequireDefault(_keys);

var _regenerator = __webpack_require__(3);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _mutations = __webpack_require__(14);

var types = _interopRequireWildcard(_mutations);

var _bcxjsWs = __webpack_require__(8);

var _api = __webpack_require__(10);

var _api2 = _interopRequireDefault(_api);

var _utils = __webpack_require__(96);

var _utils2 = __webpack_require__(59);

var _utils3 = _interopRequireDefault(_utils2);

var _helper = __webpack_require__(34);

var _helper2 = _interopRequireDefault(_helper);

var _asset_constants = __webpack_require__(394);

var _asset_constants2 = _interopRequireDefault(_asset_constants);

var _asset_utils = __webpack_require__(546);

var _asset_utils2 = _interopRequireDefault(_asset_utils);

var _bcxjsCores = __webpack_require__(7);

var _immutable = __webpack_require__(23);

var _immutable2 = _interopRequireDefault(_immutable);

var _bignumber = __webpack_require__(547);

var _bignumber2 = _interopRequireDefault(_bignumber);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var estimationGas = exports.estimationGas = function _callee(store, _ref) {
  var amount = _ref.amount;
  var commit, getters, rootGetters, core_asset, res, gas, gas_asset;
  return _regenerator2.default.async(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          commit = store.commit, getters = store.getters, rootGetters = store.rootGetters;

          if (!isNaN(Number(amount))) {
            _context.next = 3;
            break;
          }

          return _context.abrupt('return', { code: 135, message: "Please check parameter data type" });

        case 3:
          _context.next = 5;
          return _regenerator2.default.awrap(_api2.default.Assets.fetch(["1.3.0"], true));

        case 5:
          core_asset = _context.sent;
          _context.t0 = _regenerator2.default;
          _context.t1 = _api2.default.Assets;
          _context.next = 10;
          return _regenerator2.default.awrap(_helper2.default.toOpAmount(amount, core_asset));

        case 10:
          _context.t2 = _context.sent.data;
          _context.t3 = _context.t1.estimation_gas.call(_context.t1, _context.t2);
          _context.next = 14;
          return _context.t0.awrap.call(_context.t0, _context.t3);

        case 14:
          res = _context.sent;

          if (!(res.code != 1)) {
            _context.next = 17;
            break;
          }

          return _context.abrupt('return', res);

        case 17:
          gas = res.data;
          _context.next = 20;
          return _regenerator2.default.awrap(_api2.default.Assets.fetch([gas.asset_id], true));

        case 20:
          gas_asset = _context.sent;


          gas.amount = _helper2.default.getFullNum(gas.amount, gas_asset.precision);
          gas.amount_symbol = gas_asset.symbol;
          return _context.abrupt('return', { code: 1, data: gas });

        case 24:
        case 'end':
          return _context.stop();
      }
    }
  }, null, undefined);
};

var fetchAssets = exports.fetchAssets = function _callee2(store, _ref2) {
  var assets = _ref2.assets,
      _ref2$isOne = _ref2.isOne,
      isOne = _ref2$isOne === undefined ? false : _ref2$isOne,
      _ref2$isCache = _ref2.isCache,
      isCache = _ref2$isCache === undefined ? true : _ref2$isCache;
  var commit, getters, rootGetters, composedResult, currentAssetsIds, filteredAssets, result;
  return _regenerator2.default.async(function _callee2$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          commit = store.commit, getters = store.getters, rootGetters = store.rootGetters;
          composedResult = [];
          currentAssetsIds = (0, _keys2.default)(getters.getAssets);
          filteredAssets = assets.filter(function (id) {
            //Get the collection of requested assets not in cache.
            if (currentAssetsIds.indexOf(id) >= 0) {
              //if current asset is in cache.
              composedResult.push(getters.getAssets[id]);
            } else {
              return true; //Requested asset didn't exists in cache.
            }
          });

          if (!(isCache && filteredAssets.length == 0)) {
            _context2.next = 9;
            break;
          }

          //All the requested assets are existing in cache.
          composedResult = (0, _utils.arrayToObject)(composedResult);

          if (!isOne) {
            _context2.next = 8;
            break;
          }

          return _context2.abrupt('return', composedResult[assets[0]]);

        case 8:
          return _context2.abrupt('return', composedResult);

        case 9:

          commit(types.FETCH_ASSETS_REQUEST);
          //If it is a cache request, only requests the assets didn't exist in cache
          _context2.next = 12;
          return _regenerator2.default.awrap(_api2.default.Assets.fetch(isCache ? filteredAssets : assets));

        case 12:
          result = _context2.sent;

          if (result && result.length) {
            //If it is a cache request, then merge request assets into cached assets, else return the requested asset.
            composedResult = isCache ? result.concat(composedResult) : result;
          }

          if (!composedResult.length) {
            _context2.next = 20;
            break;
          }

          composedResult = (0, _utils.arrayToObject)(composedResult);
          commit(types.FETCH_ASSETS_COMPLETE, { assets: composedResult });

          if (!isOne) {
            _context2.next = 19;
            break;
          }

          return _context2.abrupt('return', composedResult[assets[0]] || null);

        case 19:
          return _context2.abrupt('return', composedResult);

        case 20:

          commit(types.FETCH_ASSETS_ERROR);
          return _context2.abrupt('return', null);

        case 22:
        case 'end':
          return _context2.stop();
      }
    }
  }, null, undefined);
};

var fetchDefaultAssets = exports.fetchDefaultAssets = function _callee3(store) {
  var commit, rootGetters, defaultAssetsNames, assets, ids;
  return _regenerator2.default.async(function _callee3$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          commit = store.commit, rootGetters = store.rootGetters;
          defaultAssetsNames = rootGetters["setting/g_settingsAPIs"].defaultAssetsNames;
          _context3.next = 4;
          return _regenerator2.default.awrap(fetchAssets(store, { assets: defaultAssetsNames }));

        case 4:
          assets = _context3.sent;

          if (assets) {
            ids = (0, _keys2.default)(assets);

            commit(types.SAVE_DEFAULT_ASSETS_IDS, { ids: ids });
          }

          return _context3.abrupt('return', assets);

        case 7:
        case 'end':
          return _context3.stop();
      }
    }
  }, null, undefined);
};

var set_assets = exports.set_assets = function set_assets(_ref3, assets) {
  var commit = _ref3.commit;

  commit(types.SET_ASSETS, assets);
};

var getTransactionBaseFee = exports.getTransactionBaseFee = function _callee4(_ref4, _ref5) {
  var dispatch = _ref4.dispatch;
  var transactionType = _ref5.transactionType,
      _ref5$feeAssetId = _ref5.feeAssetId,
      feeAssetId = _ref5$feeAssetId === undefined ? "1.3.0" : _ref5$feeAssetId,
      _ref5$isCache = _ref5.isCache,
      isCache = _ref5$isCache === undefined ? true : _ref5$isCache;
  var globalObject, feeAsset, coreAsset, fee;
  return _regenerator2.default.async(function _callee4$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          if (transactionType) {
            _context4.next = 2;
            break;
          }

          return _context4.abrupt('return', { code: 128, message: "Parameter 'transactionType' can not be empty" });

        case 2:
          _context4.next = 4;
          return _regenerator2.default.awrap(_api2.default.Explorer.getGlobalObject());

        case 4:
          globalObject = _context4.sent;

          if (!(globalObject.code != 1)) {
            _context4.next = 7;
            break;
          }

          return _context4.abrupt('return', globalObject);

        case 7:
          globalObject = globalObject.data;
          _context4.prev = 8;
          _context4.next = 11;
          return _regenerator2.default.awrap(dispatch("fetchAssets", { assets: [feeAssetId], isOne: true, isCache: isCache }));

        case 11:
          feeAsset = _context4.sent;
          _context4.next = 14;
          return _regenerator2.default.awrap(dispatch("fetchAssets", { assets: ["1.3.0"], isOne: true }));

        case 14:
          coreAsset = _context4.sent;


          // let fee =helper.getFullNum(utils.estimateFee(transactionType, null, globalObject)/Math.pow(10,coreAsset.precision));
          fee = _helper2.default.getFullNum(_utils3.default.getFee(transactionType, feeAsset, coreAsset, globalObject).getAmount({ real: true }));
          return _context4.abrupt('return', { code: 1, data: {
              fee_amount: fee,
              fee_symbol: feeAsset.symbol
            } });

        case 19:
          _context4.prev = 19;
          _context4.t0 = _context4['catch'](8);
          return _context4.abrupt('return', { code: 0, message: _context4.t0.message });

        case 22:
        case 'end':
          return _context4.stop();
      }
    }
  }, null, undefined, [[8, 19]]);
};

var queryFees = exports.queryFees = function _callee5(_ref6) {
  var dispatch = _ref6.dispatch;

  var _operationTypes, fee_grouping, globalObject, current_fees_parameters, _ref7, precision, symbol, _fee_grouping, _loop, groupName;

  return _regenerator2.default.async(function _callee5$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          _operationTypes = {};

          (0, _keys2.default)(_bcxjsCores.ChainTypes.operations).forEach(function (name) {
            var code = _bcxjsCores.ChainTypes.operations[name];
            _operationTypes[code] = name;
          });

          fee_grouping = {
            general: [0, 27],
            contract: [34, 35, 50],
            nh_asset: [37, 40, 41, 42, 43, 44, 45],
            asset: [8, 9, 10, 11, 12, 13, 14, 15, 16, 17],
            market: [1, 2, 3, 4, 16, 17],
            account: [5, 6, 7],
            business: [18, 19, 20, 21, 22, 23, 24, 25]
          };
          _context5.next = 5;
          return _regenerator2.default.awrap(_api2.default.Explorer.getGlobalObject());

        case 5:
          globalObject = _context5.sent;

          if (!(globalObject.code != 1)) {
            _context5.next = 8;
            break;
          }

          return _context5.abrupt('return', globalObject);

        case 8:
          globalObject = globalObject.data;
          current_fees_parameters = globalObject.parameters.current_fees.parameters;
          _context5.next = 12;
          return _regenerator2.default.awrap(_api2.default.Assets.fetch(["1.3.0"], true));

        case 12:
          _ref7 = _context5.sent;
          precision = _ref7.precision;
          symbol = _ref7.symbol;
          _fee_grouping = {};

          _loop = function _loop(groupName) {
            var feeIds = fee_grouping[groupName];
            // console.info('feeIds',feeIds);
            feeIds.forEach(function (code) {
              var fees = current_fees_parameters[code][1];
              for (var key in fees) {
                fees[key] = _helper2.default.getFullNum(fees[key], precision) + " " + symbol;
              }
              if (!_fee_grouping[groupName]) _fee_grouping[groupName] = [];
              _fee_grouping[groupName].push({
                type: _operationTypes[code],
                fees: fees
              });
            });
          };

          for (groupName in fee_grouping) {
            _loop(groupName);
          }

          return _context5.abrupt('return', { code: 1, data: _fee_grouping });

        case 19:
        case 'end':
          return _context5.stop();
      }
    }
  }, null, undefined);
};

var updateAsset = exports.updateAsset = function _callee6(_ref8, _ref9) {
  var dispatch = _ref8.dispatch;
  var issuer = _ref9.issuer,
      new_issuer = _ref9.new_issuer,
      update = _ref9.update,
      core_exchange_rate = _ref9.core_exchange_rate,
      asset = _ref9.asset,
      flags = _ref9.flags,
      permissions = _ref9.permissions,
      isBitAsset = _ref9.isBitAsset,
      bitasset_opts = _ref9.bitasset_opts,
      original_bitasset_opts = _ref9.original_bitasset_opts,
      description = _ref9.description,
      feedProducers = _ref9.feedProducers,
      originalFeedProducers = _ref9.originalFeedProducers,
      callback = _ref9.callback,
      assetChanged = _ref9.assetChanged;
  var quotePrecision, max_market_fee, cr_quote_amount, cr_base_amount, cr_quote_asset, cr_quote_precision, cr_base_asset, cr_base_precision, updateObject, operations, bitAssetUpdateObject;
  return _regenerator2.default.async(function _callee6$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          quotePrecision = _utils3.default.get_asset_precision(asset.get("precision"));


          _bignumber2.default.config({ DECIMAL_PLACES: asset.get("precision") });
          // let max_supply = new big(update.max_supply)
          //     .times(quotePrecision)
          //     .toString();
          max_market_fee = new _bignumber2.default(update.max_market_fee || 0).times(quotePrecision).toString();
          cr_quote_amount = void 0, cr_base_amount = void 0;

          if (!core_exchange_rate) {
            _context6.next = 19;
            break;
          }

          _context6.next = 7;
          return _regenerator2.default.awrap(_api2.default.Assets.fetch([core_exchange_rate.quote.asset_id]));

        case 7:
          cr_quote_asset = _context6.sent[0];
          cr_quote_precision = _utils3.default.get_asset_precision(cr_quote_asset.precision);
          _context6.next = 11;
          return _regenerator2.default.awrap(_api2.default.Assets.fetch([core_exchange_rate.base.asset_id]));

        case 11:
          cr_base_asset = _context6.sent[0];
          cr_base_precision = _utils3.default.get_asset_precision(cr_base_asset.precision);


          cr_quote_amount = new _bignumber2.default(core_exchange_rate.quote.amount).times(cr_quote_precision).toString();
          cr_base_amount = new _bignumber2.default(core_exchange_rate.base.amount).times(cr_base_precision).toString();

          if (!(core_exchange_rate.base.amount > 1000 || core_exchange_rate.quote.amount > 1000)) {
            _context6.next = 17;
            break;
          }

          return _context6.abrupt('return', { code: 171, message: "The amount of fee exchange rate assets should not exceed 1000" });

        case 17:
          if (!(_helper2.default.getDecimals(cr_base_amount) > cr_base_precision || _helper2.default.getDecimals(cr_quote_amount) > cr_quote_precision)) {
            _context6.next = 19;
            break;
          }

          return _context6.abrupt('return', { code: 172, message: "precision overflow of fee exchange rate assets" });

        case 19:
          updateObject = {
            fee: {
              amount: 0,
              asset_id: 0
            },
            asset_to_update: asset.get("id"),
            extensions: asset.get("extensions"),
            issuer: issuer,
            new_issuer: new_issuer,
            new_options: {
              max_supply: update.max_supply,
              max_market_fee: max_market_fee,
              market_fee_percent: update.market_fee_percent * 100,
              description: description,
              issuer_permissions: permissions,
              flags: flags,
              extensions: asset.getIn(["options", "extensions"])
            }
          };

          if (core_exchange_rate) {
            updateObject.new_options.core_exchange_rate = {
              quote: {
                amount: cr_quote_amount,
                asset_id: core_exchange_rate.quote.asset_id
              },
              base: {
                amount: cr_base_amount,
                asset_id: core_exchange_rate.base.asset_id
              }
            };
          }

          if (issuer === new_issuer || !new_issuer) {
            delete updateObject.new_issuer;
          }
          // console.info("updateObject",updateObject);
          operations = [{
            op_type: 9,
            type: "asset_update",
            params: updateObject
          }];

          if (isBitAsset && original_bitasset_opts && (bitasset_opts.feed_lifetime_sec !== original_bitasset_opts.feed_lifetime_sec || bitasset_opts.minimum_feeds !== original_bitasset_opts.minimum_feeds || bitasset_opts.force_settlement_delay_sec !== original_bitasset_opts.force_settlement_delay_sec || bitasset_opts.force_settlement_offset_percent !== original_bitasset_opts.force_settlement_offset_percent || bitasset_opts.maximum_force_settlement_volume !== original_bitasset_opts.maximum_force_settlement_volume || bitasset_opts.short_backing_asset !== original_bitasset_opts.short_backing_asset)) {
            bitAssetUpdateObject = {
              fee: {
                amount: 0,
                asset_id: 0
              },
              asset_to_update: asset.get("id"),
              issuer: issuer,
              new_options: bitasset_opts
            };


            operations.push({
              op_type: 11,
              type: "asset_update_bitasset",
              params: bitAssetUpdateObject
            });

            // console.info("operations",operations);
          }

          return _context6.abrupt('return', dispatch('transactions/_transactionOperations', {
            operations: operations
          }, { root: true }));

        case 25:
        case 'end':
          return _context6.stop();
      }
    }
  }, null, undefined);
};

var _updateAsset = exports._updateAsset = function _callee7(_ref10, params) {
  var dispatch = _ref10.dispatch,
      rootGetters = _ref10.rootGetters;

  var assetId, maxSupply, newIssuer, coreExchangeRate, whiteList, transferRestricted, chargeMarketFee, description, bitassetOpts, _params$onlyGetFee, onlyGetFee, u_asset, isBitAsset, flagBooleans, flags, _params, bitasset_data_id, bitassetData, _bitasset_opts, feedLifetimeSec, minimumFeeds, forceSettlementDelaySec, forceSettlementOffsetPercent, maximumForceSettlementVolume, shortBackingAsset, bitasset_options, minimum_feeds, feed_lifetime_sec, force_settlement_delay_sec, force_settlement_offset_percent, maximum_force_settlement_volume;

  return _regenerator2.default.async(function _callee7$(_context7) {
    while (1) {
      switch (_context7.prev = _context7.next) {
        case 0:
          assetId = params.assetId, maxSupply = params.maxSupply, newIssuer = params.newIssuer, coreExchangeRate = params.coreExchangeRate, whiteList = params.whiteList, transferRestricted = params.transferRestricted, chargeMarketFee = params.chargeMarketFee, description = params.description, bitassetOpts = params.bitassetOpts, _params$onlyGetFee = params.onlyGetFee, onlyGetFee = _params$onlyGetFee === undefined ? false : _params$onlyGetFee;

          if (assetId) {
            _context7.next = 3;
            break;
          }

          return _context7.abrupt('return', { code: 101, message: "Parameter 'assetId' is missing" });

        case 3:
          if (!newIssuer) {
            _context7.next = 10;
            break;
          }

          _context7.next = 6;
          return _regenerator2.default.awrap(_api2.default.Account.getUser(newIssuer, true));

        case 6:
          newIssuer = _context7.sent;

          if (!(newIssuer.code != 1)) {
            _context7.next = 9;
            break;
          }

          return _context7.abrupt('return', newIssuer);

        case 9:
          newIssuer = newIssuer.data.account.id;

        case 10:
          _context7.next = 12;
          return _regenerator2.default.awrap(_api2.default.Assets.fetch_asset_one(assetId));

        case 12:
          u_asset = _context7.sent;

          if (!(u_asset.code != 1)) {
            _context7.next = 15;
            break;
          }

          return _context7.abrupt('return', { code: 162, message: u_asset.message });

        case 15:
          u_asset = u_asset.data;

          isBitAsset = u_asset.bitasset_data_id !== undefined;
          flagBooleans = _asset_utils2.default.getFlagBooleans(0, isBitAsset);
          // console.info("flagBooleans0000",JSON.parse(JSON.stringify(flagBooleans)));

          if (chargeMarketFee) flagBooleans["charge_market_fee"] = true;

          // let permissionBooleans = assetUtils.getFlagBooleans("all",isBitAsset);

          u_asset = _immutable2.default.fromJS(u_asset);

          flagBooleans.witness_fed_asset = false;
          flagBooleans.committee_fed_asset = false;

          if (whiteList != undefined) flagBooleans.white_list = whiteList;
          if (transferRestricted != undefined) flagBooleans.transfer_restricted = transferRestricted;

          // console.info("flagBooleans1111",flagBooleans);
          flags = _asset_utils2.default.getFlags(flagBooleans, isBitAsset);
          // console.info("flags",flags);
          // if(whiteList!=undefined||transferRestricted!=undefined){
          //   if(whiteList!=undefined) flagBooleans.white_list=whiteList;
          //   if(transferRestricted!=undefined) flagBooleans.transfer_restricted=transferRestricted;
          //   // console.info("flagBooleans",flagBooleans,isBitAsset);
          //   flags = assetUtils.getFlags(flagBooleans, isBitAsset);
          // }else{
          //   flags=u_asset.getIn(["options","issuer_permissions"])
          // }

          // let permissions = assetUtils.getPermissions(
          //   permissionBooleans,
          //   isBitAssetisBitAsset
          // );

          _params = {
            issuer: rootGetters["account/getAccountUserId"],
            new_issuer: newIssuer,
            update: {
              symbol: assetId,
              // precision,
              max_supply: u_asset.getIn(["options", "max_supply"]),
              market_fee_percent: Number(u_asset.getIn(["options", "market_fee_percent"])),
              max_market_fee: Number(u_asset.getIn(["options", "max_market_fee"]))
            },
            asset: u_asset,
            flags: flags, //u_asset.getIn(["options","flags"]),
            permissions: u_asset.getIn(["options", "issuer_permissions"]),
            isBitAsset: isBitAsset,
            bitasset_opts: {
              feed_lifetime_sec: 60 * 60 * 24,
              minimum_feeds: 1,
              force_settlement_delay_sec: 60 * 60 * 24,
              force_settlement_offset_percent: 1 * _asset_constants2.default.GRAPHENE_1_PERCENT,
              maximum_force_settlement_volume: 20 * _asset_constants2.default.GRAPHENE_1_PERCENT,
              short_backing_asset: "1.3.0"
            }, //u_asset.get("bitasset_data"),
            original_bitasset_opts: null,
            description: u_asset.getIn(["options", "description"]),
            // auths,
            feedProducers: null,
            originalFeedProducers: null,
            assetChanged: true,
            onlyGetFee: onlyGetFee
          };


          if (u_asset.getIn(["options", "core_exchange_rate"])) {
            _params.core_exchange_rate = u_asset.getIn(["options", "core_exchange_rate"]).toJS();
            // console.info("_params.core_exchange_rate",_params.core_exchange_rate);
            if (coreExchangeRate) {
              //&&u_asset.get("id")=="1.3.1"
              _params.core_exchange_rate.quote.amount = coreExchangeRate.quoteAmount || 1;
              _params.core_exchange_rate.base.amount = coreExchangeRate.baseAmount || 1;
            }
          }

          if (maxSupply) {
            _params.update.max_supply = maxSupply * Math.pow(10, u_asset.get("precision"));
          }

          if (description) {
            _params.description = (0, _stringify2.default)({ main: description, short_name: "", market: "" });
          }

          if (chargeMarketFee) {
            _params.update.market_fee_percent = chargeMarketFee.marketFeePercent || 0;
            _params.update.max_market_fee = chargeMarketFee.maxMarketFee || 0;
          }

          // console.info("u_asset",u_asset);
          bitasset_data_id = u_asset.get("bitasset_data_id");

          if (!(bitasset_data_id && bitassetOpts)) {
            _context7.next = 53;
            break;
          }

          _context7.next = 34;
          return _regenerator2.default.awrap(dispatch("explorer/getDataByIds", { ids: [bitasset_data_id] }, { root: true }));

        case 34:
          bitassetData = _context7.sent;
          ;

          if (!(bitassetData.code != 1)) {
            _context7.next = 38;
            break;
          }

          return _context7.abrupt('return', bitassetData);

        case 38:
          if (!bitassetData.data.length) {
            _context7.next = 53;
            break;
          }

          _bitasset_opts = bitassetData.data[0];
          feedLifetimeSec = bitassetOpts.feedLifetimeSec, minimumFeeds = bitassetOpts.minimumFeeds, forceSettlementDelaySec = bitassetOpts.forceSettlementDelaySec, forceSettlementOffsetPercent = bitassetOpts.forceSettlementOffsetPercent, maximumForceSettlementVolume = bitassetOpts.maximumForceSettlementVolume, shortBackingAsset = bitassetOpts.shortBackingAsset;
          bitasset_options = JSON.parse((0, _stringify2.default)(_bitasset_opts.options));

          if (minimumFeeds) bitasset_options.minimum_feeds = Number(minimumFeeds);
          if (feedLifetimeSec) bitasset_options.feed_lifetime_sec = Number(feedLifetimeSec) * 60;
          if (forceSettlementDelaySec) bitasset_options.force_settlement_delay_sec = Number(forceSettlementDelaySec) * 60;
          if (forceSettlementOffsetPercent) bitasset_options.force_settlement_offset_percent = Number(forceSettlementOffsetPercent) * _asset_constants2.default.GRAPHENE_1_PERCENT;
          if (maximumForceSettlementVolume) bitasset_options.maximum_force_settlement_volume = Number(maximumForceSettlementVolume) * _asset_constants2.default.GRAPHENE_1_PERCENT;
          if (shortBackingAsset) bitasset_options.short_backing_asset = shortBackingAsset;

          minimum_feeds = bitasset_options.minimum_feeds, feed_lifetime_sec = bitasset_options.feed_lifetime_sec, force_settlement_delay_sec = bitasset_options.force_settlement_delay_sec, force_settlement_offset_percent = bitasset_options.force_settlement_offset_percent, maximum_force_settlement_volume = bitasset_options.maximum_force_settlement_volume;

          if (!(isNaN(minimum_feeds) || isNaN(feed_lifetime_sec) || isNaN(force_settlement_delay_sec) || isNaN(force_settlement_offset_percent) || isNaN(maximum_force_settlement_volume))) {
            _context7.next = 51;
            break;
          }

          return _context7.abrupt('return', { code: 135, message: "Please check parameter data type" });

        case 51:
          //  console.info("_params.bitasset_opts",bitasset_options,_bitasset_opts);
          _params.bitasset_opts = bitasset_options;
          _params.original_bitasset_opts = _bitasset_opts.options;

        case 53:
          return _context7.abrupt('return', dispatch("updateAsset", _params));

        case 54:
        case 'end':
          return _context7.stop();
      }
    }
  }, null, undefined);
};

var assetClaimFees = exports.assetClaimFees = function _callee8(_ref11, _ref12) {
  var commit = _ref11.commit,
      dispatch = _ref11.dispatch;
  var assetId = _ref12.assetId,
      amount = _ref12.amount,
      account = _ref12.account,
      _ref12$onlyGetFee = _ref12.onlyGetFee,
      onlyGetFee = _ref12$onlyGetFee === undefined ? false : _ref12$onlyGetFee;

  var asset, _asset$data, id, precision, amount_res;

  return _regenerator2.default.async(function _callee8$(_context8) {
    while (1) {
      switch (_context8.prev = _context8.next) {
        case 0:
          _context8.next = 2;
          return _regenerator2.default.awrap(_api2.default.Assets.fetch_asset_one(assetId));

        case 2:
          asset = _context8.sent;

          if (!(asset.code !== 1)) {
            _context8.next = 5;
            break;
          }

          return _context8.abrupt('return', asset);

        case 5:
          _asset$data = asset.data, id = _asset$data.id, precision = _asset$data.precision;
          _context8.next = 8;
          return _regenerator2.default.awrap(_helper2.default.toOpAmount(amount, asset.data));

        case 8:
          amount_res = _context8.sent;

          if (amount_res.success) {
            _context8.next = 11;
            break;
          }

          return _context8.abrupt('return', amount_res);

        case 11:
          return _context8.abrupt('return', dispatch('transactions/_transactionOperations', {
            operations: [{
              op_type: 31,
              type: "asset_claim_fees",
              params: {
                issuer: account.id,
                amount_to_claim: amount_res.data
              }
            }],
            onlyGetFee: onlyGetFee
          }, { root: true }));

        case 12:
        case 'end':
          return _context8.stop();
      }
    }
  }, null, undefined);
};

/********Capital injection fee pool START*/
var assetFundFeePool = exports.assetFundFeePool = function _callee9(_ref13, _ref14) {
  var commit = _ref13.commit,
      dispatch = _ref13.dispatch;
  var assetId = _ref14.assetId,
      amount = _ref14.amount,
      account = _ref14.account,
      _ref14$onlyGetFee = _ref14.onlyGetFee,
      onlyGetFee = _ref14$onlyGetFee === undefined ? false : _ref14$onlyGetFee;
  var asset, core_asset, amount_res;
  return _regenerator2.default.async(function _callee9$(_context9) {
    while (1) {
      switch (_context9.prev = _context9.next) {
        case 0:
          _context9.next = 2;
          return _regenerator2.default.awrap(_api2.default.Assets.fetch_asset_one(assetId));

        case 2:
          asset = _context9.sent;

          if (!(asset.code !== 1)) {
            _context9.next = 5;
            break;
          }

          return _context9.abrupt('return', asset);

        case 5:
          _context9.next = 7;
          return _regenerator2.default.awrap(_api2.default.Assets.fetch_asset_one("1.3.0"));

        case 7:
          core_asset = _context9.sent;

          if (!(core_asset.code !== 1)) {
            _context9.next = 10;
            break;
          }

          return _context9.abrupt('return', core_asset);

        case 10:
          _context9.next = 12;
          return _regenerator2.default.awrap(_helper2.default.toOpAmount(amount, core_asset.data));

        case 12:
          amount_res = _context9.sent;

          if (amount_res.success) {
            _context9.next = 15;
            break;
          }

          return _context9.abrupt('return', amount_res);

        case 15:
          return _context9.abrupt('return', dispatch('transactions/_transactionOperations', {
            operations: [{
              op_type: 15,
              type: "asset_fund_fee_pool",
              params: {
                asset_id: asset.data.id,
                amount: amount_res.data.amount,
                from_account: account.id
              }
            }],
            onlyGetFee: onlyGetFee
          }, { root: true }));

        case 16:
        case 'end':
          return _context9.stop();
      }
    }
  }, null, undefined);
};
/********Capital injection fee pool END*/

var reserveAsset = exports.reserveAsset = function _callee10(_ref15, _ref16) {
  var commit = _ref15.commit,
      dispatch = _ref15.dispatch;
  var assetId = _ref16.assetId,
      amount = _ref16.amount,
      account = _ref16.account,
      _ref16$onlyGetFee = _ref16.onlyGetFee,
      onlyGetFee = _ref16$onlyGetFee === undefined ? false : _ref16$onlyGetFee;
  var asset, amount_res;
  return _regenerator2.default.async(function _callee10$(_context10) {
    while (1) {
      switch (_context10.prev = _context10.next) {
        case 0:
          _context10.next = 2;
          return _regenerator2.default.awrap(_api2.default.Assets.fetch_asset_one(assetId));

        case 2:
          asset = _context10.sent;

          if (!(asset.code !== 1)) {
            _context10.next = 5;
            break;
          }

          return _context10.abrupt('return', asset);

        case 5:
          _context10.next = 7;
          return _regenerator2.default.awrap(_helper2.default.toOpAmount(amount, asset.data));

        case 7:
          amount_res = _context10.sent;

          if (amount_res.success) {
            _context10.next = 10;
            break;
          }

          return _context10.abrupt('return', amount_res);

        case 10:
          return _context10.abrupt('return', dispatch('transactions/_transactionOperations', {
            operations: [{
              op_type: 14,
              type: "asset_reserve",
              params: {
                amount_to_reserve: amount_res.data,
                payer: account.id,
                extensions: []
              }
            }],
            onlyGetFee: onlyGetFee
          }, { root: true }));

        case 11:
        case 'end':
          return _context10.stop();
      }
    }
  }, null, undefined);
};

var createAsset = exports.createAsset = function _callee11(_ref17, _ref18) {
  var commit = _ref17.commit,
      dispatch = _ref17.dispatch;
  var account_id = _ref18.account_id,
      createObject = _ref18.createObject,
      flags = _ref18.flags,
      permissions = _ref18.permissions,
      cer = _ref18.cer,
      isBitAsset = _ref18.isBitAsset,
      bitasset_opts = _ref18.bitasset_opts,
      description = _ref18.description;
  var precision, max_supply, max_market_fee, coreAsset, corePrecision, operationJSON;
  return _regenerator2.default.async(function _callee11$(_context11) {
    while (1) {
      switch (_context11.prev = _context11.next) {
        case 0:
          // Create asset action here...
          //  console.log(
          //   "create asset:",
          //   createObject,
          //   "flags:",
          //    flags,
          //   "isBitAsset:",
          //   isBitAsset,
          //   "bitasset_opts:",
          //   bitasset_opts
          // );
          precision = _utils3.default.get_asset_precision(createObject.precision);


          _bignumber2.default.config({ DECIMAL_PLACES: Number(createObject.precision) });
          max_supply = new _bignumber2.default(createObject.max_supply).times(precision).toString();
          max_market_fee = new _bignumber2.default(createObject.max_market_fee || 0).times(precision).toString();
          // console.log("max_supply:", max_supply);
          // console.log("max_market_fee:", max_market_fee);

          _context11.next = 6;
          return _regenerator2.default.awrap(dispatch("assets/fetchAssets", { assets: ["1.3.0"], isOne: true }, { root: true }));

        case 6:
          coreAsset = _context11.sent;
          corePrecision = _utils3.default.get_asset_precision(coreAsset.precision);

          // if(cer.base.amount>1000|| cer.quote.amount>1000){
          //   return {code:171,message:"The amount of fee exchange rate assets should not exceed 1000"}
          // }
          // if(helper.getDecimals(cer.base.amount)>8||helper.getDecimals(cer.quote.amount)>8){
          //   return {code:172,message:"precision overflow of fee exchange rate assets"}
          // }

          operationJSON = {
            fee: {
              amount: 0,
              asset_id: 0
            },
            issuer: account_id,
            symbol: createObject.symbol,
            precision: parseInt(createObject.precision, 10),
            common_options: {
              max_supply: max_supply,
              market_fee_percent: createObject.market_fee_percent * 100 || 0,
              max_market_fee: max_market_fee,
              issuer_permissions: permissions,
              flags: flags,
              description: description,
              extensions: null
            },
            extensions: null
          };


          if (isBitAsset) {
            operationJSON.bitasset_opts = bitasset_opts;
          }

          return _context11.abrupt('return', dispatch('transactions/_transactionOperations', {
            operations: [{
              op_type: 8,
              type: "asset_create",
              params: operationJSON
            }]
          }, { root: true }));

        case 11:
        case 'end':
          return _context11.stop();
      }
    }
  }, null, undefined);
};

var _createAsset = exports._createAsset = function _callee12(_ref19, params) {
  var dispatch = _ref19.dispatch,
      rootGetters = _ref19.rootGetters;

  var _params$isBitAsset, isBitAsset, assetId, _params$maxSupply, maxSupply, _params$precision, precision, coreExchangeRate, chargeMarketFee, description, bitassetOpts, c_asset, flagBooleans, permissionBooleans, flags, permissions, _params, _bitassetOpts$feedLif, feedLifetimeSec, _bitassetOpts$minimum, minimumFeeds, _bitassetOpts$forceSe, forceSettlementDelaySec, _bitassetOpts$forceSe2, forceSettlementOffsetPercent, _bitassetOpts$maximum, maximumForceSettlementVolume, _bitassetOpts$shortBa, shortBackingAsset;

  return _regenerator2.default.async(function _callee12$(_context12) {
    while (1) {
      switch (_context12.prev = _context12.next) {
        case 0:
          if (_helper2.default.trimParams(params, { description: "" })) {
            _context12.next = 2;
            break;
          }

          return _context12.abrupt('return', { code: 101, message: "Parameter is missing" });

        case 2:
          _params$isBitAsset = params.isBitAsset, isBitAsset = _params$isBitAsset === undefined ? false : _params$isBitAsset, assetId = params.assetId, _params$maxSupply = params.maxSupply, maxSupply = _params$maxSupply === undefined ? 100000 : _params$maxSupply, _params$precision = params.precision, precision = _params$precision === undefined ? 5 : _params$precision, coreExchangeRate = params.coreExchangeRate, chargeMarketFee = params.chargeMarketFee, description = params.description, bitassetOpts = params.bitassetOpts;
          _context12.next = 5;
          return _regenerator2.default.awrap(dispatch("assets/fetchAssets", { assets: [assetId], isOne: true }, { root: true }));

        case 5:
          c_asset = _context12.sent;

          if (!c_asset) {
            _context12.next = 8;
            break;
          }

          return _context12.abrupt('return', { code: 162, message: "The asset already exists" });

        case 8:
          flagBooleans = _asset_utils2.default.getFlagBooleans(0, isBitAsset);

          flagBooleans["charge_market_fee"] = chargeMarketFee;

          permissionBooleans = _asset_utils2.default.getFlagBooleans("all", isBitAsset);
          flags = _asset_utils2.default.getFlags(flagBooleans, isBitAsset);
          permissions = _asset_utils2.default.getPermissions(permissionBooleans, isBitAsset);
          _params = {
            account_id: rootGetters["account/getAccountUserId"],
            createObject: {
              symbol: assetId,
              precision: precision,
              max_supply: maxSupply,
              market_fee_percent: 0,
              max_market_fee: 0
            },
            flags: flags,
            permissions: permissions,
            // cer: {
            //   quote: {
            //     asset_id: "1.3.0",
            //     amount: 1
            //   },
            //   base: {
            //       asset_id:null,
            //       amount: 1
            //   }
            // },
            isBitAsset: isBitAsset,
            bitasset_opts: {
              feed_lifetime_sec: 60 * 60 * 24,
              minimum_feeds: 1,
              force_settlement_delay_sec: 60 * 60 * 24,
              force_settlement_offset_percent: 1 * _asset_constants2.default.GRAPHENE_1_PERCENT,
              maximum_force_settlement_volume: 20 * _asset_constants2.default.GRAPHENE_1_PERCENT,
              short_backing_asset: "1.3.0"
            },
            description: (0, _stringify2.default)({ main: description, short_name: "", market: "" })
            // if(coreExchangeRate){
            //   _params.cer.quote.amount=coreExchangeRate.quoteAmount||1;
            //   _params.cer.base.amount=coreExchangeRate.baseAmount||1;
            // }

          };
          if (chargeMarketFee) {
            _params.createObject.market_fee_percent = chargeMarketFee.marketFeePercent || 0;
            _params.createObject.max_market_fee = chargeMarketFee.maxMarketFee || 0;
          }

          if (!(bitassetOpts && isBitAsset)) {
            _context12.next = 20;
            break;
          }

          _bitassetOpts$feedLif = bitassetOpts.feedLifetimeSec, feedLifetimeSec = _bitassetOpts$feedLif === undefined ? 60 * 60 * 24 : _bitassetOpts$feedLif, _bitassetOpts$minimum = bitassetOpts.minimumFeeds, minimumFeeds = _bitassetOpts$minimum === undefined ? 1 : _bitassetOpts$minimum, _bitassetOpts$forceSe = bitassetOpts.forceSettlementDelaySec, forceSettlementDelaySec = _bitassetOpts$forceSe === undefined ? 60 * 60 * 24 : _bitassetOpts$forceSe, _bitassetOpts$forceSe2 = bitassetOpts.forceSettlementOffsetPercent, forceSettlementOffsetPercent = _bitassetOpts$forceSe2 === undefined ? 1 * _asset_constants2.default.GRAPHENE_1_PERCENT : _bitassetOpts$forceSe2, _bitassetOpts$maximum = bitassetOpts.maximumForceSettlementVolume, maximumForceSettlementVolume = _bitassetOpts$maximum === undefined ? 20 * _asset_constants2.default.GRAPHENE_1_PERCENT : _bitassetOpts$maximum, _bitassetOpts$shortBa = bitassetOpts.shortBackingAsset, shortBackingAsset = _bitassetOpts$shortBa === undefined ? "1.3.0" : _bitassetOpts$shortBa;

          if (!(!feedLifetimeSec || !minimumFeeds || !forceSettlementDelaySec || !forceSettlementOffsetPercent || !maximumForceSettlementVolume || !shortBackingAsset)) {
            _context12.next = 19;
            break;
          }

          return _context12.abrupt('return', { code: 101, message: "Parameter is missing" });

        case 19:
          _params.bitasset_opts = {
            feed_lifetime_sec: feedLifetimeSec,
            minimum_feeds: minimumFeeds,
            force_settlement_delay_sec: forceSettlementDelaySec,
            force_settlement_offset_percent: forceSettlementOffsetPercent * _asset_constants2.default.GRAPHENE_1_PERCENT,
            maximum_force_settlement_volume: maximumForceSettlementVolume * _asset_constants2.default.GRAPHENE_1_PERCENT,
            short_backing_asset: shortBackingAsset
          };

        case 20:
          return _context12.abrupt('return', dispatch("createAsset", _params));

        case 21:
        case 'end':
          return _context12.stop();
      }
    }
  }, null, undefined);
};

var issueAsset = exports.issueAsset = function issueAsset(_ref20, params) {
  var dispatch = _ref20.dispatch;

  if (!_helper2.default.trimParams(params, { memo: "" })) {
    return { code: 101, message: "Parameter is missing" };
  }
  var toAccount = params.toAccount,
      amount = params.amount,
      memo = params.memo,
      _params$assetId = params.assetId,
      assetId = _params$assetId === undefined ? "" : _params$assetId,
      _params$isEncryption = params.isEncryption,
      isEncryption = _params$isEncryption === undefined ? true : _params$isEncryption;

  assetId = assetId.toUpperCase();
  return dispatch('transactions/_transactionOperations', {
    operations: [{
      op_type: 13,
      type: "asset_issue",
      params: {
        to: toAccount,
        amount: amount,
        asset_id: assetId,
        memo: memo,
        isEncryption: isEncryption
      }
    }]
  }, { root: true });
};

var assetUpdateRestricted = exports.assetUpdateRestricted = function _callee14(_ref21, params) {
  var dispatch = _ref21.dispatch,
      rootGetters = _ref21.rootGetters;

  var _params$assetId2, assetId, _params$isadd, isadd, _params$restrictedTyp, restrictedType, _params$restrictedLis, restrictedList, _params$onlyGetFee2, onlyGetFee, asset_res;

  return _regenerator2.default.async(function _callee14$(_context14) {
    while (1) {
      switch (_context14.prev = _context14.next) {
        case 0:
          if (_helper2.default.trimParams(params, { memo: "" })) {
            _context14.next = 2;
            break;
          }

          return _context14.abrupt('return', { code: 101, message: "Parameter is missing" });

        case 2:
          _params$assetId2 = params.assetId, assetId = _params$assetId2 === undefined ? "1.3.0" : _params$assetId2, _params$isadd = params.isadd, isadd = _params$isadd === undefined ? true : _params$isadd, _params$restrictedTyp = params.restrictedType, restrictedType = _params$restrictedTyp === undefined ? 0 : _params$restrictedTyp, _params$restrictedLis = params.restrictedList, restrictedList = _params$restrictedLis === undefined ? [] : _params$restrictedLis, _params$onlyGetFee2 = params.onlyGetFee, onlyGetFee = _params$onlyGetFee2 === undefined ? false : _params$onlyGetFee2;

          restrictedType = Number(restrictedType);

          if (!isNaN(restrictedType)) {
            _context14.next = 6;
            break;
          }

          return _context14.abrupt('return', { code: 173, message: "restrictedType must be a number" });

        case 6:
          if (Array.isArray(restrictedList)) {
            _context14.next = 8;
            break;
          }

          return _context14.abrupt('return', { code: 174, message: "restricted_list must be a array" });

        case 8:

          assetId = assetId.toUpperCase();
          _context14.next = 11;
          return _regenerator2.default.awrap(_api2.default.Assets.fetch_asset_one(assetId));

        case 11:
          asset_res = _context14.sent;

          if (!(asset_res.code !== 1)) {
            _context14.next = 14;
            break;
          }

          return _context14.abrupt('return', asset_res);

        case 14:
          _context14.next = 16;
          return _regenerator2.default.awrap(_promise2.default.all(restrictedList.map(function _callee13(id) {
            var acc_res, _asset_res;

            return _regenerator2.default.async(function _callee13$(_context13) {
              while (1) {
                switch (_context13.prev = _context13.next) {
                  case 0:
                    if (!(restrictedType == 1 || restrictedType == 2)) {
                      _context13.next = 10;
                      break;
                    }

                    if (!/^1.2.\d+$/.test(id)) {
                      _context13.next = 3;
                      break;
                    }

                    return _context13.abrupt('return', id);

                  case 3:
                    _context13.next = 5;
                    return _regenerator2.default.awrap(_api2.default.Account.getUser(id, true));

                  case 5:
                    acc_res = _context13.sent;

                    if (!(acc_res.code == 1)) {
                      _context13.next = 8;
                      break;
                    }

                    return _context13.abrupt('return', acc_res.data.account.id);

                  case 8:
                    _context13.next = 18;
                    break;

                  case 10:
                    if (!(restrictedType == 3 || restrictedType == 4)) {
                      _context13.next = 18;
                      break;
                    }

                    if (!/^1.3.\d+$/.test(id)) {
                      _context13.next = 13;
                      break;
                    }

                    return _context13.abrupt('return', id);

                  case 13:
                    _context13.next = 15;
                    return _regenerator2.default.awrap(_api2.default.Assets.fetch_asset_one(id));

                  case 15:
                    _asset_res = _context13.sent;

                    if (!(_asset_res.code == 1)) {
                      _context13.next = 18;
                      break;
                    }

                    return _context13.abrupt('return', _asset_res.data.id);

                  case 18:
                    return _context13.abrupt('return', "");

                  case 19:
                  case 'end':
                    return _context13.stop();
                }
              }
            }, null, undefined);
          })));

        case 16:
          restrictedList = _context14.sent;

          restrictedList = restrictedList.filter(function (id) {
            return id != "";
          });

          if (restrictedList.length) {
            _context14.next = 20;
            break;
          }

          return _context14.abrupt('return', { code: 175, message: "Please check the parameter restrictedList" });

        case 20:
          return _context14.abrupt('return', dispatch('transactions/_transactionOperations', {
            operations: [{
              op_type: 10,
              type: "asset_update_restricted",
              params: {
                payer: rootGetters['account/getAccountUserId'],
                target_asset: asset_res.data.id,
                isadd: !!isadd,
                restricted_type: restrictedType,
                restricted_list: restrictedList,
                extensions: []
              }
            }],
            onlyGetFee: onlyGetFee
          }, { root: true }));

        case 21:
        case 'end':
          return _context14.stop();
      }
    }
  }, null, undefined);
};

var queryAssets = exports.queryAssets = function _callee15(_ref22, _ref23) {
  var dispatch = _ref22.dispatch,
      state = _ref22.state,
      commit = _ref22.commit;
  var _ref23$symbol = _ref23.symbol,
      symbol = _ref23$symbol === undefined ? "" : _ref23$symbol,
      _ref23$assetId = _ref23.assetId,
      assetId = _ref23$assetId === undefined ? "" : _ref23$assetId,
      _ref23$simple = _ref23.simple,
      simple = _ref23$simple === undefined ? false : _ref23$simple;
  var assets, lastAsset, symbolRes, r_assets;
  return _regenerator2.default.async(function _callee15$(_context15) {
    while (1) {
      switch (_context15.prev = _context15.next) {
        case 0:
          assets = state.assets;
          lastAsset = assets.sort(function (a, b) {
            if (a.symbol > b.symbol) {
              return 1;
            } else if (a.symbol < b.symbol) {
              return -1;
            } else {
              return 0;
            }
          }).last();


          symbol = symbol || assetId;

          if (!symbol) {
            _context15.next = 15;
            break;
          }

          symbol = symbol.trim();
          _context15.next = 7;
          return _regenerator2.default.awrap(_api2.default.Assets.fetch_asset_one(symbol));

        case 7:
          symbolRes = _context15.sent;

          if (!(symbolRes.code != 1)) {
            _context15.next = 10;
            break;
          }

          return _context15.abrupt('return', symbolRes);

        case 10:
          _context15.next = 12;
          return _regenerator2.default.awrap(dispatch("onGetAssetList", { start: symbolRes.data.symbol, count: 1 }));

        case 12:
          state.assetsFetched = state.assetsFetched + 99;
          _context15.next = 25;
          break;

        case 15:
          if (!(assets.size === 0)) {
            _context15.next = 21;
            break;
          }

          _context15.next = 18;
          return _regenerator2.default.awrap(dispatch("onGetAssetList", { start: "A", count: 100 }));

        case 18:
          state.assetsFetched = 100;
          _context15.next = 25;
          break;

        case 21:
          if (!(assets.size >= state.assetsFetched)) {
            _context15.next = 25;
            break;
          }

          _context15.next = 24;
          return _regenerator2.default.awrap(dispatch("onGetAssetList", { start: lastAsset.symbol, count: 100 }));

        case 24:
          state.assetsFetched = state.assetsFetched + 99;

        case 25:

          if (assets.size > state.totalAssets) {
            accountStorage.set("totalAssets", assets.size);
          }

          if (!(state.assetsFetched >= state.totalAssets - 100)) {
            _context15.next = 28;
            break;
          }

          return _context15.abrupt('return', { code: 1, data: state.assets.toJS() });

        case 28:
          if (!(assets.size < state.assetsFetched)) {
            _context15.next = 39;
            break;
          }

          _context15.next = 31;
          return _regenerator2.default.awrap(dispatch("formatAssets", {
            assets: state.assets_arr,
            simple: simple
          }));

        case 31:
          r_assets = _context15.sent;


          commit(types.FETCH_ASSETS_COMPLETE, { assets: (0, _utils.arrayToObject)(r_assets) });

          state.assetsFetched = 0;
          state.assets_arr = [];
          state.assets = _immutable2.default.fromJS([]);
          return _context15.abrupt('return', { code: 1, data: r_assets });

        case 39:
          dispatch("queryAssets", { symbol: "" });

        case 40:
        case 'end':
          return _context15.stop();
      }
    }
  }, null, undefined);
};

var formatAssets = exports.formatAssets = function _callee16(_ref24, _ref25) {
  var dispatch = _ref24.dispatch;
  var assets = _ref25.assets,
      _ref25$simple = _ref25.simple,
      simple = _ref25$simple === undefined ? false : _ref25$simple;

  var r_assets, issuer_res, i, _assets$i, issuer, dynamic, precision, id, symbol, options, bitasset_data_id, dynamic_asset_data_id, core_exchange_rate, description, market_fee_percent, max_market_fee, max_supply, flags, issuer_permissions, whitelist_authorities, whitelist_markets, blacklist_authorities, blacklist_markets, base, quote, base_asset, quote_asset, bitasset_data, _bitasset_data$curren, _base, _quote, _base_asset, _quote_asset, asset_item, permissionBooleans;

  return _regenerator2.default.async(function _callee16$(_context16) {
    while (1) {
      switch (_context16.prev = _context16.next) {
        case 0:
          r_assets = [];
          issuer_res = void 0;

          assets = assets.sort(function (a, b) {
            a = a.id.split(".")[2];
            b = b.id.split(".")[2];
            if (a > b) {
              return 1;
            } else if (a < b) {
              return -1;
            } else {
              return 0;
            }
          });
          i = 0;

        case 4:
          if (!(i < assets.length)) {
            _context16.next = 41;
            break;
          }

          _assets$i = assets[i], issuer = _assets$i.issuer, dynamic = _assets$i.dynamic, precision = _assets$i.precision, id = _assets$i.id, symbol = _assets$i.symbol, options = _assets$i.options, bitasset_data_id = _assets$i.bitasset_data_id, dynamic_asset_data_id = _assets$i.dynamic_asset_data_id;
          core_exchange_rate = options.core_exchange_rate, description = options.description, market_fee_percent = options.market_fee_percent, max_market_fee = options.max_market_fee, max_supply = options.max_supply, flags = options.flags, issuer_permissions = options.issuer_permissions, whitelist_authorities = options.whitelist_authorities, whitelist_markets = options.whitelist_markets, blacklist_authorities = options.blacklist_authorities, blacklist_markets = options.blacklist_markets;
          _context16.next = 9;
          return _regenerator2.default.awrap(dispatch("user/getUserInfo", { account: issuer, isCache: true }, { root: true }));

        case 9:
          issuer_res = _context16.sent;

          if (!core_exchange_rate) {
            _context16.next = 19;
            break;
          }

          base = core_exchange_rate.base, quote = core_exchange_rate.quote;
          _context16.next = 14;
          return _regenerator2.default.awrap(_api2.default.Assets.fetch_asset_one(base.asset_id));

        case 14:
          base_asset = _context16.sent.data;
          _context16.next = 17;
          return _regenerator2.default.awrap(_api2.default.Assets.fetch_asset_one(quote.asset_id));

        case 17:
          quote_asset = _context16.sent.data;


          core_exchange_rate.text = (_helper2.default.formatAmount(quote.amount, quote_asset.precision) || 1) / _helper2.default.formatAmount(base.amount, base_asset.precision) + " " + quote_asset.symbol + "/" + base_asset.symbol;

        case 19:
          bitasset_data = assets[i].bitasset_data;
          // console.info("bitasset_data",bitasset_data);

          if (!bitasset_data) {
            _context16.next = 30;
            break;
          }

          _bitasset_data$curren = bitasset_data.current_feed.settlement_price, _base = _bitasset_data$curren.base, _quote = _bitasset_data$curren.quote;
          _context16.next = 24;
          return _regenerator2.default.awrap(_api2.default.Assets.fetch_asset_one(_base.asset_id));

        case 24:
          _base_asset = _context16.sent.data;
          _context16.next = 27;
          return _regenerator2.default.awrap(_api2.default.Assets.fetch_asset_one(_quote.asset_id));

        case 27:
          _quote_asset = _context16.sent.data;


          assets[i].bitasset_data.format_feed_price = _utils3.default.format_price(bitasset_data.current_feed.settlement_price.quote.amount, _quote_asset, bitasset_data.current_feed.settlement_price.base.amount, _base_asset, true, true, false);
          assets[i].bitasset_data.format_feed_price_text = _utils3.default.format_price(bitasset_data.current_feed.settlement_price.quote.amount, _quote_asset, bitasset_data.current_feed.settlement_price.base.amount, _base_asset, false, true, false);

        case 30:
          asset_item = void 0;

          _bcxjsCores.ChainStore.getAsset(id);
          _bcxjsCores.ChainStore.getObject(dynamic_asset_data_id);

          flags = _asset_utils2.default.getFlagBooleans(flags, !!bitasset_data_id //whether it's a smart asset
          );
          if (simple) {
            asset_item = {
              id: id,
              dynamic_asset_data_id: dynamic_asset_data_id,
              issuer: issuer,
              issuer_name: issuer_res.code == 1 && issuer_res.data ? issuer_res.data.account.name : "",
              precision: precision,
              symbol: symbol,
              dynamic: {
                current_supply: _helper2.default.formatAmount(dynamic.current_supply, precision),
                accumulated_fees: _helper2.default.formatAmount(dynamic.accumulated_fees, precision)
              },
              options: {
                core_exchange_rate: core_exchange_rate,
                flags: flags,
                // flags:{
                //   transfer_restricted:flags.transfer_restricted,
                //   white_list:flags.white_list
                // },
                max_supply: _helper2.default.formatAmount(max_supply, precision)
              }
            };
          } else {
            //  console.info('assets[i]',assets[i]);
            permissionBooleans = _asset_utils2.default.getFlagBooleans(issuer_permissions, !!bitasset_data_id //whether it's a smart asset
            );
            // console.info('permissionBooleans',permissionBooleans);

            asset_item = {
              bitasset_data: assets[i].bitasset_data,
              bitasset_data_id: bitasset_data_id,
              dynamic_asset_data_id: dynamic_asset_data_id,
              dynamic: {
                current_supply: _helper2.default.formatAmount(dynamic.current_supply, precision),
                accumulated_fees: _helper2.default.formatAmount(dynamic.accumulated_fees, precision)
              },
              id: id,
              issuer: issuer,
              issuer_name: issuer_res.data.account.name,
              options: {
                description: "",
                flags: flags,
                permissionBooleans: permissionBooleans,
                market_fee_percent: market_fee_percent / 100,
                max_market_fee: _helper2.default.formatAmount(max_market_fee, precision),
                max_supply: _helper2.default.formatAmount(max_supply, precision)
              },
              precision: precision,
              symbol: symbol
              //charge_market_fee
            };
          }
          if (core_exchange_rate) {
            asset_item.options.core_exchange_rate = core_exchange_rate;
          }
          try {
            if (description) asset_item.description = JSON.parse(description).main;
          } catch (e) {}

          r_assets.push(asset_item);

        case 38:
          i++;
          _context16.next = 4;
          break;

        case 41:
          return _context16.abrupt('return', JSON.parse((0, _stringify2.default)(r_assets)));

        case 42:
        case 'end':
          return _context16.stop();
      }
    }
  }, null, undefined);
};

var onGetAssetList = exports.onGetAssetList = function _callee17(_ref26, _ref27) {
  var dispatch = _ref26.dispatch,
      state = _ref26.state;
  var start = _ref27.start,
      count = _ref27.count;
  var payload;
  return _regenerator2.default.async(function _callee17$(_context17) {
    while (1) {
      switch (_context17.prev = _context17.next) {
        case 0:
          _context17.next = 2;
          return _regenerator2.default.awrap(_api2.default.Assets.getAssetList(start, count));

        case 2:
          payload = _context17.sent;

          if (payload) {
            _context17.next = 5;
            break;
          }

          return _context17.abrupt('return', false);

        case 5:
          // this.assetsLoading = payload.loading;
          if (payload.assets) {
            payload.assets.forEach(function (asset) {
              for (var i = 0; i < payload.dynamic.length; i++) {
                if (payload.dynamic[i].id === asset.dynamic_asset_data_id) {
                  asset.dynamic = payload.dynamic[i];
                  break;
                }
              }

              if (asset.bitasset_data_id) {
                asset.market_asset = true;

                for (var i = 0; i < payload.bitasset_data.length; i++) {
                  if (payload.bitasset_data[i].id === asset.bitasset_data_id) {
                    asset.bitasset_data = payload.bitasset_data[i];
                    break;
                  }
                }
              } else {
                asset.market_asset = false;
              }

              state.assets = state.assets.set(asset.id, asset);
              state.assets_arr.push(asset);
              state.asset_symbol_to_id[asset.symbol] = asset.id;
            });
          }

        case 6:
        case 'end':
          return _context17.stop();
      }
    }
  }, null, undefined);
};

var queryAssetRestricted = exports.queryAssetRestricted = function _callee19(_ref28, _ref29) {
  var dispatch = _ref28.dispatch;
  var assetId = _ref29.assetId,
      restrictedType = _ref29.restrictedType;
  var asset_res, res;
  return _regenerator2.default.async(function _callee19$(_context19) {
    while (1) {
      switch (_context19.prev = _context19.next) {
        case 0:
          assetId = assetId.toUpperCase();
          _context19.next = 3;
          return _regenerator2.default.awrap(_api2.default.Assets.fetch_asset_one(assetId));

        case 3:
          asset_res = _context19.sent;

          if (!(asset_res.code !== 1)) {
            _context19.next = 6;
            break;
          }

          return _context19.abrupt('return', asset_res);

        case 6:
          _context19.next = 8;
          return _regenerator2.default.awrap(_api2.default.Assets.list_asset_restricted_objects(asset_res.data.id, restrictedType));

        case 8:
          res = _context19.sent;

          if (!(res.code == 1)) {
            _context19.next = 13;
            break;
          }

          _context19.next = 12;
          return _regenerator2.default.awrap(_promise2.default.all(res.data.map(function _callee18(item) {
            var r_id, _data$account, _id, name, _data, _id2, _symbol;

            return _regenerator2.default.async(function _callee18$(_context18) {
              while (1) {
                switch (_context18.prev = _context18.next) {
                  case 0:
                    // item.symbol=asset_res.data.symbol;
                    r_id = item.restricted_id;

                    if (!/^1.2.\d+$/.test(r_id)) {
                      _context18.next = 11;
                      break;
                    }

                    _context18.next = 4;
                    return _regenerator2.default.awrap(_api2.default.Account.getAccount(r_id));

                  case 4:
                    _data$account = _context18.sent.data.account;
                    _id = _data$account.id;
                    name = _data$account.name;

                    item.restricted_account_id = _id;
                    item.restricted_account_name = name;
                    _context18.next = 19;
                    break;

                  case 11:
                    if (!/^1.3.\d+/.test(r_id)) {
                      _context18.next = 19;
                      break;
                    }

                    _context18.next = 14;
                    return _regenerator2.default.awrap(_api2.default.Assets.fetch_asset_one(r_id));

                  case 14:
                    _data = _context18.sent.data;
                    _id2 = _data.id;
                    _symbol = _data.symbol;

                    item.restricted_asset_id = _id2;
                    item.restricted_asset_symbol = _symbol;

                  case 19:
                    return _context18.abrupt('return', item);

                  case 20:
                  case 'end':
                    return _context18.stop();
                }
              }
            }, null, undefined);
          })));

        case 12:
          res.data = _context19.sent;

        case 13:
          return _context19.abrupt('return', res);

        case 14:
        case 'end':
          return _context19.stop();
      }
    }
  }, null, undefined);
};

var assetPublishFeed = exports.assetPublishFeed = function _callee20(_ref30, params) {
  var dispatch = _ref30.dispatch,
      rootGetters = _ref30.rootGetters;

  var assetId, price, maintenanceCollateralRatio, maximumShortSqueezeRatio, coreExchangeRate, onlyGetFee, asset_res, _asset_res$data, id, precision, options, price_feed;

  return _regenerator2.default.async(function _callee20$(_context20) {
    while (1) {
      switch (_context20.prev = _context20.next) {
        case 0:
          if (_helper2.default.trimParams(params)) {
            _context20.next = 2;
            break;
          }

          return _context20.abrupt('return', { code: 101, message: "Parameter is missing" });

        case 2:
          assetId = params.assetId, price = params.price, maintenanceCollateralRatio = params.maintenanceCollateralRatio, maximumShortSqueezeRatio = params.maximumShortSqueezeRatio, coreExchangeRate = params.coreExchangeRate, onlyGetFee = params.onlyGetFee;


          assetId = assetId.toUpperCase();
          _context20.next = 6;
          return _regenerator2.default.awrap(_api2.default.Assets.fetch_asset_one(assetId));

        case 6:
          asset_res = _context20.sent;

          if (!(asset_res.code !== 1)) {
            _context20.next = 9;
            break;
          }

          return _context20.abrupt('return', asset_res);

        case 9:
          _asset_res$data = asset_res.data, id = _asset_res$data.id, precision = _asset_res$data.precision, options = _asset_res$data.options;

          // let core_exchange_rate=options.core_exchange_rate;
          // if(coreExchangeRate.baseAmount){
          //   let cr_base_asset =(await API.Assets.fetch([core_exchange_rate.base.asset_id]))[0]
          //   let cr_base_precision = utils.get_asset_precision(
          //       cr_base_asset.precision
          //   );
          //   core_exchange_rate.base.amount = new big(coreExchangeRate.baseAmount)
          //   .times(cr_base_precision)
          //   .toString();

          // } 
          // if(coreExchangeRate.quoteAmount){
          //   let cr_quote_asset =(await API.Assets.fetch([core_exchange_rate.quote.asset_id]))[0];
          //   let cr_quote_precision = utils.get_asset_precision(
          //       cr_quote_asset.precision
          //   );
          //   core_exchange_rate.quote.amount=new big(coreExchangeRate.quoteAmount)
          //   .times(cr_quote_precision)
          //   .toString();
          // } 

          _context20.t0 = {
            amount: _helper2.default.getFullNum(1 * Math.pow(10, precision)),
            asset_id: id
          };
          _context20.next = 13;
          return _regenerator2.default.awrap(_helper2.default.toOpAmount(price, "1.3.0"));

        case 13:
          _context20.t1 = _context20.sent.data;
          _context20.t2 = {
            base: _context20.t0,
            quote: _context20.t1
          };
          _context20.t3 = Number((maintenanceCollateralRatio * 1000).toFixed(0));
          _context20.t4 = Number((maximumShortSqueezeRatio * 1000).toFixed(0));
          price_feed = {
            settlement_price: _context20.t2,
            maintenance_collateral_ratio: _context20.t3,
            maximum_short_squeeze_ratio: _context20.t4
          };
          return _context20.abrupt('return', dispatch('transactions/_transactionOperations', {
            operations: [{
              op_type: 17,
              type: "asset_publish_feed",
              params: {
                publisher: rootGetters['account/getAccountUserId'],
                asset_id: id,
                feed: price_feed,
                extensions: []
              }
            }],
            onlyGetFee: onlyGetFee
          }, { root: true }));

        case 19:
        case 'end':
          return _context20.stop();
      }
    }
  }, null, undefined);
};

var assetUpdateFeedProducers = exports.assetUpdateFeedProducers = function _callee21(_ref31, _ref32) {
  var dispatch = _ref31.dispatch,
      rootGetters = _ref31.rootGetters;
  var assetId = _ref32.assetId,
      newFeedProducers = _ref32.newFeedProducers,
      onlyGetFee = _ref32.onlyGetFee;
  var asset_res;
  return _regenerator2.default.async(function _callee21$(_context21) {
    while (1) {
      switch (_context21.prev = _context21.next) {
        case 0:
          assetId = assetId.toUpperCase();
          _context21.next = 3;
          return _regenerator2.default.awrap(_api2.default.Assets.fetch_asset_one(assetId));

        case 3:
          asset_res = _context21.sent;

          if (!(asset_res.code !== 1)) {
            _context21.next = 6;
            break;
          }

          return _context21.abrupt('return', asset_res);

        case 6:
          return _context21.abrupt('return', dispatch('transactions/_transactionOperations', {
            operations: [{
              op_type: 12,
              type: "asset_update_feed_producers",
              params: {
                issuer: rootGetters['account/getAccountUserId'],
                asset_to_update: asset_res.data.id,
                new_feed_producers: newFeedProducers,
                extensions: []
              }
            }],
            onlyGetFee: onlyGetFee
          }, { root: true }));

        case 7:
        case 'end':
          return _context21.stop();
      }
    }
  }, null, undefined);
};

var assetGlobalSettle = exports.assetGlobalSettle = function _callee22(_ref33, params) {
  var dispatch = _ref33.dispatch,
      rootGetters = _ref33.rootGetters;

  var assetId, price, onlyGetFee, asset_res, _asset_res$data2, id, precision;

  return _regenerator2.default.async(function _callee22$(_context22) {
    while (1) {
      switch (_context22.prev = _context22.next) {
        case 0:
          if (_helper2.default.trimParams(params)) {
            _context22.next = 2;
            break;
          }

          return _context22.abrupt('return', { code: 101, message: "Parameter is missing" });

        case 2:
          assetId = params.assetId, price = params.price, onlyGetFee = params.onlyGetFee;

          if (!isNaN(Number(price))) {
            _context22.next = 5;
            break;
          }

          return _context22.abrupt('return', { code: 135, message: "Please check parameter data type" });

        case 5:
          assetId = assetId.toUpperCase();
          _context22.next = 8;
          return _regenerator2.default.awrap(_api2.default.Assets.fetch_asset_one(assetId));

        case 8:
          asset_res = _context22.sent;

          if (!(asset_res.code !== 1)) {
            _context22.next = 11;
            break;
          }

          return _context22.abrupt('return', asset_res);

        case 11:
          _asset_res$data2 = asset_res.data, id = _asset_res$data2.id, precision = _asset_res$data2.precision;
          _context22.t0 = dispatch;
          _context22.t1 = rootGetters['account/getAccountUserId'];
          _context22.t2 = id;
          _context22.t3 = {
            amount: 1 * Math.pow(10, precision),
            asset_id: id
          };
          _context22.t4 = price;
          _context22.t5 = Math;
          _context22.next = 20;
          return _regenerator2.default.awrap(_api2.default.Assets.fetch_asset_one("1.3.0"));

        case 20:
          _context22.t6 = _context22.sent.data.precision;
          _context22.t7 = _context22.t5.pow.call(_context22.t5, 10, _context22.t6);
          _context22.t8 = _context22.t4 * _context22.t7;
          _context22.t9 = {
            amount: _context22.t8,
            asset_id: "1.3.0"
          };
          _context22.t10 = {
            base: _context22.t3,
            quote: _context22.t9
          };
          _context22.t11 = [];
          _context22.t12 = {
            issuer: _context22.t1,
            asset_to_settle: _context22.t2,
            settle_price: _context22.t10,
            extensions: _context22.t11
          };
          _context22.t13 = {
            op_type: 17,
            type: "asset_global_settle",
            params: _context22.t12
          };
          _context22.t14 = [_context22.t13];
          _context22.t15 = onlyGetFee;
          _context22.t16 = {
            operations: _context22.t14,
            onlyGetFee: _context22.t15
          };
          _context22.t17 = { root: true };
          return _context22.abrupt('return', (0, _context22.t0)('transactions/_transactionOperations', _context22.t16, _context22.t17));

        case 33:
        case 'end':
          return _context22.stop();
      }
    }
  }, null, undefined);
};

var assetSettle = exports.assetSettle = function _callee23(_ref34, params) {
  var dispatch = _ref34.dispatch,
      rootGetters = _ref34.rootGetters;
  var assetId, amount, onlyGetFee, asset_res;
  return _regenerator2.default.async(function _callee23$(_context23) {
    while (1) {
      switch (_context23.prev = _context23.next) {
        case 0:
          if (_helper2.default.trimParams(params)) {
            _context23.next = 2;
            break;
          }

          return _context23.abrupt('return', { code: 101, message: "Parameter is missing" });

        case 2:
          assetId = params.assetId, amount = params.amount, onlyGetFee = params.onlyGetFee;

          if (!isNaN(Number(amount))) {
            _context23.next = 5;
            break;
          }

          return _context23.abrupt('return', { code: 135, message: "Please check parameter data type" });

        case 5:
          assetId = assetId.toUpperCase();
          _context23.next = 8;
          return _regenerator2.default.awrap(_api2.default.Assets.fetch_asset_one(assetId));

        case 8:
          asset_res = _context23.sent;

          if (!(asset_res.code !== 1)) {
            _context23.next = 11;
            break;
          }

          return _context23.abrupt('return', asset_res);

        case 11:
          _context23.t0 = dispatch;
          _context23.t1 = rootGetters['account/getAccountUserId'];
          _context23.next = 15;
          return _regenerator2.default.awrap(_helper2.default.toOpAmount(amount, asset_res.data));

        case 15:
          _context23.t2 = _context23.sent.data;
          _context23.t3 = [];
          _context23.t4 = {
            account: _context23.t1,
            amount: _context23.t2,
            extensions: _context23.t3
          };
          _context23.t5 = {
            op_type: 16,
            type: "asset_settle",
            params: _context23.t4
          };
          _context23.t6 = [_context23.t5];
          _context23.t7 = onlyGetFee;
          _context23.t8 = {
            operations: _context23.t6,
            onlyGetFee: _context23.t7
          };
          _context23.t9 = { root: true };
          return _context23.abrupt('return', (0, _context23.t0)('transactions/_transactionOperations', _context23.t8, _context23.t9));

        case 24:
        case 'end':
          return _context23.stop();
      }
    }
  }, null, undefined);
};

var updateCollateralForGas = exports.updateCollateralForGas = function _callee24(_ref35, params) {
  var dispatch = _ref35.dispatch,
      rootGetters = _ref35.rootGetters;

  var mortgager, beneficiary, amount, _params$isPropose, isPropose, mortgager_res, beneficiary_res, core_asset, proposeAccount;

  return _regenerator2.default.async(function _callee24$(_context24) {
    while (1) {
      switch (_context24.prev = _context24.next) {
        case 0:
          if (_helper2.default.trimParams(params, { mortgager: "" })) {
            _context24.next = 2;
            break;
          }

          return _context24.abrupt('return', { code: 101, message: "Parameter is missing" });

        case 2:
          mortgager = params.mortgager, beneficiary = params.beneficiary, amount = params.amount, _params$isPropose = params.isPropose, isPropose = _params$isPropose === undefined ? false : _params$isPropose;

          if (mortgager) {
            _context24.next = 7;
            break;
          }

          mortgager = rootGetters["account/getAccountUserId"];
          _context24.next = 13;
          break;

        case 7:
          _context24.next = 9;
          return _regenerator2.default.awrap(dispatch("user/getUserInfo", { account: mortgager, isCache: true }, { root: true }));

        case 9:
          mortgager_res = _context24.sent;

          if (!(mortgager_res.code != 1)) {
            _context24.next = 12;
            break;
          }

          return _context24.abrupt('return', mortgager_res);

        case 12:
          mortgager = mortgager_res.data.account.id;

        case 13:
          _context24.next = 15;
          return _regenerator2.default.awrap(dispatch("user/getUserInfo", { account: beneficiary, isCache: true }, { root: true }));

        case 15:
          beneficiary_res = _context24.sent;

          if (!(beneficiary_res.code != 1)) {
            _context24.next = 18;
            break;
          }

          return _context24.abrupt('return', beneficiary_res);

        case 18:
          beneficiary = beneficiary_res.data.account.id;

          if (!isNaN(Number(amount))) {
            _context24.next = 21;
            break;
          }

          return _context24.abrupt('return', { code: 135, message: "Please check parameter data type" });

        case 21:
          _context24.next = 23;
          return _regenerator2.default.awrap(_api2.default.Assets.fetch(["1.3.0"], true));

        case 23:
          core_asset = _context24.sent;
          _context24.next = 26;
          return _regenerator2.default.awrap(_helper2.default.toOpAmount(amount, core_asset));

        case 26:
          amount = _context24.sent.data.amount;
          proposeAccount = "";

          if (isPropose) {
            proposeAccount = rootGetters["account/getAccountUserId"];
          }
          return _context24.abrupt('return', dispatch('transactions/_transactionOperations', {
            operations: [{
              op_type: 54,
              type: "update_collateral_for_gas",
              params: {
                mortgager: mortgager,
                beneficiary: beneficiary,
                collateral: amount
              }
            }],
            proposeAccount: proposeAccount
          }, { root: true }));

        case 30:
        case 'end':
          return _context24.stop();
      }
    }
  }, null, undefined);
};

/***/ }),
/* 546 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _keys = __webpack_require__(24);

var _keys2 = _interopRequireDefault(_keys);

var _classCallCheck2 = __webpack_require__(11);

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(15);

var _createClass3 = _interopRequireDefault(_createClass2);

var _asset_constants = __webpack_require__(394);

var _asset_constants2 = _interopRequireDefault(_asset_constants);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var AssetUtils = function () {
    function AssetUtils() {
        (0, _classCallCheck3.default)(this, AssetUtils);
    }

    (0, _createClass3.default)(AssetUtils, null, [{
        key: "getFlagBooleans",
        value: function getFlagBooleans(mask) {
            var isBitAsset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

            var booleans = {
                charge_market_fee: false,
                white_list: false,
                override_authority: false,
                transfer_restricted: false,
                disable_force_settle: false,
                global_settle: false,
                disable_issuer: true,
                // disable_confidential: false,
                witness_fed_asset: false,
                committee_fed_asset: false
            };

            if (mask === "all") {
                for (var flag in booleans) {
                    if (!isBitAsset && _asset_constants2.default.uia_permission_mask.indexOf(flag) === -1) {
                        delete booleans[flag];
                    } else {
                        booleans[flag] = true;
                    }
                }
                return booleans;
            }

            for (var _flag in booleans) {
                if (!isBitAsset && _asset_constants2.default.uia_permission_mask.indexOf(_flag) === -1) {
                    delete booleans[_flag];
                } else {
                    // console.info("mask",mask,assetConstants.permission_flags[flag],mask & assetConstants.permission_flags[flag])
                    if (mask & _asset_constants2.default.permission_flags[_flag]) {
                        booleans[_flag] = true;
                    }
                }
            }

            return booleans;
        }
    }, {
        key: "getFlags",
        value: function getFlags(flagBooleans) {
            var keys = (0, _keys2.default)(_asset_constants2.default.permission_flags);

            var flags = 0;

            keys.forEach(function (key) {
                if (flagBooleans[key] && key !== "global_settle") {
                    flags += _asset_constants2.default.permission_flags[key];
                }
            });

            return flags;
        }
    }, {
        key: "getPermissions",
        value: function getPermissions(flagBooleans) {
            var isBitAsset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

            var permissions = isBitAsset ? (0, _keys2.default)(_asset_constants2.default.permission_flags) : _asset_constants2.default.uia_permission_mask;
            var flags = 0;
            permissions.forEach(function (permission) {
                if (flagBooleans[permission] && permission !== "global_settle") {
                    flags += _asset_constants2.default.permission_flags[permission];
                }
            });

            if (isBitAsset) {
                flags += _asset_constants2.default.permission_flags["global_settle"];
            }

            return flags;
        }
    }, {
        key: "parseDescription",
        value: function parseDescription(description) {
            var parsed = void 0;
            try {
                parsed = JSON.parse(description);
            } catch (error) {}

            return parsed ? parsed : { main: description };
        }
    }]);
    return AssetUtils;
}();

exports.default = AssetUtils;

/***/ }),
/* 547 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*! bignumber.js v4.1.0 https://github.com/MikeMcl/bignumber.js/LICENCE */

;(function (globalObj) {
    'use strict';

    /*
      bignumber.js v4.1.0
      A JavaScript library for arbitrary-precision arithmetic.
      https://github.com/MikeMcl/bignumber.js
      Copyright (c) 2017 Michael Mclaughlin <M8ch88l@gmail.com>
      MIT Expat Licence
    */


    var BigNumber,
        isNumeric = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
        mathceil = Math.ceil,
        mathfloor = Math.floor,
        notBool = ' not a boolean or binary digit',
        roundingMode = 'rounding mode',
        tooManyDigits = 'number type has more than 15 significant digits',
        ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_',
        BASE = 1e14,
        LOG_BASE = 14,
        MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
        // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
        POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
        SQRT_BASE = 1e7,

        /*
         * The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
         * the arguments to toExponential, toFixed, toFormat, and toPrecision, beyond which an
         * exception is thrown (if ERRORS is true).
         */
        MAX = 1E9;                                   // 0 to MAX_INT32


    /*
     * Create and return a BigNumber constructor.
     */
    function constructorFactory(config) {
        var div, parseNumeric,

            // id tracks the caller function, so its name can be included in error messages.
            id = 0,
            P = BigNumber.prototype,
            ONE = new BigNumber(1),


            /********************************* EDITABLE DEFAULTS **********************************/


            /*
             * The default values below must be integers within the inclusive ranges stated.
             * The values can also be changed at run-time using BigNumber.config.
             */

            // The maximum number of decimal places for operations involving division.
            DECIMAL_PLACES = 20,                     // 0 to MAX

            /*
             * The rounding mode used when rounding to the above decimal places, and when using
             * toExponential, toFixed, toFormat and toPrecision, and round (default value).
             * UP         0 Away from zero.
             * DOWN       1 Towards zero.
             * CEIL       2 Towards +Infinity.
             * FLOOR      3 Towards -Infinity.
             * HALF_UP    4 Towards nearest neighbour. If equidistant, up.
             * HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
             * HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
             * HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
             * HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
             */
            ROUNDING_MODE = 4,                       // 0 to 8

            // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

            // The exponent value at and beneath which toString returns exponential notation.
            // Number type: -7
            TO_EXP_NEG = -7,                         // 0 to -MAX

            // The exponent value at and above which toString returns exponential notation.
            // Number type: 21
            TO_EXP_POS = 21,                         // 0 to MAX

            // RANGE : [MIN_EXP, MAX_EXP]

            // The minimum exponent value, beneath which underflow to zero occurs.
            // Number type: -324  (5e-324)
            MIN_EXP = -1e7,                          // -1 to -MAX

            // The maximum exponent value, above which overflow to Infinity occurs.
            // Number type:  308  (1.7976931348623157e+308)
            // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
            MAX_EXP = 1e7,                           // 1 to MAX

            // Whether BigNumber Errors are ever thrown.
            ERRORS = true,                           // true or false

            // Change to intValidatorNoErrors if ERRORS is false.
            isValidInt = intValidatorWithErrors,     // intValidatorWithErrors/intValidatorNoErrors

            // Whether to use cryptographically-secure random number generation, if available.
            CRYPTO = false,                          // true or false

            /*
             * The modulo mode used when calculating the modulus: a mod n.
             * The quotient (q = a / n) is calculated according to the corresponding rounding mode.
             * The remainder (r) is calculated as: r = a - n * q.
             *
             * UP        0 The remainder is positive if the dividend is negative, else is negative.
             * DOWN      1 The remainder has the same sign as the dividend.
             *             This modulo mode is commonly known as 'truncated division' and is
             *             equivalent to (a % n) in JavaScript.
             * FLOOR     3 The remainder has the same sign as the divisor (Python %).
             * HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
             * EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
             *             The remainder is always positive.
             *
             * The truncated division, floored division, Euclidian division and IEEE 754 remainder
             * modes are commonly used for the modulus operation.
             * Although the other rounding modes can also be used, they may not give useful results.
             */
            MODULO_MODE = 1,                         // 0 to 9

            // The maximum number of significant digits of the result of the toPower operation.
            // If POW_PRECISION is 0, there will be unlimited significant digits.
            POW_PRECISION = 0,                       // 0 to MAX

            // The format specification used by the BigNumber.prototype.toFormat method.
            FORMAT = {
                decimalSeparator: '.',
                groupSeparator: ',',
                groupSize: 3,
                secondaryGroupSize: 0,
                fractionGroupSeparator: '\xA0',      // non-breaking space
                fractionGroupSize: 0
            };


        /******************************************************************************************/


        // CONSTRUCTOR


        /*
         * The BigNumber constructor and exported function.
         * Create and return a new instance of a BigNumber object.
         *
         * n {number|string|BigNumber} A numeric value.
         * [b] {number} The base of n. Integer, 2 to 64 inclusive.
         */
        function BigNumber( n, b ) {
            var c, e, i, num, len, str,
                x = this;

            // Enable constructor usage without new.
            if ( !( x instanceof BigNumber ) ) {

                // 'BigNumber() constructor call without new: {n}'
                if (ERRORS) raise( 26, 'constructor call without new', n );
                return new BigNumber( n, b );
            }

            // 'new BigNumber() base not an integer: {b}'
            // 'new BigNumber() base out of range: {b}'
            if ( b == null || !isValidInt( b, 2, 64, id, 'base' ) ) {

                // Duplicate.
                if ( n instanceof BigNumber ) {
                    x.s = n.s;
                    x.e = n.e;
                    x.c = ( n = n.c ) ? n.slice() : n;
                    id = 0;
                    return;
                }

                if ( ( num = typeof n == 'number' ) && n * 0 == 0 ) {
                    x.s = 1 / n < 0 ? ( n = -n, -1 ) : 1;

                    // Fast path for integers.
                    if ( n === ~~n ) {
                        for ( e = 0, i = n; i >= 10; i /= 10, e++ );
                        x.e = e;
                        x.c = [n];
                        id = 0;
                        return;
                    }

                    str = n + '';
                } else {
                    if ( !isNumeric.test( str = n + '' ) ) return parseNumeric( x, str, num );
                    x.s = str.charCodeAt(0) === 45 ? ( str = str.slice(1), -1 ) : 1;
                }
            } else {
                b = b | 0;
                str = n + '';

                // Ensure return value is rounded to DECIMAL_PLACES as with other bases.
                // Allow exponential notation to be used with base 10 argument.
                if ( b == 10 ) {
                    x = new BigNumber( n instanceof BigNumber ? n : str );
                    return round( x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE );
                }

                // Avoid potential interpretation of Infinity and NaN as base 44+ values.
                // Any number in exponential form will fail due to the [Ee][+-].
                if ( ( num = typeof n == 'number' ) && n * 0 != 0 ||
                  !( new RegExp( '^-?' + ( c = '[' + ALPHABET.slice( 0, b ) + ']+' ) +
                    '(?:\\.' + c + ')?$',b < 37 ? 'i' : '' ) ).test(str) ) {
                    return parseNumeric( x, str, num, b );
                }

                if (num) {
                    x.s = 1 / n < 0 ? ( str = str.slice(1), -1 ) : 1;

                    if ( ERRORS && str.replace( /^0\.0*|\./, '' ).length > 15 ) {

                        // 'new BigNumber() number type has more than 15 significant digits: {n}'
                        raise( id, tooManyDigits, n );
                    }

                    // Prevent later check for length on converted number.
                    num = false;
                } else {
                    x.s = str.charCodeAt(0) === 45 ? ( str = str.slice(1), -1 ) : 1;
                }

                str = convertBase( str, 10, b, x.s );
            }

            // Decimal point?
            if ( ( e = str.indexOf('.') ) > -1 ) str = str.replace( '.', '' );

            // Exponential form?
            if ( ( i = str.search( /e/i ) ) > 0 ) {

                // Determine exponent.
                if ( e < 0 ) e = i;
                e += +str.slice( i + 1 );
                str = str.substring( 0, i );
            } else if ( e < 0 ) {

                // Integer.
                e = str.length;
            }

            // Determine leading zeros.
            for ( i = 0; str.charCodeAt(i) === 48; i++ );

            // Determine trailing zeros.
            for ( len = str.length; str.charCodeAt(--len) === 48; );
            str = str.slice( i, len + 1 );

            if (str) {
                len = str.length;

                // Disallow numbers with over 15 significant digits if number type.
                // 'new BigNumber() number type has more than 15 significant digits: {n}'
                if ( num && ERRORS && len > 15 && ( n > MAX_SAFE_INTEGER || n !== mathfloor(n) ) ) {
                    raise( id, tooManyDigits, x.s * n );
                }

                e = e - i - 1;

                 // Overflow?
                if ( e > MAX_EXP ) {

                    // Infinity.
                    x.c = x.e = null;

                // Underflow?
                } else if ( e < MIN_EXP ) {

                    // Zero.
                    x.c = [ x.e = 0 ];
                } else {
                    x.e = e;
                    x.c = [];

                    // Transform base

                    // e is the base 10 exponent.
                    // i is where to slice str to get the first element of the coefficient array.
                    i = ( e + 1 ) % LOG_BASE;
                    if ( e < 0 ) i += LOG_BASE;

                    if ( i < len ) {
                        if (i) x.c.push( +str.slice( 0, i ) );

                        for ( len -= LOG_BASE; i < len; ) {
                            x.c.push( +str.slice( i, i += LOG_BASE ) );
                        }

                        str = str.slice(i);
                        i = LOG_BASE - str.length;
                    } else {
                        i -= len;
                    }

                    for ( ; i--; str += '0' );
                    x.c.push( +str );
                }
            } else {

                // Zero.
                x.c = [ x.e = 0 ];
            }

            id = 0;
        }


        // CONSTRUCTOR PROPERTIES


        BigNumber.another = constructorFactory;

        BigNumber.ROUND_UP = 0;
        BigNumber.ROUND_DOWN = 1;
        BigNumber.ROUND_CEIL = 2;
        BigNumber.ROUND_FLOOR = 3;
        BigNumber.ROUND_HALF_UP = 4;
        BigNumber.ROUND_HALF_DOWN = 5;
        BigNumber.ROUND_HALF_EVEN = 6;
        BigNumber.ROUND_HALF_CEIL = 7;
        BigNumber.ROUND_HALF_FLOOR = 8;
        BigNumber.EUCLID = 9;


        /*
         * Configure infrequently-changing library-wide settings.
         *
         * Accept an object or an argument list, with one or many of the following properties or
         * parameters respectively:
         *
         *   DECIMAL_PLACES  {number}  Integer, 0 to MAX inclusive
         *   ROUNDING_MODE   {number}  Integer, 0 to 8 inclusive
         *   EXPONENTIAL_AT  {number|number[]}  Integer, -MAX to MAX inclusive or
         *                                      [integer -MAX to 0 incl., 0 to MAX incl.]
         *   RANGE           {number|number[]}  Non-zero integer, -MAX to MAX inclusive or
         *                                      [integer -MAX to -1 incl., integer 1 to MAX incl.]
         *   ERRORS          {boolean|number}   true, false, 1 or 0
         *   CRYPTO          {boolean|number}   true, false, 1 or 0
         *   MODULO_MODE     {number}           0 to 9 inclusive
         *   POW_PRECISION   {number}           0 to MAX inclusive
         *   FORMAT          {object}           See BigNumber.prototype.toFormat
         *      decimalSeparator       {string}
         *      groupSeparator         {string}
         *      groupSize              {number}
         *      secondaryGroupSize     {number}
         *      fractionGroupSeparator {string}
         *      fractionGroupSize      {number}
         *
         * (The values assigned to the above FORMAT object properties are not checked for validity.)
         *
         * E.g.
         * BigNumber.config(20, 4) is equivalent to
         * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
         *
         * Ignore properties/parameters set to null or undefined.
         * Return an object with the properties current values.
         */
        BigNumber.config = BigNumber.set = function () {
            var v, p,
                i = 0,
                r = {},
                a = arguments,
                o = a[0],
                has = o && typeof o == 'object'
                  ? function () { if ( o.hasOwnProperty(p) ) return ( v = o[p] ) != null; }
                  : function () { if ( a.length > i ) return ( v = a[i++] ) != null; };

            // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
            // 'config() DECIMAL_PLACES not an integer: {v}'
            // 'config() DECIMAL_PLACES out of range: {v}'
            if ( has( p = 'DECIMAL_PLACES' ) && isValidInt( v, 0, MAX, 2, p ) ) {
                DECIMAL_PLACES = v | 0;
            }
            r[p] = DECIMAL_PLACES;

            // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
            // 'config() ROUNDING_MODE not an integer: {v}'
            // 'config() ROUNDING_MODE out of range: {v}'
            if ( has( p = 'ROUNDING_MODE' ) && isValidInt( v, 0, 8, 2, p ) ) {
                ROUNDING_MODE = v | 0;
            }
            r[p] = ROUNDING_MODE;

            // EXPONENTIAL_AT {number|number[]}
            // Integer, -MAX to MAX inclusive or [integer -MAX to 0 inclusive, 0 to MAX inclusive].
            // 'config() EXPONENTIAL_AT not an integer: {v}'
            // 'config() EXPONENTIAL_AT out of range: {v}'
            if ( has( p = 'EXPONENTIAL_AT' ) ) {

                if ( isArray(v) ) {
                    if ( isValidInt( v[0], -MAX, 0, 2, p ) && isValidInt( v[1], 0, MAX, 2, p ) ) {
                        TO_EXP_NEG = v[0] | 0;
                        TO_EXP_POS = v[1] | 0;
                    }
                } else if ( isValidInt( v, -MAX, MAX, 2, p ) ) {
                    TO_EXP_NEG = -( TO_EXP_POS = ( v < 0 ? -v : v ) | 0 );
                }
            }
            r[p] = [ TO_EXP_NEG, TO_EXP_POS ];

            // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
            // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
            // 'config() RANGE not an integer: {v}'
            // 'config() RANGE cannot be zero: {v}'
            // 'config() RANGE out of range: {v}'
            if ( has( p = 'RANGE' ) ) {

                if ( isArray(v) ) {
                    if ( isValidInt( v[0], -MAX, -1, 2, p ) && isValidInt( v[1], 1, MAX, 2, p ) ) {
                        MIN_EXP = v[0] | 0;
                        MAX_EXP = v[1] | 0;
                    }
                } else if ( isValidInt( v, -MAX, MAX, 2, p ) ) {
                    if ( v | 0 ) MIN_EXP = -( MAX_EXP = ( v < 0 ? -v : v ) | 0 );
                    else if (ERRORS) raise( 2, p + ' cannot be zero', v );
                }
            }
            r[p] = [ MIN_EXP, MAX_EXP ];

            // ERRORS {boolean|number} true, false, 1 or 0.
            // 'config() ERRORS not a boolean or binary digit: {v}'
            if ( has( p = 'ERRORS' ) ) {

                if ( v === !!v || v === 1 || v === 0 ) {
                    id = 0;
                    isValidInt = ( ERRORS = !!v ) ? intValidatorWithErrors : intValidatorNoErrors;
                } else if (ERRORS) {
                    raise( 2, p + notBool, v );
                }
            }
            r[p] = ERRORS;

            // CRYPTO {boolean|number} true, false, 1 or 0.
            // 'config() CRYPTO not a boolean or binary digit: {v}'
            // 'config() crypto unavailable: {crypto}'
            if ( has( p = 'CRYPTO' ) ) {

                if ( v === true || v === false || v === 1 || v === 0 ) {
                    if (v) {
                        v = typeof crypto == 'undefined';
                        if ( !v && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                            CRYPTO = true;
                        } else if (ERRORS) {
                            raise( 2, 'crypto unavailable', v ? void 0 : crypto );
                        } else {
                            CRYPTO = false;
                        }
                    } else {
                        CRYPTO = false;
                    }
                } else if (ERRORS) {
                    raise( 2, p + notBool, v );
                }
            }
            r[p] = CRYPTO;

            // MODULO_MODE {number} Integer, 0 to 9 inclusive.
            // 'config() MODULO_MODE not an integer: {v}'
            // 'config() MODULO_MODE out of range: {v}'
            if ( has( p = 'MODULO_MODE' ) && isValidInt( v, 0, 9, 2, p ) ) {
                MODULO_MODE = v | 0;
            }
            r[p] = MODULO_MODE;

            // POW_PRECISION {number} Integer, 0 to MAX inclusive.
            // 'config() POW_PRECISION not an integer: {v}'
            // 'config() POW_PRECISION out of range: {v}'
            if ( has( p = 'POW_PRECISION' ) && isValidInt( v, 0, MAX, 2, p ) ) {
                POW_PRECISION = v | 0;
            }
            r[p] = POW_PRECISION;

            // FORMAT {object}
            // 'config() FORMAT not an object: {v}'
            if ( has( p = 'FORMAT' ) ) {

                if ( typeof v == 'object' ) {
                    FORMAT = v;
                } else if (ERRORS) {
                    raise( 2, p + ' not an object', v );
                }
            }
            r[p] = FORMAT;

            return r;
        };


        /*
         * Return a new BigNumber whose value is the maximum of the arguments.
         *
         * arguments {number|string|BigNumber}
         */
        BigNumber.max = function () { return maxOrMin( arguments, P.lt ); };


        /*
         * Return a new BigNumber whose value is the minimum of the arguments.
         *
         * arguments {number|string|BigNumber}
         */
        BigNumber.min = function () { return maxOrMin( arguments, P.gt ); };


        /*
         * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
         * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
         * zeros are produced).
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         *
         * 'random() decimal places not an integer: {dp}'
         * 'random() decimal places out of range: {dp}'
         * 'random() crypto unavailable: {crypto}'
         */
        BigNumber.random = (function () {
            var pow2_53 = 0x20000000000000;

            // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
            // Check if Math.random() produces more than 32 bits of randomness.
            // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
            // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
            var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
              ? function () { return mathfloor( Math.random() * pow2_53 ); }
              : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
                  (Math.random() * 0x800000 | 0); };

            return function (dp) {
                var a, b, e, k, v,
                    i = 0,
                    c = [],
                    rand = new BigNumber(ONE);

                dp = dp == null || !isValidInt( dp, 0, MAX, 14 ) ? DECIMAL_PLACES : dp | 0;
                k = mathceil( dp / LOG_BASE );

                if (CRYPTO) {

                    // Browsers supporting crypto.getRandomValues.
                    if (crypto.getRandomValues) {

                        a = crypto.getRandomValues( new Uint32Array( k *= 2 ) );

                        for ( ; i < k; ) {

                            // 53 bits:
                            // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
                            // 11111 11111111 11111111 11111111 11100000 00000000 00000000
                            // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
                            //                                     11111 11111111 11111111
                            // 0x20000 is 2^21.
                            v = a[i] * 0x20000 + (a[i + 1] >>> 11);

                            // Rejection sampling:
                            // 0 <= v < 9007199254740992
                            // Probability that v >= 9e15, is
                            // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
                            if ( v >= 9e15 ) {
                                b = crypto.getRandomValues( new Uint32Array(2) );
                                a[i] = b[0];
                                a[i + 1] = b[1];
                            } else {

                                // 0 <= v <= 8999999999999999
                                // 0 <= (v % 1e14) <= 99999999999999
                                c.push( v % 1e14 );
                                i += 2;
                            }
                        }
                        i = k / 2;

                    // Node.js supporting crypto.randomBytes.
                    } else if (crypto.randomBytes) {

                        // buffer
                        a = crypto.randomBytes( k *= 7 );

                        for ( ; i < k; ) {

                            // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
                            // 0x100000000 is 2^32, 0x1000000 is 2^24
                            // 11111 11111111 11111111 11111111 11111111 11111111 11111111
                            // 0 <= v < 9007199254740992
                            v = ( ( a[i] & 31 ) * 0x1000000000000 ) + ( a[i + 1] * 0x10000000000 ) +
                                  ( a[i + 2] * 0x100000000 ) + ( a[i + 3] * 0x1000000 ) +
                                  ( a[i + 4] << 16 ) + ( a[i + 5] << 8 ) + a[i + 6];

                            if ( v >= 9e15 ) {
                                crypto.randomBytes(7).copy( a, i );
                            } else {

                                // 0 <= (v % 1e14) <= 99999999999999
                                c.push( v % 1e14 );
                                i += 7;
                            }
                        }
                        i = k / 7;
                    } else {
                        CRYPTO = false;
                        if (ERRORS) raise( 14, 'crypto unavailable', crypto );
                    }
                }

                // Use Math.random.
                if (!CRYPTO) {

                    for ( ; i < k; ) {
                        v = random53bitInt();
                        if ( v < 9e15 ) c[i++] = v % 1e14;
                    }
                }

                k = c[--i];
                dp %= LOG_BASE;

                // Convert trailing digits to zeros according to dp.
                if ( k && dp ) {
                    v = POWS_TEN[LOG_BASE - dp];
                    c[i] = mathfloor( k / v ) * v;
                }

                // Remove trailing elements which are zero.
                for ( ; c[i] === 0; c.pop(), i-- );

                // Zero?
                if ( i < 0 ) {
                    c = [ e = 0 ];
                } else {

                    // Remove leading elements which are zero and adjust exponent accordingly.
                    for ( e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

                    // Count the digits of the first element of c to determine leading zeros, and...
                    for ( i = 1, v = c[0]; v >= 10; v /= 10, i++);

                    // adjust the exponent accordingly.
                    if ( i < LOG_BASE ) e -= LOG_BASE - i;
                }

                rand.e = e;
                rand.c = c;
                return rand;
            };
        })();


        // PRIVATE FUNCTIONS


        // Convert a numeric string of baseIn to a numeric string of baseOut.
        function convertBase( str, baseOut, baseIn, sign ) {
            var d, e, k, r, x, xc, y,
                i = str.indexOf( '.' ),
                dp = DECIMAL_PLACES,
                rm = ROUNDING_MODE;

            if ( baseIn < 37 ) str = str.toLowerCase();

            // Non-integer.
            if ( i >= 0 ) {
                k = POW_PRECISION;

                // Unlimited precision.
                POW_PRECISION = 0;
                str = str.replace( '.', '' );
                y = new BigNumber(baseIn);
                x = y.pow( str.length - i );
                POW_PRECISION = k;

                // Convert str as if an integer, then restore the fraction part by dividing the
                // result by its base raised to a power.
                y.c = toBaseOut( toFixedPoint( coeffToString( x.c ), x.e ), 10, baseOut );
                y.e = y.c.length;
            }

            // Convert the number as integer.
            xc = toBaseOut( str, baseIn, baseOut );
            e = k = xc.length;

            // Remove trailing zeros.
            for ( ; xc[--k] == 0; xc.pop() );
            if ( !xc[0] ) return '0';

            if ( i < 0 ) {
                --e;
            } else {
                x.c = xc;
                x.e = e;

                // sign is needed for correct rounding.
                x.s = sign;
                x = div( x, y, dp, rm, baseOut );
                xc = x.c;
                r = x.r;
                e = x.e;
            }

            d = e + dp + 1;

            // The rounding digit, i.e. the digit to the right of the digit that may be rounded up.
            i = xc[d];
            k = baseOut / 2;
            r = r || d < 0 || xc[d + 1] != null;

            r = rm < 4 ? ( i != null || r ) && ( rm == 0 || rm == ( x.s < 0 ? 3 : 2 ) )
                       : i > k || i == k &&( rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
                         rm == ( x.s < 0 ? 8 : 7 ) );

            if ( d < 1 || !xc[0] ) {

                // 1^-dp or 0.
                str = r ? toFixedPoint( '1', -dp ) : '0';
            } else {
                xc.length = d;

                if (r) {

                    // Rounding up may mean the previous digit has to be rounded up and so on.
                    for ( --baseOut; ++xc[--d] > baseOut; ) {
                        xc[d] = 0;

                        if ( !d ) {
                            ++e;
                            xc = [1].concat(xc);
                        }
                    }
                }

                // Determine trailing zeros.
                for ( k = xc.length; !xc[--k]; );

                // E.g. [4, 11, 15] becomes 4bf.
                for ( i = 0, str = ''; i <= k; str += ALPHABET.charAt( xc[i++] ) );
                str = toFixedPoint( str, e );
            }

            // The caller will add the sign.
            return str;
        }


        // Perform division in the specified base. Called by div and convertBase.
        div = (function () {

            // Assume non-zero x and k.
            function multiply( x, k, base ) {
                var m, temp, xlo, xhi,
                    carry = 0,
                    i = x.length,
                    klo = k % SQRT_BASE,
                    khi = k / SQRT_BASE | 0;

                for ( x = x.slice(); i--; ) {
                    xlo = x[i] % SQRT_BASE;
                    xhi = x[i] / SQRT_BASE | 0;
                    m = khi * xlo + xhi * klo;
                    temp = klo * xlo + ( ( m % SQRT_BASE ) * SQRT_BASE ) + carry;
                    carry = ( temp / base | 0 ) + ( m / SQRT_BASE | 0 ) + khi * xhi;
                    x[i] = temp % base;
                }

                if (carry) x = [carry].concat(x);

                return x;
            }

            function compare( a, b, aL, bL ) {
                var i, cmp;

                if ( aL != bL ) {
                    cmp = aL > bL ? 1 : -1;
                } else {

                    for ( i = cmp = 0; i < aL; i++ ) {

                        if ( a[i] != b[i] ) {
                            cmp = a[i] > b[i] ? 1 : -1;
                            break;
                        }
                    }
                }
                return cmp;
            }

            function subtract( a, b, aL, base ) {
                var i = 0;

                // Subtract b from a.
                for ( ; aL--; ) {
                    a[aL] -= i;
                    i = a[aL] < b[aL] ? 1 : 0;
                    a[aL] = i * base + a[aL] - b[aL];
                }

                // Remove leading zeros.
                for ( ; !a[0] && a.length > 1; a.splice(0, 1) );
            }

            // x: dividend, y: divisor.
            return function ( x, y, dp, rm, base ) {
                var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
                    yL, yz,
                    s = x.s == y.s ? 1 : -1,
                    xc = x.c,
                    yc = y.c;

                // Either NaN, Infinity or 0?
                if ( !xc || !xc[0] || !yc || !yc[0] ) {

                    return new BigNumber(

                      // Return NaN if either NaN, or both Infinity or 0.
                      !x.s || !y.s || ( xc ? yc && xc[0] == yc[0] : !yc ) ? NaN :

                        // Return Â±0 if x is Â±0 or y is Â±Infinity, or return Â±Infinity as y is Â±0.
                        xc && xc[0] == 0 || !yc ? s * 0 : s / 0
                    );
                }

                q = new BigNumber(s);
                qc = q.c = [];
                e = x.e - y.e;
                s = dp + e + 1;

                if ( !base ) {
                    base = BASE;
                    e = bitFloor( x.e / LOG_BASE ) - bitFloor( y.e / LOG_BASE );
                    s = s / LOG_BASE | 0;
                }

                // Result exponent may be one less then the current value of e.
                // The coefficients of the BigNumbers from convertBase may have trailing zeros.
                for ( i = 0; yc[i] == ( xc[i] || 0 ); i++ );
                if ( yc[i] > ( xc[i] || 0 ) ) e--;

                if ( s < 0 ) {
                    qc.push(1);
                    more = true;
                } else {
                    xL = xc.length;
                    yL = yc.length;
                    i = 0;
                    s += 2;

                    // Normalise xc and yc so highest order digit of yc is >= base / 2.

                    n = mathfloor( base / ( yc[0] + 1 ) );

                    // Not necessary, but to handle odd bases where yc[0] == ( base / 2 ) - 1.
                    // if ( n > 1 || n++ == 1 && yc[0] < base / 2 ) {
                    if ( n > 1 ) {
                        yc = multiply( yc, n, base );
                        xc = multiply( xc, n, base );
                        yL = yc.length;
                        xL = xc.length;
                    }

                    xi = yL;
                    rem = xc.slice( 0, yL );
                    remL = rem.length;

                    // Add zeros to make remainder as long as divisor.
                    for ( ; remL < yL; rem[remL++] = 0 );
                    yz = yc.slice();
                    yz = [0].concat(yz);
                    yc0 = yc[0];
                    if ( yc[1] >= base / 2 ) yc0++;
                    // Not necessary, but to prevent trial digit n > base, when using base 3.
                    // else if ( base == 3 && yc0 == 1 ) yc0 = 1 + 1e-15;

                    do {
                        n = 0;

                        // Compare divisor and remainder.
                        cmp = compare( yc, rem, yL, remL );

                        // If divisor < remainder.
                        if ( cmp < 0 ) {

                            // Calculate trial digit, n.

                            rem0 = rem[0];
                            if ( yL != remL ) rem0 = rem0 * base + ( rem[1] || 0 );

                            // n is how many times the divisor goes into the current remainder.
                            n = mathfloor( rem0 / yc0 );

                            //  Algorithm:
                            //  1. product = divisor * trial digit (n)
                            //  2. if product > remainder: product -= divisor, n--
                            //  3. remainder -= product
                            //  4. if product was < remainder at 2:
                            //    5. compare new remainder and divisor
                            //    6. If remainder > divisor: remainder -= divisor, n++

                            if ( n > 1 ) {

                                // n may be > base only when base is 3.
                                if (n >= base) n = base - 1;

                                // product = divisor * trial digit.
                                prod = multiply( yc, n, base );
                                prodL = prod.length;
                                remL = rem.length;

                                // Compare product and remainder.
                                // If product > remainder.
                                // Trial digit n too high.
                                // n is 1 too high about 5% of the time, and is not known to have
                                // ever been more than 1 too high.
                                while ( compare( prod, rem, prodL, remL ) == 1 ) {
                                    n--;

                                    // Subtract divisor from product.
                                    subtract( prod, yL < prodL ? yz : yc, prodL, base );
                                    prodL = prod.length;
                                    cmp = 1;
                                }
                            } else {

                                // n is 0 or 1, cmp is -1.
                                // If n is 0, there is no need to compare yc and rem again below,
                                // so change cmp to 1 to avoid it.
                                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                                if ( n == 0 ) {

                                    // divisor < remainder, so n must be at least 1.
                                    cmp = n = 1;
                                }

                                // product = divisor
                                prod = yc.slice();
                                prodL = prod.length;
                            }

                            if ( prodL < remL ) prod = [0].concat(prod);

                            // Subtract product from remainder.
                            subtract( rem, prod, remL, base );
                            remL = rem.length;

                             // If product was < remainder.
                            if ( cmp == -1 ) {

                                // Compare divisor and new remainder.
                                // If divisor < new remainder, subtract divisor from remainder.
                                // Trial digit n too low.
                                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                                while ( compare( yc, rem, yL, remL ) < 1 ) {
                                    n++;

                                    // Subtract divisor from remainder.
                                    subtract( rem, yL < remL ? yz : yc, remL, base );
                                    remL = rem.length;
                                }
                            }
                        } else if ( cmp === 0 ) {
                            n++;
                            rem = [0];
                        } // else cmp === 1 and n will be 0

                        // Add the next digit, n, to the result array.
                        qc[i++] = n;

                        // Update the remainder.
                        if ( rem[0] ) {
                            rem[remL++] = xc[xi] || 0;
                        } else {
                            rem = [ xc[xi] ];
                            remL = 1;
                        }
                    } while ( ( xi++ < xL || rem[0] != null ) && s-- );

                    more = rem[0] != null;

                    // Leading zero?
                    if ( !qc[0] ) qc.splice(0, 1);
                }

                if ( base == BASE ) {

                    // To calculate q.e, first get the number of digits of qc[0].
                    for ( i = 1, s = qc[0]; s >= 10; s /= 10, i++ );
                    round( q, dp + ( q.e = i + e * LOG_BASE - 1 ) + 1, rm, more );

                // Caller is convertBase.
                } else {
                    q.e = e;
                    q.r = +more;
                }

                return q;
            };
        })();


        /*
         * Return a string representing the value of BigNumber n in fixed-point or exponential
         * notation rounded to the specified decimal places or significant digits.
         *
         * n is a BigNumber.
         * i is the index of the last digit required (i.e. the digit that may be rounded up).
         * rm is the rounding mode.
         * caller is caller id: toExponential 19, toFixed 20, toFormat 21, toPrecision 24.
         */
        function format( n, i, rm, caller ) {
            var c0, e, ne, len, str;

            rm = rm != null && isValidInt( rm, 0, 8, caller, roundingMode )
              ? rm | 0 : ROUNDING_MODE;

            if ( !n.c ) return n.toString();
            c0 = n.c[0];
            ne = n.e;

            if ( i == null ) {
                str = coeffToString( n.c );
                str = caller == 19 || caller == 24 && ne <= TO_EXP_NEG
                  ? toExponential( str, ne )
                  : toFixedPoint( str, ne );
            } else {
                n = round( new BigNumber(n), i, rm );

                // n.e may have changed if the value was rounded up.
                e = n.e;

                str = coeffToString( n.c );
                len = str.length;

                // toPrecision returns exponential notation if the number of significant digits
                // specified is less than the number of digits necessary to represent the integer
                // part of the value in fixed-point notation.

                // Exponential notation.
                if ( caller == 19 || caller == 24 && ( i <= e || e <= TO_EXP_NEG ) ) {

                    // Append zeros?
                    for ( ; len < i; str += '0', len++ );
                    str = toExponential( str, e );

                // Fixed-point notation.
                } else {
                    i -= ne;
                    str = toFixedPoint( str, e );

                    // Append zeros?
                    if ( e + 1 > len ) {
                        if ( --i > 0 ) for ( str += '.'; i--; str += '0' );
                    } else {
                        i += e - len;
                        if ( i > 0 ) {
                            if ( e + 1 == len ) str += '.';
                            for ( ; i--; str += '0' );
                        }
                    }
                }
            }

            return n.s < 0 && c0 ? '-' + str : str;
        }


        // Handle BigNumber.max and BigNumber.min.
        function maxOrMin( args, method ) {
            var m, n,
                i = 0;

            if ( isArray( args[0] ) ) args = args[0];
            m = new BigNumber( args[0] );

            for ( ; ++i < args.length; ) {
                n = new BigNumber( args[i] );

                // If any number is NaN, return NaN.
                if ( !n.s ) {
                    m = n;
                    break;
                } else if ( method.call( m, n ) ) {
                    m = n;
                }
            }

            return m;
        }


        /*
         * Return true if n is an integer in range, otherwise throw.
         * Use for argument validation when ERRORS is true.
         */
        function intValidatorWithErrors( n, min, max, caller, name ) {
            if ( n < min || n > max || n != truncate(n) ) {
                raise( caller, ( name || 'decimal places' ) +
                  ( n < min || n > max ? ' out of range' : ' not an integer' ), n );
            }

            return true;
        }


        /*
         * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
         * Called by minus, plus and times.
         */
        function normalise( n, c, e ) {
            var i = 1,
                j = c.length;

             // Remove trailing zeros.
            for ( ; !c[--j]; c.pop() );

            // Calculate the base 10 exponent. First get the number of digits of c[0].
            for ( j = c[0]; j >= 10; j /= 10, i++ );

            // Overflow?
            if ( ( e = i + e * LOG_BASE - 1 ) > MAX_EXP ) {

                // Infinity.
                n.c = n.e = null;

            // Underflow?
            } else if ( e < MIN_EXP ) {

                // Zero.
                n.c = [ n.e = 0 ];
            } else {
                n.e = e;
                n.c = c;
            }

            return n;
        }


        // Handle values that fail the validity test in BigNumber.
        parseNumeric = (function () {
            var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
                dotAfter = /^([^.]+)\.$/,
                dotBefore = /^\.([^.]+)$/,
                isInfinityOrNaN = /^-?(Infinity|NaN)$/,
                whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

            return function ( x, str, num, b ) {
                var base,
                    s = num ? str : str.replace( whitespaceOrPlus, '' );

                // No exception on Â±Infinity or NaN.
                if ( isInfinityOrNaN.test(s) ) {
                    x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
                } else {
                    if ( !num ) {

                        // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
                        s = s.replace( basePrefix, function ( m, p1, p2 ) {
                            base = ( p2 = p2.toLowerCase() ) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
                            return !b || b == base ? p1 : m;
                        });

                        if (b) {
                            base = b;

                            // E.g. '1.' to '1', '.1' to '0.1'
                            s = s.replace( dotAfter, '$1' ).replace( dotBefore, '0.$1' );
                        }

                        if ( str != s ) return new BigNumber( s, base );
                    }

                    // 'new BigNumber() not a number: {n}'
                    // 'new BigNumber() not a base {b} number: {n}'
                    if (ERRORS) raise( id, 'not a' + ( b ? ' base ' + b : '' ) + ' number', str );
                    x.s = null;
                }

                x.c = x.e = null;
                id = 0;
            }
        })();


        // Throw a BigNumber Error.
        function raise( caller, msg, val ) {
            var error = new Error( [
                'new BigNumber',     // 0
                'cmp',               // 1
                'config',            // 2
                'div',               // 3
                'divToInt',          // 4
                'eq',                // 5
                'gt',                // 6
                'gte',               // 7
                'lt',                // 8
                'lte',               // 9
                'minus',             // 10
                'mod',               // 11
                'plus',              // 12
                'precision',         // 13
                'random',            // 14
                'round',             // 15
                'shift',             // 16
                'times',             // 17
                'toDigits',          // 18
                'toExponential',     // 19
                'toFixed',           // 20
                'toFormat',          // 21
                'toFraction',        // 22
                'pow',               // 23
                'toPrecision',       // 24
                'toString',          // 25
                'BigNumber'          // 26
            ][caller] + '() ' + msg + ': ' + val );

            error.name = 'BigNumber Error';
            id = 0;
            throw error;
        }


        /*
         * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
         * If r is truthy, it is known that there are more digits after the rounding digit.
         */
        function round( x, sd, rm, r ) {
            var d, i, j, k, n, ni, rd,
                xc = x.c,
                pows10 = POWS_TEN;

            // if x is not Infinity or NaN...
            if (xc) {

                // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
                // n is a base 1e14 number, the value of the element of array x.c containing rd.
                // ni is the index of n within x.c.
                // d is the number of digits of n.
                // i is the index of rd within n including leading zeros.
                // j is the actual index of rd within n (if < 0, rd is a leading zero).
                out: {

                    // Get the number of digits of the first element of xc.
                    for ( d = 1, k = xc[0]; k >= 10; k /= 10, d++ );
                    i = sd - d;

                    // If the rounding digit is in the first element of xc...
                    if ( i < 0 ) {
                        i += LOG_BASE;
                        j = sd;
                        n = xc[ ni = 0 ];

                        // Get the rounding digit at index j of n.
                        rd = n / pows10[ d - j - 1 ] % 10 | 0;
                    } else {
                        ni = mathceil( ( i + 1 ) / LOG_BASE );

                        if ( ni >= xc.length ) {

                            if (r) {

                                // Needed by sqrt.
                                for ( ; xc.length <= ni; xc.push(0) );
                                n = rd = 0;
                                d = 1;
                                i %= LOG_BASE;
                                j = i - LOG_BASE + 1;
                            } else {
                                break out;
                            }
                        } else {
                            n = k = xc[ni];

                            // Get the number of digits of n.
                            for ( d = 1; k >= 10; k /= 10, d++ );

                            // Get the index of rd within n.
                            i %= LOG_BASE;

                            // Get the index of rd within n, adjusted for leading zeros.
                            // The number of leading zeros of n is given by LOG_BASE - d.
                            j = i - LOG_BASE + d;

                            // Get the rounding digit at index j of n.
                            rd = j < 0 ? 0 : n / pows10[ d - j - 1 ] % 10 | 0;
                        }
                    }

                    r = r || sd < 0 ||

                    // Are there any non-zero digits after the rounding digit?
                    // The expression  n % pows10[ d - j - 1 ]  returns all digits of n to the right
                    // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
                      xc[ni + 1] != null || ( j < 0 ? n : n % pows10[ d - j - 1 ] );

                    r = rm < 4
                      ? ( rd || r ) && ( rm == 0 || rm == ( x.s < 0 ? 3 : 2 ) )
                      : rd > 5 || rd == 5 && ( rm == 4 || r || rm == 6 &&

                        // Check whether the digit to the left of the rounding digit is odd.
                        ( ( i > 0 ? j > 0 ? n / pows10[ d - j ] : 0 : xc[ni - 1] ) % 10 ) & 1 ||
                          rm == ( x.s < 0 ? 8 : 7 ) );

                    if ( sd < 1 || !xc[0] ) {
                        xc.length = 0;

                        if (r) {

                            // Convert sd to decimal places.
                            sd -= x.e + 1;

                            // 1, 0.1, 0.01, 0.001, 0.0001 etc.
                            xc[0] = pows10[ ( LOG_BASE - sd % LOG_BASE ) % LOG_BASE ];
                            x.e = -sd || 0;
                        } else {

                            // Zero.
                            xc[0] = x.e = 0;
                        }

                        return x;
                    }

                    // Remove excess digits.
                    if ( i == 0 ) {
                        xc.length = ni;
                        k = 1;
                        ni--;
                    } else {
                        xc.length = ni + 1;
                        k = pows10[ LOG_BASE - i ];

                        // E.g. 56700 becomes 56000 if 7 is the rounding digit.
                        // j > 0 means i > number of leading zeros of n.
                        xc[ni] = j > 0 ? mathfloor( n / pows10[ d - j ] % pows10[j] ) * k : 0;
                    }

                    // Round up?
                    if (r) {

                        for ( ; ; ) {

                            // If the digit to be rounded up is in the first element of xc...
                            if ( ni == 0 ) {

                                // i will be the length of xc[0] before k is added.
                                for ( i = 1, j = xc[0]; j >= 10; j /= 10, i++ );
                                j = xc[0] += k;
                                for ( k = 1; j >= 10; j /= 10, k++ );

                                // if i != k the length has increased.
                                if ( i != k ) {
                                    x.e++;
                                    if ( xc[0] == BASE ) xc[0] = 1;
                                }

                                break;
                            } else {
                                xc[ni] += k;
                                if ( xc[ni] != BASE ) break;
                                xc[ni--] = 0;
                                k = 1;
                            }
                        }
                    }

                    // Remove trailing zeros.
                    for ( i = xc.length; xc[--i] === 0; xc.pop() );
                }

                // Overflow? Infinity.
                if ( x.e > MAX_EXP ) {
                    x.c = x.e = null;

                // Underflow? Zero.
                } else if ( x.e < MIN_EXP ) {
                    x.c = [ x.e = 0 ];
                }
            }

            return x;
        }


        // PROTOTYPE/INSTANCE METHODS


        /*
         * Return a new BigNumber whose value is the absolute value of this BigNumber.
         */
        P.absoluteValue = P.abs = function () {
            var x = new BigNumber(this);
            if ( x.s < 0 ) x.s = 1;
            return x;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber rounded to a whole
         * number in the direction of Infinity.
         */
        P.ceil = function () {
            return round( new BigNumber(this), this.e + 1, 2 );
        };


        /*
         * Return
         * 1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
         * -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
         * 0 if they have the same value,
         * or null if the value of either is NaN.
         */
        P.comparedTo = P.cmp = function ( y, b ) {
            id = 1;
            return compare( this, new BigNumber( y, b ) );
        };


        /*
         * Return the number of decimal places of the value of this BigNumber, or null if the value
         * of this BigNumber is Â±Infinity or NaN.
         */
        P.decimalPlaces = P.dp = function () {
            var n, v,
                c = this.c;

            if ( !c ) return null;
            n = ( ( v = c.length - 1 ) - bitFloor( this.e / LOG_BASE ) ) * LOG_BASE;

            // Subtract the number of trailing zeros of the last number.
            if ( v = c[v] ) for ( ; v % 10 == 0; v /= 10, n-- );
            if ( n < 0 ) n = 0;

            return n;
        };


        /*
         *  n / 0 = I
         *  n / N = N
         *  n / I = 0
         *  0 / n = 0
         *  0 / 0 = N
         *  0 / N = N
         *  0 / I = 0
         *  N / n = N
         *  N / 0 = N
         *  N / N = N
         *  N / I = N
         *  I / n = I
         *  I / 0 = I
         *  I / N = N
         *  I / I = N
         *
         * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
         * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
         */
        P.dividedBy = P.div = function ( y, b ) {
            id = 3;
            return div( this, new BigNumber( y, b ), DECIMAL_PLACES, ROUNDING_MODE );
        };


        /*
         * Return a new BigNumber whose value is the integer part of dividing the value of this
         * BigNumber by the value of BigNumber(y, b).
         */
        P.dividedToIntegerBy = P.divToInt = function ( y, b ) {
            id = 4;
            return div( this, new BigNumber( y, b ), 0, 1 );
        };


        /*
         * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
         * otherwise returns false.
         */
        P.equals = P.eq = function ( y, b ) {
            id = 5;
            return compare( this, new BigNumber( y, b ) ) === 0;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber rounded to a whole
         * number in the direction of -Infinity.
         */
        P.floor = function () {
            return round( new BigNumber(this), this.e + 1, 3 );
        };


        /*
         * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
         * otherwise returns false.
         */
        P.greaterThan = P.gt = function ( y, b ) {
            id = 6;
            return compare( this, new BigNumber( y, b ) ) > 0;
        };


        /*
         * Return true if the value of this BigNumber is greater than or equal to the value of
         * BigNumber(y, b), otherwise returns false.
         */
        P.greaterThanOrEqualTo = P.gte = function ( y, b ) {
            id = 7;
            return ( b = compare( this, new BigNumber( y, b ) ) ) === 1 || b === 0;

        };


        /*
         * Return true if the value of this BigNumber is a finite number, otherwise returns false.
         */
        P.isFinite = function () {
            return !!this.c;
        };


        /*
         * Return true if the value of this BigNumber is an integer, otherwise return false.
         */
        P.isInteger = P.isInt = function () {
            return !!this.c && bitFloor( this.e / LOG_BASE ) > this.c.length - 2;
        };


        /*
         * Return true if the value of this BigNumber is NaN, otherwise returns false.
         */
        P.isNaN = function () {
            return !this.s;
        };


        /*
         * Return true if the value of this BigNumber is negative, otherwise returns false.
         */
        P.isNegative = P.isNeg = function () {
            return this.s < 0;
        };


        /*
         * Return true if the value of this BigNumber is 0 or -0, otherwise returns false.
         */
        P.isZero = function () {
            return !!this.c && this.c[0] == 0;
        };


        /*
         * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
         * otherwise returns false.
         */
        P.lessThan = P.lt = function ( y, b ) {
            id = 8;
            return compare( this, new BigNumber( y, b ) ) < 0;
        };


        /*
         * Return true if the value of this BigNumber is less than or equal to the value of
         * BigNumber(y, b), otherwise returns false.
         */
        P.lessThanOrEqualTo = P.lte = function ( y, b ) {
            id = 9;
            return ( b = compare( this, new BigNumber( y, b ) ) ) === -1 || b === 0;
        };


        /*
         *  n - 0 = n
         *  n - N = N
         *  n - I = -I
         *  0 - n = -n
         *  0 - 0 = 0
         *  0 - N = N
         *  0 - I = -I
         *  N - n = N
         *  N - 0 = N
         *  N - N = N
         *  N - I = N
         *  I - n = I
         *  I - 0 = I
         *  I - N = N
         *  I - I = N
         *
         * Return a new BigNumber whose value is the value of this BigNumber minus the value of
         * BigNumber(y, b).
         */
        P.minus = P.sub = function ( y, b ) {
            var i, j, t, xLTy,
                x = this,
                a = x.s;

            id = 10;
            y = new BigNumber( y, b );
            b = y.s;

            // Either NaN?
            if ( !a || !b ) return new BigNumber(NaN);

            // Signs differ?
            if ( a != b ) {
                y.s = -b;
                return x.plus(y);
            }

            var xe = x.e / LOG_BASE,
                ye = y.e / LOG_BASE,
                xc = x.c,
                yc = y.c;

            if ( !xe || !ye ) {

                // Either Infinity?
                if ( !xc || !yc ) return xc ? ( y.s = -b, y ) : new BigNumber( yc ? x : NaN );

                // Either zero?
                if ( !xc[0] || !yc[0] ) {

                    // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
                    return yc[0] ? ( y.s = -b, y ) : new BigNumber( xc[0] ? x :

                      // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                      ROUNDING_MODE == 3 ? -0 : 0 );
                }
            }

            xe = bitFloor(xe);
            ye = bitFloor(ye);
            xc = xc.slice();

            // Determine which is the bigger number.
            if ( a = xe - ye ) {

                if ( xLTy = a < 0 ) {
                    a = -a;
                    t = xc;
                } else {
                    ye = xe;
                    t = yc;
                }

                t.reverse();

                // Prepend zeros to equalise exponents.
                for ( b = a; b--; t.push(0) );
                t.reverse();
            } else {

                // Exponents equal. Check digit by digit.
                j = ( xLTy = ( a = xc.length ) < ( b = yc.length ) ) ? a : b;

                for ( a = b = 0; b < j; b++ ) {

                    if ( xc[b] != yc[b] ) {
                        xLTy = xc[b] < yc[b];
                        break;
                    }
                }
            }

            // x < y? Point xc to the array of the bigger number.
            if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;

            b = ( j = yc.length ) - ( i = xc.length );

            // Append zeros to xc if shorter.
            // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
            if ( b > 0 ) for ( ; b--; xc[i++] = 0 );
            b = BASE - 1;

            // Subtract yc from xc.
            for ( ; j > a; ) {

                if ( xc[--j] < yc[j] ) {
                    for ( i = j; i && !xc[--i]; xc[i] = b );
                    --xc[i];
                    xc[j] += BASE;
                }

                xc[j] -= yc[j];
            }

            // Remove leading zeros and adjust exponent accordingly.
            for ( ; xc[0] == 0; xc.splice(0, 1), --ye );

            // Zero?
            if ( !xc[0] ) {

                // Following IEEE 754 (2008) 6.3,
                // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
                y.s = ROUNDING_MODE == 3 ? -1 : 1;
                y.c = [ y.e = 0 ];
                return y;
            }

            // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
            // for finite x and y.
            return normalise( y, xc, ye );
        };


        /*
         *   n % 0 =  N
         *   n % N =  N
         *   n % I =  n
         *   0 % n =  0
         *  -0 % n = -0
         *   0 % 0 =  N
         *   0 % N =  N
         *   0 % I =  0
         *   N % n =  N
         *   N % 0 =  N
         *   N % N =  N
         *   N % I =  N
         *   I % n =  N
         *   I % 0 =  N
         *   I % N =  N
         *   I % I =  N
         *
         * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
         * BigNumber(y, b). The result depends on the value of MODULO_MODE.
         */
        P.modulo = P.mod = function ( y, b ) {
            var q, s,
                x = this;

            id = 11;
            y = new BigNumber( y, b );

            // Return NaN if x is Infinity or NaN, or y is NaN or zero.
            if ( !x.c || !y.s || y.c && !y.c[0] ) {
                return new BigNumber(NaN);

            // Return x if y is Infinity or x is zero.
            } else if ( !y.c || x.c && !x.c[0] ) {
                return new BigNumber(x);
            }

            if ( MODULO_MODE == 9 ) {

                // Euclidian division: q = sign(y) * floor(x / abs(y))
                // r = x - qy    where  0 <= r < abs(y)
                s = y.s;
                y.s = 1;
                q = div( x, y, 0, 3 );
                y.s = s;
                q.s *= s;
            } else {
                q = div( x, y, 0, MODULO_MODE );
            }

            return x.minus( q.times(y) );
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber negated,
         * i.e. multiplied by -1.
         */
        P.negated = P.neg = function () {
            var x = new BigNumber(this);
            x.s = -x.s || null;
            return x;
        };


        /*
         *  n + 0 = n
         *  n + N = N
         *  n + I = I
         *  0 + n = n
         *  0 + 0 = 0
         *  0 + N = N
         *  0 + I = I
         *  N + n = N
         *  N + 0 = N
         *  N + N = N
         *  N + I = N
         *  I + n = I
         *  I + 0 = I
         *  I + N = N
         *  I + I = I
         *
         * Return a new BigNumber whose value is the value of this BigNumber plus the value of
         * BigNumber(y, b).
         */
        P.plus = P.add = function ( y, b ) {
            var t,
                x = this,
                a = x.s;

            id = 12;
            y = new BigNumber( y, b );
            b = y.s;

            // Either NaN?
            if ( !a || !b ) return new BigNumber(NaN);

            // Signs differ?
             if ( a != b ) {
                y.s = -b;
                return x.minus(y);
            }

            var xe = x.e / LOG_BASE,
                ye = y.e / LOG_BASE,
                xc = x.c,
                yc = y.c;

            if ( !xe || !ye ) {

                // Return Â±Infinity if either Â±Infinity.
                if ( !xc || !yc ) return new BigNumber( a / 0 );

                // Either zero?
                // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
                if ( !xc[0] || !yc[0] ) return yc[0] ? y : new BigNumber( xc[0] ? x : a * 0 );
            }

            xe = bitFloor(xe);
            ye = bitFloor(ye);
            xc = xc.slice();

            // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
            if ( a = xe - ye ) {
                if ( a > 0 ) {
                    ye = xe;
                    t = yc;
                } else {
                    a = -a;
                    t = xc;
                }

                t.reverse();
                for ( ; a--; t.push(0) );
                t.reverse();
            }

            a = xc.length;
            b = yc.length;

            // Point xc to the longer array, and b to the shorter length.
            if ( a - b < 0 ) t = yc, yc = xc, xc = t, b = a;

            // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
            for ( a = 0; b; ) {
                a = ( xc[--b] = xc[b] + yc[b] + a ) / BASE | 0;
                xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
            }

            if (a) {
                xc = [a].concat(xc);
                ++ye;
            }

            // No need to check for zero, as +x + +y != 0 && -x + -y != 0
            // ye = MAX_EXP + 1 possible
            return normalise( y, xc, ye );
        };


        /*
         * Return the number of significant digits of the value of this BigNumber.
         *
         * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.
         */
        P.precision = P.sd = function (z) {
            var n, v,
                x = this,
                c = x.c;

            // 'precision() argument not a boolean or binary digit: {z}'
            if ( z != null && z !== !!z && z !== 1 && z !== 0 ) {
                if (ERRORS) raise( 13, 'argument' + notBool, z );
                if ( z != !!z ) z = null;
            }

            if ( !c ) return null;
            v = c.length - 1;
            n = v * LOG_BASE + 1;

            if ( v = c[v] ) {

                // Subtract the number of trailing zeros of the last element.
                for ( ; v % 10 == 0; v /= 10, n-- );

                // Add the number of digits of the first element.
                for ( v = c[0]; v >= 10; v /= 10, n++ );
            }

            if ( z && x.e + 1 > n ) n = x.e + 1;

            return n;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber rounded to a maximum of
         * dp decimal places using rounding mode rm, or to 0 and ROUNDING_MODE respectively if
         * omitted.
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'round() decimal places out of range: {dp}'
         * 'round() decimal places not an integer: {dp}'
         * 'round() rounding mode not an integer: {rm}'
         * 'round() rounding mode out of range: {rm}'
         */
        P.round = function ( dp, rm ) {
            var n = new BigNumber(this);

            if ( dp == null || isValidInt( dp, 0, MAX, 15 ) ) {
                round( n, ~~dp + this.e + 1, rm == null ||
                  !isValidInt( rm, 0, 8, 15, roundingMode ) ? ROUNDING_MODE : rm | 0 );
            }

            return n;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
         * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
         *
         * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
         *
         * If k is out of range and ERRORS is false, the result will be Â±0 if k < 0, or Â±Infinity
         * otherwise.
         *
         * 'shift() argument not an integer: {k}'
         * 'shift() argument out of range: {k}'
         */
        P.shift = function (k) {
            var n = this;
            return isValidInt( k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER, 16, 'argument' )

              // k < 1e+21, or truncate(k) will produce exponential notation.
              ? n.times( '1e' + truncate(k) )
              : new BigNumber( n.c && n.c[0] && ( k < -MAX_SAFE_INTEGER || k > MAX_SAFE_INTEGER )
                ? n.s * ( k < 0 ? 0 : 1 / 0 )
                : n );
        };


        /*
         *  sqrt(-n) =  N
         *  sqrt( N) =  N
         *  sqrt(-I) =  N
         *  sqrt( I) =  I
         *  sqrt( 0) =  0
         *  sqrt(-0) = -0
         *
         * Return a new BigNumber whose value is the square root of the value of this BigNumber,
         * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
         */
        P.squareRoot = P.sqrt = function () {
            var m, n, r, rep, t,
                x = this,
                c = x.c,
                s = x.s,
                e = x.e,
                dp = DECIMAL_PLACES + 4,
                half = new BigNumber('0.5');

            // Negative/NaN/Infinity/zero?
            if ( s !== 1 || !c || !c[0] ) {
                return new BigNumber( !s || s < 0 && ( !c || c[0] ) ? NaN : c ? x : 1 / 0 );
            }

            // Initial estimate.
            s = Math.sqrt( +x );

            // Math.sqrt underflow/overflow?
            // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
            if ( s == 0 || s == 1 / 0 ) {
                n = coeffToString(c);
                if ( ( n.length + e ) % 2 == 0 ) n += '0';
                s = Math.sqrt(n);
                e = bitFloor( ( e + 1 ) / 2 ) - ( e < 0 || e % 2 );

                if ( s == 1 / 0 ) {
                    n = '1e' + e;
                } else {
                    n = s.toExponential();
                    n = n.slice( 0, n.indexOf('e') + 1 ) + e;
                }

                r = new BigNumber(n);
            } else {
                r = new BigNumber( s + '' );
            }

            // Check for zero.
            // r could be zero if MIN_EXP is changed after the this value was created.
            // This would cause a division by zero (x/t) and hence Infinity below, which would cause
            // coeffToString to throw.
            if ( r.c[0] ) {
                e = r.e;
                s = e + dp;
                if ( s < 3 ) s = 0;

                // Newton-Raphson iteration.
                for ( ; ; ) {
                    t = r;
                    r = half.times( t.plus( div( x, t, dp, 1 ) ) );

                    if ( coeffToString( t.c   ).slice( 0, s ) === ( n =
                         coeffToString( r.c ) ).slice( 0, s ) ) {

                        // The exponent of r may here be one less than the final result exponent,
                        // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
                        // are indexed correctly.
                        if ( r.e < e ) --s;
                        n = n.slice( s - 3, s + 1 );

                        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
                        // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
                        // iteration.
                        if ( n == '9999' || !rep && n == '4999' ) {

                            // On the first iteration only, check to see if rounding up gives the
                            // exact result as the nines may infinitely repeat.
                            if ( !rep ) {
                                round( t, t.e + DECIMAL_PLACES + 2, 0 );

                                if ( t.times(t).eq(x) ) {
                                    r = t;
                                    break;
                                }
                            }

                            dp += 4;
                            s += 4;
                            rep = 1;
                        } else {

                            // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
                            // result. If not, then there are further digits and m will be truthy.
                            if ( !+n || !+n.slice(1) && n.charAt(0) == '5' ) {

                                // Truncate to the first rounding digit.
                                round( r, r.e + DECIMAL_PLACES + 2, 1 );
                                m = !r.times(r).eq(x);
                            }

                            break;
                        }
                    }
                }
            }

            return round( r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m );
        };


        /*
         *  n * 0 = 0
         *  n * N = N
         *  n * I = I
         *  0 * n = 0
         *  0 * 0 = 0
         *  0 * N = N
         *  0 * I = N
         *  N * n = N
         *  N * 0 = N
         *  N * N = N
         *  N * I = N
         *  I * n = I
         *  I * 0 = N
         *  I * N = N
         *  I * I = I
         *
         * Return a new BigNumber whose value is the value of this BigNumber times the value of
         * BigNumber(y, b).
         */
        P.times = P.mul = function ( y, b ) {
            var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
                base, sqrtBase,
                x = this,
                xc = x.c,
                yc = ( id = 17, y = new BigNumber( y, b ) ).c;

            // Either NaN, Â±Infinity or Â±0?
            if ( !xc || !yc || !xc[0] || !yc[0] ) {

                // Return NaN if either is NaN, or one is 0 and the other is Infinity.
                if ( !x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc ) {
                    y.c = y.e = y.s = null;
                } else {
                    y.s *= x.s;

                    // Return Â±Infinity if either is Â±Infinity.
                    if ( !xc || !yc ) {
                        y.c = y.e = null;

                    // Return Â±0 if either is Â±0.
                    } else {
                        y.c = [0];
                        y.e = 0;
                    }
                }

                return y;
            }

            e = bitFloor( x.e / LOG_BASE ) + bitFloor( y.e / LOG_BASE );
            y.s *= x.s;
            xcL = xc.length;
            ycL = yc.length;

            // Ensure xc points to longer array and xcL to its length.
            if ( xcL < ycL ) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;

            // Initialise the result array with zeros.
            for ( i = xcL + ycL, zc = []; i--; zc.push(0) );

            base = BASE;
            sqrtBase = SQRT_BASE;

            for ( i = ycL; --i >= 0; ) {
                c = 0;
                ylo = yc[i] % sqrtBase;
                yhi = yc[i] / sqrtBase | 0;

                for ( k = xcL, j = i + k; j > i; ) {
                    xlo = xc[--k] % sqrtBase;
                    xhi = xc[k] / sqrtBase | 0;
                    m = yhi * xlo + xhi * ylo;
                    xlo = ylo * xlo + ( ( m % sqrtBase ) * sqrtBase ) + zc[j] + c;
                    c = ( xlo / base | 0 ) + ( m / sqrtBase | 0 ) + yhi * xhi;
                    zc[j--] = xlo % base;
                }

                zc[j] = c;
            }

            if (c) {
                ++e;
            } else {
                zc.splice(0, 1);
            }

            return normalise( y, zc, e );
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber rounded to a maximum of
         * sd significant digits using rounding mode rm, or ROUNDING_MODE if rm is omitted.
         *
         * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toDigits() precision out of range: {sd}'
         * 'toDigits() precision not an integer: {sd}'
         * 'toDigits() rounding mode not an integer: {rm}'
         * 'toDigits() rounding mode out of range: {rm}'
         */
        P.toDigits = function ( sd, rm ) {
            var n = new BigNumber(this);
            sd = sd == null || !isValidInt( sd, 1, MAX, 18, 'precision' ) ? null : sd | 0;
            rm = rm == null || !isValidInt( rm, 0, 8, 18, roundingMode ) ? ROUNDING_MODE : rm | 0;
            return sd ? round( n, sd, rm ) : n;
        };


        /*
         * Return a string representing the value of this BigNumber in exponential notation and
         * rounded using ROUNDING_MODE to dp fixed decimal places.
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toExponential() decimal places not an integer: {dp}'
         * 'toExponential() decimal places out of range: {dp}'
         * 'toExponential() rounding mode not an integer: {rm}'
         * 'toExponential() rounding mode out of range: {rm}'
         */
        P.toExponential = function ( dp, rm ) {
            return format( this,
              dp != null && isValidInt( dp, 0, MAX, 19 ) ? ~~dp + 1 : null, rm, 19 );
        };


        /*
         * Return a string representing the value of this BigNumber in fixed-point notation rounding
         * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
         *
         * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
         * but e.g. (-0.00001).toFixed(0) is '-0'.
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toFixed() decimal places not an integer: {dp}'
         * 'toFixed() decimal places out of range: {dp}'
         * 'toFixed() rounding mode not an integer: {rm}'
         * 'toFixed() rounding mode out of range: {rm}'
         */
        P.toFixed = function ( dp, rm ) {
            return format( this, dp != null && isValidInt( dp, 0, MAX, 20 )
              ? ~~dp + this.e + 1 : null, rm, 20 );
        };


        /*
         * Return a string representing the value of this BigNumber in fixed-point notation rounded
         * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
         * of the FORMAT object (see BigNumber.config).
         *
         * FORMAT = {
         *      decimalSeparator : '.',
         *      groupSeparator : ',',
         *      groupSize : 3,
         *      secondaryGroupSize : 0,
         *      fractionGroupSeparator : '\xA0',    // non-breaking space
         *      fractionGroupSize : 0
         * };
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toFormat() decimal places not an integer: {dp}'
         * 'toFormat() decimal places out of range: {dp}'
         * 'toFormat() rounding mode not an integer: {rm}'
         * 'toFormat() rounding mode out of range: {rm}'
         */
        P.toFormat = function ( dp, rm ) {
            var str = format( this, dp != null && isValidInt( dp, 0, MAX, 21 )
              ? ~~dp + this.e + 1 : null, rm, 21 );

            if ( this.c ) {
                var i,
                    arr = str.split('.'),
                    g1 = +FORMAT.groupSize,
                    g2 = +FORMAT.secondaryGroupSize,
                    groupSeparator = FORMAT.groupSeparator,
                    intPart = arr[0],
                    fractionPart = arr[1],
                    isNeg = this.s < 0,
                    intDigits = isNeg ? intPart.slice(1) : intPart,
                    len = intDigits.length;

                if (g2) i = g1, g1 = g2, g2 = i, len -= i;

                if ( g1 > 0 && len > 0 ) {
                    i = len % g1 || g1;
                    intPart = intDigits.substr( 0, i );

                    for ( ; i < len; i += g1 ) {
                        intPart += groupSeparator + intDigits.substr( i, g1 );
                    }

                    if ( g2 > 0 ) intPart += groupSeparator + intDigits.slice(i);
                    if (isNeg) intPart = '-' + intPart;
                }

                str = fractionPart
                  ? intPart + FORMAT.decimalSeparator + ( ( g2 = +FORMAT.fractionGroupSize )
                    ? fractionPart.replace( new RegExp( '\\d{' + g2 + '}\\B', 'g' ),
                      '$&' + FORMAT.fractionGroupSeparator )
                    : fractionPart )
                  : intPart;
            }

            return str;
        };


        /*
         * Return a string array representing the value of this BigNumber as a simple fraction with
         * an integer numerator and an integer denominator. The denominator will be a positive
         * non-zero value less than or equal to the specified maximum denominator. If a maximum
         * denominator is not specified, the denominator will be the lowest value necessary to
         * represent the number exactly.
         *
         * [md] {number|string|BigNumber} Integer >= 1 and < Infinity. The maximum denominator.
         *
         * 'toFraction() max denominator not an integer: {md}'
         * 'toFraction() max denominator out of range: {md}'
         */
        P.toFraction = function (md) {
            var arr, d0, d2, e, exp, n, n0, q, s,
                k = ERRORS,
                x = this,
                xc = x.c,
                d = new BigNumber(ONE),
                n1 = d0 = new BigNumber(ONE),
                d1 = n0 = new BigNumber(ONE);

            if ( md != null ) {
                ERRORS = false;
                n = new BigNumber(md);
                ERRORS = k;

                if ( !( k = n.isInt() ) || n.lt(ONE) ) {

                    if (ERRORS) {
                        raise( 22,
                          'max denominator ' + ( k ? 'out of range' : 'not an integer' ), md );
                    }

                    // ERRORS is false:
                    // If md is a finite non-integer >= 1, round it to an integer and use it.
                    md = !k && n.c && round( n, n.e + 1, 1 ).gte(ONE) ? n : null;
                }
            }

            if ( !xc ) return x.toString();
            s = coeffToString(xc);

            // Determine initial denominator.
            // d is a power of 10 and the minimum max denominator that specifies the value exactly.
            e = d.e = s.length - x.e - 1;
            d.c[0] = POWS_TEN[ ( exp = e % LOG_BASE ) < 0 ? LOG_BASE + exp : exp ];
            md = !md || n.cmp(d) > 0 ? ( e > 0 ? d : n1 ) : n;

            exp = MAX_EXP;
            MAX_EXP = 1 / 0;
            n = new BigNumber(s);

            // n0 = d1 = 0
            n0.c[0] = 0;

            for ( ; ; )  {
                q = div( n, d, 0, 1 );
                d2 = d0.plus( q.times(d1) );
                if ( d2.cmp(md) == 1 ) break;
                d0 = d1;
                d1 = d2;
                n1 = n0.plus( q.times( d2 = n1 ) );
                n0 = d2;
                d = n.minus( q.times( d2 = d ) );
                n = d2;
            }

            d2 = div( md.minus(d0), d1, 0, 1 );
            n0 = n0.plus( d2.times(n1) );
            d0 = d0.plus( d2.times(d1) );
            n0.s = n1.s = x.s;
            e *= 2;

            // Determine which fraction is closer to x, n0/d0 or n1/d1
            arr = div( n1, d1, e, ROUNDING_MODE ).minus(x).abs().cmp(
                  div( n0, d0, e, ROUNDING_MODE ).minus(x).abs() ) < 1
                    ? [ n1.toString(), d1.toString() ]
                    : [ n0.toString(), d0.toString() ];

            MAX_EXP = exp;
            return arr;
        };


        /*
         * Return the value of this BigNumber converted to a number primitive.
         */
        P.toNumber = function () {
            return +this;
        };


        /*
         * Return a BigNumber whose value is the value of this BigNumber raised to the power n.
         * If m is present, return the result modulo m.
         * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
         * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using
         * ROUNDING_MODE.
         *
         * The modular power operation works efficiently when x, n, and m are positive integers,
         * otherwise it is equivalent to calculating x.toPower(n).modulo(m) (with POW_PRECISION 0).
         *
         * n {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
         * [m] {number|string|BigNumber} The modulus.
         *
         * 'pow() exponent not an integer: {n}'
         * 'pow() exponent out of range: {n}'
         *
         * Performs 54 loop iterations for n of 9007199254740991.
         */
        P.toPower = P.pow = function ( n, m ) {
            var k, y, z,
                i = mathfloor( n < 0 ? -n : +n ),
                x = this;

            if ( m != null ) {
                id = 23;
                m = new BigNumber(m);
            }

            // Pass Â±Infinity to Math.pow if exponent is out of range.
            if ( !isValidInt( n, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER, 23, 'exponent' ) &&
              ( !isFinite(n) || i > MAX_SAFE_INTEGER && ( n /= 0 ) ||
                parseFloat(n) != n && !( n = NaN ) ) || n == 0 ) {
                k = Math.pow( +x, n );
                return new BigNumber( m ? k % m : k );
            }

            if (m) {
                if ( n > 1 && x.gt(ONE) && x.isInt() && m.gt(ONE) && m.isInt() ) {
                    x = x.mod(m);
                } else {
                    z = m;

                    // Nullify m so only a single mod operation is performed at the end.
                    m = null;
                }
            } else if (POW_PRECISION) {

                // Truncating each coefficient array to a length of k after each multiplication
                // equates to truncating significant digits to POW_PRECISION + [28, 41],
                // i.e. there will be a minimum of 28 guard digits retained.
                // (Using + 1.5 would give [9, 21] guard digits.)
                k = mathceil( POW_PRECISION / LOG_BASE + 2 );
            }

            y = new BigNumber(ONE);

            for ( ; ; ) {
                if ( i % 2 ) {
                    y = y.times(x);
                    if ( !y.c ) break;
                    if (k) {
                        if ( y.c.length > k ) y.c.length = k;
                    } else if (m) {
                        y = y.mod(m);
                    }
                }

                i = mathfloor( i / 2 );
                if ( !i ) break;
                x = x.times(x);
                if (k) {
                    if ( x.c && x.c.length > k ) x.c.length = k;
                } else if (m) {
                    x = x.mod(m);
                }
            }

            if (m) return y;
            if ( n < 0 ) y = ONE.div(y);

            return z ? y.mod(z) : k ? round( y, POW_PRECISION, ROUNDING_MODE ) : y;
        };


        /*
         * Return a string representing the value of this BigNumber rounded to sd significant digits
         * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
         * necessary to represent the integer part of the value in fixed-point notation, then use
         * exponential notation.
         *
         * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toPrecision() precision not an integer: {sd}'
         * 'toPrecision() precision out of range: {sd}'
         * 'toPrecision() rounding mode not an integer: {rm}'
         * 'toPrecision() rounding mode out of range: {rm}'
         */
        P.toPrecision = function ( sd, rm ) {
            return format( this, sd != null && isValidInt( sd, 1, MAX, 24, 'precision' )
              ? sd | 0 : null, rm, 24 );
        };


        /*
         * Return a string representing the value of this BigNumber in base b, or base 10 if b is
         * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
         * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
         * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
         * TO_EXP_NEG, return exponential notation.
         *
         * [b] {number} Integer, 2 to 64 inclusive.
         *
         * 'toString() base not an integer: {b}'
         * 'toString() base out of range: {b}'
         */
        P.toString = function (b) {
            var str,
                n = this,
                s = n.s,
                e = n.e;

            // Infinity or NaN?
            if ( e === null ) {

                if (s) {
                    str = 'Infinity';
                    if ( s < 0 ) str = '-' + str;
                } else {
                    str = 'NaN';
                }
            } else {
                str = coeffToString( n.c );

                if ( b == null || !isValidInt( b, 2, 64, 25, 'base' ) ) {
                    str = e <= TO_EXP_NEG || e >= TO_EXP_POS
                      ? toExponential( str, e )
                      : toFixedPoint( str, e );
                } else {
                    str = convertBase( toFixedPoint( str, e ), b | 0, 10, s );
                }

                if ( s < 0 && n.c[0] ) str = '-' + str;
            }

            return str;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber truncated to a whole
         * number.
         */
        P.truncated = P.trunc = function () {
            return round( new BigNumber(this), this.e + 1, 1 );
        };


        /*
         * Return as toString, but do not accept a base argument, and include the minus sign for
         * negative zero.
         */
        P.valueOf = P.toJSON = function () {
            var str,
                n = this,
                e = n.e;

            if ( e === null ) return n.toString();

            str = coeffToString( n.c );

            str = e <= TO_EXP_NEG || e >= TO_EXP_POS
                ? toExponential( str, e )
                : toFixedPoint( str, e );

            return n.s < 0 ? '-' + str : str;
        };


        P.isBigNumber = true;

        if ( config != null ) BigNumber.config(config);

        return BigNumber;
    }


    // PRIVATE HELPER FUNCTIONS


    function bitFloor(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
    }


    // Return a coefficient array as a string of base 10 digits.
    function coeffToString(a) {
        var s, z,
            i = 1,
            j = a.length,
            r = a[0] + '';

        for ( ; i < j; ) {
            s = a[i++] + '';
            z = LOG_BASE - s.length;
            for ( ; z--; s = '0' + s );
            r += s;
        }

        // Determine trailing zeros.
        for ( j = r.length; r.charCodeAt(--j) === 48; );
        return r.slice( 0, j + 1 || 1 );
    }


    // Compare the value of BigNumbers x and y.
    function compare( x, y ) {
        var a, b,
            xc = x.c,
            yc = y.c,
            i = x.s,
            j = y.s,
            k = x.e,
            l = y.e;

        // Either NaN?
        if ( !i || !j ) return null;

        a = xc && !xc[0];
        b = yc && !yc[0];

        // Either zero?
        if ( a || b ) return a ? b ? 0 : -j : i;

        // Signs differ?
        if ( i != j ) return i;

        a = i < 0;
        b = k == l;

        // Either Infinity?
        if ( !xc || !yc ) return b ? 0 : !xc ^ a ? 1 : -1;

        // Compare exponents.
        if ( !b ) return k > l ^ a ? 1 : -1;

        j = ( k = xc.length ) < ( l = yc.length ) ? k : l;

        // Compare digit by digit.
        for ( i = 0; i < j; i++ ) if ( xc[i] != yc[i] ) return xc[i] > yc[i] ^ a ? 1 : -1;

        // Compare lengths.
        return k == l ? 0 : k > l ^ a ? 1 : -1;
    }


    /*
     * Return true if n is a valid number in range, otherwise false.
     * Use for argument validation when ERRORS is false.
     * Note: parseInt('1e+1') == 1 but parseFloat('1e+1') == 10.
     */
    function intValidatorNoErrors( n, min, max ) {
        return ( n = truncate(n) ) >= min && n <= max;
    }


    function isArray(obj) {
        return Object.prototype.toString.call(obj) == '[object Array]';
    }


    /*
     * Convert string of baseIn to an array of numbers of baseOut.
     * Eg. convertBase('255', 10, 16) returns [15, 15].
     * Eg. convertBase('ff', 16, 10) returns [2, 5, 5].
     */
    function toBaseOut( str, baseIn, baseOut ) {
        var j,
            arr = [0],
            arrL,
            i = 0,
            len = str.length;

        for ( ; i < len; ) {
            for ( arrL = arr.length; arrL--; arr[arrL] *= baseIn );
            arr[ j = 0 ] += ALPHABET.indexOf( str.charAt( i++ ) );

            for ( ; j < arr.length; j++ ) {

                if ( arr[j] > baseOut - 1 ) {
                    if ( arr[j + 1] == null ) arr[j + 1] = 0;
                    arr[j + 1] += arr[j] / baseOut | 0;
                    arr[j] %= baseOut;
                }
            }
        }

        return arr.reverse();
    }


    function toExponential( str, e ) {
        return ( str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str ) +
          ( e < 0 ? 'e' : 'e+' ) + e;
    }


    function toFixedPoint( str, e ) {
        var len, z;

        // Negative exponent?
        if ( e < 0 ) {

            // Prepend zeros.
            for ( z = '0.'; ++e; z += '0' );
            str = z + str;

        // Positive exponent
        } else {
            len = str.length;

            // Append zeros.
            if ( ++e > len ) {
                for ( z = '0', e -= len; --e; z += '0' );
                str += z;
            } else if ( e < len ) {
                str = str.slice( 0, e ) + '.' + str.slice(e);
            }
        }

        return str;
    }


    function truncate(n) {
        n = parseFloat(n);
        return n < 0 ? mathceil(n) : mathfloor(n);
    }


    // EXPORT


    BigNumber = constructorFactory();
    BigNumber['default'] = BigNumber.BigNumber = BigNumber;


    // AMD.
    if ( true ) {
        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () { return BigNumber; }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

    // Node.js and other environments that support module.exports.
    } else if ( typeof module != 'undefined' && module.exports ) {
        module.exports = BigNumber;

    // Browser.
    } else {
        if ( !globalObj ) globalObj = typeof self != 'undefined' ? self : Function('return this')();
        globalObj.BigNumber = BigNumber;
    }
})(this);


/***/ }),
/* 548 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAssets = getAssets;
exports.getAssetsArr = getAssetsArr;
exports.getDefaultAssetsIds = getDefaultAssetsIds;
exports.getAssetById = getAssetById;
/**
 * Returns object with all assets
 */
function getAssets(_ref) {
  var cache_assets = _ref.cache_assets;

  return cache_assets || {};
}

function getAssetsArr(_ref2) {
  var cache_assets = _ref2.cache_assets;

  var assets = [];
  for (var key in cache_assets) {
    if (/^1.3.(\d+)$/.test(key)) {
      assets.push(cache_assets[key]);
    }
  }
  return assets;
}

/**
 * Returns array with default assets ids
 */
function getDefaultAssetsIds(_ref3) {
  var defaultAssetsIds = _ref3.defaultAssetsIds;

  return defaultAssetsIds;
}

/**
 * Returns function to get asset by id
 */
function getAssetById(state) {
  var cache_assets = state.cache_assets;

  return function (id) {
    return cache_assets && cache_assets[id] ? cache_assets[id] : null;
  };
}

/***/ }),
/* 549 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var ls_key_exists = function _ls_key_exists(key, ls) {
  return key in ls;
};
exports.ls_key_exists = ls_key_exists;
exports.default = typeof window == "undefined" || typeof window.localStorage === "undefined" ? null : localStorage;

/***/ }),
/* 550 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _defineProperty2 = __webpack_require__(27);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _promise = __webpack_require__(4);

var _promise2 = _interopRequireDefault(_promise);

var _keys = __webpack_require__(24);

var _keys2 = _interopRequireDefault(_keys);

var _toConsumableArray2 = __webpack_require__(144);

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _regenerator = __webpack_require__(3);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _mutations;

// const GphMarket = API.Market['1.3.0'];


var _vue = __webpack_require__(19);

var _vue2 = _interopRequireDefault(_vue);

var _mutations2 = __webpack_require__(14);

var types = _interopRequireWildcard(_mutations2);

var _api = __webpack_require__(10);

var _api2 = _interopRequireDefault(_api);

var _market = __webpack_require__(393);

var _market2 = _interopRequireDefault(_market);

var _immutable = __webpack_require__(23);

var _immutable2 = _interopRequireDefault(_immutable);

var _market_utils = __webpack_require__(226);

var _market_utils2 = _interopRequireDefault(_market_utils);

var _utils = __webpack_require__(59);

var _utils2 = _interopRequireDefault(_utils);

var _MarketClasses = __webpack_require__(148);

var _bcxjsCores = __webpack_require__(7);

var _chainListener = __webpack_require__(224);

var _chainListener2 = _interopRequireDefault(_chainListener);

var _subscriptions = __webpack_require__(225);

var _subscriptions2 = _interopRequireDefault(_subscriptions);

var _bcxjsWs = __webpack_require__(8);

var _helper = __webpack_require__(34);

var _helper2 = _interopRequireDefault(_helper);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var actions = {
    cancelLimitOrder: function cancelLimitOrder(_ref, _ref2) {
        var dispatch = _ref.dispatch;
        var orderId = _ref2.orderId,
            _ref2$feeAssetId = _ref2.feeAssetId,
            feeAssetId = _ref2$feeAssetId === undefined ? "1.3.0" : _ref2$feeAssetId;

        if (!orderId) {
            return { code: 136, message: "Parameter 'orderId' can not be empty" };
        }
        return dispatch('transactions/_transactionOperations', {
            operations: [{
                op_type: 2,
                type: "limit_order_cancel",
                params: {
                    orderId: orderId,
                    fee_asset_id: feeAssetId
                }
            }]
        }, { root: true });
    },
    queryDebt: function queryDebt(_ref3, params) {
        var rootGetters = _ref3.rootGetters,
            dispatch = _ref3.dispatch;

        var account_id, debtAssetId, collateralAssetId, debt_asset, user_result, currentPosition, base_asset, base_asset_precision, _base_asset, smart_asset_res, _smart_asset_res$data, format_feed_price, format_feed_price_text, current_feed;

        return _regenerator2.default.async(function queryDebt$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        account_id = params.account_id, debtAssetId = params.debtAssetId, collateralAssetId = params.collateralAssetId;
                        _context.next = 3;
                        return _regenerator2.default.awrap(_api2.default.Assets.fetch_asset_one(debtAssetId));

                    case 3:
                        debt_asset = _context.sent;

                        if (!(debt_asset.code != 1)) {
                            _context.next = 6;
                            break;
                        }

                        return _context.abrupt('return', debt_asset);

                    case 6:
                        debtAssetId = debt_asset.data.id;
                        _context.next = 9;
                        return _regenerator2.default.awrap(dispatch("user/fetchUser", account_id, { root: true }));

                    case 9:
                        user_result = _context.sent;

                        if (!user_result.success) {
                            _context.next = 42;
                            break;
                        }

                        currentPosition = user_result.data.call_orders.filter(function (item) {
                            return !!item;
                        }).find(function (item) {
                            return item.call_price.quote.asset_id === debtAssetId;
                        });

                        if (!currentPosition) {
                            _context.next = 24;
                            break;
                        }

                        _context.next = 15;
                        return _regenerator2.default.awrap(_api2.default.Assets.fetch_asset_one(currentPosition.call_price.base.asset_id));

                    case 15:
                        base_asset = _context.sent;
                        base_asset_precision = base_asset.data.precision;


                        currentPosition.call_price_text = _utils2.default.format_price(currentPosition.call_price.quote.amount, debt_asset.data, currentPosition.call_price.base.amount, base_asset.data, false, true, false);

                        // currentPosition.call_price_text=(helper.getFullNum(currentPosition.call_price.base.amount,
                        //     base_asset_precision)/helper.getFullNum(currentPosition.call_price.quote.amount,
                        //         debt_asset.data.precision)).toFixed(base_asset_precision)+" "+base_asset.data.symbol+"/"+debt_asset.data.symbol;
                        //Call Price
                        currentPosition.collateral_value = _helper2.default.getFullNum(currentPosition.collateral, base_asset_precision);
                        currentPosition.debt_value = _helper2.default.getFullNum(currentPosition.debt, debt_asset.data.precision);
                        currentPosition.collateral_symbol = base_asset.data.symbol;
                        currentPosition.debt_symbol = debt_asset.data.symbol;
                        _context.next = 30;
                        break;

                    case 24:
                        if (collateralAssetId) {
                            _context.next = 26;
                            break;
                        }

                        return _context.abrupt('return', { code: 178, message: "collateralAssetId Can not be empty" });

                    case 26:
                        _context.next = 28;
                        return _regenerator2.default.awrap(_api2.default.Assets.fetch_asset_one(collateralAssetId));

                    case 28:
                        _base_asset = _context.sent;

                        // console.info("collateralAssetId",collateralAssetId,base_asset);
                        currentPosition = {
                            call_price_text: "æ— ",
                            collateral_value: 0,
                            debt_value: 0,
                            collateral_symbol: _base_asset.data.symbol,
                            debt_symbol: debt_asset.data.symbol
                        };

                    case 30:
                        _context.next = 32;
                        return _regenerator2.default.awrap(dispatch("assets/queryAssets", { assetId: debt_asset.data.symbol }, { root: true }));

                    case 32:
                        smart_asset_res = _context.sent;

                        if (!(smart_asset_res.code != 1)) {
                            _context.next = 35;
                            break;
                        }

                        return _context.abrupt('return', smart_asset_res);

                    case 35:
                        _smart_asset_res$data = smart_asset_res.data[0].bitasset_data, format_feed_price = _smart_asset_res$data.format_feed_price, format_feed_price_text = _smart_asset_res$data.format_feed_price_text, current_feed = _smart_asset_res$data.current_feed;

                        currentPosition.format_feed_price = format_feed_price;
                        currentPosition.format_feed_price_text = format_feed_price_text;
                        currentPosition.maintenance_collateral_ratio = current_feed.maintenance_collateral_ratio / 1000;
                        return _context.abrupt('return', { code: 1, data: currentPosition });

                    case 42:
                        return _context.abrupt('return', user_result);

                    case 43:
                    case 'end':
                        return _context.stop();
                }
            }
        }, null, undefined);
    },
    callOrderUpdate: function callOrderUpdate(_ref4, params) {
        var commit = _ref4.commit,
            rootGetters = _ref4.rootGetters,
            dispatch = _ref4.dispatch;

        var collateralAmount, collateralAssetId, debtAmount, debtAssetId, account, collateral_asset, debt_asset, delta_collateral, delta_debt, user_result, currentPosition, _currentPosition;

        return _regenerator2.default.async(function callOrderUpdate$(_context2) {
            while (1) {
                switch (_context2.prev = _context2.next) {
                    case 0:
                        if (!(!_helper2.default.trimParams(params) || !params.collateralAmount || !params.debtAmount)) {
                            _context2.next = 2;
                            break;
                        }

                        return _context2.abrupt('return', { code: 101, message: "Parameter is missing" });

                    case 2:
                        collateralAmount = params.collateralAmount, collateralAssetId = params.collateralAssetId, debtAmount = params.debtAmount, debtAssetId = params.debtAssetId, account = params.account;

                        collateralAmount = Number(collateralAmount);
                        debtAmount = Number(debtAmount);
                        collateralAmount = isNaN(collateralAmount) ? 0 : collateralAmount;
                        debtAmount = isNaN(debtAmount) ? 0 : debtAmount;

                        _context2.next = 9;
                        return _regenerator2.default.awrap(_api2.default.Assets.fetch_asset_one(collateralAssetId));

                    case 9:
                        collateral_asset = _context2.sent;
                        _context2.next = 12;
                        return _regenerator2.default.awrap(_api2.default.Assets.fetch_asset_one(debtAssetId));

                    case 12:
                        debt_asset = _context2.sent;

                        if (!(collateral_asset.code != 1)) {
                            _context2.next = 15;
                            break;
                        }

                        return _context2.abrupt('return', collateral_asset);

                    case 15:
                        if (!(debt_asset.code != 1)) {
                            _context2.next = 17;
                            break;
                        }

                        return _context2.abrupt('return', debt_asset);

                    case 17:
                        _context2.next = 19;
                        return _regenerator2.default.awrap(_helper2.default.toOpAmount(collateralAmount, collateral_asset.data));

                    case 19:
                        delta_collateral = _context2.sent.data;
                        _context2.next = 22;
                        return _regenerator2.default.awrap(_helper2.default.toOpAmount(debtAmount, debt_asset.data));

                    case 22:
                        delta_debt = _context2.sent.data;
                        _context2.next = 25;
                        return _regenerator2.default.awrap(dispatch("user/fetchUser", account.id, { root: true }));

                    case 25:
                        user_result = _context2.sent;
                        currentPosition = {
                            collateral: null,
                            debt: null
                        };

                        if (!user_result.success) {
                            _context2.next = 32;
                            break;
                        }

                        _currentPosition = user_result.data.call_orders.filter(function (item) {
                            return !!item;
                        }).find(function (item) {
                            return item.call_price.quote.asset_id === debtAssetId;
                        });

                        if (_currentPosition) currentPosition = _currentPosition;
                        _context2.next = 33;
                        break;

                    case 32:
                        return _context2.abrupt('return', user_result);

                    case 33:

                        delta_collateral.amount = parseInt(delta_collateral.amount - currentPosition.collateral, 10);
                        delta_debt.amount = parseInt(delta_debt.amount - currentPosition.debt, 10);

                        return _context2.abrupt('return', dispatch('transactions/_transactionOperations', {
                            operations: [{
                                op_type: 3,
                                type: "call_order_update",
                                params: {
                                    funding_account: rootGetters["account/getAccountUserId"],
                                    delta_collateral: delta_collateral,
                                    delta_debt: delta_debt
                                }
                            }]
                        }, { root: true }));

                    case 36:
                    case 'end':
                        return _context2.stop();
                }
            }
        }, null, undefined);
    },
    createLimitOrder: function createLimitOrder(_ref5, _ref6) {
        var dispatch = _ref5.dispatch,
            rootGetters = _ref5.rootGetters;
        var price = _ref6.price,
            amount = _ref6.amount,
            transactionPair = _ref6.transactionPair,
            _ref6$type = _ref6.type,
            type = _ref6$type === undefined ? 0 : _ref6$type,
            callback = _ref6.callback,
            _ref6$isAsk = _ref6.isAsk,
            isAsk = _ref6$isAsk === undefined ? true : _ref6$isAsk,
            _ref6$onlyGetFee = _ref6.onlyGetFee,
            onlyGetFee = _ref6$onlyGetFee === undefined ? false : _ref6$onlyGetFee;

        var quoteAsset, baseAsset, coreAsset, currentAccount, _amount, turnover, a, val, current, accountBalance, quoteBalance, baseBalance, coreBalance, id, order;

        return _regenerator2.default.async(function createLimitOrder$(_context3) {
            while (1) {
                switch (_context3.prev = _context3.next) {
                    case 0:

                        transactionPair = transactionPair.split("_");
                        _context3.next = 3;
                        return _regenerator2.default.awrap(dispatch("assets/fetchAssets", { assets: [transactionPair[0]], isOne: true }, { root: true }));

                    case 3:
                        quoteAsset = _context3.sent;
                        _context3.next = 6;
                        return _regenerator2.default.awrap(dispatch("assets/fetchAssets", { assets: [transactionPair[1]], isOne: true }, { root: true }));

                    case 6:
                        baseAsset = _context3.sent;
                        _context3.next = 9;
                        return _regenerator2.default.awrap(dispatch("assets/fetchAssets", { assets: ["1.3.0"], isOne: true }, { root: true }));

                    case 9:
                        coreAsset = _context3.sent;
                        currentAccount = rootGetters["user/getAllAccountObject"];
                        // let {
                        //   sellFeeAsset,
                        //   sellFeeAssets,
                        //   sellFee
                        //  } = getFeeAssets(quoteAsset, baseAsset, coreAsset,currentAccount);

                        _amount = new _MarketClasses.Asset({
                            asset_id: quoteAsset.id,
                            precision: quoteAsset.precision
                        });
                        turnover = new _MarketClasses.Asset({
                            asset_id: baseAsset.id,
                            precision: baseAsset.precision
                        });


                        price = new _MarketClasses.Price({
                            base: isAsk ? _amount : turnover,
                            quote: isAsk ? turnover : _amount,
                            real: parseFloat(price) || 0
                        });

                        a = parseFloat(amount) || 0;
                        val = price.toReal() * a;


                        amount = _amount;
                        amount.setAmount({ real: a || 0 });
                        turnover.setAmount({ real: val || 0 });

                        current = {
                            orderType: 0,
                            price: price,
                            amount: amount,
                            turnover: turnover
                            //   chargefee:sellFee
                        };
                        accountBalance = currentAccount.balances;
                        quoteBalance = void 0, baseBalance = void 0, coreBalance = void 0;

                        if (accountBalance) {
                            for (id in accountBalance) {
                                if (id === quoteAsset.id) {
                                    quoteBalance = accountBalance[id].balance;
                                }
                                if (id === baseAsset.id) {
                                    baseBalance = accountBalance[id].balance;
                                }
                                if (id === "1.3.0") {
                                    coreBalance = accountBalance[id].balance;
                                }
                            }
                        }
                        quoteBalance = current.amount.clone(quoteBalance ? parseInt(quoteBalance, 10) : 0);
                        coreBalance = new _MarketClasses.Asset({
                            amount: coreBalance ? parseInt(coreBalance, 10) : 0
                        });

                        // let fee = utils.getFee("limit_order_create",sellFeeAsset,coreAsset);

                        // let feeID = verifyFee(fee, current.amount.getAmount(), quoteBalance.getAmount(), coreBalance.getAmount());
                        // if(!feeID){
                        //   return {code:1,message:"Insufficient funds to pay fees"};
                        // }
                        type = Number(type);
                        order = new _MarketClasses.LimitOrderCreate({
                            for_sale: type ? current.turnover : current.amount,
                            to_receive: type ? current.amount : current.turnover,
                            seller: currentAccount.account.id
                            // fee: {
                            //     asset_id: feeID,
                            //     amount: 0
                            // }
                        });


                        order.setExpiration();
                        order = order.toObject();
                        return _context3.abrupt('return', dispatch('transactions/_transactionOperations', {
                            operations: [{
                                op_type: 1,
                                type: "limit_order_create",
                                params: order
                            }],
                            onlyGetFee: onlyGetFee
                        }, { root: true }));

                    case 30:
                    case 'end':
                        return _context3.stop();
                }
            }
        }, null, undefined);
    },
    queryPriceHistory: function queryPriceHistory(_ref7, _ref8) {
        var dispatch = _ref7.dispatch;
        var trxSymbol = _ref8.trxSymbol,
            step = _ref8.step,
            _ref8$page = _ref8.page,
            page = _ref8$page === undefined ? 1 : _ref8$page,
            pageSize = _ref8.pageSize;

        var _trxSymbols, trxAssets, base, quote, endDate, _startDate, _endDate, startDateISO, endDateISO, history, prices;

        return _regenerator2.default.async(function queryPriceHistory$(_context4) {
            while (1) {
                switch (_context4.prev = _context4.next) {
                    case 0:
                        _trxSymbols = trxSymbol.split("_");
                        _context4.next = 3;
                        return _regenerator2.default.awrap(dispatch("assets/fetchAssets", { assets: _trxSymbols, isCache: true }, { root: true }));

                    case 3:
                        trxAssets = _context4.sent;
                        base = trxAssets[_trxSymbols[1]];
                        quote = trxAssets[_trxSymbols[0]];
                        endDate = new Date();
                        _startDate = new Date(endDate - step * 1000 * pageSize * page);
                        _endDate = new Date(endDate - step * 1000 * pageSize * (page - 1));
                        startDateISO = _startDate.toISOString().slice(0, -5);
                        endDateISO = _endDate.toISOString().slice(0, -5);
                        _context4.next = 13;
                        return _regenerator2.default.awrap(_bcxjsWs.Apis.instance().history_api().exec('get_market_history', [base.id, quote.id, step, startDateISO, endDateISO]));

                    case 13:
                        history = _context4.sent;
                        prices = _priceChart(history, _immutable2.default.fromJS(base), _immutable2.default.fromJS(quote), step);
                        return _context4.abrupt('return', { code: 1, data: prices });

                    case 16:
                    case 'end':
                        return _context4.stop();
                }
            }
        }, null, undefined);
    },
    getMarketStats: function getMarketStats(_ref9, params) {
        var dispatch = _ref9.dispatch,
            state = _ref9.state,
            getters = _ref9.getters;

        var quoteAssets, baseAsset, _params$days, days, _params$assetCache, assetCache, callback, quoteAssetsIds, baseAssetId;

        return _regenerator2.default.async(function getMarketStats$(_context5) {
            while (1) {
                switch (_context5.prev = _context5.next) {
                    case 0:
                        state.getMarketStatsParams = params && params.subscribe ? params : null;

                        if (params.subscribe && !getters.isSubscribed) {
                            dispatch("subscribeToMarket");
                        }

                        quoteAssets = params.quoteAssets, baseAsset = params.baseAsset, _params$days = params.days, days = _params$days === undefined ? 2 : _params$days, _params$assetCache = params.assetCache, assetCache = _params$assetCache === undefined ? true : _params$assetCache, callback = params.callback;
                        _context5.next = 5;
                        return _regenerator2.default.awrap(dispatch("assets/fetchAssets", { assets: [baseAsset].concat((0, _toConsumableArray3.default)(quoteAssets)), isCache: assetCache }, { root: true }));

                    case 5:
                        quoteAssets = _context5.sent;
                        quoteAssetsIds = [];
                        baseAssetId = "1.3.0";


                        (0, _keys2.default)(quoteAssets).forEach(function (asset_id) {
                            if (/1.3.\d+/.test(asset_id)) {
                                var asset = quoteAssets[asset_id];
                                if (asset.symbol != baseAsset) {
                                    quoteAssetsIds.push(asset_id);
                                } else {
                                    baseAssetId = asset_id;
                                }
                            }
                        });
                        return _context5.abrupt('return', dispatch("market/fetchMarketHistory_v1", {
                            assetsIds: quoteAssetsIds,
                            baseId: baseAssetId,
                            days: days
                        }, { root: true }).then(function (data) {
                            callback && callback({ code: 1, data: data });
                            return { code: 1, data: data };
                        }).catch(function (error) {
                            callback && callback({ code: 0, message: error.message, error: error });
                            return { code: 0, message: error.message, error: error };
                        }));

                    case 10:
                    case 'end':
                        return _context5.stop();
                }
            }
        }, null, undefined);
    },
    fetchMarketHistory_v1: function fetchMarketHistory_v1(store, _ref10) {
        var assetsIds = _ref10.assetsIds,
            baseId = _ref10.baseId,
            _ref10$days = _ref10.days,
            days = _ref10$days === undefined ? 2 : _ref10$days;
        var dispatch = store.dispatch,
            commit = store.commit,
            rootGetters = store.rootGetters;

        var assets = rootGetters['assets/getAssets'];
        var baseAsset = assets[baseId];
        commit(types.FETCH_MARKET_HISTORY_REQUEST, { baseId: baseId, days: days });
        return _promise2.default.all(assetsIds.map(function _callee(assetId) {
            var quote, result, marketStats, stats, price;
            return _regenerator2.default.async(function _callee$(_context6) {
                while (1) {
                    switch (_context6.prev = _context6.next) {
                        case 0:
                            // const prices = await API.Assets.fetchPriceHistory(baseAsset, assets[assetId], days);
                            // console.info("prices",prices);
                            quote = assets[assetId];
                            _context6.next = 3;
                            return _regenerator2.default.awrap(_api2.default.Assets.fetchPriceHistory(baseAsset, assets[assetId], days));

                        case 3:
                            result = _context6.sent;

                            if (result) {
                                _context6.next = 6;
                                break;
                            }

                            throw new Error('error market history');

                        case 6:
                            marketStats = {
                                history: result[0],
                                last: result[1],
                                market: quote.symbol + "_" + baseAsset.symbol,
                                base: baseAsset,
                                quote: quote
                                // console.info("result",result,marketStats);

                            };
                            stats = _calcMarketStats(marketStats.history, marketStats.base, marketStats.quote, marketStats.last);
                            price = _utils2.default.convertPrice(_immutable2.default.fromJS(marketStats.quote), _immutable2.default.fromJS(marketStats.base));


                            stats.latestPrice = stats && stats.latestPrice ? stats.latestPrice : stats && stats.close && stats.close.quote.amount && stats.close.base.amount ? _utils2.default.get_asset_price(stats.close.quote.amount, marketStats.quote, stats.close.base.amount, marketStats.base, true) : _utils2.default.get_asset_price(price.base.amount, marketStats.base, price.quote.amount, marketStats.quote);

                            stats.latest_price = stats.latestPrice.toFixed(baseAsset.precision);

                            delete stats.latestPrice;

                            stats.base_symbol = baseAsset.symbol;
                            stats.quote_symbol = quote.symbol;

                            stats.volume_base = stats.volumeBase;
                            stats.volume_quote = stats.volumeQuote;
                            delete stats.volumeBase;
                            delete stats.volumeQuote;

                            return _context6.abrupt('return', stats);

                        case 19:
                        case 'end':
                            return _context6.stop();
                    }
                }
            }, null, undefined);
        })).then(function (results) {
            return results.map(function (item) {
                delete item.close;
                return item;
            });
        }).catch(function () {
            commit(types.FETCH_MARKET_HISTORY_ERROR);
        });
    },
    fetchMarketHistory: function fetchMarketHistory(store, _ref11) {
        var assetsIds = _ref11.assetsIds,
            baseId = _ref11.baseId,
            days = _ref11.days;
        var commit = store.commit,
            rootGetters = store.rootGetters;

        var assets = rootGetters['assets/getAssets'];
        var baseAsset = assets[baseId];

        commit(types.FETCH_MARKET_HISTORY_REQUEST, { baseId: baseId, days: days });
        _promise2.default.all(assetsIds.map(function _callee2(assetId) {
            var prices;
            return _regenerator2.default.async(function _callee2$(_context7) {
                while (1) {
                    switch (_context7.prev = _context7.next) {
                        case 0:
                            _context7.next = 2;
                            return _regenerator2.default.awrap(_api2.default.Assets.fetchPriceHistory(baseAsset, assets[assetId], days));

                        case 2:
                            prices = _context7.sent;

                            if (prices) {
                                _context7.next = 5;
                                break;
                            }

                            throw new Error('error market history');

                        case 5:
                            return _context7.abrupt('return', {
                                assetId: assetId,
                                prices: prices
                            });

                        case 6:
                        case 'end':
                            return _context7.stop();
                    }
                }
            }, null, undefined);
        })).then(function (pricesObjects) {
            var prices = pricesObjects.reduce(function (result, obj) {
                result[obj.assetId] = obj.prices;
                return result;
            }, {});
            commit(types.FETCH_MARKET_HISTORY_COMPLETE, { prices: prices });
        }).catch(function () {
            commit(types.FETCH_MARKET_HISTORY_ERROR);
        });
    },
    getTransactionPairData: function getTransactionPairData(store, params) {
        var commit, state, dispatch, rootGetters, getters, transactionPair, _params$hasMyTradeHis, hasMyTradeHistory, callback, currentAccount;

        return _regenerator2.default.async(function getTransactionPairData$(_context8) {
            while (1) {
                switch (_context8.prev = _context8.next) {
                    case 0:
                        commit = store.commit, state = store.state, dispatch = store.dispatch, rootGetters = store.rootGetters, getters = store.getters;

                        state.getTrxPairDataParams = params.subscribe ? params : null;
                        transactionPair = params.transactionPair, _params$hasMyTradeHis = params.hasMyTradeHistory, hasMyTradeHistory = _params$hasMyTradeHis === undefined ? false : _params$hasMyTradeHis, callback = params.callback;
                        currentAccount = rootGetters["user/getAllAccountObject"];

                        if (params.subscribe && !getters.isSubscribed) {
                            dispatch("subscribeToMarket");
                        }
                        return _context8.abrupt('return', new _market2.default().subscribeToExchangeRate(transactionPair, currentAccount, hasMyTradeHistory, function (marketsDataRes, id, amount) {
                            callback && callback(marketsDataRes);
                        }).then(function () {
                            console.log('subscribed to market successfully');
                        }));

                    case 6:
                    case 'end':
                        return _context8.stop();
                }
            }
        }, null, undefined);
    },
    subscribeToMarket: function subscribeToMarket(_ref12) {
        var commit = _ref12.commit,
            state = _ref12.state,
            dispatch = _ref12.dispatch;

        var marketsSubscription = new _subscriptions2.default.Markets({
            callback: function callback(type, object) {
                clearTimeout(state.marketUpdateTimer);
                state.marketUpdateTimer = setTimeout(function () {
                    var getTrxPairDataParams = state.getTrxPairDataParams,
                        getMarketStatsParams = state.getMarketStatsParams;

                    if (getTrxPairDataParams) {
                        dispatch("getTransactionPairData", getTrxPairDataParams);
                    }
                    if (getMarketStatsParams) {
                        dispatch("getMarketStats", getMarketStatsParams);
                    }
                }, 500);
            }
        });
        _chainListener2.default.addSubscription(marketsSubscription);
        commit(types.SUB_TO_MARKET_COMPLETE);
    },
    unsubscribeFromMarket: function unsubscribeFromMarket(store, _ref13) {
        var balances = _ref13.balances;
        var commit = store.commit;

        var assetsIds = (0, _keys2.default)(balances);
        GphMarket.unsubscribeFromMarkets();
        _promise2.default.all(assetsIds.map(function (id) {
            console.log('unsubscribing: ', id);
            return GphMarket.unsubscribeFromExchangeRate(id);
        })).then(function () {
            commit(types.UNSUB_FROM_MARKET_COMPLETE);
            console.log('unsubscribed from market');
        });
    },


    updateMarketPrice: function updateMarketPrice(store, _ref14) {
        var assetId = _ref14.assetId,
            price = _ref14.price,
            GphMarket = _ref14.GphMarket;
        var commit, orders;
        return _regenerator2.default.async(function updateMarketPrice$(_context9) {
            while (1) {
                switch (_context9.prev = _context9.next) {
                    case 0:
                        commit = store.commit;

                        commit(types.UPDATE_MARKET_PRICE, { assetId: assetId, price: price });
                        _context9.next = 4;
                        return _regenerator2.default.awrap(store.dispatch('transactions/createOrdersFromDistribution', GphMarket, { root: true }));

                    case 4:
                        orders = _context9.sent;
                        return _context9.abrupt('return', orders);

                    case 6:
                    case 'end':
                        return _context9.stop();
                }
            }
        }, null, undefined);
    },

    setMarketStats: function setMarketStats(_ref15, payload) {
        var commit = _ref15.commit;

        commit(types.SET_MARKET_STATS, payload);
    }
};

var getFeeAssets = function getFeeAssets(quote, base, coreAsset, currentAccount) {
    quote = _immutable2.default.fromJS(quote);
    base = _immutable2.default.fromJS(base);
    currentAccount = _immutable2.default.fromJS(currentAccount);
    function addMissingAsset(target, asset) {
        if (target.indexOf(asset) === -1) {
            target.push(asset);
        }
    }

    var sellFeeAssets = [coreAsset, quote === coreAsset ? base : quote];
    addMissingAsset(sellFeeAssets, quote);
    addMissingAsset(sellFeeAssets, base);
    var sellFeeAsset = void 0;

    var balances = {};

    currentAccount.get("balances", []).filter(function (balance, id) {
        return ["1.3.0", quote.get("id"), base.get("id")].indexOf(id) >= 0;
    }).forEach(function (balance, id) {
        var balanceObject = balance;
        balances[id] = {
            balance: balanceObject ? parseInt(balanceObject.get("balance"), 10) : 0,
            fee: _utils2.default.getFee("limit_order_create", _bcxjsCores.ChainStore.getAsset(id))
        };
    });

    // await Promise.all(currentAccount.get("balances", []).filter((balance, id) => {
    //     return (["1.3.0", quote.get("id"), base.get("id")].indexOf(id) >= 0);
    // }).map(async (balance, id) => {
    //     let balanceObject = balance;
    //     let coreAsset=(await API.Assets.fetch_asset_one(id)).data;
    //     console.info('coreAsset',coreAsset,id);

    //     balances[id] = {
    //         balance: balanceObject ? parseInt(balanceObject.get("balance"), 10) : 0,
    //         fee: utils.getFee("limit_order_create",coreAsset)
    //     };
    // }))

    sellFeeAssets = sellFeeAssets.filter(function (a) {
        if (!balances[a.id]) {
            return false;
        }
        return balances[a.id].balance > balances[a.id].fee.getAmount();
    });

    if (!sellFeeAssets.length) {
        sellFeeAsset = coreAsset;
        sellFeeAssets.push(coreAsset);
    } else {
        sellFeeAsset = sellFeeAssets[Math.min(sellFeeAssets.length - 1, 0)]; //sellFeeAssetIdx
    }

    //   let sellFee = utils.getFee("limit_order_create",sellFeeAsset);

    return {
        sellFeeAsset: sellFeeAsset,
        sellFeeAssets: sellFeeAssets
        //sellFee
    };
};

var verifyFee = function verifyFee(fee, sellAmount, sellBalance, coreBalance) {
    var coreFee = _utils2.default.getFee("limit_order_create");

    var sellSum = fee.getAmount() + sellAmount;
    if (fee.asset_id === "1.3.0") {
        if (coreFee.getAmount() <= coreBalance) {
            return "1.3.0";
        } else {
            return null;
        }
    } else {

        if (sellSum <= sellBalance) {
            // sufficient funds
            return fee.asset_id;
        } else if (coreFee.getAmount() <= coreBalance && fee.asset_id !== "1.3.0") {
            // sufficient core assets for fee cost
            return "1.3.0";
        } else {
            return null; // insufficient funds
        }
    }
};

var getters = {
    getPriceById: function getPriceById(state) {
        return function (assetId) {
            if (assetId === state.baseId) return 1;
            return state.prices[assetId] || 0;
        };
    },
    getBaseAssetId: function getBaseAssetId(state) {
        return state.baseAssetId;
    },
    getAssetMultiplier: function getAssetMultiplier(state) {
        return function (assetId) {
            if (!state.history[assetId]) {
                return {
                    first: 0,
                    last: 0
                };
            }
            return {
                first: 1 / state.history[assetId].first,
                last: 1 / state.history[assetId].last
            };
        };
    },
    getMarketHistory: function getMarketHistory(state) {
        return state.history;
    },
    isFetching: function isFetching(state) {
        return state.pending;
    },
    isError: function isError(state) {
        return state.error;
    },
    isSubscribed: function isSubscribed(state) {
        return state.subscribed;
    },
    getAllMarketStats: function getAllMarketStats(state) {
        return state.allMarketStats;
    }
};

var initialState = {
    history: {},
    days: 7,
    pending: false,
    error: false,
    baseAssetId: null,
    subscribed: false,
    prices: {},
    allMarketStats: {},
    markets: {},
    getMarketStatsParams: null,
    getTrxPairDataParams: null,
    marketUpdateTimer: 0
};

var mutations = (_mutations = {}, (0, _defineProperty3.default)(_mutations, types.FETCH_MARKET_HISTORY_REQUEST, function (state, _ref16) {
    var baseId = _ref16.baseId,
        days = _ref16.days;

    state.fetching = true;
    state.baseAssetId = baseId;
    state.days = days;
}), (0, _defineProperty3.default)(_mutations, types.FETCH_MARKET_HISTORY_COMPLETE, function (state, _ref17) {
    var prices = _ref17.prices;

    state.fetching = false;
    (0, _keys2.default)(prices).forEach(function (assetId) {
        _vue2.default.set(state.history, assetId, prices[assetId]);
    });
}), (0, _defineProperty3.default)(_mutations, types.FETCH_MARKET_HISTORY_ERROR, function (state) {
    state.fetching = false;
    state.error = true;
}), (0, _defineProperty3.default)(_mutations, types.UPDATE_MARKET_PRICE, function (state, _ref18) {
    var assetId = _ref18.assetId,
        price = _ref18.price;

    if (!state.history[assetId]) _vue2.default.set(state.history, assetId, {});
    _vue2.default.set(state.history[assetId], 'last', price);
}), (0, _defineProperty3.default)(_mutations, types.SUB_TO_MARKET_COMPLETE, function (state) {
    state.subscribed = true;
}), (0, _defineProperty3.default)(_mutations, types.UNSUB_FROM_MARKET_COMPLETE, function (state) {
    state.subscribed = false;
}), (0, _defineProperty3.default)(_mutations, types.SET_MARKET_STATS, function (state, payload) {
    if (payload) {
        var stats = _calcMarketStats(payload.history, payload.base, payload.quote, payload.last);
        _vue2.default.set(state.allMarketStats, payload.market, stats);
    }
}), _mutations);

var _calcMarketStats = function _calcMarketStats(history, baseAsset, quoteAsset, recent) {
    var yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    // console.info("yesterday",yesterday.format("yyyy/MM:dd HH:mm:ss"))

    yesterday = yesterday.getTime();
    var volumeBase = 0,
        volumeQuote = 0,
        change = 0,
        last = { close_quote: null, close_base: null },
        invert = void 0,
        latestPrice = void 0,
        noTrades = true;

    baseAsset = _immutable2.default.fromJS(baseAsset);
    quoteAsset = _immutable2.default.fromJS(quoteAsset);

    if (history.length) {
        var first = void 0;
        history.forEach(function (bucket, i) {
            var date = new Date(bucket.key.open + "+00:00").getTime();
            if (date > yesterday) {
                noTrades = false;
                if (!first) {
                    first = history[i > 0 ? i - 1 : i];
                    invert = first.key.base === baseAsset.get("id");
                }
                if (invert) {
                    volumeBase += parseInt(bucket.base_volume, 10);
                    volumeQuote += parseInt(bucket.quote_volume, 10);
                } else {
                    volumeQuote += parseInt(bucket.base_volume, 10);
                    volumeBase += parseInt(bucket.quote_volume, 10);
                }
            }
        });
        if (!first) {
            first = history[0];
        }
        last = history[history.length - 1];
        var open = void 0,
            _close = void 0;
        if (invert) {
            open = _utils2.default.get_asset_price(first.open_quote, quoteAsset, first.open_base, baseAsset, invert);
            _close = _utils2.default.get_asset_price(last.close_quote, quoteAsset, last.close_base, baseAsset, invert);
        } else {
            open = _utils2.default.get_asset_price(first.open_quote, baseAsset, first.open_base, quoteAsset, invert); //Opening price
            _close = _utils2.default.get_asset_price(last.close_quote, baseAsset, last.close_base, quoteAsset, invert); //Closing price
        }
        change = noTrades ? 0 : Math.round(10000 * (_close - open) / open) / 100;
    }

    if (recent && recent.length && recent.length > 1) {
        var order = recent[1].op;
        var paysAsset = void 0,
            receivesAsset = void 0,
            isAsk = false;

        if (order.pays.asset_id === baseAsset.get("id")) {
            paysAsset = baseAsset;
            receivesAsset = quoteAsset;
            isAsk = true;
        } else {
            paysAsset = quoteAsset;
            receivesAsset = baseAsset;
        }
        var flipped = baseAsset.get("id").split(".")[2] > quoteAsset.get("id").split(".")[2];
        latestPrice = _market_utils2.default.parse_order_history(order, paysAsset, receivesAsset, isAsk, flipped).full;
    }

    var close = last.close_base && last.close_quote ? {
        quote: {
            amount: invert ? last.close_quote : last.close_base,
            asset_id: invert ? last.key.quote : last.key.base
        },
        base: {
            amount: invert ? last.close_base : last.close_quote,
            asset_id: invert ? last.key.base : last.key.quote
        }
    } : null;

    return {
        change: change.toFixed(2),
        volumeBase: _utils2.default.get_asset_amount(volumeBase, baseAsset),
        volumeQuote: _utils2.default.get_asset_amount(volumeQuote, quoteAsset),
        close: close,
        latestPrice: latestPrice
    };
};

var _priceChart = function _priceChart(priceHistory, baseAsset, quoteAsset, bucketSize) {
    var volumeData = [];
    var prices = [];

    var open = void 0,
        high = void 0,
        low = void 0,
        close = void 0,
        volume = void 0;

    var addTime = function addTime(time, i, bucketSize) {
        return new Date(time.getTime() + i * bucketSize * 1000);
    };

    for (var i = 0; i < priceHistory.length; i++) {
        var findMax = function findMax(a, b) {
            if (a !== Infinity && b !== Infinity) {
                return Math.max(a, b);
            } else if (a === Infinity) {
                return b;
            } else {
                return a;
            }
        };

        var findMin = function findMin(a, b) {
            if (a !== 0 && b !== 0) {
                return Math.min(a, b);
            } else if (a === 0) {
                return b;
            } else {
                return a;
            }
        };

        var current = priceHistory[i];
        if (!/Z$/.test(current.key.open)) {
            current.key.open += "Z";
        }
        var date = new Date(current.key.open);

        if (quoteAsset.get("id") === current.key.quote) {
            high = _utils2.default.get_asset_price(current.high_base, baseAsset, current.high_quote, quoteAsset);
            low = _utils2.default.get_asset_price(current.low_base, baseAsset, current.low_quote, quoteAsset);
            open = _utils2.default.get_asset_price(current.open_base, baseAsset, current.open_quote, quoteAsset);
            close = _utils2.default.get_asset_price(current.close_base, baseAsset, current.close_quote, quoteAsset);
            volume = _utils2.default.get_asset_amount(current.quote_volume, quoteAsset);
        } else {
            low = _utils2.default.get_asset_price(current.high_quote, baseAsset, current.high_base, quoteAsset);
            high = _utils2.default.get_asset_price(current.low_quote, baseAsset, current.low_base, quoteAsset);
            open = _utils2.default.get_asset_price(current.open_quote, baseAsset, current.open_base, quoteAsset);
            close = _utils2.default.get_asset_price(current.close_quote, baseAsset, current.close_base, quoteAsset);
            volume = _utils2.default.get_asset_amount(current.base_volume, quoteAsset);
        }

        if (low === 0) {
            low = findMin(open, close);
        }

        if (isNaN(high) || high === Infinity) {
            high = findMax(open, close);
        }

        if (close === Infinity || close === 0) {
            close = open;
        }

        if (open === Infinity || open === 0) {
            open = close;
        }

        if (high > 1.3 * ((open + close) / 2)) {
            high = findMax(open, close);
        }

        if (low < 0.7 * ((open + close) / 2)) {
            low = findMin(open, close);
        }

        prices.push({ date: date, open: open, high: high, low: low, close: close, volume: volume });
        volumeData.push([date, volume]);
    }

    // max buckets returned is 200, if we get less, fill in the gaps starting at the first data point
    var priceLength = prices.length;
    if (priceLength > 0 && priceLength < 200) {
        var now = new Date().getTime();
        // let firstDate = prices[0].date;
        // United Labs of BCTech.
        // ensure there's a final entry close to the current time
        var _i = 1;
        while (addTime(prices[0].date, _i, bucketSize).getTime() < now) {
            _i++;
        }
        var finalDate = addTime(prices[0].date, _i - 1, bucketSize);
        if (prices[priceLength - 1].date !== finalDate) {
            if (priceLength === 1) {
                prices.push({
                    date: addTime(finalDate, -1, bucketSize),
                    open: prices[0].close,
                    high: prices[0].close,
                    low: prices[0].close,
                    close: prices[0].close,
                    volume: 0
                });
                prices.push({
                    date: finalDate,
                    open: prices[0].close,
                    high: prices[0].close,
                    low: prices[0].close,
                    close: prices[0].close,
                    volume: 0
                });
                volumeData.push([addTime(finalDate, -1, bucketSize), 0]);
            } else {
                prices.push({
                    date: finalDate,
                    open: prices[priceLength - 1].close,
                    high: prices[priceLength - 1].close,
                    low: prices[priceLength - 1].close,
                    close: prices[priceLength - 1].close,
                    volume: 0
                });
            }
            volumeData.push([finalDate, 0]);
        }

        // Loop over the data and fill in any blank time periods
        for (var ii = 0; ii < prices.length - 1; ii++) {
            // If next date is beyond one bucket up
            if (prices[ii + 1].date.getTime() !== addTime(prices[ii].date, 1, bucketSize).getTime()) {
                // Break if next date is beyond now
                if (addTime(prices[ii].date, 1, bucketSize).getTime() > now) {
                    break;
                }

                prices.splice(ii + 1, 0, {
                    date: addTime(prices[ii].date, 1, bucketSize),
                    open: prices[ii].close,
                    high: prices[ii].close,
                    low: prices[ii].close,
                    close: prices[ii].close,
                    volume: 0
                });
                volumeData.splice(ii + 1, 0, [addTime(prices[ii].date, 1, bucketSize), 0]);
            }
        }
    }
    return prices;
};
exports.default = {
    state: initialState,
    actions: actions,
    getters: getters,
    mutations: mutations,
    namespaced: true
};

/***/ }),
/* 551 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(27);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _regenerator = __webpack_require__(3);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _stringify = __webpack_require__(18);

var _stringify2 = _interopRequireDefault(_stringify);

var _mutations;

var _vue = __webpack_require__(19);

var _vue2 = _interopRequireDefault(_vue);

var _mutations2 = __webpack_require__(14);

var types = _interopRequireWildcard(_mutations2);

var _api = __webpack_require__(10);

var _api2 = _interopRequireDefault(_api);

var _subscriptions = __webpack_require__(225);

var _subscriptions2 = _interopRequireDefault(_subscriptions);

var _helper = __webpack_require__(34);

var _helper2 = _interopRequireDefault(_helper);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var actions = {
  queryUserOperations: function queryUserOperations(_ref, params) {
    var dispatch = _ref.dispatch;
    var res;
    return _regenerator2.default.async(function queryUserOperations$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (params.limit) {
              _context.next = 2;
              break;
            }

            return _context.abrupt('return', { code: 101, message: "Parameter is missing" });

          case 2:
            _context.next = 4;
            return _regenerator2.default.awrap(dispatch("fetchUserOperations", params));

          case 4:
            res = _context.sent;

            try {
              res.data = JSON.parse((0, _stringify2.default)(res.data));
              res.data = res.data.operations;
            } catch (e) {}
            return _context.abrupt('return', res);

          case 7:
          case 'end':
            return _context.stop();
        }
      }
    }, null, undefined);
  },

  formatOperations: function formatOperations(store, _ref2) {
    var ops = _ref2.ops,
        _ref2$isReqDate = _ref2.isReqDate,
        isReqDate = _ref2$isReqDate === undefined ? false : _ref2$isReqDate;
    var res;
    return _regenerator2.default.async(function formatOperations$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return _regenerator2.default.awrap(_api2.default.Operations.parseOperations({ operations: ops, store: store, isReqDate: isReqDate }));

          case 2:
            res = _context2.sent;
            return _context2.abrupt('return', { code: 1, data: res.operations });

          case 4:
          case 'end':
            return _context2.stop();
        }
      }
    }, null, undefined);
  },
  /**
   * Dispatches actions to fetch user operations & subscribe to new operations of this user
   * @param {String} userId - user's id
   */

  /**
   * Fetches user operations
   * @param {String} userId - user's id
   */
  fetchUserOperations: function fetchUserOperations(store, _ref3) {
    var account_id = _ref3.account_id,
        limit = _ref3.limit,
        startId = _ref3.startId,
        endId = _ref3.endId;
    var commit, result;
    return _regenerator2.default.async(function fetchUserOperations$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            commit = store.commit;

            commit(types.FETCH_USER_OPERATIONS_REQUEST);

            _context3.next = 4;
            return _regenerator2.default.awrap(_api2.default.Operations.getUserOperations({ userId: account_id, limit: limit, store: store, startId: startId, endId: endId }));

          case 4:
            result = _context3.sent;

            if (result.code == 1) {
              // fetch assets used in operations
              // store.dispatch('assets/fetchAssets', { assets: result.data.assetsIds }, { root: true });
              commit(types.FETCH_USER_OPERATIONS_COMPLETE, {
                operations: result.data.operations
              });
            } else {
              commit(types.FETCH_USER_OPERATIONS_ERROR, {
                error: result.error
              });
            }
            return _context3.abrupt('return', result);

          case 7:
          case 'end':
            return _context3.stop();
        }
      }
    }, null, undefined);
  },

  /**
   * Add new operation to operation's list. This action is dispatched on a callback
    to new user's operation received
   * @param {String} userId - user's id
   * @param {Object} operation - operation date object
   */
  addUserOperation: function addUserOperation(store, _ref4) {
    var operation = _ref4.operation,
        userId = _ref4.userId;
    var commit, parsedData, type;
    return _regenerator2.default.async(function addUserOperation$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            commit = store.commit;
            // parse operation data for better format & information

            _context4.next = 3;
            return _regenerator2.default.awrap(_api2.default.Operations.parseOperations({
              operations: [operation],
              store: store
            }));

          case 3:
            parsedData = _context4.sent;

            if (parsedData) {
              _context4.next = 6;
              break;
            }

            return _context4.abrupt('return');

          case 6:
            type = parsedData.operations[0].type;

            if (type === 'transfer' || type === 'fill_order' || type === 'cancel_order') {}
            // update current user balances
            // todo : maybe refactor to modify balances directly
            //store.dispatch('account/fetchCurrentUser', null, { root: true });
            //United Labs of BCTech.

            // store.dispatch('assets/fetchAssets', { assets: parsedData.assetsIds }, { root: true });

            commit(types.ADD_USER_OPERATION, {
              operation: parsedData.operations[0]
            });

            return _context4.abrupt('return', parsedData.operations[0]);

          case 10:
          case 'end':
            return _context4.stop();
        }
      }
    }, null, undefined);
  },
  addAllOperation: function addAllOperation(store, _ref5) {
    var operation = _ref5.operation,
        userId = _ref5.userId;
    var commit, parsedData, type;
    return _regenerator2.default.async(function addAllOperation$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            commit = store.commit;
            // parse operation data for better format & information

            _context5.next = 3;
            return _regenerator2.default.awrap(_api2.default.Operations.parseOperations({
              operations: [operation],
              store: store,
              isReqDate: true
            }));

          case 3:
            parsedData = _context5.sent;

            if (parsedData) {
              _context5.next = 6;
              break;
            }

            return _context5.abrupt('return');

          case 6:
            type = parsedData.operations[0].type;
            return _context5.abrupt('return', parsedData.operations[0]);

          case 8:
          case 'end':
            return _context5.stop();
        }
      }
    }, null, undefined);
  },

  /**
   * Subscribes to new user's operations
   * @param {String} userId - user's id
   */
  subscribeToUserOperations: function subscribeToUserOperations(store, _ref6) {
    var userId = _ref6.userId,
        _callback = _ref6.callback;
    var commit, state, rootGetters;
    return _regenerator2.default.async(function subscribeToUserOperations$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            commit = store.commit, state = store.state, rootGetters = store.rootGetters;

            _api2.default.Explorer.getDynGlobalObject(true);

            _api2.default.ChainListener.addSubscription(new _subscriptions2.default.UserOperations({
              userId: userId,
              callback: function callback(operation) {
                return _regenerator2.default.async(function callback$(_context6) {
                  while (1) {
                    switch (_context6.prev = _context6.next) {
                      case 0:
                        _context6.next = 2;
                        return _regenerator2.default.awrap(actions.addUserOperation(store, { operation: operation, userId: userId }));

                      case 2:
                        operation = _context6.sent;

                        operation = JSON.parse((0, _stringify2.default)(operation));
                        _callback && _callback({
                          code: 1,
                          data: {
                            operations: JSON.parse((0, _stringify2.default)(state.list)),
                            operation: operation
                          }
                        });

                      case 5:
                      case 'end':
                        return _context6.stop();
                    }
                  }
                }, null, undefined);
              }
            }));
            commit(types.SUBSCRIBE_TO_USER_OPERATIONS);

          case 4:
          case 'end':
            return _context7.stop();
        }
      }
    }, null, undefined);
  },

  subscribeToAllOperations: function subscribeToAllOperations(store, _ref7) {
    var _this = this;

    var _callback2 = _ref7.callback;
    var commit = store.commit,
        state = store.state;

    _api2.default.Explorer.getDynGlobalObject(true);

    _api2.default.ChainListener.addSubscription(new _subscriptions2.default.AllOperations({
      callback: function callback(operation) {
        return _regenerator2.default.async(function callback$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return _regenerator2.default.awrap(actions.addAllOperation(store, { operation: operation, userId: "" }));

              case 2:
                operation = _context8.sent;

                operation = JSON.parse((0, _stringify2.default)(operation));
                _callback2 && _callback2({ code: 1, data: operation });
                //}, 50);

              case 5:
              case 'end':
                return _context8.stop();
            }
          }
        }, null, _this);
      }
    }));
  },
  subscribeBlocks: function subscribeBlocks(store, _ref8) {
    var _callback3 = _ref8.callback,
        _ref8$isReqTrx = _ref8.isReqTrx,
        isReqTrx = _ref8$isReqTrx === undefined ? false : _ref8$isReqTrx;
    var commit = store.commit,
        state = store.state,
        dispatch = store.dispatch,
        rootGetters = store.rootGetters;

    _api2.default.Explorer.getDynGlobalObject(true);

    _api2.default.ChainListener.addSubscription(new _subscriptions2.default.BlocksOp({
      isReqTrx: isReqTrx,
      callback: function callback(blockInfo) {
        dispatch("explorer/queryBlock", {
          block: blockInfo.head_block_number,
          isReqTrx: isReqTrx,
          maxOpCount: rootGetters["setting/g_settingsAPIs"].sub_max_ops,
          block_res: { code: 1, data: blockInfo }
        }, { root: true }).then(function (block) {
          _callback3 && _callback3(block);
        });
        // if(isReqTrx){
        //   dispatch("explorer/queryBlock",{
        //     United Labs of BCTech.,
        //     block:res.data.block_num,
        //     maxOpCount:20,
        //     block_res:res
        //   },{root:true}).then(block=>{
        //       callback&&callback(block);
        //   });  
        // }else{
        //   callback&&callback({code:1,data:res});
        // }
      }
    }));
    // commit(types.SUBSCRIBE_TO_USER_OPERATIONS);
  },

  unsubscribe: function unsubscribe(store, params) {
    var methods, types, method, delete_res, account, i;
    return _regenerator2.default.async(function unsubscribe$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            methods = [];

            if (params && params.methods && Array.isArray(params.methods)) {
              methods = params.methods;
            }

            if (methods.length) {
              _context9.next = 4;
              break;
            }

            return _context9.abrupt('return', _api2.default.ChainListener._deleteSubscription(""));

          case 4:
            types = {
              "subscribeToBlocks": "BlocksOp",
              "subscribeToChainTranscation": "allOperation",
              "subscribeToUserOperations": "userOperation",
              "subscribeToAccountOperations": "userOperation"
            };
            method = "", delete_res = void 0, account = "";
            i = 0;

          case 7:
            if (!(i < methods.length)) {
              _context9.next = 25;
              break;
            }

            method = methods[i];

            if (!/\|/.test(method)) {
              _context9.next = 19;
              break;
            }

            account = method.replace(/subscribeToAccountOperations\|/, "");

            if (!account) {
              _context9.next = 18;
              break;
            }

            _context9.next = 14;
            return _regenerator2.default.awrap(_api2.default.Account.getUser(account, true));

          case 14:
            account = _context9.sent;

            if (!(account.code != 1)) {
              _context9.next = 17;
              break;
            }

            return _context9.abrupt('return', account);

          case 17:
            account = account.data.account.id;

          case 18:
            method = "subscribeToUserOperations";

          case 19:
            if (!(method && !types[method])) {
              _context9.next = 21;
              break;
            }

            return _context9.abrupt('return', { code: 169, message: "Method does not exist" });

          case 21:
            _api2.default.ChainListener._deleteSubscription(types[method], account);

          case 22:
            i++;
            _context9.next = 7;
            break;

          case 25:
            return _context9.abrupt('return', { code: 1 });

          case 26:
          case 'end':
            return _context9.stop();
        }
      }
    }, null, undefined);
  },
  /**
   * Unsubscribes from new user's operations
   */
  unsubscribeFromUserOperations: function unsubscribeFromUserOperations(store) {
    var commit = store.commit;

    _api2.default.ChainListener.deleteSubscription('userOperation');
    commit(types.UNSUBSCRIBE_FROM_USER_OPERATIONS);
  },
  resetState: function resetState(store) {
    var commit = store.commit;

    commit(types.RESET_OPERATIONS);
  }
};

var getters = {
  getOperations: function getOperations(state) {
    return state.list;
  },
  isFetching: function isFetching(state) {
    return state.pending;
  },
  isError: function isError(state) {
    return state.error;
  },
  isSubscribed: function isSubscribed(state) {
    return state.subscribed;
  }
};

var initialState = {
  list: [],
  pending: false,
  error: false,
  subscribed: false
};

var mutations = (_mutations = {}, (0, _defineProperty3.default)(_mutations, types.FETCH_USER_OPERATIONS_REQUEST, function (state) {
  state.pending = true;
  state.error = null;
}), (0, _defineProperty3.default)(_mutations, types.FETCH_USER_OPERATIONS_COMPLETE, function (state, _ref9) {
  var operations = _ref9.operations;

  state.pending = false;
  _vue2.default.set(state, 'list', operations);
}), (0, _defineProperty3.default)(_mutations, types.FETCH_USER_OPERATIONS_ERROR, function (state, _ref10) {
  var error = _ref10.error;

  state.pending = false;
  state.error = error;
}), (0, _defineProperty3.default)(_mutations, types.ADD_USER_OPERATION, function (state, _ref11) {
  var operation = _ref11.operation;

  var newList = state.list.slice();
  newList.unshift(operation);
  _vue2.default.set(state, 'list', newList);
}), (0, _defineProperty3.default)(_mutations, types.SUBSCRIBE_TO_USER_OPERATIONS, function (state) {
  state.subscribed = true;
}), (0, _defineProperty3.default)(_mutations, types.UNSUBSCRIBE_FROM_USER_OPERATIONS, function (state) {
  state.subscribed = false;
}), (0, _defineProperty3.default)(_mutations, types.RESET_OPERATIONS, function (state) {
  state.list = [];
  state.pending = false;
  state.error = false;
}), _mutations);

exports.default = {
  state: initialState,
  mutations: mutations,
  actions: actions,
  getters: getters,
  namespaced: true
};

/***/ }),
/* 552 */
/***/ (function(module, exports, __webpack_require__) {

/*! @preserve
 *
 * tcomb.js - Type checking and DDD for JavaScript
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2014-2016 Giulio Canti
 *
 */

// core
var t = __webpack_require__(20);

// types
t.Any = __webpack_require__(228);
t.Array = __webpack_require__(554);
t.Boolean = __webpack_require__(398);
t.Date = __webpack_require__(555);
t.Error = __webpack_require__(556);
t.Function = __webpack_require__(153);
t.Nil = __webpack_require__(399);
t.Number = __webpack_require__(400);
t.Integer = __webpack_require__(557);
t.IntegerT = t.Integer;
t.Object = __webpack_require__(558);
t.RegExp = __webpack_require__(559);
t.String = __webpack_require__(231);
t.Type = __webpack_require__(560);
t.TypeT = t.Type;

// short alias are deprecated
t.Arr = t.Array;
t.Bool = t.Boolean;
t.Dat = t.Date;
t.Err = t.Error;
t.Func = t.Function;
t.Num = t.Number;
t.Obj = t.Object;
t.Re = t.RegExp;
t.Str = t.String;

// combinators
t.dict = __webpack_require__(232);
t.declare = __webpack_require__(561);
t.enums = __webpack_require__(562);
t.irreducible = __webpack_require__(40);
t.list = __webpack_require__(402);
t.maybe = __webpack_require__(563);
t.refinement = __webpack_require__(230);
t.struct = __webpack_require__(565);
t.tuple = __webpack_require__(405);
t.union = __webpack_require__(569);
t.func = __webpack_require__(570);
t.intersection = __webpack_require__(571);
t.subtype = t.refinement;
t.inter = __webpack_require__(572); // IE8 alias
t['interface'] = t.inter;

// functions
t.assert = t;
t.update = __webpack_require__(573);
t.mixin = __webpack_require__(233);
t.isType = __webpack_require__(37);
t.is = __webpack_require__(65);
t.getTypeName = __webpack_require__(35);
t.match = __webpack_require__(574);

module.exports = t;


/***/ }),
/* 553 */
/***/ (function(module, exports) {

module.exports = function fail(message) {
  throw new TypeError('[tcomb] ' + message);
};

/***/ }),
/* 554 */
/***/ (function(module, exports, __webpack_require__) {

var irreducible = __webpack_require__(40);
var isArray = __webpack_require__(62);

module.exports = irreducible('Array', isArray);


/***/ }),
/* 555 */
/***/ (function(module, exports, __webpack_require__) {

var irreducible = __webpack_require__(40);

module.exports = irreducible('Date', function (x) { return x instanceof Date; });


/***/ }),
/* 556 */
/***/ (function(module, exports, __webpack_require__) {

var irreducible = __webpack_require__(40);

module.exports = irreducible('Error', function (x) { return x instanceof Error; });


/***/ }),
/* 557 */
/***/ (function(module, exports, __webpack_require__) {

var refinement = __webpack_require__(230);
var Number = __webpack_require__(400);

module.exports = refinement(Number, function (x) { return x % 1 === 0; }, 'Integer');


/***/ }),
/* 558 */
/***/ (function(module, exports, __webpack_require__) {

var irreducible = __webpack_require__(40);
var isObject = __webpack_require__(61);

module.exports = irreducible('Object', isObject);


/***/ }),
/* 559 */
/***/ (function(module, exports, __webpack_require__) {

var irreducible = __webpack_require__(40);

module.exports = irreducible('RegExp', function (x) { return x instanceof RegExp; });


/***/ }),
/* 560 */
/***/ (function(module, exports, __webpack_require__) {

var irreducible = __webpack_require__(40);
var isType = __webpack_require__(37);

module.exports = irreducible('Type', isType);

/***/ }),
/* 561 */
/***/ (function(module, exports, __webpack_require__) {

var assert = __webpack_require__(20);
var isTypeName = __webpack_require__(46);
var isType = __webpack_require__(37);
var isNil = __webpack_require__(53);
var mixin = __webpack_require__(233);
var getTypeName = __webpack_require__(35);
var isUnion = __webpack_require__(401);

// All the .declare-d types should be clearly different from each other thus they should have
// different names when a name was not explicitly provided.
var nextDeclareUniqueId = 1;

module.exports = function declare(name) {
  if (true) {
    assert(isTypeName(name), function () { return 'Invalid argument name ' + name + ' supplied to declare([name]) (expected a string)'; });
  }

  var type;

  function Declare(value, path) {
    if (true) {
      assert(!isNil(type), function () { return 'Type declared but not defined, don\'t forget to call .define on every declared type'; });
      if (isUnion(type)) {
        assert(type.dispatch === Declare.dispatch, function () { return 'Please define the custom ' + name + '.dispatch function before calling ' + name + '.define()'; });
      }
    }
    return type(value, path);
  }

  Declare.define = function (spec) {
    if (true) {
      assert(isType(spec), function () { return 'Invalid argument type ' + assert.stringify(spec) +  ' supplied to define(type) (expected a type)'; });
      assert(isNil(type), function () { return 'Declare.define(type) can only be invoked once'; });
      // assert(isNil(spec.meta.name) && Object.keys(spec.prototype).length === 0, function () { return 'Invalid argument type ' + assert.stringify(spec) + ' supplied to define(type) (expected a fresh, unnamed type)'; });
    }

    if (isUnion(spec) && Declare.hasOwnProperty('dispatch')) {
      spec.dispatch = Declare.dispatch;
    }
    type = spec;
    mixin(Declare, type, true); // true because it overwrites Declare.displayName
    if (name) {
      type.displayName = Declare.displayName = name;
      Declare.meta.name = name;
    }
    Declare.meta.identity = type.meta.identity;
    Declare.prototype = type.prototype;
    return Declare;
  };

  Declare.displayName = name || ( getTypeName(Declare) + "$" + nextDeclareUniqueId++ );
  // in general I can't say if this type will be an identity, for safety setting to false
  Declare.meta = { identity: false };
  Declare.prototype = null;
  return Declare;
};


/***/ }),
/* 562 */
/***/ (function(module, exports, __webpack_require__) {

var assert = __webpack_require__(20);
var isTypeName = __webpack_require__(46);
var forbidNewOperator = __webpack_require__(133);
var isNumber = __webpack_require__(229);
var isString = __webpack_require__(151);
var isObject = __webpack_require__(61);

function getDefaultName(map) {
  return Object.keys(map).map(function (k) { return assert.stringify(k); }).join(' | ');
}

function enums(map, name) {

  if (true) {
    assert(isObject(map), function () { return 'Invalid argument map ' + assert.stringify(map) + ' supplied to enums(map, [name]) combinator (expected a dictionary of String -> String | Number)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to enums(map, [name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(map);

  function Enums(value, path) {

    if (true) {
      forbidNewOperator(this, Enums);
      path = path || [displayName];
      assert(Enums.is(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (expected one of ' + assert.stringify(Object.keys(map)) + ')'; });
    }

    return value;
  }

  Enums.meta = {
    kind: 'enums',
    map: map,
    name: name,
    identity: true
  };

  Enums.displayName = displayName;

  Enums.is = function (x) {
    return (isString(x) || isNumber(x)) && map.hasOwnProperty(x);
  };

  return Enums;
}

enums.of = function (keys, name) {
  keys = isString(keys) ? keys.split(' ') : keys;
  var value = {};
  keys.forEach(function (k) {
    value[k] = k;
  });
  return enums(value, name);
};

enums.getDefaultName = getDefaultName;
module.exports = enums;



/***/ }),
/* 563 */
/***/ (function(module, exports, __webpack_require__) {

var assert = __webpack_require__(20);
var isTypeName = __webpack_require__(46);
var isFunction = __webpack_require__(36);
var isMaybe = __webpack_require__(564);
var isIdentity = __webpack_require__(63);
var Any = __webpack_require__(228);
var create = __webpack_require__(64);
var Nil = __webpack_require__(399);
var forbidNewOperator = __webpack_require__(133);
var is = __webpack_require__(65);
var getTypeName = __webpack_require__(35);

function getDefaultName(type) {
  return '?' + getTypeName(type);
}

function maybe(type, name) {

  if (isMaybe(type) || type === Any || type === Nil) { // makes the combinator idempotent and handle Any, Nil
    return type;
  }

  if (true) {
    assert(isFunction(type), function () { return 'Invalid argument type ' + assert.stringify(type) + ' supplied to maybe(type, [name]) combinator (expected a type)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to maybe(type, [name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(type);
  var identity = isIdentity(type);

  function Maybe(value, path) {
    if (true) {
      if (identity) {
        forbidNewOperator(this, Maybe);
      }
    }
    return Nil.is(value) ? value : create(type, value, path);
  }

  Maybe.meta = {
    kind: 'maybe',
    type: type,
    name: name,
    identity: identity
  };

  Maybe.displayName = displayName;

  Maybe.is = function (x) {
    return Nil.is(x) || is(x, type);
  };

  return Maybe;
}

maybe.getDefaultName = getDefaultName;
module.exports = maybe;


/***/ }),
/* 564 */
/***/ (function(module, exports, __webpack_require__) {

var isType = __webpack_require__(37);

module.exports = function isMaybe(x) {
  return isType(x) && ( x.meta.kind === 'maybe' );
};

/***/ }),
/* 565 */
/***/ (function(module, exports, __webpack_require__) {

var assert = __webpack_require__(20);
var isTypeName = __webpack_require__(46);
var String = __webpack_require__(231);
var Function = __webpack_require__(153);
var isBoolean = __webpack_require__(152);
var isObject = __webpack_require__(61);
var isNil = __webpack_require__(53);
var create = __webpack_require__(64);
var getTypeName = __webpack_require__(35);
var dict = __webpack_require__(232);
var getDefaultInterfaceName = __webpack_require__(403);
var extend = __webpack_require__(404);

function getDefaultName(props) {
  return 'Struct' + getDefaultInterfaceName(props);
}

function extendStruct(mixins, name) {
  return extend(struct, mixins, name);
}

function getOptions(options) {
  if (!isObject(options)) {
    options = isNil(options) ? {} : { name: options };
  }
  if (!options.hasOwnProperty('strict')) {
    options.strict = struct.strict;
  }
  if (!options.hasOwnProperty('defaultProps')) {
    options.defaultProps = {};
  }
  return options;
}

function struct(props, options) {

  options = getOptions(options);
  var name = options.name;
  var strict = options.strict;
  var defaultProps = options.defaultProps;

  if (true) {
    assert(dict(String, Function).is(props), function () { return 'Invalid argument props ' + assert.stringify(props) + ' supplied to struct(props, [options]) combinator (expected a dictionary String -> Type)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to struct(props, [options]) combinator (expected a string)'; });
    assert(isBoolean(strict), function () { return 'Invalid argument strict ' + assert.stringify(strict) + ' supplied to struct(props, [options]) combinator (expected a boolean)'; });
    assert(isObject(defaultProps), function () { return 'Invalid argument defaultProps ' + assert.stringify(defaultProps) + ' supplied to struct(props, [options]) combinator (expected an object)'; });
  }

  var displayName = name || getDefaultName(props);

  function Struct(value, path) {

    if (Struct.is(value)) { // implements idempotency
      return value;
    }

    if (true) {
      path = path || [displayName];
      assert(isObject(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (expected an object)'; });
      // strictness
      if (strict) {
        for (k in value) {
          if (value.hasOwnProperty(k)) {
            assert(props.hasOwnProperty(k), function () { return 'Invalid additional prop "' + k + '" supplied to ' + path.join('/'); });
          }
        }
      }
    }

    if (!(this instanceof Struct)) { // `new` is optional
      return new Struct(value, path);
    }

    for (var k in props) {
      if (props.hasOwnProperty(k)) {
        var expected = props[k];
        var actual = value[k];
        // apply defaults
        if (actual === undefined) {
          actual = defaultProps[k];
        }
        this[k] = create(expected, actual, (  true ? path.concat(k + ': ' + getTypeName(expected)) : null ));
      }
    }

    if (true) {
      Object.freeze(this);
    }

  }

  Struct.meta = {
    kind: 'struct',
    props: props,
    name: name,
    identity: false,
    strict: strict,
    defaultProps: defaultProps
  };

  Struct.displayName = displayName;

  Struct.is = function (x) {
    return x instanceof Struct;
  };

  Struct.update = function (instance, patch) {
    return new Struct(assert.update(instance, patch));
  };

  Struct.extend = function (xs, name) {
    return extendStruct([Struct].concat(xs), name);
  };

  return Struct;
}

struct.strict = false;
struct.getOptions = getOptions;
struct.getDefaultName = getDefaultName;
struct.extend = extendStruct;
module.exports = struct;


/***/ }),
/* 566 */
/***/ (function(module, exports, __webpack_require__) {

var isType = __webpack_require__(37);

module.exports = function isStruct(x) {
  return isType(x) && ( x.meta.kind === 'struct' );
};

/***/ }),
/* 567 */
/***/ (function(module, exports, __webpack_require__) {

var isType = __webpack_require__(37);

module.exports = function isInterface(x) {
  return isType(x) && ( x.meta.kind === 'interface' );
};

/***/ }),
/* 568 */
/***/ (function(module, exports, __webpack_require__) {

var isType = __webpack_require__(37);

function isRefinement(type) {
  return isType(type) && type.meta.kind === 'subtype';
}

function getPredicates(type) {
  return isRefinement(type) ?
    [type.meta.predicate].concat(getPredicates(type.meta.type)) :
    [];
}

function getUnrefinedType(type) {
  return isRefinement(type) ?
    getUnrefinedType(type.meta.type) :
    type;
}

function decompose(type) {
  return {
    predicates: getPredicates(type),
    unrefinedType: getUnrefinedType(type)
  };
}

module.exports = decompose;

/***/ }),
/* 569 */
/***/ (function(module, exports, __webpack_require__) {

var assert = __webpack_require__(20);
var isTypeName = __webpack_require__(46);
var isFunction = __webpack_require__(36);
var getTypeName = __webpack_require__(35);
var isIdentity = __webpack_require__(63);
var isArray = __webpack_require__(62);
var create = __webpack_require__(64);
var is = __webpack_require__(65);
var forbidNewOperator = __webpack_require__(133);
var isUnion = __webpack_require__(401);
var isNil = __webpack_require__(53);

function getDefaultName(types) {
  return types.map(getTypeName).join(' | ');
}

function union(types, name) {

  if (true) {
    assert(isArray(types) && types.every(isFunction) && types.length >= 2, function () { return 'Invalid argument types ' + assert.stringify(types) + ' supplied to union(types, [name]) combinator (expected an array of at least 2 types)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to union(types, [name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(types);
  var identity = types.every(isIdentity);

  function Union(value, path) {

    if (false) {
      if (identity) {
        return value;
      }
    }

    var type = Union.dispatch(value);
    if (!type && Union.is(value)) {
      return value;
    }

    if (true) {
      if (identity) {
        forbidNewOperator(this, Union);
      }
      path = path || [displayName];
      assert(isFunction(type), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/') + ' (no constructor returned by dispatch)'; });
      path[path.length - 1] += '(' + getTypeName(type) + ')';
    }

    return create(type, value, path);
  }

  Union.meta = {
    kind: 'union',
    types: types,
    name: name,
    identity: identity
  };

  Union.displayName = displayName;

  Union.is = function (x) {
    return types.some(function (type) {
      return is(x, type);
    });
  };

  Union.dispatch = function (x) { // default dispatch implementation
    for (var i = 0, len = types.length; i < len; i++ ) {
      var type = types[i];
      if (isUnion(type)) { // handle union of unions
        var t = type.dispatch(x);
        if (!isNil(t)) {
          return t;
        }
      }
      else if (is(x, type)) {
        return type;
      }
    }
  };

  Union.update = function (instance, patch) {
    return Union(assert.update(instance, patch));
  };

  return Union;
}

union.getDefaultName = getDefaultName;
module.exports = union;



/***/ }),
/* 570 */
/***/ (function(module, exports, __webpack_require__) {

var assert = __webpack_require__(20);
var isTypeName = __webpack_require__(46);
var FunctionType = __webpack_require__(153);
var isArray = __webpack_require__(62);
var list = __webpack_require__(402);
var isObject = __webpack_require__(61);
var create = __webpack_require__(64);
var isNil = __webpack_require__(53);
var isBoolean = __webpack_require__(152);
var tuple = __webpack_require__(405);
var getFunctionName = __webpack_require__(132);
var getTypeName = __webpack_require__(35);
var isType = __webpack_require__(37);

function getDefaultName(domain, codomain) {
  return '(' + domain.map(getTypeName).join(', ') + ') => ' + getTypeName(codomain);
}

function isInstrumented(f) {
  return FunctionType.is(f) && isObject(f.instrumentation);
}

function getOptionalArgumentsIndex(types) {
  var end = types.length;
  var areAllMaybes = false;
  for (var i = end - 1; i >= 0; i--) {
    var type = types[i];
    if (!isType(type) || type.meta.kind !== 'maybe') {
      return (i + 1);
    } else {
      areAllMaybes = true;
    }
  }
  return areAllMaybes ? 0 : end;
}

function func(domain, codomain, name) {

  domain = isArray(domain) ? domain : [domain]; // handle handy syntax for unary functions

  if (true) {
    assert(list(FunctionType).is(domain), function () { return 'Invalid argument domain ' + assert.stringify(domain) + ' supplied to func(domain, codomain, [name]) combinator (expected an array of types)'; });
    assert(FunctionType.is(codomain), function () { return 'Invalid argument codomain ' + assert.stringify(codomain) + ' supplied to func(domain, codomain, [name]) combinator (expected a type)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to func(domain, codomain, [name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(domain, codomain);
  var domainLength = domain.length;
  var optionalArgumentsIndex = getOptionalArgumentsIndex(domain);

  function FuncType(value, path) {

    if (!isInstrumented(value)) { // automatically instrument the function
      return FuncType.of(value);
    }

    if (true) {
      path = path || [displayName];
      assert(FuncType.is(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
    }

    return value;
  }

  FuncType.meta = {
    kind: 'func',
    domain: domain,
    codomain: codomain,
    name: name,
    identity: true
  };

  FuncType.displayName = displayName;

  FuncType.is = function (x) {
    return isInstrumented(x) &&
      x.instrumentation.domain.length === domainLength &&
      x.instrumentation.domain.every(function (type, i) {
        return type === domain[i];
      }) &&
      x.instrumentation.codomain === codomain;
  };

  FuncType.of = function (f, curried) {

    if (true) {
      assert(FunctionType.is(f), function () { return 'Invalid argument f supplied to func.of ' + displayName + ' (expected a function)'; });
      assert(isNil(curried) || isBoolean(curried), function () { return 'Invalid argument curried ' + assert.stringify(curried) + ' supplied to func.of ' + displayName + ' (expected a boolean)'; });
    }

    if (FuncType.is(f)) { // makes FuncType.of idempotent
      return f;
    }

    function fn() {
      var args = Array.prototype.slice.call(arguments);
      var argsLength = args.length;

      if (true) {
        // type-check arguments
        var tupleLength = curried ? argsLength : Math.max(argsLength, optionalArgumentsIndex);
        tuple(domain.slice(0, tupleLength), 'arguments of function ' + displayName)(args);
      }

      if (curried && argsLength < domainLength) {
        if (true) {
          assert(argsLength > 0, 'Invalid arguments.length = 0 for curried function ' + displayName);
        }
        var g = Function.prototype.bind.apply(f, [this].concat(args));
        var newDomain = func(domain.slice(argsLength), codomain);
        return newDomain.of(g, true);
      }
      else {
        return create(codomain, f.apply(this, args));
      }
    }

    fn.instrumentation = {
      domain: domain,
      codomain: codomain,
      f: f
    };

    fn.displayName = getFunctionName(f);

    return fn;

  };

  return FuncType;

}

func.getDefaultName = getDefaultName;
func.getOptionalArgumentsIndex = getOptionalArgumentsIndex;
module.exports = func;


/***/ }),
/* 571 */
/***/ (function(module, exports, __webpack_require__) {

var assert = __webpack_require__(20);
var isTypeName = __webpack_require__(46);
var isFunction = __webpack_require__(36);
var isArray = __webpack_require__(62);
var forbidNewOperator = __webpack_require__(63);
var is = __webpack_require__(65);
var getTypeName = __webpack_require__(35);
var isIdentity = __webpack_require__(63);

function getDefaultName(types) {
  return types.map(getTypeName).join(' & ');
}

function intersection(types, name) {

  if (true) {
    assert(isArray(types) && types.every(isFunction) && types.length >= 2, function () { return 'Invalid argument types ' + assert.stringify(types) + ' supplied to intersection(types, [name]) combinator (expected an array of at least 2 types)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to intersection(types, [name]) combinator (expected a string)'; });
  }

  var displayName = name || getDefaultName(types);
  var identity = types.every(isIdentity);

  function Intersection(value, path) {

    if (true) {
      if (identity) {
        forbidNewOperator(this, Intersection);
      }
      path = path || [displayName];
      assert(Intersection.is(value), function () { return 'Invalid value ' + assert.stringify(value) + ' supplied to ' + path.join('/'); });
    }

    return value;
  }

  Intersection.meta = {
    kind: 'intersection',
    types: types,
    name: name,
    identity: identity
  };

  Intersection.displayName = displayName;

  Intersection.is = function (x) {
    return types.every(function (type) {
      return is(x, type);
    });
  };

  Intersection.update = function (instance, patch) {
    return Intersection(assert.update(instance, patch));
  };

  return Intersection;
}

intersection.getDefaultName = getDefaultName;
module.exports = intersection;



/***/ }),
/* 572 */
/***/ (function(module, exports, __webpack_require__) {

var assert = __webpack_require__(20);
var isTypeName = __webpack_require__(46);
var String = __webpack_require__(231);
var Function = __webpack_require__(153);
var isBoolean = __webpack_require__(152);
var isObject = __webpack_require__(61);
var isNil = __webpack_require__(53);
var create = __webpack_require__(64);
var getTypeName = __webpack_require__(35);
var dict = __webpack_require__(232);
var getDefaultInterfaceName = __webpack_require__(403);
var isIdentity = __webpack_require__(63);
var is = __webpack_require__(65);
var extend = __webpack_require__(404);
var assign = __webpack_require__(406);

function extendInterface(mixins, name) {
  return extend(inter, mixins, name);
}

function getOptions(options) {
  if (!isObject(options)) {
    options = isNil(options) ? {} : { name: options };
  }
  if (!options.hasOwnProperty('strict')) {
    options.strict = inter.strict;
  }
  return options;
}

function inter(props, options) {

  options = getOptions(options);
  var name = options.name;
  var strict = options.strict;

  if (true) {
    assert(dict(String, Function).is(props), function () { return 'Invalid argument props ' + assert.stringify(props) + ' supplied to interface(props, [options]) combinator (expected a dictionary String -> Type)'; });
    assert(isTypeName(name), function () { return 'Invalid argument name ' + assert.stringify(name) + ' supplied to interface(props, [options]) combinator (expected a string)'; });
    assert(isBoolean(strict), function () { return 'Invalid argument strict ' + assert.stringify(strict) + ' supplied to struct(props, [options]) combinator (expected a boolean)'; });
  }

  var displayName = name || getDefaultInterfaceName(props);
  var identity = Object.keys(props).map(function (prop) { return props[prop]; }).every(isIdentity);

  function Interface(value, path) {

    if (false) {
      if (identity) {
        return value; // just trust the input if elements must not be hydrated
      }
    }

    if (true) {
      path = path || [displayName];
      assert(!isNil(value), function () { return 'Invalid value ' + value + ' supplied to ' + path.join('/'); });
      // strictness
      if (strict) {
        for (var k in value) {
          assert(props.hasOwnProperty(k), function () { return 'Invalid additional prop "' + k + '" supplied to ' + path.join('/'); });
        }
      }
    }

    var idempotent = true;
    var ret = identity ? {} : assign({}, value);
    for (var prop in props) {
      var expected = props[prop];
      var actual = value[prop];
      var instance = create(expected, actual, (  true ? path.concat(prop + ': ' + getTypeName(expected)) : null ));
      idempotent = idempotent && ( actual === instance );
      ret[prop] = instance;
    }

    if (idempotent) { // implements idempotency
      ret = value;
    }

    if (true) {
      Object.freeze(ret);
    }

    return ret;

  }

  Interface.meta = {
    kind: 'interface',
    props: props,
    name: name,
    identity: identity,
    strict: strict
  };

  Interface.displayName = displayName;

  Interface.is = function (x) {
    if (isNil(x)) {
      return false;
    }
    if (strict) {
      for (var k in x) {
        if (!props.hasOwnProperty(k)) {
          return false;
        }
      }
    }
    for (var prop in props) {
      if (!is(x[prop], props[prop])) {
        return false;
      }
    }
    return true;
  };

  Interface.update = function (instance, patch) {
    return Interface(assert.update(instance, patch));
  };

  Interface.extend = function (xs, name) {
    return extendInterface([Interface].concat(xs), name);
  };

  return Interface;
}

inter.strict = false;
inter.getOptions = getOptions;
inter.getDefaultName = getDefaultInterfaceName;
inter.extend = extendInterface;
module.exports = inter;


/***/ }),
/* 573 */
/***/ (function(module, exports, __webpack_require__) {

var assert = __webpack_require__(20);
var isObject = __webpack_require__(61);
var isFunction = __webpack_require__(36);
var isArray = __webpack_require__(62);
var isNumber = __webpack_require__(229);
var assign = __webpack_require__(406);

function getShallowCopy(x) {
  if (isObject(x)) {
    if (x instanceof Date || x instanceof RegExp) {
      return x;
    }
    return assign({}, x);
  }
  if (isArray(x)) {
    return x.concat();
  }
  return x;
}

function isCommand(k) {
  return update.commands.hasOwnProperty(k);
}

function getCommand(k) {
  return update.commands[k];
}

function update(instance, patch) {

  if (true) {
    assert(isObject(patch), function () { return 'Invalid argument patch ' + assert.stringify(patch) + ' supplied to function update(instance, patch): expected an object containing commands'; });
  }

  var value = instance;
  var isChanged = false;
  var newValue;
  for (var k in patch) {
    if (patch.hasOwnProperty(k)) {
      if (isCommand(k)) {
        newValue = getCommand(k)(patch[k], value);
        if (newValue !== instance) {
          isChanged = true;
          value = newValue;
        } else {
          value = instance;
        }
      }
      else {
        if (value === instance) {
          value = getShallowCopy(instance);
        }
        newValue = update(value[k], patch[k]);
        isChanged = isChanged || ( newValue !== value[k] );
        value[k] = newValue;
      }
    }
  }
  return isChanged ? value : instance;
}

// built-in commands

function $apply(f, value) {
  if (true) {
    assert(isFunction(f), 'Invalid argument f supplied to immutability helper { $apply: f } (expected a function)');
  }
  return f(value);
}

function $push(elements, arr) {
  if (true) {
    assert(isArray(elements), 'Invalid argument elements supplied to immutability helper { $push: elements } (expected an array)');
    assert(isArray(arr), 'Invalid value supplied to immutability helper $push (expected an array)');
  }
  if (elements.length > 0) {
    return arr.concat(elements);
  }
  return arr;
}

function $remove(keys, obj) {
  if (true) {
    assert(isArray(keys), 'Invalid argument keys supplied to immutability helper { $remove: keys } (expected an array)');
    assert(isObject(obj), 'Invalid value supplied to immutability helper $remove (expected an object)');
  }
  if (keys.length > 0) {
    obj = getShallowCopy(obj);
    for (var i = 0, len = keys.length; i < len; i++ ) {
      delete obj[keys[i]];
    }
  }
  return obj;
}

function $set(value) {
  return value;
}

function $splice(splices, arr) {
  if (true) {
    assert(isArray(splices) && splices.every(isArray), 'Invalid argument splices supplied to immutability helper { $splice: splices } (expected an array of arrays)');
    assert(isArray(arr), 'Invalid value supplied to immutability helper $splice (expected an array)');
  }
  if (splices.length > 0) {
    arr = getShallowCopy(arr);
    return splices.reduce(function (acc, splice) {
      acc.splice.apply(acc, splice);
      return acc;
    }, arr);
  }
  return arr;
}

function $swap(config, arr) {
  if (true) {
    assert(isObject(config), 'Invalid argument config supplied to immutability helper { $swap: config } (expected an object)');
    assert(isNumber(config.from), 'Invalid argument config.from supplied to immutability helper { $swap: config } (expected a number)');
    assert(isNumber(config.to), 'Invalid argument config.to supplied to immutability helper { $swap: config } (expected a number)');
    assert(isArray(arr), 'Invalid value supplied to immutability helper $swap (expected an array)');
  }
  if (config.from !== config.to) {
    arr = getShallowCopy(arr);
    var element = arr[config.to];
    arr[config.to] = arr[config.from];
    arr[config.from] = element;
  }
  return arr;
}

function $unshift(elements, arr) {
  if (true) {
    assert(isArray(elements), 'Invalid argument elements supplied to immutability helper {$unshift: elements} (expected an array)');
    assert(isArray(arr), 'Invalid value supplied to immutability helper $unshift (expected an array)');
  }
  if (elements.length > 0) {
    return elements.concat(arr);
  }
  return arr;
}

function $merge(whatToMerge, value) {
  var isChanged = false;
  var result = getShallowCopy(value);
  for (var k in whatToMerge) {
    if (whatToMerge.hasOwnProperty(k)) {
      result[k] = whatToMerge[k];
      isChanged = isChanged || ( result[k] !== value[k] );
    }
  }
  return isChanged ? result : value;
}

update.commands = {
  $apply: $apply,
  $push: $push,
  $remove: $remove,
  $set: $set,
  $splice: $splice,
  $swap: $swap,
  $unshift: $unshift,
  $merge: $merge
};

module.exports = update;


/***/ }),
/* 574 */
/***/ (function(module, exports, __webpack_require__) {

var assert = __webpack_require__(20);
var isFunction = __webpack_require__(36);
var isType = __webpack_require__(37);
var Any = __webpack_require__(228);

module.exports = function match(x) {
  var type, guard, f, count;
  for (var i = 1, len = arguments.length; i < len; ) {
    type = arguments[i];
    guard = arguments[i + 1];
    f = arguments[i + 2];

    if (isFunction(f) && !isType(f)) {
      i = i + 3;
    }
    else {
      f = guard;
      guard = Any.is;
      i = i + 2;
    }

    if (true) {
      count = (count || 0) + 1;
      assert(isType(type), function () { return 'Invalid type in clause #' + count; });
      assert(isFunction(guard), function () { return 'Invalid guard in clause #' + count; });
      assert(isFunction(f), function () { return 'Invalid block in clause #' + count; });
    }

    if (type.is(x) && guard(x)) {
      return f(x);
    }
  }
  assert.fail('Match error');
};


/***/ }),
/* 575 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _defineProperty2 = __webpack_require__(27);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _slicedToArray2 = __webpack_require__(90);

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _getIterator2 = __webpack_require__(52);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _regenerator = __webpack_require__(3);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _promise = __webpack_require__(4);

var _promise2 = _interopRequireDefault(_promise);

var _mutations;
// import dictionary from '..United Labs of BCTech./assets/brainkey_dictionary.js';


var _vue = __webpack_require__(19);

var _vue2 = _interopRequireDefault(_vue);

var _mutations2 = __webpack_require__(14);

var types = _interopRequireWildcard(_mutations2);

var _bcxjsCores = __webpack_require__(7);

var _bcxjsWs = __webpack_require__(8);

var _idbInstance = __webpack_require__(60);

var _idbInstance2 = _interopRequireDefault(_idbInstance);

var _idbHelper = __webpack_require__(149);

var _idbHelper2 = _interopRequireDefault(_idbHelper);

var _tcomb_structs = __webpack_require__(396);

var _api = __webpack_require__(10);

var _api2 = _interopRequireDefault(_api);

var _lodash = __webpack_require__(576);

var _backup = __webpack_require__(407);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// let aes_private = null;
// let _passwordKey=null;
var _brainkey_look_ahead = void 0;
var _generateNextKey_pubcache = [];

var initialState = {
    aes_private: null,
    _passwordKey: null,
    wallet: null
};
var TRACE = false;

var getters = {
    wallet: function wallet(state) {
        return state.wallet;
    },
    aes_private: function aes_private(state) {
        return state.aes_private;
    },
    _passwordKey: function _passwordKey(state) {
        return state._passwordKey;
    },
    isLocked: function isLocked(state) {
        var aes_private = state.aes_private,
            _passwordKey = state._passwordKey;

        return !(!!aes_private || !!_passwordKey);
    },
    decryptTcomb_PrivateKey: function decryptTcomb_PrivateKey(state) {
        return function (private_key_tcomb) {
            if (!private_key_tcomb) return null;
            var aes_private = state.aes_private,
                _passwordKey = state._passwordKey;

            if (!(!!aes_private || !!_passwordKey)) return ""; //throw new Error("wallet locked")
            if (_passwordKey && _passwordKey[private_key_tcomb.pubkey]) {
                return _passwordKey[private_key_tcomb.pubkey];
            }

            var private_key_hex = aes_private.decryptHex(private_key_tcomb.encrypted_key);
            return _bcxjsCores.PrivateKey.fromBuffer(new Buffer(private_key_hex, 'hex'));
        };
    }
};

var actions = {
    deleteWallet: function deleteWallet(_ref) {
        var state = _ref.state;

        state.wallet = null;
    },
    clearKeys: function clearKeys(_ref2) {
        var commit = _ref2.commit;

        // aes_private=null;
        // _passwordKey=null;
        commit(types.SET_PASSWORD_KEY, null);
        commit(types.SET_AES_PRIVATE, null);
    },
    generateKeyFromPassword: function generateKeyFromPassword(state, _ref3) {
        var account = _ref3.account,
            role = _ref3.role,
            password = _ref3.password;

        var seed = account + role + password;
        var privKey = _bcxjsCores.PrivateKey.fromSeed(seed);
        var pubKey = privKey.toPublicKey().toString();

        return { privKey: privKey, pubKey: pubKey };
    },
    validatePassword: function validatePassword(_ref4, _ref5) {
        var commit = _ref4.commit,
            dispatch = _ref4.dispatch,
            rootGetters = _ref4.rootGetters,
            getters = _ref4.getters;
        var _ref5$password = _ref5.password,
            password = _ref5$password === undefined ? "" : _ref5$password,
            _ref5$unlock = _ref5.unlock,
            unlock = _ref5$unlock === undefined ? false : _ref5$unlock,
            _ref5$account = _ref5.account,
            account = _ref5$account === undefined ? null : _ref5$account,
            _ref5$roles = _ref5.roles,
            roles = _ref5$roles === undefined ? ["active", "owner", "memo"] : _ref5$roles,
            _ref5$isChangePasswor = _ref5.isChangePassword,
            isChangePassword = _ref5$isChangePasswor === undefined ? false : _ref5$isChangePasswor;

        var _passwordKey, setKey, id, fromWif, acc, _key, res, wallet, isAccountMode, encryptionKey, password_private, password_pubkey, _password_pubkey, password_aes, encryption_plainbuffer, aes_private;

        return _regenerator2.default.async(function validatePassword$(_context2) {
            while (1) {
                switch (_context2.prev = _context2.next) {
                    case 0:
                        password = password.trim();
                        _passwordKey = null;

                        if (!account) {
                            _context2.next = 32;
                            break;
                        }

                        setKey = function setKey(role, priv, pub) {
                            if (!_passwordKey) _passwordKey = {};
                            _passwordKey[pub] = priv;

                            id++;

                            dispatch("PrivateKeyStore/setKeys", {
                                pubkey: pub,
                                import_account_names: [account],
                                encrypted_key: null,
                                id: id,
                                brainkey_sequence: null
                            }, { root: true });
                        };

                        /* Check if the user tried to login with a private key */


                        id = 0;
                        fromWif = void 0;

                        try {
                            fromWif = _bcxjsCores.PrivateKey.fromWif(password);
                        } catch (err) {}
                        _context2.next = 9;
                        return _regenerator2.default.awrap(dispatch("user/fetchUser", account, { root: true }));

                    case 9:
                        acc = _context2.sent;

                        if (acc.success) {
                            _context2.next = 12;
                            break;
                        }

                        return _context2.abrupt('return', { code: acc.code, message: acc.error });

                    case 12:
                        acc = acc.data.account;

                        _key = void 0;

                        if (fromWif) {
                            _key = { privKey: fromWif, pubKey: fromWif.toPublicKey().toString() };
                        }

                        if (!acc) {
                            _context2.next = 18;
                            break;
                        }

                        _context2.next = 18;
                        return _regenerator2.default.awrap(_promise2.default.all(roles.map(function _callee(role) {
                            var foundRole, alsoCheckRole;
                            return _regenerator2.default.async(function _callee$(_context) {
                                while (1) {
                                    switch (_context.prev = _context.next) {
                                        case 0:
                                            if (fromWif) {
                                                _context.next = 4;
                                                break;
                                            }

                                            _context.next = 3;
                                            return _regenerator2.default.awrap(dispatch("generateKeyFromPassword", { account: account, role: role, password: password }));

                                        case 3:
                                            _key = _context.sent;

                                        case 4:
                                            foundRole = false;


                                            if (role === "memo") {
                                                if (acc.options.memo_key === _key.pubKey) {
                                                    setKey(role, _key.privKey, _key.pubKey);
                                                    foundRole = true;
                                                }
                                            } else {
                                                acc[role].key_auths.forEach(function (auth) {
                                                    if (auth[0] === _key.pubKey) {
                                                        setKey(role, _key.privKey, _key.pubKey);
                                                        foundRole = true;
                                                        return false;
                                                    }
                                                });

                                                if (!foundRole) {
                                                    alsoCheckRole = role === "active" ? "owner" : "active";

                                                    acc[alsoCheckRole].key_auths.forEach(function (auth) {
                                                        if (auth[0] === _key.pubKey) {
                                                            setKey(alsoCheckRole, _key.privKey, _key.pubKey);
                                                            foundRole = true;
                                                            return false;
                                                        }
                                                    });
                                                }
                                            }

                                        case 6:
                                        case 'end':
                                            return _context.stop();
                                    }
                                }
                            }, null, undefined);
                        })));

                    case 18:
                        if (!(!_passwordKey && rootGetters["account/getWallet"])) {
                            _context2.next = 24;
                            break;
                        }

                        _context2.next = 21;
                        return _regenerator2.default.awrap(dispatch("validatePassword", { password: password, unlock: true }));

                    case 21:
                        res = _context2.sent;

                        if (!res.success) {
                            _context2.next = 24;
                            break;
                        }

                        return _context2.abrupt('return', { code: 1, cloudMode: false });

                    case 24:
                        if (!_passwordKey) {
                            _context2.next = 29;
                            break;
                        }

                        commit(types.SET_PASSWORD_KEY, _passwordKey);
                        return _context2.abrupt('return', { code: 1, cloudMode: true });

                    case 29:
                        return _context2.abrupt('return', { code: 105, message: "wrong password", cloudMode: true });

                    case 30:
                        _context2.next = 57;
                        break;

                    case 32:
                        wallet = getters.wallet; // rootGetters["account/getWallet"];

                        isAccountMode = !wallet && !!rootGetters["account/getWallet"];

                        if (isAccountMode) {
                            wallet = rootGetters["account/getWallet"];
                        }

                        if (wallet) {
                            _context2.next = 37;
                            break;
                        }

                        return _context2.abrupt('return', { code: 154, message: "Please restore your wallet first" });

                    case 37:
                        encryptionKey = wallet.encryption_key; //||wallet.encryptionKey;

                        if (isAccountMode) {
                            encryptionKey = wallet.encryptionKey;
                        }

                        if (!((!encryptionKey || encryptionKey == "undefined") && !isChangePassword)) {
                            _context2.next = 41;
                            break;
                        }

                        return _context2.abrupt('return', { code: 107, message: "Please import the private key" });

                    case 41:
                        _context2.prev = 41;
                        password_private = _bcxjsCores.PrivateKey.fromSeed(password);
                        password_pubkey = password_private.toPublicKey().toPublicKeyString();
                        _password_pubkey = wallet[isAccountMode ? "passwordPubkey" : "password_pubkey"];

                        if (!(_password_pubkey !== password_pubkey)) {
                            _context2.next = 47;
                            break;
                        }

                        return _context2.abrupt('return', { code: 105, message: "wrong password", success: false, cloudMode: false });

                    case 47:
                        if (unlock) {
                            password_aes = _bcxjsCores.Aes.fromSeed(password);
                            encryption_plainbuffer = password_aes.decryptHexToBuffer(encryptionKey);
                            //let encryption_plainbuffer = password_aes.decryptHexToBuffer(wallet.encryptionKey);

                            aes_private = _bcxjsCores.Aes.fromSeed(encryption_plainbuffer);

                            commit(types.SET_AES_PRIVATE, aes_private);
                        }
                        _context2.next = 50;
                        return _regenerator2.default.awrap(dispatch("user/fetchUser", rootGetters["account/getAccountUserId"], { root: true }));

                    case 50:
                        return _context2.abrupt('return', { code: 1, success: true, cloudMode: false });

                    case 53:
                        _context2.prev = 53;
                        _context2.t0 = _context2['catch'](41);

                        console.error(_context2.t0);
                        return _context2.abrupt('return', { code: 0, message: _context2.t0.message, success: false, cloudMode: false });

                    case 57:
                    case 'end':
                        return _context2.stop();
                }
            }
        }, null, undefined, [[41, 53]]);
    },

    getPrivateKey: function getPrivateKey(_ref6, public_key) {
        var rootGetters = _ref6.rootGetters,
            dispatch = _ref6.dispatch,
            state = _ref6.state;

        var _passwordKey, private_key_tcomb;

        return _regenerator2.default.async(function getPrivateKey$(_context3) {
            while (1) {
                switch (_context3.prev = _context3.next) {
                    case 0:
                        _passwordKey = state._passwordKey;

                        if (!_passwordKey) {
                            _context3.next = 3;
                            break;
                        }

                        return _context3.abrupt('return', _passwordKey[public_key]);

                    case 3:
                        if (public_key) {
                            _context3.next = 5;
                            break;
                        }

                        return _context3.abrupt('return', null);

                    case 5:
                        if (public_key.Q) public_key = public_key.toPublicKeyString();
                        private_key_tcomb = rootGetters["PrivateKeyStore/getTcomb_byPubkey"](public_key);

                        if (private_key_tcomb) {
                            _context3.next = 9;
                            break;
                        }

                        return _context3.abrupt('return', null);

                    case 9:
                        _context3.next = 11;
                        return _regenerator2.default.awrap(dispatch("decryptTcomb_PrivateKey", private_key_tcomb));

                    case 11:
                        return _context3.abrupt('return', _context3.sent);

                    case 12:
                    case 'end':
                        return _context3.stop();
                }
            }
        }, null, undefined);
    },

    decryptTcomb_PrivateKey: function decryptTcomb_PrivateKey(_ref7, private_key_tcomb) {
        var getters = _ref7.getters,
            state = _ref7.state;
        var aes_private = state.aes_private,
            _passwordKey = state._passwordKey;

        if (!private_key_tcomb) return null;
        if (getters.isLocked) return ""; //throw new Error("wallet locked")
        if (_passwordKey && _passwordKey[private_key_tcomb.pubkey]) {
            return _passwordKey[private_key_tcomb.pubkey];
        }

        var private_key_hex = aes_private.decryptHex(private_key_tcomb.encrypted_key);
        return _bcxjsCores.PrivateKey.fromBuffer(new Buffer(private_key_hex, 'hex'));
    },

    lockWallet: function lockWallet(_ref8) {
        var rootGetters = _ref8.rootGetters,
            dispatch = _ref8.dispatch,
            commit = _ref8.commit,
            getters = _ref8.getters;

        // if(!(getters.wallet&&getters.wallet.encryption_key)){
        //     return {
        //         code:-7,
        //         message:"Please import the private key"
        //         United Labs of BCTech.
        //     }
        // }
        dispatch("clearKeys");
        // commit(types.SET_PASSWORD_KEY,null);
        // commit(types.SET_AES_PRIVATE,null);
        return {
            code: 1,
            message: "Account locked"
        };
    },
    loadDbData: function loadDbData(_ref9) {
        var state = _ref9.state;

        return _idbHelper2.default.cursor("wallet", function (cursor) {
            if (!cursor) return false;
            var wallet = cursor.value;
            // Convert anything other than a string or number back into its proper type
            wallet.created = new Date(wallet.created);
            wallet.last_modified = new Date(wallet.last_modified);
            wallet.backup_date = wallet.backup_date ? new Date(wallet.backup_date) : null;
            wallet.brainkey_backup_date = wallet.brainkey_backup_date ? new Date(wallet.brainkey_backup_date) : null;
            try {
                (0, _tcomb_structs.WalletTcomb)(wallet);
            } catch (e) {
                console.log("WalletDb format error", e);
            }
            state.wallet = wallet;
            return false; //stop iterating
        });
    },

    createWallet: function createWallet(_ref10, _ref11) {
        var dispatch = _ref10.dispatch;
        var password = _ref11.password,
            account = _ref11.account,
            callback = _ref11.callback,
            _ref11$isCreateAccoun = _ref11.isCreateAccount,
            isCreateAccount = _ref11$isCreateAccoun === undefined ? true : _ref11$isCreateAccoun;

        return dispatch("WalletManagerStore/setWallet", {
            wallet_name: "default",
            create_wallet_password: password
        }, { root: true }).then(function () {
            console.log("Congratulations, your wallet was successfully created.", isCreateAccount);
            if (isCreateAccount) {
                return dispatch('validatePassword', { password: password, unlock: true }).then(function (vp_res) {
                    return dispatch("createAccount", { account_name: account }).then(function (ca_res) {
                        return ca_res;
                    });
                });
            }
            return { code: 1 };
        }).catch(function (err) {
            console.error("CreateWallet failed:", err);
            return { code: 501, message: "CreateWallet failed", error: err };
        });
    },
    _createWallet: function _createWallet(_ref12, _ref13) {
        var state = _ref12.state,
            dispatch = _ref12.dispatch,
            commit = _ref12.commit;
        var password_plaintext = _ref13.password_plaintext,
            brainkey_plaintext = _ref13.brainkey_plaintext,
            _ref13$unlock = _ref13.unlock,
            unlock = _ref13$unlock === undefined ? true : _ref13$unlock,
            _ref13$public_name = _ref13.public_name,
            public_name = _ref13$public_name === undefined ? "default" : _ref13$public_name;

        var walletCreateFct = function walletCreateFct(dictionary) {
            // console.debug('---------------------',dictionary);
            return new _promise2.default(function _callee2(resolve, reject) {
                var brainkey_backup_date, password_aes, encryption_buffer, encryption_key, local_aes_private, brainkey_private, brainkey_pubkey, encrypted_brainkey, password_private, password_pubkey, wallet, transaction, add, end;
                return _regenerator2.default.async(function _callee2$(_context4) {
                    while (1) {
                        switch (_context4.prev = _context4.next) {
                            case 0:
                                if (!(typeof password_plaintext !== 'string')) {
                                    _context4.next = 2;
                                    break;
                                }

                                throw new Error("password string is required");

                            case 2:
                                brainkey_backup_date = void 0;

                                if (!brainkey_plaintext) {
                                    _context4.next = 9;
                                    break;
                                }

                                if (!(typeof brainkey_plaintext !== "string")) {
                                    _context4.next = 6;
                                    break;
                                }

                                throw new Error("Brainkey must be a string");

                            case 6:
                                if (!(brainkey_plaintext.trim() === "")) {
                                    _context4.next = 8;
                                    break;
                                }

                                throw new Error("Brainkey can not be an empty string");

                            case 8:

                                // if (brainkey_plaintext.length < 50)
                                //     throw new Error("Brainkey must be at least 50 characters long")

                                // The user just provided the Brainkey so this avoids
                                // bugging them to back it up again.United Labs of BCTech.
                                brainkey_backup_date = new Date();

                            case 9:
                                password_aes = _bcxjsCores.Aes.fromSeed(password_plaintext);
                                encryption_buffer = _bcxjsCores.key.get_random_key().toBuffer();
                                // encryption_key is the global encryption key (does not change even if the passsword changes)

                                encryption_key = password_aes.encryptToHex(encryption_buffer);
                                // If unlocking, local_aes_private will become the global aes_private object

                                local_aes_private = _bcxjsCores.Aes.fromSeed(encryption_buffer);


                                if (!brainkey_plaintext) brainkey_plaintext = _bcxjsCores.key.get_random_key().toWif(); //key.suggest_brain_key(dictionary.en)
                                else brainkey_plaintext = _bcxjsCores.key.normalize_brainKey(brainkey_plaintext);
                                _context4.next = 16;
                                return _regenerator2.default.awrap(dispatch("getBrainKeyPrivate", brainkey_plaintext));

                            case 16:
                                brainkey_private = _context4.sent;
                                brainkey_pubkey = brainkey_private.toPublicKey().toPublicKeyString();
                                encrypted_brainkey = local_aes_private.encryptToHex(brainkey_plaintext);
                                password_private = _bcxjsCores.PrivateKey.fromSeed(password_plaintext);
                                password_pubkey = password_private.toPublicKey().toPublicKeyString();
                                wallet = {
                                    public_name: public_name,
                                    password_pubkey: password_pubkey,
                                    encryption_key: encryption_key,
                                    encrypted_brainkey: encrypted_brainkey,
                                    brainkey_pubkey: brainkey_pubkey,
                                    brainkey_sequence: 0,
                                    brainkey_backup_date: brainkey_backup_date,
                                    created: new Date(),
                                    last_modified: new Date(),
                                    chain_id: _bcxjsWs.Apis.instance().chain_id
                                };

                                (0, _tcomb_structs.WalletTcomb)(wallet); // validation
                                transaction = transaction_update();
                                add = _idbHelper2.default.add(transaction.objectStore("wallet"), wallet);
                                end = _idbHelper2.default.on_transaction_end(transaction).then(function () {
                                    state.wallet = wallet;
                                    if (unlock) {
                                        commit(types.SET_AES_PRIVATE, local_aes_private);
                                        //state.aes_private = local_aes_private
                                    }
                                });
                                //console.debug('---------------------')

                                resolve(_promise2.default.all([add, end]));

                            case 27:
                            case 'end':
                                return _context4.stop();
                        }
                    }
                }, null, undefined);
            });
        };
        return walletCreateFct();
    },
    getBrainKeyPrivate: function getBrainKeyPrivate(_ref14, brainkey_plaintext) {
        var dispatch = _ref14.dispatch;

        if (!brainkey_plaintext) {
            brainkey_plaintext = dispatch("getBrainKey");
        }
        if (!brainkey_plaintext) throw new Error("missing brainkey");
        return _bcxjsCores.PrivateKey.fromSeed(_bcxjsCores.key.normalize_brainKey(brainkey_plaintext));
    },
    getBrainKey: function getBrainKey(_ref15) {
        var state = _ref15.state,
            getters = _ref15.getters;

        var wallet = state.wallet;
        if (!wallet.encrypted_brainkey) throw new Error("missing brainkey");
        if (!state.aes_private) throw new Error("wallet locked");
        var brainkey_plaintext = getters.aes_private.decryptHexToText(wallet.encrypted_brainkey);
        return brainkey_plaintext;
    },
    createAccount: function createAccount(_ref16, _ref17) {
        var state = _ref16.state,
            getters = _ref16.getters,
            rootGetters = _ref16.rootGetters,
            dispatch = _ref16.dispatch,
            commit = _ref16.commit;
        var account_name = _ref17.account_name,
            registrar = _ref17.registrar,
            referrer = _ref17.referrer,
            referrer_percent = _ref17.referrer_percent,
            refcode = _ref17.refcode;
        var error, owner_private, active_private, updateWallet, owner_pubkey, create_account, create_account_promise, settingsAPIs;
        return _regenerator2.default.async(function createAccount$(_context5) {
            while (1) {
                switch (_context5.prev = _context5.next) {
                    case 0:
                        if (!getters.isLocked) {
                            _context5.next = 3;
                            break;
                        }

                        error = "wallet locked";
                        //this.actions.brainKeyAccountCreateError( error )

                        return _context5.abrupt('return', _promise2.default.reject(error));

                    case 3:
                        _context5.next = 5;
                        return _regenerator2.default.awrap(dispatch("generateNextKey"));

                    case 5:
                        owner_private = _context5.sent;
                        _context5.next = 8;
                        return _regenerator2.default.awrap(dispatch("generateNextKey"));

                    case 8:
                        active_private = _context5.sent;

                        //let memo_private = WalletDb.generateNextKey()
                        updateWallet = function updateWallet() {
                            var transaction = transaction_update_keys();
                            var p = dispatch("saveKeys", { private_keys: [owner_private, active_private], transaction: transaction });
                            return p.catch(function (error) {
                                return transaction.abort();
                            });
                        };

                        owner_pubkey = owner_private.private_key.toPublicKey().toPublicKeyString();

                        create_account = function create_account() {
                            return dispatch("account/application_api_create_account", {
                                owner_pubkey: owner_pubkey,
                                active_pubkey: active_private.private_key.toPublicKey().toPublicKeyString(),
                                new_account_name: account_name,
                                registrar: registrar,
                                referrer: referrer,
                                referrer_percent: referrer_percent,
                                onlyGetFee: false
                            }, { root: true });
                        };

                        create_account_promise = void 0;

                        if (registrar) {
                            // using another user's account as registrar.United Labs of BCTech.
                            //return create_account();
                            create_account_promise = create_account();
                        } else {
                            // using faucet

                            settingsAPIs = rootGetters["setting/g_settingsAPIs"];


                            create_account_promise = _api2.default.Account.createAccount({
                                name: account_name,
                                activePubkey: active_private.private_key.toPublicKey().toPublicKeyString(),
                                ownerPubkey: owner_private.private_key.toPublicKey().toPublicKeyString(),
                                referrer: settingsAPIs.referrer || ''
                            }, settingsAPIs.default_faucet);
                        }

                        return _context5.abrupt('return', create_account_promise.then(function (result) {
                            if (result.error) {
                                // throw result.error;
                                return result;
                            }

                            if (!result.success) {
                                return result;
                            }

                            if (rootGetters["transactions/onlyGetOPFee"] && registrar) {
                                return result;
                            }

                            return dispatch("AccountStore/onCreateAccount", {
                                name_or_account: account_name,
                                owner_pubkey: owner_pubkey
                            }, { root: true }).then(function (account_id) {
                                if (registrar) {
                                    return result;
                                } else {
                                    updateWallet();
                                    return dispatch("account/getAccountInfo", null, { root: true });
                                }
                            });
                        }).catch(function (error) {
                            if (error instanceof TypeError || error.toString().indexOf("ECONNREFUSED") != -1) {
                                console.log("Warning! faucet registration failed, falling back to direct application_api.create_account..");
                                //return create_account();
                            }
                            throw error;
                        }));

                    case 15:
                    case 'end':
                        return _context5.stop();
                }
            }
        }, null, undefined);
    },
    generateNextKey: function generateNextKey(_ref18) {
        var state = _ref18.state,
            dispatch = _ref18.dispatch;
        var save = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var brainkey, wallet, sequence, used_sequence, i, private_key, pubkey, next_key;
        return _regenerator2.default.async(function generateNextKey$(_context6) {
            while (1) {
                switch (_context6.prev = _context6.next) {
                    case 0:
                        _context6.next = 2;
                        return _regenerator2.default.awrap(dispatch("getBrainKey"));

                    case 2:
                        brainkey = _context6.sent;
                        wallet = state.wallet;
                        sequence = wallet.brainkey_sequence;
                        used_sequence = null;
                        // Skip ahead in the sequence if any keys are found in use.United Labs of BCTech.
                        // Slowly look ahead (1 new key per block) to keep the wallet fast after unlocking

                        _brainkey_look_ahead = Math.min(10, (_brainkey_look_ahead || 0) + 1);
                        i = sequence;

                    case 8:
                        if (!(i < sequence + _brainkey_look_ahead)) {
                            _context6.next = 20;
                            break;
                        }

                        private_key = _bcxjsCores.key.get_brainPrivateKey(brainkey, i);
                        pubkey = _generateNextKey_pubcache[i] ? _generateNextKey_pubcache[i] : _generateNextKey_pubcache[i] = private_key.toPublicKey().toPublicKeyString();
                        next_key = _bcxjsCores.ChainStore.getAccountRefsOfKey(pubkey);
                        // TODO if ( next_key === undefined ) return undefined

                        if (!(next_key && next_key.size)) {
                            _context6.next = 17;
                            break;
                        }

                        used_sequence = i;
                        console.log("WARN: Private key sequence " + used_sequence + " in-use. " + "I am saving the private key and will go onto the next one.");
                        _context6.next = 17;
                        return _regenerator2.default.awrap(dispatch("saveKey", { private_key: private_key, brainkey_sequence: used_sequence }));

                    case 17:
                        i++;
                        _context6.next = 8;
                        break;

                    case 20:
                        if (!(used_sequence !== null)) {
                            _context6.next = 24;
                            break;
                        }

                        wallet.brainkey_sequence = used_sequence + 1;
                        _context6.next = 24;
                        return _regenerator2.default.awrap(dispatch("_updateWallet"));

                    case 24:
                        sequence = wallet.brainkey_sequence;
                        private_key = _bcxjsCores.key.get_brainPrivateKey(brainkey, sequence);

                        if (!save) {
                            _context6.next = 31;
                            break;
                        }

                        _context6.next = 29;
                        return _regenerator2.default.awrap(dispatch("saveKey", { private_key: private_key, brainkey_sequence: sequence }));

                    case 29:
                        _context6.next = 31;
                        return _regenerator2.default.awrap(dispatch("incrementBrainKeySequence"));

                    case 31:
                        return _context6.abrupt('return', { private_key: private_key, sequence: sequence });

                    case 32:
                    case 'end':
                        return _context6.stop();
                }
            }
        }, null, undefined);
    },
    incrementBrainKeySequence: function incrementBrainKeySequence(_ref19, transaction) {
        var state = _ref19.state,
            dispatch = _ref19.dispatch;

        var wallet = state.wallet;
        // increment in RAM so this can't be out-of-sync
        wallet.brainkey_sequence++;
        // update last modified
        return dispatch("_updateWallet", transaction);
        //TODO .error( error => ErrorStore.onAdd( "wallet", "incrementBrainKeySequence", error ))
    },
    _updateWallet: function _updateWallet(_ref20) {
        var state = _ref20.state;
        var transaction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : transaction_update();

        var wallet = state.wallet;
        if (!wallet) {
            reject("missing wallet");
            return;
        }
        //DEBUG console.log('... wallet',wallet)
        var wallet_clone = (0, _lodash.cloneDeep)(wallet);
        wallet_clone.last_modified = new Date();

        (0, _tcomb_structs.WalletTcomb)(wallet_clone); // validate

        var wallet_store = transaction.objectStore("wallet");
        var p = _idbHelper2.default.on_request_end(wallet_store.put(wallet_clone));
        var p2 = _idbHelper2.default.on_transaction_end(transaction).then(function () {
            state.wallet = wallet_clone;
        });
        return _promise2.default.all([p, p2]);
    },

    saveKeys: function saveKeys(_ref21, _ref22) {
        var dispatch = _ref21.dispatch;
        var private_keys = _ref22.private_keys,
            transaction = _ref22.transaction,
            public_key_string = _ref22.public_key_string;

        var promises = [];
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = (0, _getIterator3.default)(private_keys), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var private_key_record = _step.value;

                promises.push(dispatch("saveKey", {
                    private_key: private_key_record.private_key,
                    brainkey_sequence: private_key_record.sequence,
                    import_account_names: null, //import_account_names
                    public_key_string: public_key_string,
                    transaction: transaction
                }));
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        return _promise2.default.all(promises);
    },
    saveKey: function saveKey(_ref23, _ref24) {
        var getters = _ref23.getters,
            state = _ref23.state,
            dispatch = _ref23.dispatch;
        var private_key = _ref24.private_key,
            brainkey_sequence = _ref24.brainkey_sequence,
            import_account_names = _ref24.import_account_names,
            public_key_string = _ref24.public_key_string,
            _ref24$transaction = _ref24.transaction,
            transaction = _ref24$transaction === undefined ? transaction_update_keys() : _ref24$transaction;
        var private_cipherhex, wallet, public_key, private_key_object, p1;
        return _regenerator2.default.async(function saveKey$(_context7) {
            while (1) {
                switch (_context7.prev = _context7.next) {
                    case 0:
                        private_cipherhex = getters.aes_private.encryptToHex(private_key.toBuffer());
                        wallet = state.wallet;

                        if (public_key_string) {
                            _context7.next = 7;
                            break;
                        }

                        //S L O W
                        // console.log('WARN: public key was not provided, this may incur slow performance.-United Labs of BCTech.')
                        public_key = private_key.toPublicKey();

                        public_key_string = public_key.toPublicKeyString();
                        _context7.next = 9;
                        break;

                    case 7:
                        if (!(public_key_string.indexOf(_bcxjsWs.ChainConfig.address_prefix) != 0)) {
                            _context7.next = 9;
                            break;
                        }

                        throw new Error("Public Key should start with " + _bcxjsWs.ChainConfig.address_prefix);

                    case 9:
                        private_key_object = {
                            import_account_names: import_account_names,
                            encrypted_key: private_cipherhex,
                            pubkey: public_key_string,
                            brainkey_sequence: brainkey_sequence
                        };
                        _context7.next = 12;
                        return _regenerator2.default.awrap(dispatch("PrivateKeyStore/addKey", { private_key_object: private_key_object, transaction: transaction }, { root: true }).then(function (ret) {
                            if (TRACE) console.log('... WalletDb.saveKey result', ret.result);
                            return ret;
                        }));

                    case 12:
                        p1 = _context7.sent;
                        return _context7.abrupt('return', p1);

                    case 14:
                    case 'end':
                        return _context7.stop();
                }
            }
        }, null, undefined);
    },
    backupDownload: function backupDownload(_ref25) {
        var rootGetters = _ref25.rootGetters,
            getters = _ref25.getters,
            dispatch = _ref25.dispatch;

        // if(rootGetters["BackupStore/backup"].sha1){
        //     dispatch("BackupStore/download",null,{root:true}).then(res2=>{
        //         callback&&callback(res2);
        //     })
        // }else{
        if (!getters.wallet) {
            return { code: 154, message: "Please restore your wallet first" };
        }
        var backup_pubkey = getters.wallet.password_pubkey;
        return _promise2.default.all([(0, _backup.backup)(backup_pubkey), dispatch("WalletManagerStore/getBackupName", null, { root: true })]).then(function (_ref26) {
            var _ref27 = (0, _slicedToArray3.default)(_ref26, 2),
                contents = _ref27[0],
                name = _ref27[1];

            return dispatch("BackupStore/incommingBuffer", { name: name, contents: contents }, { root: true }).then(function (res) {
                if (res.code == 1) {
                    return dispatch("BackupStore/download", null, { root: true });
                } else {
                    return res;
                }
            });
        });
        //}
    },
    setBackupDate: function setBackupDate(_ref28) {
        var getters = _ref28.getters,
            dispatch = _ref28.dispatch;

        var wallet = getters.wallet;
        wallet.backup_date = new Date();
        return dispatch("_updateWallet");
    },
    importKeysWorker: function importKeysWorker(_ref29, private_key_objs) {
        var dispatch = _ref29.dispatch,
            state = _ref29.state;

        return new _promise2.default(function (resolve, reject) {
            var pubkeys = [];
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = (0, _getIterator3.default)(private_key_objs), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var _private_key_obj = _step2.value;

                    pubkeys.push(_private_key_obj.public_key_string);
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }

            var addyIndexPromise = dispatch("AddressIndex/addAll", pubkeys, { root: true });

            var private_plainhex_array = [];
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
                for (var _iterator3 = (0, _getIterator3.default)(private_key_objs), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var _private_key_obj2 = _step3.value;

                    private_plainhex_array.push(_private_key_obj2.private_plainhex);
                } // var AesWorker = require("worker?name=/[hash].js!../workers/AesWorker")
                // var worker = new AesWorker
                // worker.postMessage({
                //     private_plainhex_array,
                //     key: aes_private.key, iv: aes_private.iv
                // })
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
                        _iterator3.return();
                    }
                } finally {
                    if (_didIteratorError3) {
                        throw _iteratorError3;
                    }
                }
            }

            console.log("AesWorker start");

            var _private_plainhex_arr = {
                private_plainhex_array: private_plainhex_array,
                key: state.aes_private.key, iv: state.aes_private.iv
            },
                private_plainhex_array = _private_plainhex_arr.private_plainhex_array,
                iv = _private_plainhex_arr.iv,
                key = _private_plainhex_arr.key;


            var aes = new _bcxjsCores.Aes(iv, key);
            var private_cipherhex_array = [];
            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
                for (var _iterator4 = (0, _getIterator3.default)(private_plainhex_array), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                    var _private_plainhex = _step4.value;

                    var private_cipherhex = aes.encryptHex(_private_plainhex);
                    private_cipherhex_array.push(private_cipherhex);
                }
                // postMessage( private_cipherhex_array )
            } catch (err) {
                _didIteratorError4 = true;
                _iteratorError4 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion4 && _iterator4.return) {
                        _iterator4.return();
                    }
                } finally {
                    if (_didIteratorError4) {
                        throw _iteratorError4;
                    }
                }
            }

            console.log("AesWorker done");

            var _this = undefined;
            state.saving_keys = true;

            // worker.onmessage = event => {
            try {
                console.log("Preparing for private keys save");
                var private_cipherhex_array = private_cipherhex_array;
                var enc_private_key_objs = [];
                for (var i = 0; i < private_key_objs.length; i++) {
                    var private_key_obj = private_key_objs[i];
                    var import_account_names = private_key_obj.import_account_names,
                        public_key_string = private_key_obj.public_key_string,
                        private_plainhex = private_key_obj.private_plainhex;

                    var private_cipherhex = private_cipherhex_array[i];
                    if (!public_key_string) {
                        // console.log('WARN: public key was not provided, this will incur slow performance')
                        var private_key = _bcxjsCores.PrivateKey.fromHex(private_plainhex);
                        var public_key = private_key.toPublicKey(); // S L O W
                        public_key_string = public_key.toPublicKeyString();
                    } else if (public_key_string.indexOf(_bcxjsWs.ChainConfig.address_prefix) != 0) throw new Error("Public Key should start with " + _bcxjsWs.ChainConfig.address_prefix);

                    var private_key_object = {
                        import_account_names: import_account_names,
                        encrypted_key: private_cipherhex,
                        pubkey: public_key_string
                        // null brainkey_sequence
                    };
                    enc_private_key_objs.push(private_key_object);
                }
                console.log("Saving private keys", new Date().toString());
                var transaction = transaction_update_keys();
                var insertKeysPromise = _idbHelper2.default.on_transaction_end(transaction);
                try {
                    var duplicate_count = dispatch("PrivateKeyStore/addPrivateKeys_noindex", {
                        private_key_objects: enc_private_key_objs,
                        transaction: transaction }, { root: true });
                    //
                    if (private_key_objs.length != duplicate_count) dispatch("_updateWallet", transaction);
                    state.saving_keys = false;
                    resolve(_promise2.default.all([insertKeysPromise, addyIndexPromise]).then(function () {
                        console.log("Done saving keys", new Date().toString());
                        // return { duplicate_count }
                    }));
                } catch (e) {
                    transaction.abort();
                    console.error(e);
                    reject(e);
                }
            } catch (e) {
                console.error('AesWorker.encrypt', e);
            }
            // }
        });
    }
    // const isLocked=()=>{
    //     return aes_private ? false : true;
    // }

};var transaction_update = function transaction_update() {
    var transaction = _idbInstance2.default.instance().db().transaction(["wallet"], "readwrite");
    return transaction;
};

var transaction_update_keys = function transaction_update_keys() {
    var transaction = _idbInstance2.default.instance().db().transaction(["wallet", "private_keys"], "readwrite");
    return transaction;
};

var mutations = (_mutations = {}, (0, _defineProperty3.default)(_mutations, types.SET_PASSWORD_KEY, function (state, keys) {
    state._passwordKey = keys;
}), (0, _defineProperty3.default)(_mutations, types.SET_AES_PRIVATE, function (state, aes_private) {
    state.aes_private = aes_private;
}), _mutations);

exports.default = {
    state: initialState,
    mutations: mutations,
    actions: actions,
    getters: getters,
    namespaced: true
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),
/* 576 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, module) {var __WEBPACK_AMD_DEFINE_RESULT__;/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '4.17.15';

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Error message constants. */
  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
      FUNC_ERROR_TEXT = 'Expected a function';

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG = 4;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /** Used to compose bitmasks for function metadata. */
  var WRAP_BIND_FLAG = 1,
      WRAP_BIND_KEY_FLAG = 2,
      WRAP_CURRY_BOUND_FLAG = 4,
      WRAP_CURRY_FLAG = 8,
      WRAP_CURRY_RIGHT_FLAG = 16,
      WRAP_PARTIAL_FLAG = 32,
      WRAP_PARTIAL_RIGHT_FLAG = 64,
      WRAP_ARY_FLAG = 128,
      WRAP_REARG_FLAG = 256,
      WRAP_FLIP_FLAG = 512;

  /** Used as default options for `_.truncate`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2,
      LAZY_WHILE_FLAG = 3;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0,
      MAX_SAFE_INTEGER = 9007199254740991,
      MAX_INTEGER = 1.7976931348623157e+308,
      NAN = 0 / 0;

  /** Used as references for the maximum length and index of an array. */
  var MAX_ARRAY_LENGTH = 4294967295,
      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

  /** Used to associate wrap methods with their bit flags. */
  var wrapFlags = [
    ['ary', WRAP_ARY_FLAG],
    ['bind', WRAP_BIND_FLAG],
    ['bindKey', WRAP_BIND_KEY_FLAG],
    ['curry', WRAP_CURRY_FLAG],
    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
    ['flip', WRAP_FLIP_FLAG],
    ['partial', WRAP_PARTIAL_FLAG],
    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
    ['rearg', WRAP_REARG_FLAG]
  ];

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      asyncTag = '[object AsyncFunction]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      domExcTag = '[object DOMException]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      nullTag = '[object Null]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      proxyTag = '[object Proxy]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      undefinedTag = '[object Undefined]',
      weakMapTag = '[object WeakMap]',
      weakSetTag = '[object WeakSet]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
      reUnescapedHtml = /[&<>"']/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
      reHasRegExpChar = RegExp(reRegExpChar.source);

  /** Used to match leading and trailing whitespace. */
  var reTrim = /^\s+|\s+$/g,
      reTrimStart = /^\s+/,
      reTrimEnd = /\s+$/;

  /** Used to match wrap detail comments. */
  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
      reSplitDetails = /,? & /;

  /** Used to match words composed of alphanumeric characters. */
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /** Used to match Latin Unicode letters (excluding mathematical operators). */
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to compose unicode character classes. */
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f',
      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange = '\\u20d0-\\u20ff',
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsDingbatRange = '\\u2700-\\u27bf',
      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
      rsPunctuationRange = '\\u2000-\\u206f',
      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
      rsVarRange = '\\ufe0e\\ufe0f',
      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

  /** Used to compose unicode capture groups. */
  var rsApos = "['\u2019]",
      rsAstral = '[' + rsAstralRange + ']',
      rsBreak = '[' + rsBreakRange + ']',
      rsCombo = '[' + rsComboRange + ']',
      rsDigits = '\\d+',
      rsDingbat = '[' + rsDingbatRange + ']',
      rsLower = '[' + rsLowerRange + ']',
      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsUpper = '[' + rsUpperRange + ']',
      rsZWJ = '\\u200d';

  /** Used to compose unicode regexes. */
  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
      reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange + ']?',
      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

  /** Used to match apostrophes. */
  var reApos = RegExp(rsApos, 'g');

  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */
  var reComboMark = RegExp(rsCombo, 'g');

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

  /** Used to match complex or compound words. */
  var reUnicodeWord = RegExp([
    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
    rsUpper + '+' + rsOptContrUpper,
    rsOrdUpper,
    rsOrdLower,
    rsDigits,
    rsEmoji
  ].join('|'), 'g');

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

  /** Used to detect strings that need a more robust regexp to match words. */
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
  cloneableTags[boolTag] = cloneableTags[dateTag] =
  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
  cloneableTags[int32Tag] = cloneableTags[mapTag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[setTag] =
  cloneableTags[stringTag] = cloneableTags[symbolTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[weakMapTag] = false;

  /** Used to map Latin Unicode letters to basic Latin letters. */
  var deburredLetters = {
    // Latin-1 Supplement block.
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss',
    // Latin Extended-A block.
    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
    '\u0134': 'J',  '\u0135': 'j',
    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
    '\u0174': 'W',  '\u0175': 'w',
    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
    '\u0132': 'IJ', '\u0133': 'ij',
    '\u0152': 'Oe', '\u0153': 'oe',
    '\u0149': "'n", '\u017f': 's'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'"
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Built-in method references without a dependency on `root`. */
  var freeParseFloat = parseFloat,
      freeParseInt = parseInt;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Detect free variable `exports`. */
  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  /* Node.js helper references. */
  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
      nodeIsDate = nodeUtil && nodeUtil.isDate,
      nodeIsMap = nodeUtil && nodeUtil.isMap,
      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
      nodeIsSet = nodeUtil && nodeUtil.isSet,
      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /*--------------------------------------------------------------------------*/

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  /**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */
  function arrayAggregator(array, setter, iteratee, accumulator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      var value = array[index];
      setter(accumulator, value, iteratee(value), array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEachRight(array, iteratee) {
    var length = array == null ? 0 : array.length;

    while (length--) {
      if (iteratee(array[length], length, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */
  function arrayEvery(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }

  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludesWith(array, value, comparator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array == null ? 0 : array.length;

    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
    var length = array == null ? 0 : array.length;
    if (initAccum && length) {
      accumulator = array[--length];
    }
    while (length--) {
      accumulator = iteratee(accumulator, array[length], length, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  var asciiSize = baseProperty('length');

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray(string) {
    return string.split('');
  }

  /**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }

  /**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */
  function baseFindKey(collection, predicate, eachFunc) {
    var result;
    eachFunc(collection, function(value, key, collection) {
      if (predicate(value, key, collection)) {
        result = key;
        return false;
      }
    });
    return result;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    return value === value
      ? strictIndexOf(array, value, fromIndex)
      : baseFindIndex(array, baseIsNaN, fromIndex);
  }

  /**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOfWith(array, value, fromIndex, comparator) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (comparator(array[index], value)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
  function baseIsNaN(value) {
    return value !== value;
  }

  /**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */
  function baseMean(array, iteratee) {
    var length = array == null ? 0 : array.length;
    return length ? (baseSum(array, iteratee) / length) : NAN;
  }

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */
  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function(value, index, collection) {
      accumulator = initAccum
        ? (initAccum = false, value)
        : iteratee(accumulator, value, index, collection);
    });
    return accumulator;
  }

  /**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */
  function baseSortBy(array, comparer) {
    var length = array.length;

    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }

  /**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */
  function baseSum(array, iteratee) {
    var result,
        index = -1,
        length = array.length;

    while (++index < length) {
      var current = iteratee(array[index]);
      if (current !== undefined) {
        result = result === undefined ? current : (result + current);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */
  function baseToPairs(object, props) {
    return arrayMap(props, function(key) {
      return [key, object[key]];
    });
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */
  function baseValues(object, props) {
    return arrayMap(props, function(key) {
      return object[key];
    });
  }

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  /**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */
  function charsStartIndex(strSymbols, chrSymbols) {
    var index = -1,
        length = strSymbols.length;

    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */
  function charsEndIndex(strSymbols, chrSymbols) {
    var index = strSymbols.length;

    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */
  function countHolders(array, placeholder) {
    var length = array.length,
        result = 0;

    while (length--) {
      if (array[length] === placeholder) {
        ++result;
      }
    }
    return result;
  }

  /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  var deburrLetter = basePropertyOf(deburredLetters);

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  var escapeHtmlChar = basePropertyOf(htmlEscapes);

  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  /**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }

  /**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */
  function iteratorToArray(iterator) {
    var data,
        result = [];

    while (!(data = iterator.next()).done) {
      result.push(data.value);
    }
    return result;
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (value === placeholder || value === PLACEHOLDER) {
        array[index] = PLACEHOLDER;
        result[resIndex++] = index;
      }
    }
    return result;
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  /**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */
  function setToPairs(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = [value, value];
    });
    return result;
  }

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictLastIndexOf(array, value, fromIndex) {
    var index = fromIndex + 1;
    while (index--) {
      if (array[index] === value) {
        return index;
      }
    }
    return index;
  }

  /**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */
  function stringSize(string) {
    return hasUnicode(string)
      ? unicodeSize(string)
      : asciiSize(string);
  }

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray(string) {
    return hasUnicode(string)
      ? unicodeToArray(string)
      : asciiToArray(string);
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

  /**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;
    while (reUnicode.test(string)) {
      ++result;
    }
    return result;
  }

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }

  /**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  var runInContext = (function runInContext(context) {
    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

    /** Built-in constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for built-in method references. */
    var arrayProto = Array.prototype,
        funcProto = Function.prototype,
        objectProto = Object.prototype;

    /** Used to detect overreaching core-js shims. */
    var coreJsData = context['__core-js_shared__'];

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto.toString;

    /** Used to infer the `Object` constructor. */
    var objectCtorString = funcToString.call(Object);

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = root._;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Built-in value references. */
    var Buffer = moduleExports ? context.Buffer : undefined,
        Symbol = context.Symbol,
        Uint8Array = context.Uint8Array,
        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
        getPrototype = overArg(Object.getPrototypeOf, Object),
        objectCreate = Object.create,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        splice = arrayProto.splice,
        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
        symIterator = Symbol ? Symbol.iterator : undefined,
        symToStringTag = Symbol ? Symbol.toStringTag : undefined;

    var defineProperty = (function() {
      try {
        var func = getNative(Object, 'defineProperty');
        func({}, '', {});
        return func;
      } catch (e) {}
    }());

    /** Mocked built-ins. */
    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
        ctxNow = Date && Date.now !== root.Date.now && Date.now,
        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil,
        nativeFloor = Math.floor,
        nativeGetSymbols = Object.getOwnPropertySymbols,
        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
        nativeIsFinite = context.isFinite,
        nativeJoin = arrayProto.join,
        nativeKeys = overArg(Object.keys, Object),
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = Date.now,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random,
        nativeReverse = arrayProto.reverse;

    /* Built-in method references that are verified to be native. */
    var DataView = getNative(context, 'DataView'),
        Map = getNative(context, 'Map'),
        Promise = getNative(context, 'Promise'),
        Set = getNative(context, 'Set'),
        WeakMap = getNative(context, 'WeakMap'),
        nativeCreate = getNative(Object, 'create');

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup unminified function names. */
    var realNames = {};

    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map),
        promiseCtorString = toSource(Promise),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap);

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol ? Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object;
        object.prototype = undefined;
        return result;
      };
    }());

    /**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */
    function LodashWrapper(value, chainAll) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__chain__ = !!chainAll;
      this.__index__ = 0;
      this.__values__ = undefined;
    }

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */
        '_': lodash
      }
    };

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;
    lodash.prototype.constructor = lodash;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = MAX_ARRAY_LENGTH;
      this.__views__ = [];
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var result = new LazyWrapper(this.__wrapped__);
      result.__actions__ = copyArray(this.__actions__);
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = copyArray(this.__iteratees__);
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = copyArray(this.__views__);
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value(),
          dir = this.__dir__,
          isArr = isArray(array),
          isRight = dir < 0,
          arrLength = isArr ? array.length : 0,
          view = getView(0, arrLength, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          index = isRight ? end : (start - 1),
          iteratees = this.__iteratees__,
          iterLength = iteratees.length,
          resIndex = 0,
          takeCount = nativeMin(length, this.__takeCount__);

      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
        return baseWrapperValue(array, this.__actions__);
      }
      var result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              type = data.type,
              computed = iteratee(value);

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        result[resIndex++] = value;
      }
      return result;
    }

    // Ensure `LazyWrapper` is an instance of `baseLodash`.
    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
    }

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
      return this;
    }

    // Add methods to `Hash`.
    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    // Add methods to `ListCache`.
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
      };
    }

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      var result = getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      var data = getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    // Add methods to `MapCache`.
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var index = -1,
          length = values == null ? 0 : values.length;

      this.__data__ = new MapCache;
      while (++index < length) {
        this.add(values[index]);
      }
    }

    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }

    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
    function setCacheHas(value) {
      return this.__data__.has(value);
    }

    // Add methods to `SetCache`.
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }

    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
      this.__data__ = new ListCache;
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
      var data = this.__data__,
          result = data['delete'](key);

      this.size = data.size;
      return result;
    }

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
      return this.__data__.get(key);
    }

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
      return this.__data__.has(key);
    }

    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }

    // Add methods to `Stack`.
    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */
    function arraySample(array) {
      var length = array.length;
      return length ? array[baseRandom(0, length - 1)] : undefined;
    }

    /**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function arraySampleSize(array, n) {
      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
    }

    /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function arrayShuffle(array) {
      return shuffleSelf(copyArray(array));
    }

    /**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignMergeValue(object, key, value) {
      if ((value !== undefined && !eq(object[key], value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key, collection) {
        setter(accumulator, value, iteratee(value), collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }

    /**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }

    /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function baseAssignValue(object, key, value) {
      if (key == '__proto__' && defineProperty) {
        defineProperty(object, key, {
          'configurable': true,
          'enumerable': true,
          'value': value,
          'writable': true
        });
      } else {
        object[key] = value;
      }
    }

    /**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */
    function baseAt(object, paths) {
      var index = -1,
          length = paths.length,
          result = Array(length),
          skip = object == null;

      while (++index < length) {
        result[index] = skip ? undefined : get(object, paths[index]);
      }
      return result;
    }

    /**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */
    function baseClamp(number, lower, upper) {
      if (number === number) {
        if (upper !== undefined) {
          number = number <= upper ? number : upper;
        }
        if (lower !== undefined) {
          number = number >= lower ? number : lower;
        }
      }
      return number;
    }

    /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result,
          isDeep = bitmask & CLONE_DEEP_FLAG,
          isFlat = bitmask & CLONE_FLAT_FLAG,
          isFull = bitmask & CLONE_SYMBOLS_FLAG;

      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value),
            isFunc = tag == funcTag || tag == genTag;

        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = (isFlat || isFunc) ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat
              ? copySymbolsIn(value, baseAssignIn(result, value))
              : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      // Check for circular references and return its corresponding clone.
      stack || (stack = new Stack);
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);

      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key) {
          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
        });
      }

      var keysFunc = isFull
        ? (isFlat ? getAllKeysIn : getAllKeys)
        : (isFlat ? keysIn : keys);

      var props = isArr ? undefined : keysFunc(value);
      arrayEach(props || value, function(subValue, key) {
        if (props) {
          key = subValue;
          subValue = value[key];
        }
        // Recursively populate clone (susceptible to call stack limits).
        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
      return result;
    }

    /**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */
    function baseConforms(source) {
      var props = keys(source);
      return function(object) {
        return baseConformsTo(object, source, props);
      };
    }

    /**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */
    function baseConformsTo(object, source, props) {
      var length = props.length;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (length--) {
        var key = props[length],
            predicate = source[key],
            value = object[key];

        if ((value === undefined && !(key in object)) || !predicate(value)) {
          return false;
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          isCommon = true,
          length = array.length,
          result = [],
          valuesLength = values.length;

      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      }
      else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee == null ? value : iteratee(value);

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (!includes(values, computed, comparator)) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);

    /**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */
    function baseExtremum(array, iteratee, comparator) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        var value = array[index],
            current = iteratee(value);

        if (current != null && (computed === undefined
              ? (current === current && !isSymbol(current))
              : comparator(current, computed)
            )) {
          var computed = current,
              result = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = toInteger(start);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : toInteger(end);
      if (end < 0) {
        end += length;
      }
      end = start > end ? 0 : toLength(end);
      while (start < end) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1,
          length = array.length;

      predicate || (predicate = isFlattenable);
      result || (result = []);

      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);

    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return object && baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */
    function baseFunctions(object, props) {
      return arrayFilter(props, function(key) {
        return isFunction(object[key]);
      });
    }

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = castPath(path, object);

      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    /**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */
    function baseGt(value, other) {
      return value > other;
    }

    /**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHas(object, key) {
      return object != null && hasOwnProperty.call(object, key);
    }

    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }

    /**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */
    function baseInRange(number, start, end) {
      return number >= nativeMin(start, end) && number < nativeMax(start, end);
    }

    /**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */
    function baseIntersection(arrays, iteratee, comparator) {
      var includes = comparator ? arrayIncludesWith : arrayIncludes,
          length = arrays[0].length,
          othLength = arrays.length,
          othIndex = othLength,
          caches = Array(othLength),
          maxLength = Infinity,
          result = [];

      while (othIndex--) {
        var array = arrays[othIndex];
        if (othIndex && iteratee) {
          array = arrayMap(array, baseUnary(iteratee));
        }
        maxLength = nativeMin(array.length, maxLength);
        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
          ? new SetCache(othIndex && array)
          : undefined;
      }
      array = arrays[0];

      var index = -1,
          seen = caches[0];

      outer:
      while (++index < length && result.length < maxLength) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (!(seen
              ? cacheHas(seen, computed)
              : includes(result, computed, comparator)
            )) {
          othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if (!(cache
                  ? cacheHas(cache, computed)
                  : includes(arrays[othIndex], computed, comparator))
                ) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseInverter(object, setter, iteratee, accumulator) {
      baseForOwn(object, function(value, key, object) {
        setter(accumulator, iteratee(value), key, object);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
    function baseInvoke(object, path, args) {
      path = castPath(path, object);
      object = parent(object, path);
      var func = object == null ? object : object[toKey(last(path))];
      return func == null ? undefined : apply(func, object, args);
    }

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }

    /**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */
    function baseIsArrayBuffer(value) {
      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
    }

    /**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */
    function baseIsDate(value) {
      return isObjectLike(value) && baseGetTag(value) == dateTag;
    }

    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = objIsArr ? arrayTag : getTag(object),
          othTag = othIsArr ? arrayTag : getTag(other);

      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;

      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack);
        return (objIsArr || isTypedArray(object))
          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;

          stack || (stack = new Stack);
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack);
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }

    /**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }

    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack;
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === undefined
                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
                : result
              )) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }

    /**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */
    function baseIsRegExp(value) {
      return isObjectLike(value) && baseGetTag(value) == regexpTag;
    }

    /**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike(value) &&
        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
    function baseIteratee(value) {
      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
      if (typeof value == 'function') {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == 'object') {
        return isArray(value)
          ? baseMatchesProperty(value[0], value[1])
          : baseMatches(value);
      }
      return property(value);
    }

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object),
          result = [];

      for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */
    function baseLt(value, other) {
      return value < other;
    }

    /**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return (objValue === undefined && objValue === srcValue)
          ? hasIn(object, path)
          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }

    /**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack);
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        }
        else {
          var newValue = customizer
            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
            : undefined;

          if (newValue === undefined) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key),
          srcValue = safeGet(source, key),
          stacked = stack.get(srcValue);

      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer
        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
        : undefined;

      var isCommon = newValue === undefined;

      if (isCommon) {
        var isArr = isArray(srcValue),
            isBuff = !isArr && isBuffer(srcValue),
            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          }
          else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          }
          else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          }
          else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          }
          else {
            newValue = [];
          }
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          }
          else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        }
        else {
          isCommon = false;
        }
      }
      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack['delete'](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }

    /**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */
    function baseNth(array, n) {
      var length = array.length;
      if (!length) {
        return;
      }
      n += n < 0 ? length : 0;
      return isIndex(n, length) ? array[n] : undefined;
    }

    /**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseOrderBy(collection, iteratees, orders) {
      var index = -1;
      iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));

      var result = baseMap(collection, function(value, key, collection) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { 'criteria': criteria, 'index': ++index, 'value': value };
      });

      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }

    /**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */
    function basePick(object, paths) {
      return basePickBy(object, paths, function(value, path) {
        return hasIn(object, path);
      });
    }

    /**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */
    function basePickBy(object, paths, predicate) {
      var index = -1,
          length = paths.length,
          result = {};

      while (++index < length) {
        var path = paths[index],
            value = baseGet(object, path);

        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }

    /**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */
    function basePullAll(array, values, iteratee, comparator) {
      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
          index = -1,
          length = values.length,
          seen = array;

      if (array === values) {
        values = copyArray(values);
      }
      if (iteratee) {
        seen = arrayMap(array, baseUnary(iteratee));
      }
      while (++index < length) {
        var fromIndex = 0,
            value = values[index],
            computed = iteratee ? iteratee(value) : value;

        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
          if (seen !== array) {
            splice.call(seen, fromIndex, 1);
          }
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0,
          lastIndex = length - 1;

      while (length--) {
        var index = indexes[length];
        if (length == lastIndex || index !== previous) {
          var previous = index;
          if (isIndex(index)) {
            splice.call(array, index, 1);
          } else {
            baseUnset(array, index);
          }
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */
    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }

    /**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */
    function baseRange(start, end, step, fromRight) {
      var index = -1,
          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (length--) {
        result[fromRight ? length : ++index] = start;
        start += step;
      }
      return result;
    }

    /**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */
    function baseRepeat(string, n) {
      var result = '';
      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        if (n) {
          string += string;
        }
      } while (n);

      return result;
    }

    /**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + '');
    }

    /**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */
    function baseSample(collection) {
      return arraySample(values(collection));
    }

    /**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function baseSampleSize(collection, n) {
      var array = values(collection);
      return shuffleSelf(array, baseClamp(n, 0, array.length));
    }

    /**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = toKey(path[index]),
            newValue = value;

        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : undefined;
          if (newValue === undefined) {
            newValue = isObject(objValue)
              ? objValue
              : (isIndex(path[index + 1]) ? [] : {});
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }

    /**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': constant(string),
        'writable': true
      });
    };

    /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function baseShuffle(collection) {
      return shuffleSelf(values(collection));
    }

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndex(array, value, retHighest) {
      var low = 0,
          high = array == null ? low : array.length;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if (computed !== null && !isSymbol(computed) &&
              (retHighest ? (computed <= value) : (computed < value))) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return baseSortedIndexBy(array, value, identity, retHighest);
    }

    /**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndexBy(array, value, iteratee, retHighest) {
      value = iteratee(value);

      var low = 0,
          high = array == null ? 0 : array.length,
          valIsNaN = value !== value,
          valIsNull = value === null,
          valIsSymbol = isSymbol(value),
          valIsUndefined = value === undefined;

      while (low < high) {
        var mid = nativeFloor((low + high) / 2),
            computed = iteratee(array[mid]),
            othIsDefined = computed !== undefined,
            othIsNull = computed === null,
            othIsReflexive = computed === computed,
            othIsSymbol = isSymbol(computed);

        if (valIsNaN) {
          var setLow = retHighest || othIsReflexive;
        } else if (valIsUndefined) {
          setLow = othIsReflexive && (retHighest || othIsDefined);
        } else if (valIsNull) {
          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
        } else if (valIsSymbol) {
          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
        } else if (othIsNull || othIsSymbol) {
          setLow = false;
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseSortedUniq(array, iteratee) {
      var index = -1,
          length = array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        if (!index || !eq(computed, seen)) {
          var seen = computed;
          result[resIndex++] = value === 0 ? 0 : value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */
    function baseToNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      return +value;
    }

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return arrayMap(value, baseToString) + '';
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseUniq(array, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          length = array.length,
          isCommon = true,
          result = [],
          seen = result;

      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      }
      else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache;
      }
      else {
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */
    function baseUnset(object, path) {
      path = castPath(path, object);
      object = parent(object, path);
      return object == null || delete object[toKey(last(path))];
    }

    /**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseUpdate(object, path, updater, customizer) {
      return baseSet(object, path, updater(baseGet(object, path)), customizer);
    }

    /**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) &&
        predicate(array[index], index, array)) {}

      return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      return arrayReduce(actions, function(result, action) {
        return action.func.apply(action.thisArg, arrayPush([result], action.args));
      }, result);
    }

    /**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */
    function baseXor(arrays, iteratee, comparator) {
      var length = arrays.length;
      if (length < 2) {
        return length ? baseUniq(arrays[0]) : [];
      }
      var index = -1,
          result = Array(length);

      while (++index < length) {
        var array = arrays[index],
            othIndex = -1;

        while (++othIndex < length) {
          if (othIndex != index) {
            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
          }
        }
      }
      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
    }

    /**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */
    function baseZipObject(props, values, assignFunc) {
      var index = -1,
          length = props.length,
          valsLength = values.length,
          result = {};

      while (++index < length) {
        var value = index < valsLength ? values[index] : undefined;
        assignFunc(result, props[index], value);
      }
      return result;
    }

    /**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */
    function castArrayLikeObject(value) {
      return isArrayLikeObject(value) ? value : [];
    }

    /**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */
    function castFunction(value) {
      return typeof value == 'function' ? value : identity;
    }

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }

    /**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    var castRest = baseRest;

    /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === undefined ? length : end;
      return (!start && end >= length) ? array : baseSlice(array, start, end);
    }

    /**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */
    var clearTimeout = ctxClearTimeout || function(id) {
      return root.clearTimeout(id);
    };

    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length,
          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

      buffer.copy(result);
      return result;
    }

    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }

    /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }

    /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }

    /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }

    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }

    /**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== undefined,
            valIsNull = value === null,
            valIsReflexive = value === value,
            valIsSymbol = isSymbol(value);

        var othIsDefined = other !== undefined,
            othIsNull = other === null,
            othIsReflexive = other === other,
            othIsSymbol = isSymbol(other);

        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
            (valIsNull && othIsDefined && othIsReflexive) ||
            (!valIsDefined && othIsReflexive) ||
            !valIsReflexive) {
          return 1;
        }
        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
            (othIsNull && valIsDefined && valIsReflexive) ||
            (!othIsDefined && valIsReflexive) ||
            !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }

    /**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */
    function compareMultiple(object, other, orders) {
      var index = -1,
          objCriteria = object.criteria,
          othCriteria = other.criteria,
          length = objCriteria.length,
          ordersLength = orders.length;

      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == 'desc' ? -1 : 1);
        }
      }
      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
      // that causes it, under certain circumstances, to provide the same value for
      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
      // for more details.
      //
      // This also ensures a stable sort in V8 and other engines.
      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
      return object.index - other.index;
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersLength = holders.length,
          leftIndex = -1,
          leftLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(leftLength + rangeLength),
          isUncurried = !isCurried;

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[holders[argsIndex]] = args[argsIndex];
        }
      }
      while (rangeLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersIndex = -1,
          holdersLength = holders.length,
          rightIndex = -1,
          rightLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(rangeLength + rightLength),
          isUncurried = !isCurried;

      while (++argsIndex < rangeLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[offset + holders[holdersIndex]] = args[argsIndex++];
        }
      }
      return result;
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];

        var newValue = customizer
          ? customizer(object[key], source[key], key, object, source)
          : undefined;

        if (newValue === undefined) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }

    /**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }

    /**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }

    /**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func = isArray(collection) ? arrayAggregator : baseAggregator,
            accumulator = initializer ? initializer() : {};

        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
      };
    }

    /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined;

        customizer = (assigner.length > 3 && typeof customizer == 'function')
          ? (length--, customizer)
          : undefined;

        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length,
            index = fromRight ? length : -1,
            iterable = Object(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;

        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createBind(func, bitmask, thisArg) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);

        var strSymbols = hasUnicode(string)
          ? stringToArray(string)
          : undefined;

        var chr = strSymbols
          ? strSymbols[0]
          : string.charAt(0);

        var trailing = strSymbols
          ? castSlice(strSymbols, 1).join('')
          : string.slice(1);

        return chr[methodName]() + trailing;
      };
    }

    /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtor(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors. See
        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCurry(func, bitmask, arity) {
      var Ctor = createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length,
            placeholder = getHolder(wrapper);

        while (index--) {
          args[index] = arguments[index];
        }
        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
          ? []
          : replaceHolders(args, placeholder);

        length -= holders.length;
        if (length < arity) {
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, undefined,
            args, holders, undefined, undefined, arity - length);
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return apply(fn, this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = getIteratee(predicate, 3);
          collection = keys(collection);
          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
        }
        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
      };
    }

    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return flatRest(function(funcs) {
        var length = funcs.length,
            index = length,
            prereq = LodashWrapper.prototype.thru;

        if (fromRight) {
          funcs.reverse();
        }
        while (index--) {
          var func = funcs[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
            var wrapper = new LodashWrapper([], true);
          }
        }
        index = wrapper ? index : length;
        while (++index < length) {
          func = funcs[index];

          var funcName = getFuncName(func),
              data = funcName == 'wrapper' ? getData(func) : undefined;

          if (data && isLaziable(data[0]) &&
                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
                !data[4].length && data[9] == 1
              ) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = (func.length == 1 && isLaziable(func))
              ? wrapper[funcName]()
              : wrapper.thru(func);
          }
        }
        return function() {
          var args = arguments,
              value = args[0];

          if (wrapper && args.length == 1 && isArray(value)) {
            return wrapper.plant(value).value();
          }
          var index = 0,
              result = length ? funcs[index].apply(this, args) : value;

          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      });
    }

    /**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & WRAP_ARY_FLAG,
          isBind = bitmask & WRAP_BIND_FLAG,
          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
          isFlip = bitmask & WRAP_FLIP_FLAG,
          Ctor = isBindKey ? undefined : createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length;

        while (index--) {
          args[index] = arguments[index];
        }
        if (isCurried) {
          var placeholder = getHolder(wrapper),
              holdersCount = countHolders(args, placeholder);
        }
        if (partials) {
          args = composeArgs(args, partials, holders, isCurried);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
        }
        length -= holdersCount;
        if (isCurried && length < arity) {
          var newHolders = replaceHolders(args, placeholder);
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
            args, newHolders, argPos, ary, arity - length
          );
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        length = args.length;
        if (argPos) {
          args = reorder(args, argPos);
        } else if (isFlip && length > 1) {
          args.reverse();
        }
        if (isAry && ary < length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtor(fn);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */
    function createInverter(setter, toIteratee) {
      return function(object, iteratee) {
        return baseInverter(object, setter, toIteratee(iteratee), {});
      };
    }

    /**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */
    function createMathOperation(operator, defaultValue) {
      return function(value, other) {
        var result;
        if (value === undefined && other === undefined) {
          return defaultValue;
        }
        if (value !== undefined) {
          result = value;
        }
        if (other !== undefined) {
          if (result === undefined) {
            return other;
          }
          if (typeof value == 'string' || typeof other == 'string') {
            value = baseToString(value);
            other = baseToString(other);
          } else {
            value = baseToNumber(value);
            other = baseToNumber(other);
          }
          result = operator(value, other);
        }
        return result;
      };
    }

    /**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */
    function createOver(arrayFunc) {
      return flatRest(function(iteratees) {
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        return baseRest(function(args) {
          var thisArg = this;
          return arrayFunc(iteratees, function(iteratee) {
            return apply(iteratee, thisArg, args);
          });
        });
      });
    }

    /**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */
    function createPadding(length, chars) {
      chars = chars === undefined ? ' ' : baseToString(chars);

      var charsLength = chars.length;
      if (charsLength < 2) {
        return charsLength ? baseRepeat(chars, length) : chars;
      }
      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
      return hasUnicode(chars)
        ? castSlice(stringToArray(result), 0, length).join('')
        : result.slice(0, length);
    }

    /**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */
    function createPartial(func, bitmask, thisArg, partials) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength),
            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        return apply(fn, isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */
    function createRange(fromRight) {
      return function(start, end, step) {
        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
          end = step = undefined;
        }
        // Ensure the sign of `-0` is preserved.
        start = toFinite(start);
        if (end === undefined) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
        return baseRange(start, end, step, fromRight);
      };
    }

    /**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */
    function createRelationalOperation(operator) {
      return function(value, other) {
        if (!(typeof value == 'string' && typeof other == 'string')) {
          value = toNumber(value);
          other = toNumber(other);
        }
        return operator(value, other);
      };
    }

    /**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
      var isCurry = bitmask & WRAP_CURRY_FLAG,
          newHolders = isCurry ? holders : undefined,
          newHoldersRight = isCurry ? undefined : holders,
          newPartials = isCurry ? partials : undefined,
          newPartialsRight = isCurry ? undefined : partials;

      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
      }
      var newData = [
        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
        newHoldersRight, argPos, ary, arity
      ];

      var result = wrapFunc.apply(undefined, newData);
      if (isLaziable(func)) {
        setData(result, newData);
      }
      result.placeholder = placeholder;
      return setWrapToString(result, func, bitmask);
    }

    /**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        number = toNumber(number);
        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
        if (precision && nativeIsFinite(number)) {
          // Shift with exponential notation to avoid floating-point issues.
          // See [MDN](https://mdn.io/round#Examples) for more details.
          var pair = (toString(number) + 'e').split('e'),
              value = func(pair[0] + 'e' + (+pair[1] + precision));

          pair = (toString(value) + 'e').split('e');
          return +(pair[0] + 'e' + (+pair[1] - precision));
        }
        return func(number);
      };
    }

    /**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */
    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
      return new Set(values);
    };

    /**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */
    function createToPairs(keysFunc) {
      return function(object) {
        var tag = getTag(object);
        if (tag == mapTag) {
          return mapToArray(object);
        }
        if (tag == setTag) {
          return setToPairs(object);
        }
        return baseToPairs(object, keysFunc(object));
      };
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
        partials = holders = undefined;
      }
      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
      arity = arity === undefined ? arity : toInteger(arity);
      length -= holders ? holders.length : 0;

      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func);

      var newData = [
        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
        argPos, ary, arity
      ];

      if (data) {
        mergeData(newData, data);
      }
      func = newData[0];
      bitmask = newData[1];
      thisArg = newData[2];
      partials = newData[3];
      holders = newData[4];
      arity = newData[9] = newData[9] === undefined
        ? (isBindKey ? 0 : func.length)
        : nativeMax(newData[9] - length, 0);

      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
      }
      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
        var result = createBind(func, bitmask, thisArg);
      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
        result = createCurry(func, bitmask, arity);
      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
        result = createPartial(func, bitmask, thisArg, partials);
      } else {
        result = createHybrid.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setWrapToString(setter(result, newData), func, bitmask);
    }

    /**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsAssignIn(objValue, srcValue, key, object) {
      if (objValue === undefined ||
          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
        return srcValue;
      }
      return objValue;
    }

    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
      if (isObject(objValue) && isObject(srcValue)) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, objValue);
        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
        stack['delete'](srcValue);
      }
      return objValue;
    }

    /**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */
    function customOmitClone(value) {
      return isPlainObject(value) ? undefined : value;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1,
          result = true,
          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

      stack.set(array, other);
      stack.set(other, array);

      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, arrValue, index, other, array, stack)
            : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
          if (!arraySome(other, function(othValue, othIndex) {
                if (!cacheHas(seen, othIndex) &&
                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
            result = false;
            break;
          }
        } else if (!(
              arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack)
            )) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if ((object.byteLength != other.byteLength) ||
              (object.byteOffset != other.byteOffset)) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag:
          if ((object.byteLength != other.byteLength) ||
              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;

        case boolTag:
        case dateTag:
        case numberTag:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq(+object, +other);

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == (other + '');

        case mapTag:
          var convert = mapToArray;

        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;

          // Recursively compare objects (susceptible to call stack limits).
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          objProps = getAllKeys(object),
          objLength = objProps.length,
          othProps = getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);

      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, objValue, key, other, object, stack)
            : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined
              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
              : compared
            )) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    function flatRest(func) {
      return setToString(overRest(func, undefined, flatten), func + '');
    }

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }

    /**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = (func.name + ''),
          array = realNames[result],
          length = hasOwnProperty.call(realNames, result) ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    /**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */
    function getHolder(func) {
      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
      return object.placeholder;
    }

    /**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */
    function getIteratee() {
      var result = lodash.iteratee || iteratee;
      result = result === iteratee ? baseIteratee : result;
      return arguments.length ? result(arguments[0], arguments[1]) : result;
    }

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = keys(object),
          length = result.length;

      while (length--) {
        var key = result[length],
            value = object[key];

        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];

      try {
        value[symToStringTag] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };

    /**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };

    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag = baseGetTag;

    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
        (Map && getTag(new Map) != mapTag) ||
        (Promise && getTag(Promise.resolve()) != promiseTag) ||
        (Set && getTag(new Set) != setTag) ||
        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
      getTag = function(value) {
        var result = baseGetTag(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString: return dataViewTag;
            case mapCtorString: return mapTag;
            case promiseCtorString: return promiseTag;
            case setCtorString: return setTag;
            case weakMapCtorString: return weakMapTag;
          }
        }
        return result;
      };
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms.length;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */
    function getWrapDetails(source) {
      var match = source.match(reWrapDetails);
      return match ? match[1].split(reSplitDetails) : [];
    }

    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          result = false;

      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) &&
        (isArray(object) || isArguments(object));
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      return (typeof object.constructor == 'function' && !isPrototype(object))
        ? baseCreate(getPrototype(object))
        : {};
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case dataViewTag:
          return cloneDataView(object, isDeep);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          return cloneTypedArray(object, isDeep);

        case mapTag:
          return new Ctor;

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          return cloneRegExp(object);

        case setTag:
          return new Ctor;

        case symbolTag:
          return cloneSymbol(object);
      }
    }

    /**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */
    function insertWrapDetails(source, details) {
      var length = details.length;
      if (!length) {
        return source;
      }
      var lastIndex = length - 1;
      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
      details = details.join(length > 2 ? ', ' : ' ');
      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
    }

    /**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) ||
        !!(spreadableSymbol && value && value[spreadableSymbol]);
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
            ? (isArrayLike(object) && isIndex(index, object.length))
            : (type == 'string' && index in object)
          ) {
        return eq(object[index], value);
      }
      return false;
    }

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
          value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object != null && value in Object(object));
    }

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func),
          other = lodash[funcName];

      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
        return false;
      }
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    /**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */
    var isMaskable = coreJsData ? isFunction : stubFalse;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

      return value === proto;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }

    /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue &&
          (srcValue !== undefined || (key in Object(object)));
      };
    }

    /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });

      var cache = result.cache;
      return result;
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

      var isCombo =
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & WRAP_BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = value;
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & WRAP_ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */
    function overRest(func, start, transform) {
      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            array = Array(length);

        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }

    /**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */
    function parent(object, path) {
      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = copyArray(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function safeGet(object, key) {
      if (key === 'constructor' && typeof object[key] === 'function') {
        return;
      }

      if (key == '__proto__') {
        return;
      }

      return object[key];
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = shortOut(baseSetData);

    /**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    var setTimeout = ctxSetTimeout || function(func, wait) {
      return root.setTimeout(func, wait);
    };

    /**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var setToString = shortOut(baseSetToString);

    /**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */
    function setWrapToString(wrapper, reference, bitmask) {
      var source = (reference + '');
      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
    }

    /**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */
    function shortOut(func) {
      var count = 0,
          lastCalled = 0;

      return function() {
        var stamp = nativeNow(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(undefined, arguments);
      };
    }

    /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */
    function shuffleSelf(array, size) {
      var index = -1,
          length = array.length,
          lastIndex = length - 1;

      size = size === undefined ? length : size;
      while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];

        array[rand] = array[index];
        array[index] = value;
      }
      array.length = size;
      return array;
    }

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46 /* . */) {
        result.push('');
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    });

    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
      if (typeof value == 'string' || isSymbol(value)) {
        return value;
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    /**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */
    function updateWrapDetails(details, bitmask) {
      arrayEach(wrapFlags, function(pair) {
        var value = '_.' + pair[0];
        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
          details.push(value);
        }
      });
      return details.sort();
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      if (wrapper instanceof LazyWrapper) {
        return wrapper.clone();
      }
      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
      result.__actions__ = copyArray(wrapper.__actions__);
      result.__index__  = wrapper.__index__;
      result.__values__ = wrapper.__values__;
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
        size = 1;
      } else {
        size = nativeMax(toInteger(size), 0);
      }
      var length = array == null ? 0 : array.length;
      if (!length || size < 1) {
        return [];
      }
      var index = 0,
          resIndex = 0,
          result = Array(nativeCeil(length / size));

      while (index < length) {
        result[resIndex++] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    /**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
    function concat() {
      var length = arguments.length;
      if (!length) {
        return [];
      }
      var args = Array(length - 1),
          array = arguments[0],
          index = length;

      while (index--) {
        args[index - 1] = arguments[index];
      }
      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
    }

    /**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */
    var difference = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var differenceBy = baseRest(function(array, values) {
      var iteratee = last(values);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */
    var differenceWith = baseRest(function(array, values) {
      var comparator = last(values);
      if (isArrayLikeObject(comparator)) {
        comparator = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
        : [];
    });

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true, true)
        : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true)
        : [];
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */
    function fill(array, value, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */
    function findIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index);
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    function findLastIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length - 1;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = fromIndex < 0
          ? nativeMax(length + index, 0)
          : nativeMin(index, length - 1);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
    }

    /**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }

    /**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */
    function flattenDeep(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, INFINITY) : [];
    }

    /**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */
    function flattenDepth(array, depth) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(array, depth);
    }

    /**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */
    function fromPairs(pairs) {
      var index = -1,
          length = pairs == null ? 0 : pairs.length,
          result = {};

      while (++index < length) {
        var pair = pairs[index];
        result[pair[0]] = pair[1];
      }
      return result;
    }

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */
    function head(array) {
      return (array && array.length) ? array[0] : undefined;
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */
    function indexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseIndexOf(array, value, index);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 0, -1) : [];
    }

    /**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */
    var intersection = baseRest(function(arrays) {
      var mapped = arrayMap(arrays, castArrayLikeObject);
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped)
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */
    var intersectionBy = baseRest(function(arrays) {
      var iteratee = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      if (iteratee === last(mapped)) {
        iteratee = undefined;
      } else {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */
    var intersectionWith = baseRest(function(arrays) {
      var comparator = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      comparator = typeof comparator == 'function' ? comparator : undefined;
      if (comparator) {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, undefined, comparator)
        : [];
    });

    /**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */
    function join(array, separator) {
      return array == null ? '' : nativeJoin.call(array, separator);
    }

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
      }
      return value === value
        ? strictLastIndexOf(array, value, index)
        : baseFindIndex(array, baseIsNaN, index, true);
    }

    /**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */
    function nth(array, n) {
      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
    }

    /**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */
    var pull = baseRest(pullAll);

    /**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */
    function pullAll(array, values) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values)
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */
    function pullAllBy(array, values, iteratee) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, getIteratee(iteratee, 2))
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */
    function pullAllWith(array, values, comparator) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, undefined, comparator)
        : array;
    }

    /**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */
    var pullAt = flatRest(function(array, indexes) {
      var length = array == null ? 0 : array.length,
          result = baseAt(array, indexes);

      basePullAt(array, arrayMap(indexes, function(index) {
        return isIndex(index, length) ? +index : index;
      }).sort(compareAscending));

      return result;
    });

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = getIteratee(predicate, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    /**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function reverse(array) {
      return array == null ? array : nativeReverse.call(array);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      else {
        start = start == null ? 0 : toInteger(start);
        end = end === undefined ? length : toInteger(end);
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */
    function sortedIndex(array, value) {
      return baseSortedIndex(array, value);
    }

    /**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */
    function sortedIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
    }

    /**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */
    function sortedIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value);
        if (index < length && eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */
    function sortedLastIndex(array, value) {
      return baseSortedIndex(array, value, true);
    }

    /**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */
    function sortedLastIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
    }

    /**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */
    function sortedLastIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value, true) - 1;
        if (eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */
    function sortedUniq(array) {
      return (array && array.length)
        ? baseSortedUniq(array)
        : [];
    }

    /**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */
    function sortedUniqBy(array, iteratee) {
      return (array && array.length)
        ? baseSortedUniq(array, getIteratee(iteratee, 2))
        : [];
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */
    function tail(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 1, length) : [];
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      if (!(array && array.length)) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */
    function takeRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), false, true)
        : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */
    function takeWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3))
        : [];
    }

    /**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */
    var union = baseRest(function(arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });

    /**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    var unionBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var unionWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
    });

    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */
    function uniq(array) {
      return (array && array.length) ? baseUniq(array) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniqBy(array, iteratee) {
      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */
    function uniqWith(array, comparator) {
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */
    function unzip(array) {
      if (!(array && array.length)) {
        return [];
      }
      var length = 0;
      array = arrayFilter(array, function(group) {
        if (isArrayLikeObject(group)) {
          length = nativeMax(group.length, length);
          return true;
        }
      });
      return baseTimes(length, function(index) {
        return arrayMap(array, baseProperty(index));
      });
    }

    /**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
    function unzipWith(array, iteratee) {
      if (!(array && array.length)) {
        return [];
      }
      var result = unzip(array);
      if (iteratee == null) {
        return result;
      }
      return arrayMap(result, function(group) {
        return apply(iteratee, undefined, group);
      });
    }

    /**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */
    var without = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, values)
        : [];
    });

    /**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */
    var xor = baseRest(function(arrays) {
      return baseXor(arrayFilter(arrays, isArrayLikeObject));
    });

    /**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var xorBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var xorWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
    });

    /**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */
    var zip = baseRest(unzip);

    /**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */
    function zipObject(props, values) {
      return baseZipObject(props || [], values || [], assignValue);
    }

    /**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */
    function zipObjectDeep(props, values) {
      return baseZipObject(props || [], values || [], baseSet);
    }

    /**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */
    var zipWith = baseRest(function(arrays) {
      var length = arrays.length,
          iteratee = length > 1 ? arrays[length - 1] : undefined;

      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
      return unzipWith(arrays, iteratee);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor) {
      return interceptor(value);
    }

    /**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */
    var wrapperAt = flatRest(function(paths) {
      var length = paths.length,
          start = length ? paths[0] : 0,
          value = this.__wrapped__,
          interceptor = function(object) { return baseAt(object, paths); };

      if (length > 1 || this.__actions__.length ||
          !(value instanceof LazyWrapper) || !isIndex(start)) {
        return this.thru(interceptor);
      }
      value = value.slice(start, +start + (length ? 1 : 0));
      value.__actions__.push({
        'func': thru,
        'args': [interceptor],
        'thisArg': undefined
      });
      return new LodashWrapper(value, this.__chain__).thru(function(array) {
        if (length && !array.length) {
          array.push(undefined);
        }
        return array;
      });
    });

    /**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */
    function wrapperNext() {
      if (this.__values__ === undefined) {
        this.__values__ = toArray(this.value());
      }
      var done = this.__index__ >= this.__values__.length,
          value = done ? undefined : this.__values__[this.__index__++];

      return { 'done': done, 'value': value };
    }

    /**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */
    function wrapperToIterator() {
      return this;
    }

    /**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        clone.__index__ = 0;
        clone.__values__ = undefined;
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;
      if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
          wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({
          'func': thru,
          'args': [reverse],
          'thisArg': undefined
        });
        return new LodashWrapper(wrapped, this.__chain__);
      }
      return this.thru(reverse);
    }

    /**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        ++result[key];
      } else {
        baseAssignValue(result, key, 1);
      }
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, guard) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     */
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */
    var find = createFind(findIndex);

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    var findLast = createFind(findLastIndex);

    /**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMap(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), 1);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMapDeep(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), INFINITY);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */
    function flatMapDepth(collection, iteratee, depth) {
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(map(collection, iteratee), depth);
    }

    /**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */
    function forEachRight(collection, iteratee) {
      var func = isArray(collection) ? arrayEachRight : baseEachRight;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        baseAssignValue(result, key, [value]);
      }
    });

    /**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection)
        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
    }

    /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invokeMap = baseRest(function(collection, path, args) {
      var index = -1,
          isFunc = typeof path == 'function',
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value) {
        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
      });
      return result;
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */
    var keyBy = createAggregator(function(result, value, key) {
      baseAssignValue(result, key, value);
    });

    /**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */
    function orderBy(collection, iteratees, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      orders = guard ? undefined : orders;
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseOrderBy(collection, iteratees, orders);
    }

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduceRight : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
    }

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */
    function reject(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, negate(getIteratee(predicate, 3)));
    }

    /**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */
    function sample(collection) {
      var func = isArray(collection) ? arraySample : baseSample;
      return func(collection);
    }

    /**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */
    function sampleSize(collection, n, guard) {
      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
      return func(collection, n);
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      var func = isArray(collection) ? arrayShuffle : baseShuffle;
      return func(collection);
    }

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      if (collection == null) {
        return 0;
      }
      if (isArrayLike(collection)) {
        return isString(collection) ? stringSize(collection) : collection.length;
      }
      var tag = getTag(collection);
      if (tag == mapTag || tag == setTag) {
        return collection.size;
      }
      return baseKeys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, guard) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
     */
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */
    var now = ctxNow || function() {
      return root.Date.now();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */
    function after(n, func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      n = guard ? undefined : n;
      n = (func && n == null) ? func.length : n;
      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = undefined;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = baseRest(function(func, thisArg, partials) {
      var bitmask = WRAP_BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bind));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(func, bitmask, thisArg, partials, holders);
    });

    /**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = baseRest(function(object, key, partials) {
      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bindKey));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(key, bitmask, object, partials, holders);
    });

    /**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    function curry(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curry.placeholder;
      return result;
    }

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    function curryRight(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curryRight.placeholder;
      return result;
    }

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
    function debounce(func, wait, options) {
      var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function invokeFunc(time) {
        var args = lastArgs,
            thisArg = lastThis;

        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }

      function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
      }

      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            timeWaiting = wait - timeSinceLastCall;

        return maxing
          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
          : timeWaiting;
      }

      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;

        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
      }

      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
      }

      function trailingEdge(time) {
        timerId = undefined;

        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
      }

      function cancel() {
        if (timerId !== undefined) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
      }

      function flush() {
        return timerId === undefined ? result : trailingEdge(now());
      }

      function debounced() {
        var time = now(),
            isInvoking = shouldInvoke(time);

        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;

        if (isInvoking) {
          if (timerId === undefined) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            // Handle invocations in a tight loop.
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === undefined) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */
    var defer = baseRest(function(func, args) {
      return baseDelay(func, 1, args);
    });

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */
    var delay = baseRest(function(func, wait, args) {
      return baseDelay(func, toNumber(wait) || 0, args);
    });

    /**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */
    function flip(func) {
      return createWrap(func, WRAP_FLIP_FLAG);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache);
      return memoized;
    }

    // Expose `MapCache`.
    memoize.Cache = MapCache;

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0: return !predicate.call(this);
          case 1: return !predicate.call(this, args[0]);
          case 2: return !predicate.call(this, args[0], args[1]);
          case 3: return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */
    function once(func) {
      return before(2, func);
    }

    /**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */
    var overArgs = castRest(function(func, transforms) {
      transforms = (transforms.length == 1 && isArray(transforms[0]))
        ? arrayMap(transforms[0], baseUnary(getIteratee()))
        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

      var funcsLength = transforms.length;
      return baseRest(function(args) {
        var index = -1,
            length = nativeMin(args.length, funcsLength);

        while (++index < length) {
          args[index] = transforms[index].call(this, args[index]);
        }
        return apply(func, this, args);
      });
    });

    /**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partial));
      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
    });

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partialRight));
      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
    });

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */
    var rearg = flatRest(function(func, indexes) {
      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function rest(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start === undefined ? start : toInteger(start);
      return baseRest(func, start);
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start == null ? 0 : nativeMax(toInteger(start), 0);
      return baseRest(function(args) {
        var array = args[start],
            otherArgs = castSlice(args, 0, start);

        if (array) {
          arrayPush(otherArgs, array);
        }
        return apply(func, this, otherArgs);
      });
    }

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
      });
    }

    /**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */
    function unary(func) {
      return ary(func, 1);
    }

    /**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      return partial(castFunction(wrapper), value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */
    function castArray() {
      if (!arguments.length) {
        return [];
      }
      var value = arguments[0];
      return isArray(value) ? value : [value];
    }

    /**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */
    function cloneWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */
    function cloneDeepWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */
    function conformsTo(object, source) {
      return source == null || baseConformsTo(object, source, keys(source));
    }

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }

    /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
    var gt = createRelationalOperation(baseGt);

    /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
    var gte = createRelationalOperation(function(value, other) {
      return value >= other;
    });

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
    };

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */
    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        (isObjectLike(value) && baseGetTag(value) == boolTag);
    }

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

    /**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
    }

    /**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) &&
          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag(value);
      if (tag == mapTag || tag == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key in value) {
        if (hasOwnProperty.call(value, key)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }

    /**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */
    function isEqualWith(value, other, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      var result = customizer ? customizer(value, other) : undefined;
      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      if (!isObjectLike(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == errorTag || tag == domExcTag ||
        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */
    function isFinite(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */
    function isInteger(value) {
      return typeof value == 'number' && value == toInteger(value);
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

    /**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */
    function isMatch(object, source) {
      return object === source || baseIsMatch(object, source, getMatchData(source));
    }

    /**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */
    function isMatchWith(object, source, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseIsMatch(object, source, getMatchData(source), customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some
      // ActiveX objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (isMaskable(value)) {
        throw new Error(CORE_ERROR_TEXT);
      }
      return baseIsNative(value);
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */
    function isNil(value) {
      return value == null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        (isObjectLike(value) && baseGetTag(value) == numberTag);
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        funcToString.call(Ctor) == objectCtorString;
    }

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

    /**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */
    function isSafeInteger(value) {
      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' ||
        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
    }

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && baseGetTag(value) == symbolTag);
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    /**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */
    function isWeakMap(value) {
      return isObjectLike(value) && getTag(value) == weakMapTag;
    }

    /**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */
    function isWeakSet(value) {
      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
    }

    /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
    var lt = createRelationalOperation(baseLt);

    /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
    var lte = createRelationalOperation(function(value, other) {
      return value <= other;
    });

    /**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */
    function toArray(value) {
      if (!value) {
        return [];
      }
      if (isArrayLike(value)) {
        return isString(value) ? stringToArray(value) : copyArray(value);
      }
      if (symIterator && value[symIterator]) {
        return iteratorToArray(value[symIterator]());
      }
      var tag = getTag(value),
          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

      return func(value);
    }

    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }

    /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
    function toInteger(value) {
      var result = toFinite(value),
          remainder = result % 1;

      return result === result ? (remainder ? result - remainder : result) : 0;
    }

    /**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */
    function toLength(value) {
      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
    }

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, '');
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }

    /**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */
    function toSafeInteger(value) {
      return value
        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
        : (value === 0 ? value : 0);
    }

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      return value == null ? '' : baseToString(value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */
    var assign = createAssigner(function(object, source) {
      if (isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          assignValue(object, key, source[key]);
        }
      }
    });

    /**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */
    var assignIn = createAssigner(function(object, source) {
      copyObject(source, keysIn(source), object);
    });

    /**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keysIn(source), object, customizer);
    });

    /**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keys(source), object, customizer);
    });

    /**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */
    var at = flatRest(baseAt);

    /**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties == null ? result : baseAssign(result, properties);
    }

    /**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var defaults = baseRest(function(object, sources) {
      object = Object(object);

      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : undefined;

      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }

      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;

        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];

          if (value === undefined ||
              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
            object[key] = source[key];
          }
        }
      }

      return object;
    });

    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */
    var defaultsDeep = baseRest(function(args) {
      args.push(undefined, customDefaultsMerge);
      return apply(mergeWith, undefined, args);
    });

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    function findKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    function findLastKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
    }

    /**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */
    function forIn(object, iteratee) {
      return object == null
        ? object
        : baseFor(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */
    function forInRight(object, iteratee) {
      return object == null
        ? object
        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forOwn(object, iteratee) {
      return object && baseForOwn(object, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */
    function forOwnRight(object, iteratee) {
      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
    }

    /**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */
    function functions(object) {
      return object == null ? [] : baseFunctions(object, keys(object));
    }

    /**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */
    function functionsIn(object) {
      return object == null ? [] : baseFunctions(object, keysIn(object));
    }

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }

    /**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */
    function has(object, path) {
      return object != null && hasPath(object, path, baseHas);
    }

    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */
    var invert = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      result[value] = key;
    }, constant(identity));

    /**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */
    var invertBy = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      if (hasOwnProperty.call(result, value)) {
        result[value].push(key);
      } else {
        result[value] = [key];
      }
    }, getIteratee);

    /**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */
    var invoke = baseRest(baseInvoke);

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    function mapKeys(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, iteratee(value, key, object), value);
      });
      return result;
    }

    /**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    function mapValues(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, key, iteratee(value, key, object));
      });
      return result;
    }

    /**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });

    /**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */
    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */
    var omit = flatRest(function(object, paths) {
      var result = {};
      if (object == null) {
        return result;
      }
      var isDeep = false;
      paths = arrayMap(paths, function(path) {
        path = castPath(path, object);
        isDeep || (isDeep = path.length > 1);
        return path;
      });
      copyObject(object, getAllKeysIn(object), result);
      if (isDeep) {
        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
      }
      var length = paths.length;
      while (length--) {
        baseUnset(result, paths[length]);
      }
      return result;
    });

    /**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */
    function omitBy(object, predicate) {
      return pickBy(object, negate(getIteratee(predicate)));
    }

    /**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */
    var pick = flatRest(function(object, paths) {
      return object == null ? {} : basePick(object, paths);
    });

    /**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */
    function pickBy(object, predicate) {
      if (object == null) {
        return {};
      }
      var props = arrayMap(getAllKeysIn(object), function(prop) {
        return [prop];
      });
      predicate = getIteratee(predicate);
      return basePickBy(object, props, function(value, path) {
        return predicate(value, path[0]);
      });
    }

    /**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */
    function result(object, path, defaultValue) {
      path = castPath(path, object);

      var index = -1,
          length = path.length;

      // Ensure the loop is entered when path is empty.
      if (!length) {
        length = 1;
        object = undefined;
      }
      while (++index < length) {
        var value = object == null ? undefined : object[toKey(path[index])];
        if (value === undefined) {
          index = length;
          value = defaultValue;
        }
        object = isFunction(value) ? value.call(object) : value;
      }
      return object;
    }

    /**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    function set(object, path, value) {
      return object == null ? object : baseSet(object, path, value);
    }

    /**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */
    function setWith(object, path, value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseSet(object, path, value, customizer);
    }

    /**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */
    var toPairs = createToPairs(keys);

    /**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */
    var toPairsIn = createToPairs(keysIn);

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function transform(object, iteratee, accumulator) {
      var isArr = isArray(object),
          isArrLike = isArr || isBuffer(object) || isTypedArray(object);

      iteratee = getIteratee(iteratee, 4);
      if (accumulator == null) {
        var Ctor = object && object.constructor;
        if (isArrLike) {
          accumulator = isArr ? new Ctor : [];
        }
        else if (isObject(object)) {
          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
        }
        else {
          accumulator = {};
        }
      }
      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */
    function unset(object, path) {
      return object == null ? true : baseUnset(object, path);
    }

    /**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */
    function update(object, path, updater) {
      return object == null ? object : baseUpdate(object, path, castFunction(updater));
    }

    /**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */
    function updateWith(object, path, updater, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
    }

    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return object == null ? [] : baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */
    function clamp(number, lower, upper) {
      if (upper === undefined) {
        upper = lower;
        lower = undefined;
      }
      if (upper !== undefined) {
        upper = toNumber(upper);
        upper = upper === upper ? upper : 0;
      }
      if (lower !== undefined) {
        lower = toNumber(lower);
        lower = lower === lower ? lower : 0;
      }
      return baseClamp(toNumber(number), lower, upper);
    }

    /**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */
    function inRange(number, start, end) {
      start = toFinite(start);
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = toFinite(end);
      }
      number = toNumber(number);
      return baseInRange(number, start, end);
    }

    /**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(lower, upper, floating) {
      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
        upper = floating = undefined;
      }
      if (floating === undefined) {
        if (typeof upper == 'boolean') {
          floating = upper;
          upper = undefined;
        }
        else if (typeof lower == 'boolean') {
          floating = lower;
          lower = undefined;
        }
      }
      if (lower === undefined && upper === undefined) {
        lower = 0;
        upper = 1;
      }
      else {
        lower = toFinite(lower);
        if (upper === undefined) {
          upper = lower;
          lower = 0;
        } else {
          upper = toFinite(upper);
        }
      }
      if (lower > upper) {
        var temp = lower;
        lower = upper;
        upper = temp;
      }
      if (floating || lower % 1 || upper % 1) {
        var rand = nativeRandom();
        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
      }
      return baseRandom(lower, upper);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });

    /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */
    function capitalize(string) {
      return upperFirst(toString(string).toLowerCase());
    }

    /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('dÃ©jÃ  vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = toString(string);
      target = baseToString(target);

      var length = string.length;
      position = position === undefined
        ? length
        : baseClamp(toInteger(position), 0, length);

      var end = position;
      position -= target.length;
      return position >= 0 && string.slice(position, end) == target;
    }

    /**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      string = toString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */
    function escapeRegExp(string) {
      string = toString(string);
      return (string && reHasRegExpChar.test(string))
        ? string.replace(reRegExpChar, '\\$&')
        : string;
    }

    /**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */
    var lowerCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toLowerCase();
    });

    /**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */
    var lowerFirst = createCaseFirst('toLowerCase');

    /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      if (!length || strLength >= length) {
        return string;
      }
      var mid = (length - strLength) / 2;
      return (
        createPadding(nativeFloor(mid), chars) +
        string +
        createPadding(nativeCeil(mid), chars)
      );
    }

    /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */
    function padEnd(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (string + createPadding(length - strLength, chars))
        : string;
    }

    /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */
    function padStart(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (createPadding(length - strLength, chars) + string)
        : string;
    }

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      if (guard || radix == null) {
        radix = 0;
      } else if (radix) {
        radix = +radix;
      }
      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n, guard) {
      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      return baseRepeat(toString(string), n);
    }

    /**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */
    function replace() {
      var args = arguments,
          string = toString(args[0]);

      return args.length < 3 ? string : string.replace(args[1], args[2]);
    }

    /**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */
    function split(string, separator, limit) {
      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
        separator = limit = undefined;
      }
      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
      if (!limit) {
        return [];
      }
      string = toString(string);
      if (string && (
            typeof separator == 'string' ||
            (separator != null && !isRegExp(separator))
          )) {
        separator = baseToString(separator);
        if (!separator && hasUnicode(string)) {
          return castSlice(stringToArray(string), 0, limit);
        }
      }
      return string.split(separator, limit);
    }

    /**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + upperFirst(word);
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = toString(string);
      position = position == null
        ? 0
        : baseClamp(toInteger(position), 0, string.length);

      target = baseToString(target);
      return string.slice(position, position + target.length) == target;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, guard) {
      // Based on John Resig's `tmpl` implementation
      // (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (guard && isIterateeCall(string, options, guard)) {
        options = undefined;
      }
      string = toString(string);
      options = assignInWith({}, options, settings, customDefaultsAssignIn);

      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      // The sourceURL gets injected into the source that's eval-ed, so be careful
      // with lookup (in case of e.g. prototype pollution), and strip newlines if any.
      // A newline wouldn't be a valid sourceURL anyway, and it'd enable code injection.
      var sourceURL = '//# sourceURL=' +
        (hasOwnProperty.call(options, 'sourceURL')
          ? (options.sourceURL + '').replace(/[\r\n]/g, ' ')
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products needs `match` returned in
        // order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      // Like with sourceURL, we take care to not check the option's prototype,
      // as this configuration is a code injection vector.
      var variable = hasOwnProperty.call(options, 'variable') && options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source)
          .apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */
    function toLower(value) {
      return toString(value).toLowerCase();
    }

    /**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */
    function toUpper(value) {
      return toString(value).toUpperCase();
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrim, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          chrSymbols = stringToArray(chars),
          start = charsStartIndex(strSymbols, chrSymbols),
          end = charsEndIndex(strSymbols, chrSymbols) + 1;

      return castSlice(strSymbols, start, end).join('');
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimEnd(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimEnd, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

      return castSlice(strSymbols, 0, end).join('');
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimStart(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimStart, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          start = charsStartIndex(strSymbols, stringToArray(chars));

      return castSlice(strSymbols, start).join('');
    }

    /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function truncate(string, options) {
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (isObject(options)) {
        var separator = 'separator' in options ? options.separator : separator;
        length = 'length' in options ? toInteger(options.length) : length;
        omission = 'omission' in options ? baseToString(options.omission) : omission;
      }
      string = toString(string);

      var strLength = string.length;
      if (hasUnicode(string)) {
        var strSymbols = stringToArray(string);
        strLength = strSymbols.length;
      }
      if (length >= strLength) {
        return string;
      }
      var end = length - stringSize(omission);
      if (end < 1) {
        return omission;
      }
      var result = strSymbols
        ? castSlice(strSymbols, 0, end).join('')
        : string.slice(0, end);

      if (separator === undefined) {
        return result + omission;
      }
      if (strSymbols) {
        end += (result.length - end);
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              substring = result;

          if (!separator.global) {
            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            var newEnd = match.index;
          }
          result = result.slice(0, newEnd === undefined ? end : newEnd);
        }
      } else if (string.indexOf(baseToString(separator), end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = toString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */
    var upperCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toUpperCase();
    });

    /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */
    var upperFirst = createCaseFirst('toUpperCase');

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? undefined : pattern;

      if (pattern === undefined) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = baseRest(function(func, args) {
      try {
        return apply(func, undefined, args);
      } catch (e) {
        return isError(e) ? e : new Error(e);
      }
    });

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */
    var bindAll = flatRest(function(object, methodNames) {
      arrayEach(methodNames, function(key) {
        key = toKey(key);
        baseAssignValue(object, key, bind(object[key], object));
      });
      return object;
    });

    /**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */
    function cond(pairs) {
      var length = pairs == null ? 0 : pairs.length,
          toIteratee = getIteratee();

      pairs = !length ? [] : arrayMap(pairs, function(pair) {
        if (typeof pair[1] != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        return [toIteratee(pair[0]), pair[1]];
      });

      return baseRest(function(args) {
        var index = -1;
        while (++index < length) {
          var pair = pairs[index];
          if (apply(pair[0], this, args)) {
            return apply(pair[1], this, args);
          }
        }
      });
    }

    /**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */
    function conforms(source) {
      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */
    function defaultTo(value, defaultValue) {
      return (value == null || value !== value) ? defaultValue : value;
    }

    /**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);

    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */
    function iteratee(func) {
      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     */
    function matchesProperty(path, srcValue) {
      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */
    var method = baseRest(function(path, args) {
      return function(object) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
    var methodOf = baseRest(function(object, args) {
      return function(path) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      var props = keys(source),
          methodNames = baseFunctions(source, props);

      if (options == null &&
          !(isObject(source) && (methodNames.length || !props.length))) {
        options = source;
        source = object;
        object = this;
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
          isFunc = isFunction(object);

      arrayEach(methodNames, function(methodName) {
        var func = source[methodName];
        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = function() {
            var chainAll = this.__chain__;
            if (chain || chainAll) {
              var result = object(this.__wrapped__),
                  actions = result.__actions__ = copyArray(this.__actions__);

              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
              result.__chain__ = chainAll;
              return result;
            }
            return func.apply(object, arrayPush([this.value()], arguments));
          };
        }
      });

      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      if (root._ === this) {
        root._ = oldDash;
      }
      return this;
    }

    /**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */
    function nthArg(n) {
      n = toInteger(n);
      return baseRest(function(args) {
        return baseNth(args, n);
      });
    }

    /**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */
    var over = createOver(arrayMap);

    /**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */
    var overEvery = createOver(arrayEvery);

    /**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     */
    var overSome = createOver(arraySome);

    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }

    /**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
    function propertyOf(object) {
      return function(path) {
        return object == null ? undefined : baseGet(object, path);
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    var range = createRange();

    /**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */
    var rangeRight = createRange(true);

    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
    function stubArray() {
      return [];
    }

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */
    function stubObject() {
      return {};
    }

    /**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */
    function stubString() {
      return '';
    }

    /**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */
    function stubTrue() {
      return true;
    }

    /**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */
    function times(n, iteratee) {
      n = toInteger(n);
      if (n < 1 || n > MAX_SAFE_INTEGER) {
        return [];
      }
      var index = MAX_ARRAY_LENGTH,
          length = nativeMin(n, MAX_ARRAY_LENGTH);

      iteratee = getIteratee(iteratee);
      n -= MAX_ARRAY_LENGTH;

      var result = baseTimes(length, iteratee);
      while (++index < n) {
        iteratee(index);
      }
      return result;
    }

    /**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */
    function toPath(value) {
      if (isArray(value)) {
        return arrayMap(value, toKey);
      }
      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
    }

    /**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return toString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    var add = createMathOperation(function(augend, addend) {
      return augend + addend;
    }, 0);

    /**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
    var ceil = createRound('ceil');

    /**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */
    var divide = createMathOperation(function(dividend, divisor) {
      return dividend / divisor;
    }, 1);

    /**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
    var floor = createRound('floor');

    /**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */
    function max(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseGt)
        : undefined;
    }

    /**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */
    function maxBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
        : undefined;
    }

    /**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */
    function mean(array) {
      return baseMean(array, identity);
    }

    /**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */
    function meanBy(array, iteratee) {
      return baseMean(array, getIteratee(iteratee, 2));
    }

    /**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */
    function min(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseLt)
        : undefined;
    }

    /**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */
    function minBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
        : undefined;
    }

    /**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */
    var multiply = createMathOperation(function(multiplier, multiplicand) {
      return multiplier * multiplicand;
    }, 1);

    /**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');

    /**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */
    var subtract = createMathOperation(function(minuend, subtrahend) {
      return minuend - subtrahend;
    }, 0);

    /**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */
    function sum(array) {
      return (array && array.length)
        ? baseSum(array, identity)
        : 0;
    }

    /**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */
    function sumBy(array, iteratee) {
      return (array && array.length)
        ? baseSum(array, getIteratee(iteratee, 2))
        : 0;
    }

    /*------------------------------------------------------------------------*/

    // Add methods that return wrapped values in chain sequences.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.assignIn = assignIn;
    lodash.assignInWith = assignInWith;
    lodash.assignWith = assignWith;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.castArray = castArray;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.concat = concat;
    lodash.cond = cond;
    lodash.conforms = conforms;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defaultsDeep = defaultsDeep;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.differenceBy = differenceBy;
    lodash.differenceWith = differenceWith;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatMap = flatMap;
    lodash.flatMapDeep = flatMapDeep;
    lodash.flatMapDepth = flatMapDepth;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flattenDepth = flattenDepth;
    lodash.flip = flip;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.fromPairs = fromPairs;
    lodash.functions = functions;
    lodash.functionsIn = functionsIn;
    lodash.groupBy = groupBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.intersectionBy = intersectionBy;
    lodash.intersectionWith = intersectionWith;
    lodash.invert = invert;
    lodash.invertBy = invertBy;
    lodash.invokeMap = invokeMap;
    lodash.iteratee = iteratee;
    lodash.keyBy = keyBy;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapKeys = mapKeys;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.mergeWith = mergeWith;
    lodash.method = method;
    lodash.methodOf = methodOf;
    lodash.mixin = mixin;
    lodash.negate = negate;
    lodash.nthArg = nthArg;
    lodash.omit = omit;
    lodash.omitBy = omitBy;
    lodash.once = once;
    lodash.orderBy = orderBy;
    lodash.over = over;
    lodash.overArgs = overArgs;
    lodash.overEvery = overEvery;
    lodash.overSome = overSome;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pickBy = pickBy;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAll = pullAll;
    lodash.pullAllBy = pullAllBy;
    lodash.pullAllWith = pullAllWith;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rangeRight = rangeRight;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.reverse = reverse;
    lodash.sampleSize = sampleSize;
    lodash.set = set;
    lodash.setWith = setWith;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortedUniq = sortedUniq;
    lodash.sortedUniqBy = sortedUniqBy;
    lodash.split = split;
    lodash.spread = spread;
    lodash.tail = tail;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.toArray = toArray;
    lodash.toPairs = toPairs;
    lodash.toPairsIn = toPairsIn;
    lodash.toPath = toPath;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.unary = unary;
    lodash.union = union;
    lodash.unionBy = unionBy;
    lodash.unionWith = unionWith;
    lodash.uniq = uniq;
    lodash.uniqBy = uniqBy;
    lodash.uniqWith = uniqWith;
    lodash.unset = unset;
    lodash.unzip = unzip;
    lodash.unzipWith = unzipWith;
    lodash.update = update;
    lodash.updateWith = updateWith;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.without = without;
    lodash.words = words;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.xorBy = xorBy;
    lodash.xorWith = xorWith;
    lodash.zip = zip;
    lodash.zipObject = zipObject;
    lodash.zipObjectDeep = zipObjectDeep;
    lodash.zipWith = zipWith;

    // Add aliases.
    lodash.entries = toPairs;
    lodash.entriesIn = toPairsIn;
    lodash.extend = assignIn;
    lodash.extendWith = assignInWith;

    // Add methods to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add methods that return unwrapped values in chain sequences.
    lodash.add = add;
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.ceil = ceil;
    lodash.clamp = clamp;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.cloneDeepWith = cloneDeepWith;
    lodash.cloneWith = cloneWith;
    lodash.conformsTo = conformsTo;
    lodash.deburr = deburr;
    lodash.defaultTo = defaultTo;
    lodash.divide = divide;
    lodash.endsWith = endsWith;
    lodash.eq = eq;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.floor = floor;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.get = get;
    lodash.gt = gt;
    lodash.gte = gte;
    lodash.has = has;
    lodash.hasIn = hasIn;
    lodash.head = head;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.invoke = invoke;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isArrayBuffer = isArrayBuffer;
    lodash.isArrayLike = isArrayLike;
    lodash.isArrayLikeObject = isArrayLikeObject;
    lodash.isBoolean = isBoolean;
    lodash.isBuffer = isBuffer;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isEqualWith = isEqualWith;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isInteger = isInteger;
    lodash.isLength = isLength;
    lodash.isMap = isMap;
    lodash.isMatch = isMatch;
    lodash.isMatchWith = isMatchWith;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNil = isNil;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isObjectLike = isObjectLike;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isSafeInteger = isSafeInteger;
    lodash.isSet = isSet;
    lodash.isString = isString;
    lodash.isSymbol = isSymbol;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.isWeakMap = isWeakMap;
    lodash.isWeakSet = isWeakSet;
    lodash.join = join;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.lowerCase = lowerCase;
    lodash.lowerFirst = lowerFirst;
    lodash.lt = lt;
    lodash.lte = lte;
    lodash.max = max;
    lodash.maxBy = maxBy;
    lodash.mean = mean;
    lodash.meanBy = meanBy;
    lodash.min = min;
    lodash.minBy = minBy;
    lodash.stubArray = stubArray;
    lodash.stubFalse = stubFalse;
    lodash.stubObject = stubObject;
    lodash.stubString = stubString;
    lodash.stubTrue = stubTrue;
    lodash.multiply = multiply;
    lodash.nth = nth;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padEnd = padEnd;
    lodash.padStart = padStart;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.replace = replace;
    lodash.result = result;
    lodash.round = round;
    lodash.runInContext = runInContext;
    lodash.sample = sample;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedIndexBy = sortedIndexBy;
    lodash.sortedIndexOf = sortedIndexOf;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.sortedLastIndexBy = sortedLastIndexBy;
    lodash.sortedLastIndexOf = sortedLastIndexOf;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.subtract = subtract;
    lodash.sum = sum;
    lodash.sumBy = sumBy;
    lodash.template = template;
    lodash.times = times;
    lodash.toFinite = toFinite;
    lodash.toInteger = toInteger;
    lodash.toLength = toLength;
    lodash.toLower = toLower;
    lodash.toNumber = toNumber;
    lodash.toSafeInteger = toSafeInteger;
    lodash.toString = toString;
    lodash.toUpper = toUpper;
    lodash.trim = trim;
    lodash.trimEnd = trimEnd;
    lodash.trimStart = trimStart;
    lodash.truncate = truncate;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.upperCase = upperCase;
    lodash.upperFirst = upperFirst;

    // Add aliases.
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.first = head;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
          source[methodName] = func;
        }
      });
      return source;
    }()), { 'chain': false });

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      LazyWrapper.prototype[methodName] = function(n) {
        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

        var result = (this.__filtered__ && !index)
          ? new LazyWrapper(this)
          : this.clone();

        if (result.__filtered__) {
          result.__takeCount__ = nativeMin(n, result.__takeCount__);
        } else {
          result.__views__.push({
            'size': nativeMin(n, MAX_ARRAY_LENGTH),
            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
          });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var type = index + 1,
          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee) {
        var result = this.clone();
        result.__iteratees__.push({
          'iteratee': getIteratee(iteratee, 3),
          'type': type
        });
        result.__filtered__ = result.__filtered__ || isFilter;
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.head` and `_.last`.
    arrayEach(['head', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
    arrayEach(['initial', 'tail'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.find = function(predicate) {
      return this.filter(predicate).head();
    };

    LazyWrapper.prototype.findLast = function(predicate) {
      return this.reverse().find(predicate);
    };

    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
      if (typeof path == 'function') {
        return new LazyWrapper(this);
      }
      return this.map(function(value) {
        return baseInvoke(value, path, args);
      });
    });

    LazyWrapper.prototype.reject = function(predicate) {
      return this.filter(negate(getIteratee(predicate)));
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = toInteger(start);

      var result = this;
      if (result.__filtered__ && (start > 0 || end < 0)) {
        return new LazyWrapper(result);
      }
      if (start < 0) {
        result = result.takeRight(-start);
      } else if (start) {
        result = result.drop(start);
      }
      if (end !== undefined) {
        end = toInteger(end);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.takeRightWhile = function(predicate) {
      return this.reverse().takeWhile(predicate).reverse();
    };

    LazyWrapper.prototype.toArray = function() {
      return this.take(MAX_ARRAY_LENGTH);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
          isTaker = /^(?:head|last)$/.test(methodName),
          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
          retUnwrapped = isTaker || /^find/.test(methodName);

      if (!lodashFunc) {
        return;
      }
      lodash.prototype[methodName] = function() {
        var value = this.__wrapped__,
            args = isTaker ? [1] : arguments,
            isLazy = value instanceof LazyWrapper,
            iteratee = args[0],
            useLazy = isLazy || isArray(value);

        var interceptor = function(value) {
          var result = lodashFunc.apply(lodash, arrayPush([value], args));
          return (isTaker && chainAll) ? result[0] : result;
        };

        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // Avoid lazy use if the iteratee has a "length" value other than `1`.
          isLazy = useLazy = false;
        }
        var chainAll = this.__chain__,
            isHybrid = !!this.__actions__.length,
            isUnwrapped = retUnwrapped && !chainAll,
            onlyLazy = isLazy && !isHybrid;

        if (!retUnwrapped && useLazy) {
          value = onlyLazy ? value : new LazyWrapper(this);
          var result = func.apply(value, args);
          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
          return new LodashWrapper(result, chainAll);
        }
        if (isUnwrapped && onlyLazy) {
          return func.apply(this, args);
        }
        result = this.thru(interceptor);
        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
      };
    });

    // Add `Array` methods to `lodash.prototype`.
    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
      var func = arrayProto[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:pop|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          var value = this.value();
          return func.apply(isArray(value) ? value : [], args);
        }
        return this[chainName](function(value) {
          return func.apply(isArray(value) ? value : [], args);
        });
      };
    });

    // Map minified method names to their real names.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = lodashFunc.name + '';
        if (!hasOwnProperty.call(realNames, key)) {
          realNames[key] = [];
        }
        realNames[key].push({ 'name': methodName, 'func': lodashFunc });
      }
    });

    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
      'name': 'wrapper',
      'func': undefined
    }];

    // Add methods to `LazyWrapper`.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chain sequence methods to the `lodash` wrapper.
    lodash.prototype.at = wrapperAt;
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.next = wrapperNext;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add lazy aliases.
    lodash.prototype.first = lodash.prototype.head;

    if (symIterator) {
      lodash.prototype[symIterator] = wrapperToIterator;
    }
    return lodash;
  });

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers, like r.js, check for condition patterns like:
  if (true) {
    // Expose Lodash on the global object to prevent errors when Lodash is
    // loaded by a script tag in the presence of an AMD loader.
    // See http://requirejs.org/docs/errors.html#mismatch for more details.
    // Use `_.noConflict` to remove Lodash from the global object.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
      return _;
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
  // Check for `exports` after `define` in case a build optimizer adds it.
  else if (freeModule) {
    // Export for Node.js.
    (freeModule.exports = _)._ = _;
    // Export for CommonJS support.
    freeExports._ = _;
  }
  else {
    // Export to the global object.
    root._ = _;
  }
}.call(this));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12), __webpack_require__(143)(module)))

/***/ }),
/* 577 */
/***/ (function(module, exports, __webpack_require__) {

//! Â© 2015 Nathan Rugg <nmrugg@gmail.com> | MIT

var lzma;

function load_lzma()
{
    return lzma = __webpack_require__(578).LZMA_WORKER;
    // return require(require("path").join(__dirname, "src" ,"lzma_worker.js")).LZMA_WORKER;
}

lzma = load_lzma();

///NOTE: This function is for backwards compatibility's sake.
module.exports.LZMA = function LZMA()
{
    return lzma;
}

module.exports.compress   = lzma.compress;
module.exports.decompress = lzma.decompress;


/***/ }),
/* 578 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(setImmediate) {/// Â© 2015 Nathan Rugg <nmrugg@gmail.com> | MIT
/// See LICENSE for more details.

/* jshint noarg:true, boss:true, unused:strict, strict:true, undef:true, noarg: true, forin:true, evil:true, newcap:false, -W041, -W021, worker:true, browser:true, node:true */

/* global setImmediate, setTimeout, window, onmessage */

/** xs */
///NOTE: This is the master file that is used to generate lzma-c.js and lzma-d.js.
///      Comments are used to determine which parts are to be removed.
///
/// cs-ce (compression start-end)
/// ds-de (decompression start-end)
/// xs-xe (only in this file start-end)
/// co    (compression only)
/// do    (decompression only)
/** xe */

var LZMA = (function () {
    
    "use strict";
    
    var /** cs */
        action_compress   = 1,
        /** ce */
        /** ds */
        action_decompress = 2,
        /** de */
        action_progress   = 3,
        wait = typeof setImmediate == "function" ? setImmediate : setTimeout,
        __4294967296 = 4294967296,
        N1_longLit = [4294967295, -__4294967296],
        /** cs */
        MIN_VALUE = [0, -9223372036854775808],
        /** ce */
        P0_longLit = [0, 0],
        P1_longLit = [1, 0];
    
    function update_progress(percent, cbn) {
        postMessage({
            action: action_progress,
            cbn: cbn,
            result: percent
        });
    }
    
    function initDim(len) {
        ///NOTE: This is MUCH faster than "new Array(len)" in newer versions of v8 (starting with Node.js 0.11.15, which uses v8 3.28.73).
        var a = [];
        a[len - 1] = undefined;
        return a;
    }
    
    function add(a, b) {
        return create(a[0] + b[0], a[1] + b[1]);
    }
    
    /** cs */
    function and(a, b) {
        return makeFromBits(~~Math.max(Math.min(a[1] / __4294967296, 2147483647), -2147483648) & ~~Math.max(Math.min(b[1] / __4294967296, 2147483647), -2147483648), lowBits_0(a) & lowBits_0(b));
    }
    /** ce */
    
    function compare(a, b) {
        var nega, negb;
        if (a[0] == b[0] && a[1] == b[1]) {
            return 0;
        }
        nega = a[1] < 0;
        negb = b[1] < 0;
        if (nega && !negb) {
            return -1;
        }
        if (!nega && negb) {
            return 1;
        }
        if (sub(a, b)[1] < 0) {
            return -1;
        }
        return 1;
    }
    
    function create(valueLow, valueHigh) {
        var diffHigh, diffLow;
        valueHigh %= 1.8446744073709552E19;
        valueLow %= 1.8446744073709552E19;
        diffHigh = valueHigh % __4294967296;
        diffLow = Math.floor(valueLow / __4294967296) * __4294967296;
        valueHigh = valueHigh - diffHigh + diffLow;
        valueLow = valueLow - diffLow + diffHigh;
        while (valueLow < 0) {
            valueLow += __4294967296;
            valueHigh -= __4294967296;
        }
        while (valueLow > 4294967295) {
            valueLow -= __4294967296;
            valueHigh += __4294967296;
        }
        valueHigh = valueHigh % 1.8446744073709552E19;
        while (valueHigh > 9223372032559808512) {
            valueHigh -= 1.8446744073709552E19;
        }
        while (valueHigh < -9223372036854775808) {
            valueHigh += 1.8446744073709552E19;
        }
        return [valueLow, valueHigh];
    }
    
    /** cs */
    function eq(a, b) {
        return a[0] == b[0] && a[1] == b[1];
    }
    /** ce */
    function fromInt(value) {
        if (value >= 0) {
            return [value, 0];
        } else {
            return [value + __4294967296, -__4294967296];
        }
    }
    
    function lowBits_0(a) {
        if (a[0] >= 2147483648) {
            return ~~Math.max(Math.min(a[0] - __4294967296, 2147483647), -2147483648);
        } else {
            return ~~Math.max(Math.min(a[0], 2147483647), -2147483648);
        }
    }
    /** cs */
    function makeFromBits(highBits, lowBits) {
        var high, low;
        high = highBits * __4294967296;
        low = lowBits;
        if (lowBits < 0) {
            low += __4294967296;
        }
        return [low, high];
    }
    
    function pwrAsDouble(n) {
        if (n <= 30) {
            return 1 << n;
        } else {
            return pwrAsDouble(30) * pwrAsDouble(n - 30);
        }
    }
    
    function shl(a, n) {
        var diff, newHigh, newLow, twoToN;
        n &= 63;
        if (eq(a, MIN_VALUE)) {
            if (!n) {
                return a;
            }
            return P0_longLit;
        }
        if (a[1] < 0) {
            throw new Error("Neg");
        }
        twoToN = pwrAsDouble(n);
        newHigh = a[1] * twoToN % 1.8446744073709552E19;
        newLow = a[0] * twoToN;
        diff = newLow - newLow % __4294967296;
        newHigh += diff;
        newLow -= diff;
        if (newHigh >= 9223372036854775807) {
            newHigh -= 1.8446744073709552E19;
        }
        return [newLow, newHigh];
    }
    
    function shr(a, n) {
        var shiftFact;
        n &= 63;
        shiftFact = pwrAsDouble(n);
        return create(Math.floor(a[0] / shiftFact), a[1] / shiftFact);
    }
    
    function shru(a, n) {
        var sr;
        n &= 63;
        sr = shr(a, n);
        if (a[1] < 0) {
            sr = add(sr, shl([2, 0], 63 - n));
        }
        return sr;
    }
    
    /** ce */
    
    function sub(a, b) {
        return create(a[0] - b[0], a[1] - b[1]);
    }
    
    function $ByteArrayInputStream(this$static, buf) {
        this$static.buf = buf;
        this$static.pos = 0;
        this$static.count = buf.length;
        return this$static;
    }
    
    /** ds */
    function $read(this$static) {
        if (this$static.pos >= this$static.count)
            return -1;
        return this$static.buf[this$static.pos++] & 255;
    }
    /** de */
    /** cs */
    function $read_0(this$static, buf, off, len) {
        if (this$static.pos >= this$static.count)
            return -1;
        len = Math.min(len, this$static.count - this$static.pos);
        arraycopy(this$static.buf, this$static.pos, buf, off, len);
        this$static.pos += len;
        return len;
    }
    /** ce */
    
    function $ByteArrayOutputStream(this$static) {
        this$static.buf = initDim(32);
        this$static.count = 0;
        return this$static;
    }
    
    function $toByteArray(this$static) {
        var data = this$static.buf;
        data.length = this$static.count;
        return data;
    }
    
    /** cs */
    function $write(this$static, b) {
        this$static.buf[this$static.count++] = b << 24 >> 24;
    }
    /** ce */
    
    function $write_0(this$static, buf, off, len) {
        arraycopy(buf, off, this$static.buf, this$static.count, len);
        this$static.count += len;
    }
    
    /** cs */
    function $getChars(this$static, srcBegin, srcEnd, dst, dstBegin) {
        var srcIdx;
        for (srcIdx = srcBegin; srcIdx < srcEnd; ++srcIdx) {
            dst[dstBegin++] = this$static.charCodeAt(srcIdx);
        }
    }
    /** ce */
    
    function arraycopy(src, srcOfs, dest, destOfs, len) {
        for (var i = 0; i < len; ++i) {
            dest[destOfs + i] = src[srcOfs + i];
        }
    }
    
    /** cs */
    function $configure(this$static, encoder) {
        $SetDictionarySize_0(encoder, 1 << this$static.s);
        encoder._numFastBytes = this$static.f;
        $SetMatchFinder(encoder, this$static.m);
        
        /// lc is always 3
        /// lp is always 0
        /// pb is always 2
        encoder._numLiteralPosStateBits = 0;
        encoder._numLiteralContextBits = 3;
        encoder._posStateBits = 2;
        ///this$static._posStateMask = (1 << pb) - 1;
        encoder._posStateMask = 3;
    }
    
    function $init(this$static, input, output, length_0, mode) {
        var encoder, i;
        if (compare(length_0, N1_longLit) < 0)
            throw new Error("invalid length " + length_0);
        this$static.length_0 = length_0;
        encoder = $Encoder({});
        $configure(mode, encoder);
        encoder._writeEndMark = typeof LZMA.disableEndMark == "undefined";
        $WriteCoderProperties(encoder, output);
        for (i = 0; i < 64; i += 8)
            $write(output, lowBits_0(shr(length_0, i)) & 255);
        this$static.chunker = (encoder._needReleaseMFStream = 0 , (encoder._inStream = input , encoder._finished = 0 , $Create_2(encoder) , encoder._rangeEncoder.Stream = output , $Init_4(encoder) , $FillDistancesPrices(encoder) , $FillAlignPrices(encoder) , encoder._lenEncoder._tableSize = encoder._numFastBytes + 1 - 2 , $UpdateTables(encoder._lenEncoder, 1 << encoder._posStateBits) , encoder._repMatchLenEncoder._tableSize = encoder._numFastBytes + 1 - 2 , $UpdateTables(encoder._repMatchLenEncoder, 1 << encoder._posStateBits) , encoder.nowPos64 = P0_longLit , undefined) , $Chunker_0({}, encoder));
    }
    
    function $LZMAByteArrayCompressor(this$static, data, mode) {
        this$static.output = $ByteArrayOutputStream({});
        $init(this$static, $ByteArrayInputStream({}, data), this$static.output, fromInt(data.length), mode);
        return this$static;
    }
    /** ce */
    
    /** ds */
    function $init_0(this$static, input, output) {
        var decoder,
            hex_length = "",
            i,
            properties = [],
            r,
            tmp_length;
        
        for (i = 0; i < 5; ++i) {
            r = $read(input);
            if (r == -1)
                throw new Error("truncated input");
            properties[i] = r << 24 >> 24;
        }
        
        decoder = $Decoder({});
        if (!$SetDecoderProperties(decoder, properties)) {
            throw new Error("corrupted input");
        }
        for (i = 0; i < 64; i += 8) {
            r = $read(input);
            if (r == -1)
                throw new Error("truncated input");
            r = r.toString(16);
            if (r.length == 1) r = "0" + r;
            hex_length = r + "" + hex_length;
        }
        
        /// Was the length set in the header (if it was compressed from a stream, the length is all f"s).
        if (/^0+$|^f+$/i.test(hex_length)) {
            /// The length is unknown, so set to -1.
            this$static.length_0 = N1_longLit;
        } else {
            ///NOTE: If there is a problem with the decoder because of the length, you can always set the length to -1 (N1_longLit) which means unknown.
            tmp_length = parseInt(hex_length, 16);
            /// If the length is too long to handle, just set it to unknown.
            if (tmp_length > 4294967295) {
                this$static.length_0 = N1_longLit;
            } else {
                this$static.length_0 = fromInt(tmp_length);
            }
        }
        
        this$static.chunker = $CodeInChunks(decoder, input, output, this$static.length_0);
    }
    
    function $LZMAByteArrayDecompressor(this$static, data) {
        this$static.output = $ByteArrayOutputStream({});
        $init_0(this$static, $ByteArrayInputStream({}, data), this$static.output);
        return this$static;
    }
    /** de */
    /** cs */
    function $Create_4(this$static, keepSizeBefore, keepSizeAfter, keepSizeReserv) {
        var blockSize;
        this$static._keepSizeBefore = keepSizeBefore;
        this$static._keepSizeAfter = keepSizeAfter;
        blockSize = keepSizeBefore + keepSizeAfter + keepSizeReserv;
        if (this$static._bufferBase == null || this$static._blockSize != blockSize) {
            this$static._bufferBase = null;
            this$static._blockSize = blockSize;
            this$static._bufferBase = initDim(this$static._blockSize);
        }
        this$static._pointerToLastSafePosition = this$static._blockSize - keepSizeAfter;
    }
    
    function $GetIndexByte(this$static, index) {
        return this$static._bufferBase[this$static._bufferOffset + this$static._pos + index];
    }
    
    function $GetMatchLen(this$static, index, distance, limit) {
        var i, pby;
        if (this$static._streamEndWasReached) {
            if (this$static._pos + index + limit > this$static._streamPos) {
                limit = this$static._streamPos - (this$static._pos + index);
            }
        }
        ++distance;
        pby = this$static._bufferOffset + this$static._pos + index;
        for (i = 0; i < limit && this$static._bufferBase[pby + i] == this$static._bufferBase[pby + i - distance]; ++i) {
        }
        return i;
    }
    
    function $GetNumAvailableBytes(this$static) {
        return this$static._streamPos - this$static._pos;
    }
    
    function $MoveBlock(this$static) {
        var i, numBytes, offset;
        offset = this$static._bufferOffset + this$static._pos - this$static._keepSizeBefore;
        if (offset > 0) {
            --offset;
        }
        numBytes = this$static._bufferOffset + this$static._streamPos - offset;
        for (i = 0; i < numBytes; ++i) {
            this$static._bufferBase[i] = this$static._bufferBase[offset + i];
        }
        this$static._bufferOffset -= offset;
    }
    
    function $MovePos_1(this$static) {
        var pointerToPostion;
        ++this$static._pos;
        if (this$static._pos > this$static._posLimit) {
            pointerToPostion = this$static._bufferOffset + this$static._pos;
            if (pointerToPostion > this$static._pointerToLastSafePosition) {
                $MoveBlock(this$static);
            }
            $ReadBlock(this$static);
        }
    }
    
    function $ReadBlock(this$static) {
        var numReadBytes, pointerToPostion, size;
        if (this$static._streamEndWasReached)
            return;
        while (1) {
            size = -this$static._bufferOffset + this$static._blockSize - this$static._streamPos;
            if (!size)
                return;
            numReadBytes = $read_0(this$static._stream, this$static._bufferBase, this$static._bufferOffset + this$static._streamPos, size);
            if (numReadBytes == -1) {
                this$static._posLimit = this$static._streamPos;
                pointerToPostion = this$static._bufferOffset + this$static._posLimit;
                if (pointerToPostion > this$static._pointerToLastSafePosition) {
                    this$static._posLimit = this$static._pointerToLastSafePosition - this$static._bufferOffset;
                }
                this$static._streamEndWasReached = 1;
                return;
            }
            this$static._streamPos += numReadBytes;
            if (this$static._streamPos >= this$static._pos + this$static._keepSizeAfter) {
                this$static._posLimit = this$static._streamPos - this$static._keepSizeAfter;
            }
        }
    }
    
    function $ReduceOffsets(this$static, subValue) {
        this$static._bufferOffset += subValue;
        this$static._posLimit -= subValue;
        this$static._pos -= subValue;
        this$static._streamPos -= subValue;
    }
    
    var CrcTable = (function () {
        var i, j, r, CrcTable = [];
        for (i = 0; i < 256; ++i) {
            r = i;
            for (j = 0; j < 8; ++j)
            if ((r & 1) != 0) {
                r = r >>> 1 ^ -306674912;
            } else {
                r >>>= 1;
            }
            CrcTable[i] = r;
        }
        return CrcTable;
    }());
    
    function $Create_3(this$static, historySize, keepAddBufferBefore, matchMaxLen, keepAddBufferAfter) {
        var cyclicBufferSize, hs, windowReservSize;
        if (historySize < 1073741567) {
            this$static._cutValue = 16 + (matchMaxLen >> 1);
            windowReservSize = ~~((historySize + keepAddBufferBefore + matchMaxLen + keepAddBufferAfter) / 2) + 256;
            $Create_4(this$static, historySize + keepAddBufferBefore, matchMaxLen + keepAddBufferAfter, windowReservSize);
            this$static._matchMaxLen = matchMaxLen;
            cyclicBufferSize = historySize + 1;
            if (this$static._cyclicBufferSize != cyclicBufferSize) {
                this$static._son = initDim((this$static._cyclicBufferSize = cyclicBufferSize) * 2);
            }
    
            hs = 65536;
            if (this$static.HASH_ARRAY) {
                hs = historySize - 1;
                hs |= hs >> 1;
                hs |= hs >> 2;
                hs |= hs >> 4;
                hs |= hs >> 8;
                hs >>= 1;
                hs |= 65535;
                if (hs > 16777216)
                hs >>= 1;
                this$static._hashMask = hs;
                ++hs;
                hs += this$static.kFixHashSize;
            }
            
            if (hs != this$static._hashSizeSum) {
                this$static._hash = initDim(this$static._hashSizeSum = hs);
            }
        }
    }
    
    function $GetMatches(this$static, distances) {
        var count, cur, curMatch, curMatch2, curMatch3, cyclicPos, delta, hash2Value, hash3Value, hashValue, len, len0, len1, lenLimit, matchMinPos, maxLen, offset, pby1, ptr0, ptr1, temp;
        if (this$static._pos + this$static._matchMaxLen <= this$static._streamPos) {
            lenLimit = this$static._matchMaxLen;
        } else {
            lenLimit = this$static._streamPos - this$static._pos;
            if (lenLimit < this$static.kMinMatchCheck) {
                $MovePos_0(this$static);
                return 0;
            }
        }
        offset = 0;
        matchMinPos = this$static._pos > this$static._cyclicBufferSize?this$static._pos - this$static._cyclicBufferSize:0;
        cur = this$static._bufferOffset + this$static._pos;
        maxLen = 1;
        hash2Value = 0;
        hash3Value = 0;
        if (this$static.HASH_ARRAY) {
            temp = CrcTable[this$static._bufferBase[cur] & 255] ^ this$static._bufferBase[cur + 1] & 255;
            hash2Value = temp & 1023;
            temp ^= (this$static._bufferBase[cur + 2] & 255) << 8;
            hash3Value = temp & 65535;
            hashValue = (temp ^ CrcTable[this$static._bufferBase[cur + 3] & 255] << 5) & this$static._hashMask;
        } else {
            hashValue = this$static._bufferBase[cur] & 255 ^ (this$static._bufferBase[cur + 1] & 255) << 8;
        }

        curMatch = this$static._hash[this$static.kFixHashSize + hashValue] || 0;
        if (this$static.HASH_ARRAY) {
            curMatch2 = this$static._hash[hash2Value] || 0;
            curMatch3 = this$static._hash[1024 + hash3Value] || 0;
            this$static._hash[hash2Value] = this$static._pos;
            this$static._hash[1024 + hash3Value] = this$static._pos;
            if (curMatch2 > matchMinPos) {
                if (this$static._bufferBase[this$static._bufferOffset + curMatch2] == this$static._bufferBase[cur]) {
                    distances[offset++] = maxLen = 2;
                    distances[offset++] = this$static._pos - curMatch2 - 1;
                }
            }
            if (curMatch3 > matchMinPos) {
                if (this$static._bufferBase[this$static._bufferOffset + curMatch3] == this$static._bufferBase[cur]) {
                    if (curMatch3 == curMatch2) {
                        offset -= 2;
                    }
                    distances[offset++] = maxLen = 3;
                    distances[offset++] = this$static._pos - curMatch3 - 1;
                    curMatch2 = curMatch3;
                }
            }
            if (offset != 0 && curMatch2 == curMatch) {
                offset -= 2;
                maxLen = 1;
            }
        }
        this$static._hash[this$static.kFixHashSize + hashValue] = this$static._pos;
        ptr0 = (this$static._cyclicBufferPos << 1) + 1;
        ptr1 = this$static._cyclicBufferPos << 1;
        len0 = len1 = this$static.kNumHashDirectBytes;
        if (this$static.kNumHashDirectBytes != 0) {
            if (curMatch > matchMinPos) {
                if (this$static._bufferBase[this$static._bufferOffset + curMatch + this$static.kNumHashDirectBytes] != this$static._bufferBase[cur + this$static.kNumHashDirectBytes]) {
                    distances[offset++] = maxLen = this$static.kNumHashDirectBytes;
                    distances[offset++] = this$static._pos - curMatch - 1;
                }
            }
        }
        count = this$static._cutValue;
        while (1) {
            if (curMatch <= matchMinPos || count-- == 0) {
                this$static._son[ptr0] = this$static._son[ptr1] = 0;
                break;
            }
            delta = this$static._pos - curMatch;
            cyclicPos = (delta <= this$static._cyclicBufferPos?this$static._cyclicBufferPos - delta:this$static._cyclicBufferPos - delta + this$static._cyclicBufferSize) << 1;
            pby1 = this$static._bufferOffset + curMatch;
            len = len0 < len1?len0:len1;
            if (this$static._bufferBase[pby1 + len] == this$static._bufferBase[cur + len]) {
                while (++len != lenLimit) {
                    if (this$static._bufferBase[pby1 + len] != this$static._bufferBase[cur + len]) {
                        break;
                    }
                }
                if (maxLen < len) {
                    distances[offset++] = maxLen = len;
                    distances[offset++] = delta - 1;
                    if (len == lenLimit) {
                    this$static._son[ptr1] = this$static._son[cyclicPos];
                    this$static._son[ptr0] = this$static._son[cyclicPos + 1];
                    break;
                    }
                }
            }
            if ((this$static._bufferBase[pby1 + len] & 255) < (this$static._bufferBase[cur + len] & 255)) {
                this$static._son[ptr1] = curMatch;
                ptr1 = cyclicPos + 1;
                curMatch = this$static._son[ptr1];
                len1 = len;
            } else {
                this$static._son[ptr0] = curMatch;
                ptr0 = cyclicPos;
                curMatch = this$static._son[ptr0];
                len0 = len;
            }
        }
        $MovePos_0(this$static);
        return offset;
    }
    
    function $Init_5(this$static) {
        this$static._bufferOffset = 0;
        this$static._pos = 0;
        this$static._streamPos = 0;
        this$static._streamEndWasReached = 0;
        $ReadBlock(this$static);
        this$static._cyclicBufferPos = 0;
        $ReduceOffsets(this$static, -1);
    }
    
    function $MovePos_0(this$static) {
        var subValue;
        if (++this$static._cyclicBufferPos >= this$static._cyclicBufferSize) {
            this$static._cyclicBufferPos = 0;
        }
        $MovePos_1(this$static);
        if (this$static._pos == 1073741823) {
            subValue = this$static._pos - this$static._cyclicBufferSize;
            $NormalizeLinks(this$static._son, this$static._cyclicBufferSize * 2, subValue);
            $NormalizeLinks(this$static._hash, this$static._hashSizeSum, subValue);
            $ReduceOffsets(this$static, subValue);
        }
    }
    
    ///NOTE: This is only called after reading one whole gigabyte.
    function $NormalizeLinks(items, numItems, subValue) {
        var i, value;
        for (i = 0; i < numItems; ++i) {
            value = items[i] || 0;
            if (value <= subValue) {
                value = 0;
            } else {
                value -= subValue;
            }
            items[i] = value;
        }
    }
    
    function $SetType(this$static, numHashBytes) {
        this$static.HASH_ARRAY = numHashBytes > 2;
        if (this$static.HASH_ARRAY) {
            this$static.kNumHashDirectBytes = 0;
            this$static.kMinMatchCheck = 4;
            this$static.kFixHashSize = 66560;
        } else {
            this$static.kNumHashDirectBytes = 2;
            this$static.kMinMatchCheck = 3;
            this$static.kFixHashSize = 0;
        }
    }
    
    function $Skip(this$static, num) {
        var count, cur, curMatch, cyclicPos, delta, hash2Value, hash3Value, hashValue, len, len0, len1, lenLimit, matchMinPos, pby1, ptr0, ptr1, temp;
        do {
            if (this$static._pos + this$static._matchMaxLen <= this$static._streamPos) {
                lenLimit = this$static._matchMaxLen;
            } else {
                lenLimit = this$static._streamPos - this$static._pos;
                if (lenLimit < this$static.kMinMatchCheck) {
                    $MovePos_0(this$static);
                    continue;
                }
            }
            matchMinPos = this$static._pos > this$static._cyclicBufferSize?this$static._pos - this$static._cyclicBufferSize:0;
            cur = this$static._bufferOffset + this$static._pos;
            if (this$static.HASH_ARRAY) {
                temp = CrcTable[this$static._bufferBase[cur] & 255] ^ this$static._bufferBase[cur + 1] & 255;
                hash2Value = temp & 1023;
                this$static._hash[hash2Value] = this$static._pos;
                temp ^= (this$static._bufferBase[cur + 2] & 255) << 8;
                hash3Value = temp & 65535;
                this$static._hash[1024 + hash3Value] = this$static._pos;
                hashValue = (temp ^ CrcTable[this$static._bufferBase[cur + 3] & 255] << 5) & this$static._hashMask;
            } else {
                hashValue = this$static._bufferBase[cur] & 255 ^ (this$static._bufferBase[cur + 1] & 255) << 8;
            }
            curMatch = this$static._hash[this$static.kFixHashSize + hashValue];
            this$static._hash[this$static.kFixHashSize + hashValue] = this$static._pos;
            ptr0 = (this$static._cyclicBufferPos << 1) + 1;
            ptr1 = this$static._cyclicBufferPos << 1;
            len0 = len1 = this$static.kNumHashDirectBytes;
            count = this$static._cutValue;
            while (1) {
                if (curMatch <= matchMinPos || count-- == 0) {
                    this$static._son[ptr0] = this$static._son[ptr1] = 0;
                    break;
                }
                delta = this$static._pos - curMatch;
                cyclicPos = (delta <= this$static._cyclicBufferPos?this$static._cyclicBufferPos - delta:this$static._cyclicBufferPos - delta + this$static._cyclicBufferSize) << 1;
                pby1 = this$static._bufferOffset + curMatch;
                len = len0 < len1?len0:len1;
                if (this$static._bufferBase[pby1 + len] == this$static._bufferBase[cur + len]) {
                    while (++len != lenLimit) {
                        if (this$static._bufferBase[pby1 + len] != this$static._bufferBase[cur + len]) {
                            break;
                        }
                    }
                    if (len == lenLimit) {
                        this$static._son[ptr1] = this$static._son[cyclicPos];
                        this$static._son[ptr0] = this$static._son[cyclicPos + 1];
                        break;
                    }
                }
                if ((this$static._bufferBase[pby1 + len] & 255) < (this$static._bufferBase[cur + len] & 255)) {
                    this$static._son[ptr1] = curMatch;
                    ptr1 = cyclicPos + 1;
                    curMatch = this$static._son[ptr1];
                    len1 = len;
                } else {
                    this$static._son[ptr0] = curMatch;
                    ptr0 = cyclicPos;
                    curMatch = this$static._son[ptr0];
                    len0 = len;
                }
            }
            $MovePos_0(this$static);
        }
        while (--num != 0);
    }
    
    /** ce */
    /** ds */
    function $CopyBlock(this$static, distance, len) {
        var pos = this$static._pos - distance - 1;
        if (pos < 0) {
            pos += this$static._windowSize;
        }
        for (; len != 0; --len) {
            if (pos >= this$static._windowSize) {
                pos = 0;
            }
            this$static._buffer[this$static._pos++] = this$static._buffer[pos++];
            if (this$static._pos >= this$static._windowSize) {
                $Flush_0(this$static);
            }
        }
    }
    
    function $Create_5(this$static, windowSize) {
        if (this$static._buffer == null || this$static._windowSize != windowSize) {
            this$static._buffer = initDim(windowSize);
        }
        this$static._windowSize = windowSize;
        this$static._pos = 0;
        this$static._streamPos = 0;
    }
    
    function $Flush_0(this$static) {
        var size = this$static._pos - this$static._streamPos;
        if (!size) {
            return;
        }
        $write_0(this$static._stream, this$static._buffer, this$static._streamPos, size);
        if (this$static._pos >= this$static._windowSize) {
            this$static._pos = 0;
        }
        this$static._streamPos = this$static._pos;
    }
    
    function $GetByte(this$static, distance) {
        var pos = this$static._pos - distance - 1;
        if (pos < 0) {
            pos += this$static._windowSize;
        }
        return this$static._buffer[pos];
    }
    
    function $PutByte(this$static, b) {
        this$static._buffer[this$static._pos++] = b;
        if (this$static._pos >= this$static._windowSize) {
            $Flush_0(this$static);
        }
    }
    
    function $ReleaseStream(this$static) {
        $Flush_0(this$static);
        this$static._stream = null;
    }
    /** de */
    
    function GetLenToPosState(len) {
        len -= 2;
        if (len < 4) {
            return len;
        }
        return 3;
    }
    
    function StateUpdateChar(index) {
        if (index < 4) {
            return 0;
        }
        if (index < 10) {
            return index - 3;
        }
        return index - 6;
    }
    
    /** cs */
    function $Chunker_0(this$static, encoder) {
        this$static.encoder = encoder;
        this$static.decoder = null;
        this$static.alive = 1;
        return this$static;
    }
    /** ce */
    /** ds */
    function $Chunker(this$static, decoder) {
        this$static.decoder = decoder;
        this$static.encoder = null;
        this$static.alive = 1;
        return this$static;
    }
    /** de */
    
    function $processChunk(this$static) {
        if (!this$static.alive) {
            throw new Error("bad state");
        }
        
        if (this$static.encoder) {
            /// do:throw new Error("No encoding");
            /** cs */
            $processEncoderChunk(this$static);
            /** ce */
        } else {
            /// co:throw new Error("No decoding");
            /** ds */
            $processDecoderChunk(this$static);
            /** de */
        }
        return this$static.alive;
    }
    
    /** ds */
    function $processDecoderChunk(this$static) {
        var result = $CodeOneChunk(this$static.decoder);
        if (result == -1) {
            throw new Error("corrupted input");
        }
        this$static.inBytesProcessed = N1_longLit;
        this$static.outBytesProcessed = this$static.decoder.nowPos64;
        if (result || compare(this$static.decoder.outSize, P0_longLit) >= 0 && compare(this$static.decoder.nowPos64, this$static.decoder.outSize) >= 0) {
            $Flush_0(this$static.decoder.m_OutWindow);
            $ReleaseStream(this$static.decoder.m_OutWindow);
            this$static.decoder.m_RangeDecoder.Stream = null;
            this$static.alive = 0;
        }
    }
    /** de */
    /** cs */
    function $processEncoderChunk(this$static) {
        $CodeOneBlock(this$static.encoder, this$static.encoder.processedInSize, this$static.encoder.processedOutSize, this$static.encoder.finished);
        this$static.inBytesProcessed = this$static.encoder.processedInSize[0];
        if (this$static.encoder.finished[0]) {
            $ReleaseStreams(this$static.encoder);
            this$static.alive = 0;
        }
    }
    /** ce */
    
    /** ds */
    function $CodeInChunks(this$static, inStream, outStream, outSize) {
        this$static.m_RangeDecoder.Stream = inStream;
        $ReleaseStream(this$static.m_OutWindow);
        this$static.m_OutWindow._stream = outStream;
        $Init_1(this$static);
        this$static.state = 0;
        this$static.rep0 = 0;
        this$static.rep1 = 0;
        this$static.rep2 = 0;
        this$static.rep3 = 0;
        this$static.outSize = outSize;
        this$static.nowPos64 = P0_longLit;
        this$static.prevByte = 0;
        return $Chunker({}, this$static);
    }
    
    function $CodeOneChunk(this$static) {
        var decoder2, distance, len, numDirectBits, posSlot, posState;
        posState = lowBits_0(this$static.nowPos64) & this$static.m_PosStateMask;
        if (!$DecodeBit(this$static.m_RangeDecoder, this$static.m_IsMatchDecoders, (this$static.state << 4) + posState)) {
            decoder2 = $GetDecoder(this$static.m_LiteralDecoder, lowBits_0(this$static.nowPos64), this$static.prevByte);
            if (this$static.state < 7) {
                this$static.prevByte = $DecodeNormal(decoder2, this$static.m_RangeDecoder);
            } else {
                this$static.prevByte = $DecodeWithMatchByte(decoder2, this$static.m_RangeDecoder, $GetByte(this$static.m_OutWindow, this$static.rep0));
            }
            $PutByte(this$static.m_OutWindow, this$static.prevByte);
            this$static.state = StateUpdateChar(this$static.state);
            this$static.nowPos64 = add(this$static.nowPos64, P1_longLit);
        } else {
            if ($DecodeBit(this$static.m_RangeDecoder, this$static.m_IsRepDecoders, this$static.state)) {
                len = 0;
                if (!$DecodeBit(this$static.m_RangeDecoder, this$static.m_IsRepG0Decoders, this$static.state)) {
                    if (!$DecodeBit(this$static.m_RangeDecoder, this$static.m_IsRep0LongDecoders, (this$static.state << 4) + posState)) {
                        this$static.state = this$static.state < 7?9:11;
                        len = 1;
                    }
                } else {
                    if (!$DecodeBit(this$static.m_RangeDecoder, this$static.m_IsRepG1Decoders, this$static.state)) {
                        distance = this$static.rep1;
                    } else {
                        if (!$DecodeBit(this$static.m_RangeDecoder, this$static.m_IsRepG2Decoders, this$static.state)) {
                            distance = this$static.rep2;
                        } else {
                            distance = this$static.rep3;
                            this$static.rep3 = this$static.rep2;
                        }
                        this$static.rep2 = this$static.rep1;
                    }
                    this$static.rep1 = this$static.rep0;
                    this$static.rep0 = distance;
                }
                if (!len) {
                    len = $Decode(this$static.m_RepLenDecoder, this$static.m_RangeDecoder, posState) + 2;
                    this$static.state = this$static.state < 7?8:11;
                }
            } else {
                this$static.rep3 = this$static.rep2;
                this$static.rep2 = this$static.rep1;
                this$static.rep1 = this$static.rep0;
                len = 2 + $Decode(this$static.m_LenDecoder, this$static.m_RangeDecoder, posState);
                this$static.state = this$static.state < 7?7:10;
                posSlot = $Decode_0(this$static.m_PosSlotDecoder[GetLenToPosState(len)], this$static.m_RangeDecoder);
                if (posSlot >= 4) {
                    numDirectBits = (posSlot >> 1) - 1;
                    this$static.rep0 = (2 | posSlot & 1) << numDirectBits;
                    if (posSlot < 14) {
                        this$static.rep0 += ReverseDecode(this$static.m_PosDecoders, this$static.rep0 - posSlot - 1, this$static.m_RangeDecoder, numDirectBits);
                    } else {
                        this$static.rep0 += $DecodeDirectBits(this$static.m_RangeDecoder, numDirectBits - 4) << 4;
                        this$static.rep0 += $ReverseDecode(this$static.m_PosAlignDecoder, this$static.m_RangeDecoder);
                        if (this$static.rep0 < 0) {
                            if (this$static.rep0 == -1) {
                                return 1;
                            }
                            return -1;
                        }
                    }
                } else 
                    this$static.rep0 = posSlot;
            }
            if (compare(fromInt(this$static.rep0), this$static.nowPos64) >= 0 || this$static.rep0 >= this$static.m_DictionarySizeCheck) {
                return -1;
            }
            $CopyBlock(this$static.m_OutWindow, this$static.rep0, len);
            this$static.nowPos64 = add(this$static.nowPos64, fromInt(len));
            this$static.prevByte = $GetByte(this$static.m_OutWindow, 0);
        }
        return 0;
    }
    
    function $Decoder(this$static) {
        this$static.m_OutWindow = {};
        this$static.m_RangeDecoder = {};
        this$static.m_IsMatchDecoders = initDim(192);
        this$static.m_IsRepDecoders = initDim(12);
        this$static.m_IsRepG0Decoders = initDim(12);
        this$static.m_IsRepG1Decoders = initDim(12);
        this$static.m_IsRepG2Decoders = initDim(12);
        this$static.m_IsRep0LongDecoders = initDim(192);
        this$static.m_PosSlotDecoder = initDim(4);
        this$static.m_PosDecoders = initDim(114);
        this$static.m_PosAlignDecoder = $BitTreeDecoder({}, 4);
        this$static.m_LenDecoder = $Decoder$LenDecoder({});
        this$static.m_RepLenDecoder = $Decoder$LenDecoder({});
        this$static.m_LiteralDecoder = {};
        for (var i = 0; i < 4; ++i) {
            this$static.m_PosSlotDecoder[i] = $BitTreeDecoder({}, 6);
        }
        return this$static;
    }
    
    function $Init_1(this$static) {
        this$static.m_OutWindow._streamPos = 0;
        this$static.m_OutWindow._pos = 0;
        InitBitModels(this$static.m_IsMatchDecoders);
        InitBitModels(this$static.m_IsRep0LongDecoders);
        InitBitModels(this$static.m_IsRepDecoders);
        InitBitModels(this$static.m_IsRepG0Decoders);
        InitBitModels(this$static.m_IsRepG1Decoders);
        InitBitModels(this$static.m_IsRepG2Decoders);
        InitBitModels(this$static.m_PosDecoders);
        $Init_0(this$static.m_LiteralDecoder);
        for (var i = 0; i < 4; ++i) {
            InitBitModels(this$static.m_PosSlotDecoder[i].Models);
        }
        $Init(this$static.m_LenDecoder);
        $Init(this$static.m_RepLenDecoder);
        InitBitModels(this$static.m_PosAlignDecoder.Models);
        $Init_8(this$static.m_RangeDecoder);
    }
    
    function $SetDecoderProperties(this$static, properties) {
        var dictionarySize, i, lc, lp, pb, remainder, val;
        if (properties.length < 5)
            return 0;
        val = properties[0] & 255;
        lc = val % 9;
        remainder = ~~(val / 9);
        lp = remainder % 5;
        pb = ~~(remainder / 5);
        dictionarySize = 0;
        for (i = 0; i < 4; ++i) {
            dictionarySize += (properties[1 + i] & 255) << i * 8;
        }
        ///NOTE: If the input is bad, it might call for an insanely large dictionary size, which would crash the script.
        if (dictionarySize > 99999999 || !$SetLcLpPb(this$static, lc, lp, pb)) {
            return 0;
        }
        return $SetDictionarySize(this$static, dictionarySize);
    }
    
    function $SetDictionarySize(this$static, dictionarySize) {
        if (dictionarySize < 0) {
            return 0;
        }
        if (this$static.m_DictionarySize != dictionarySize) {
            this$static.m_DictionarySize = dictionarySize;
            this$static.m_DictionarySizeCheck = Math.max(this$static.m_DictionarySize, 1);
            $Create_5(this$static.m_OutWindow, Math.max(this$static.m_DictionarySizeCheck, 4096));
        }
        return 1;
    }
    
    function $SetLcLpPb(this$static, lc, lp, pb) {
        if (lc > 8 || lp > 4 || pb > 4) {
            return 0;
        }
        $Create_0(this$static.m_LiteralDecoder, lp, lc);
        var numPosStates = 1 << pb;
        $Create(this$static.m_LenDecoder, numPosStates);
        $Create(this$static.m_RepLenDecoder, numPosStates);
        this$static.m_PosStateMask = numPosStates - 1;
        return 1;
    }
    
    function $Create(this$static, numPosStates) {
        for (; this$static.m_NumPosStates < numPosStates; ++this$static.m_NumPosStates) {
            this$static.m_LowCoder[this$static.m_NumPosStates] = $BitTreeDecoder({}, 3);
            this$static.m_MidCoder[this$static.m_NumPosStates] = $BitTreeDecoder({}, 3);
        }
    }
    
    function $Decode(this$static, rangeDecoder, posState) {
        if (!$DecodeBit(rangeDecoder, this$static.m_Choice, 0)) {
            return $Decode_0(this$static.m_LowCoder[posState], rangeDecoder);
        }
        var symbol = 8;
        if (!$DecodeBit(rangeDecoder, this$static.m_Choice, 1)) {
            symbol += $Decode_0(this$static.m_MidCoder[posState], rangeDecoder);
        } else {
            symbol += 8 + $Decode_0(this$static.m_HighCoder, rangeDecoder);
        }
        return symbol;
    }
    
    function $Decoder$LenDecoder(this$static) {
        this$static.m_Choice = initDim(2);
        this$static.m_LowCoder = initDim(16);
        this$static.m_MidCoder = initDim(16);
        this$static.m_HighCoder = $BitTreeDecoder({}, 8);
        this$static.m_NumPosStates = 0;
        return this$static;
    }
    
    function $Init(this$static) {
        InitBitModels(this$static.m_Choice);
        for (var posState = 0; posState < this$static.m_NumPosStates; ++posState) {
            InitBitModels(this$static.m_LowCoder[posState].Models);
            InitBitModels(this$static.m_MidCoder[posState].Models);
        }
        InitBitModels(this$static.m_HighCoder.Models);
    }
    
    
    function $Create_0(this$static, numPosBits, numPrevBits) {
        var i, numStates;
        if (this$static.m_Coders != null && this$static.m_NumPrevBits == numPrevBits && this$static.m_NumPosBits == numPosBits)
            return;
        this$static.m_NumPosBits = numPosBits;
        this$static.m_PosMask = (1 << numPosBits) - 1;
        this$static.m_NumPrevBits = numPrevBits;
        numStates = 1 << this$static.m_NumPrevBits + this$static.m_NumPosBits;
        this$static.m_Coders = initDim(numStates);
        for (i = 0; i < numStates; ++i)
            this$static.m_Coders[i] = $Decoder$LiteralDecoder$Decoder2({});
    }
    
    function $GetDecoder(this$static, pos, prevByte) {
        return this$static.m_Coders[((pos & this$static.m_PosMask) << this$static.m_NumPrevBits) + ((prevByte & 255) >>> 8 - this$static.m_NumPrevBits)];
    }
    
    function $Init_0(this$static) {
        var i, numStates;
        numStates = 1 << this$static.m_NumPrevBits + this$static.m_NumPosBits;
        for (i = 0; i < numStates; ++i) {
            InitBitModels(this$static.m_Coders[i].m_Decoders);
        }
    }
    
    
    function $DecodeNormal(this$static, rangeDecoder) {
        var symbol = 1;
        do {
            symbol = symbol << 1 | $DecodeBit(rangeDecoder, this$static.m_Decoders, symbol);
        } while (symbol < 256);
        return symbol << 24 >> 24;
    }
    
    function $DecodeWithMatchByte(this$static, rangeDecoder, matchByte) {
        var bit, matchBit, symbol = 1;
        do {
            matchBit = matchByte >> 7 & 1;
            matchByte <<= 1;
            bit = $DecodeBit(rangeDecoder, this$static.m_Decoders, (1 + matchBit << 8) + symbol);
            symbol = symbol << 1 | bit;
            if (matchBit != bit) {
                while (symbol < 256) {
                    symbol = symbol << 1 | $DecodeBit(rangeDecoder, this$static.m_Decoders, symbol);
                }
            break;
            }
        } while (symbol < 256);
        return symbol << 24 >> 24;
    }
    
    function $Decoder$LiteralDecoder$Decoder2(this$static) {
        this$static.m_Decoders = initDim(768);
        return this$static;
    }
    
    /** de */
    /** cs */
    var g_FastPos = (function () {
        var j, k, slotFast, c = 2, g_FastPos = [0, 1];
        for (slotFast = 2; slotFast < 22; ++slotFast) {
            k = 1 << (slotFast >> 1) - 1;
            for (j = 0; j < k; ++j , ++c)
                g_FastPos[c] = slotFast << 24 >> 24;
        }
        return g_FastPos;
    }());
    
    function $Backward(this$static, cur) {
        var backCur, backMem, posMem, posPrev;
        this$static._optimumEndIndex = cur;
        posMem = this$static._optimum[cur].PosPrev;
        backMem = this$static._optimum[cur].BackPrev;
        do {
            if (this$static._optimum[cur].Prev1IsChar) {
                $MakeAsChar(this$static._optimum[posMem]);
                this$static._optimum[posMem].PosPrev = posMem - 1;
                if (this$static._optimum[cur].Prev2) {
                    this$static._optimum[posMem - 1].Prev1IsChar = 0;
                    this$static._optimum[posMem - 1].PosPrev = this$static._optimum[cur].PosPrev2;
                    this$static._optimum[posMem - 1].BackPrev = this$static._optimum[cur].BackPrev2;
                }
            }
            posPrev = posMem;
            backCur = backMem;
            backMem = this$static._optimum[posPrev].BackPrev;
            posMem = this$static._optimum[posPrev].PosPrev;
            this$static._optimum[posPrev].BackPrev = backCur;
            this$static._optimum[posPrev].PosPrev = cur;
            cur = posPrev;
        } while (cur > 0);
        this$static.backRes = this$static._optimum[0].BackPrev;
        this$static._optimumCurrentIndex = this$static._optimum[0].PosPrev;
        return this$static._optimumCurrentIndex;
    }
    
    function $BaseInit(this$static) {
        this$static._state = 0;
        this$static._previousByte = 0;
        for (var i = 0; i < 4; ++i) {
            this$static._repDistances[i] = 0;
        }
    }
    
    function $CodeOneBlock(this$static, inSize, outSize, finished) {
        var baseVal, complexState, curByte, distance, footerBits, i, len, lenToPosState, matchByte, pos, posReduced, posSlot, posState, progressPosValuePrev, subCoder;
        inSize[0] = P0_longLit;
        outSize[0] = P0_longLit;
        finished[0] = 1;
        if (this$static._inStream) {
            this$static._matchFinder._stream = this$static._inStream;
            $Init_5(this$static._matchFinder);
            this$static._needReleaseMFStream = 1;
            this$static._inStream = null;
        }
        if (this$static._finished) {
            return;
        }
        this$static._finished = 1;
        progressPosValuePrev = this$static.nowPos64;
        if (eq(this$static.nowPos64, P0_longLit)) {
            if (!$GetNumAvailableBytes(this$static._matchFinder)) {
                $Flush(this$static, lowBits_0(this$static.nowPos64));
                return;
            }
            $ReadMatchDistances(this$static);
            posState = lowBits_0(this$static.nowPos64) & this$static._posStateMask;
            $Encode_3(this$static._rangeEncoder, this$static._isMatch, (this$static._state << 4) + posState, 0);
            this$static._state = StateUpdateChar(this$static._state);
            curByte = $GetIndexByte(this$static._matchFinder, -this$static._additionalOffset);
            $Encode_1($GetSubCoder(this$static._literalEncoder, lowBits_0(this$static.nowPos64), this$static._previousByte), this$static._rangeEncoder, curByte);
            this$static._previousByte = curByte;
            --this$static._additionalOffset;
            this$static.nowPos64 = add(this$static.nowPos64, P1_longLit);
        }
        if (!$GetNumAvailableBytes(this$static._matchFinder)) {
            $Flush(this$static, lowBits_0(this$static.nowPos64));
            return;
        }
        while (1) {
            len = $GetOptimum(this$static, lowBits_0(this$static.nowPos64));
            pos = this$static.backRes;
            posState = lowBits_0(this$static.nowPos64) & this$static._posStateMask;
            complexState = (this$static._state << 4) + posState;
            if (len == 1 && pos == -1) {
                $Encode_3(this$static._rangeEncoder, this$static._isMatch, complexState, 0);
                curByte = $GetIndexByte(this$static._matchFinder, -this$static._additionalOffset);
                subCoder = $GetSubCoder(this$static._literalEncoder, lowBits_0(this$static.nowPos64), this$static._previousByte);
                if (this$static._state < 7) {
                    $Encode_1(subCoder, this$static._rangeEncoder, curByte);
                } else {
                    matchByte = $GetIndexByte(this$static._matchFinder, -this$static._repDistances[0] - 1 - this$static._additionalOffset);
                    $EncodeMatched(subCoder, this$static._rangeEncoder, matchByte, curByte);
                }
                this$static._previousByte = curByte;
                this$static._state = StateUpdateChar(this$static._state);
            } else {
                $Encode_3(this$static._rangeEncoder, this$static._isMatch, complexState, 1);
                if (pos < 4) {
                    $Encode_3(this$static._rangeEncoder, this$static._isRep, this$static._state, 1);
                    if (!pos) {
                        $Encode_3(this$static._rangeEncoder, this$static._isRepG0, this$static._state, 0);
                        if (len == 1) {
                            $Encode_3(this$static._rangeEncoder, this$static._isRep0Long, complexState, 0);
                        } else {
                            $Encode_3(this$static._rangeEncoder, this$static._isRep0Long, complexState, 1);
                        }
                    } else {
                        $Encode_3(this$static._rangeEncoder, this$static._isRepG0, this$static._state, 1);
                        if (pos == 1) {
                            $Encode_3(this$static._rangeEncoder, this$static._isRepG1, this$static._state, 0);
                        } else {
                            $Encode_3(this$static._rangeEncoder, this$static._isRepG1, this$static._state, 1);
                            $Encode_3(this$static._rangeEncoder, this$static._isRepG2, this$static._state, pos - 2);
                        }
                    }
                    if (len == 1) {
                        this$static._state = this$static._state < 7?9:11;
                    } else {
                        $Encode_0(this$static._repMatchLenEncoder, this$static._rangeEncoder, len - 2, posState);
                        this$static._state = this$static._state < 7?8:11;
                    }
                    distance = this$static._repDistances[pos];
                    if (pos != 0) {
                        for (i = pos; i >= 1; --i) {
                            this$static._repDistances[i] = this$static._repDistances[i - 1];
                        }
                        this$static._repDistances[0] = distance;
                    }
                } else {
                    $Encode_3(this$static._rangeEncoder, this$static._isRep, this$static._state, 0);
                    this$static._state = this$static._state < 7?7:10;
                    $Encode_0(this$static._lenEncoder, this$static._rangeEncoder, len - 2, posState);
                    pos -= 4;
                    posSlot = GetPosSlot(pos);
                    lenToPosState = GetLenToPosState(len);
                    $Encode_2(this$static._posSlotEncoder[lenToPosState], this$static._rangeEncoder, posSlot);
                    if (posSlot >= 4) {
                        footerBits = (posSlot >> 1) - 1;
                        baseVal = (2 | posSlot & 1) << footerBits;
                        posReduced = pos - baseVal;
                        if (posSlot < 14) {
                            ReverseEncode(this$static._posEncoders, baseVal - posSlot - 1, this$static._rangeEncoder, footerBits, posReduced);
                        } else {
                            $EncodeDirectBits(this$static._rangeEncoder, posReduced >> 4, footerBits - 4);
                            $ReverseEncode(this$static._posAlignEncoder, this$static._rangeEncoder, posReduced & 15);
                            ++this$static._alignPriceCount;
                        }
                    }
                    distance = pos;
                    for (i = 3; i >= 1; --i) {
                        this$static._repDistances[i] = this$static._repDistances[i - 1];
                    }
                    this$static._repDistances[0] = distance;
                    ++this$static._matchPriceCount;
                }
                this$static._previousByte = $GetIndexByte(this$static._matchFinder, len - 1 - this$static._additionalOffset);
            }
            this$static._additionalOffset -= len;
            this$static.nowPos64 = add(this$static.nowPos64, fromInt(len));
            if (!this$static._additionalOffset) {
                if (this$static._matchPriceCount >= 128) {
                    $FillDistancesPrices(this$static);
                }
                if (this$static._alignPriceCount >= 16) {
                    $FillAlignPrices(this$static);
                }
                inSize[0] = this$static.nowPos64;
                outSize[0] = $GetProcessedSizeAdd(this$static._rangeEncoder);
                if (!$GetNumAvailableBytes(this$static._matchFinder)) {
                    $Flush(this$static, lowBits_0(this$static.nowPos64));
                    return;
                }
                if (compare(sub(this$static.nowPos64, progressPosValuePrev), [4096, 0]) >= 0) {
                    this$static._finished = 0;
                    finished[0] = 0;
                    return;
                }
            }
        }
    }
    
    function $Create_2(this$static) {
        var bt, numHashBytes;
        if (!this$static._matchFinder) {
            bt = {};
            numHashBytes = 4;
            if (!this$static._matchFinderType) {
                numHashBytes = 2;
            }
            $SetType(bt, numHashBytes);
            this$static._matchFinder = bt;
        }
        $Create_1(this$static._literalEncoder, this$static._numLiteralPosStateBits, this$static._numLiteralContextBits);
        if (this$static._dictionarySize == this$static._dictionarySizePrev && this$static._numFastBytesPrev == this$static._numFastBytes) {
            return;
        }
        $Create_3(this$static._matchFinder, this$static._dictionarySize, 4096, this$static._numFastBytes, 274);
        this$static._dictionarySizePrev = this$static._dictionarySize;
        this$static._numFastBytesPrev = this$static._numFastBytes;
    }
    
    function $Encoder(this$static) {
        var i;
        this$static._repDistances = initDim(4);
        this$static._optimum = [];
        this$static._rangeEncoder = {};
        this$static._isMatch = initDim(192);
        this$static._isRep = initDim(12);
        this$static._isRepG0 = initDim(12);
        this$static._isRepG1 = initDim(12);
        this$static._isRepG2 = initDim(12);
        this$static._isRep0Long = initDim(192);
        this$static._posSlotEncoder = [];
        this$static._posEncoders = initDim(114);
        this$static._posAlignEncoder = $BitTreeEncoder({}, 4);
        this$static._lenEncoder = $Encoder$LenPriceTableEncoder({});
        this$static._repMatchLenEncoder = $Encoder$LenPriceTableEncoder({});
        this$static._literalEncoder = {};
        this$static._matchDistances = [];
        this$static._posSlotPrices = [];
        this$static._distancesPrices = [];
        this$static._alignPrices = initDim(16);
        this$static.reps = initDim(4);
        this$static.repLens = initDim(4);
        this$static.processedInSize = [P0_longLit];
        this$static.processedOutSize = [P0_longLit];
        this$static.finished = [0];
        this$static.properties = initDim(5);
        this$static.tempPrices = initDim(128);
        this$static._longestMatchLength = 0;
        this$static._matchFinderType = 1;
        this$static._numDistancePairs = 0;
        this$static._numFastBytesPrev = -1;
        this$static.backRes = 0;
        for (i = 0; i < 4096; ++i) {
            this$static._optimum[i] = {};
        }
        for (i = 0; i < 4; ++i) {
            this$static._posSlotEncoder[i] = $BitTreeEncoder({}, 6);
        }
        return this$static;
    }
    
    function $FillAlignPrices(this$static) {
        for (var i = 0; i < 16; ++i) {
            this$static._alignPrices[i] = $ReverseGetPrice(this$static._posAlignEncoder, i);
        }
        this$static._alignPriceCount = 0;
    }
    
    function $FillDistancesPrices(this$static) {
        var baseVal, encoder, footerBits, i, lenToPosState, posSlot, st, st2;
        for (i = 4; i < 128; ++i) {
            posSlot = GetPosSlot(i);
            footerBits = (posSlot >> 1) - 1;
            baseVal = (2 | posSlot & 1) << footerBits;
            this$static.tempPrices[i] = ReverseGetPrice(this$static._posEncoders, baseVal - posSlot - 1, footerBits, i - baseVal);
        }
        for (lenToPosState = 0; lenToPosState < 4; ++lenToPosState) {
            encoder = this$static._posSlotEncoder[lenToPosState];
            st = lenToPosState << 6;
            for (posSlot = 0; posSlot < this$static._distTableSize; ++posSlot) {
                this$static._posSlotPrices[st + posSlot] = $GetPrice_1(encoder, posSlot);
            }
            for (posSlot = 14; posSlot < this$static._distTableSize; ++posSlot) {
                this$static._posSlotPrices[st + posSlot] += (posSlot >> 1) - 1 - 4 << 6;
            }
            st2 = lenToPosState * 128;
            for (i = 0; i < 4; ++i) {
                this$static._distancesPrices[st2 + i] = this$static._posSlotPrices[st + i];
            }
            for (; i < 128; ++i) {
                this$static._distancesPrices[st2 + i] = this$static._posSlotPrices[st + GetPosSlot(i)] + this$static.tempPrices[i];
            }
        }
        this$static._matchPriceCount = 0;
    }
    
    function $Flush(this$static, nowPos) {
        $ReleaseMFStream(this$static);
        $WriteEndMarker(this$static, nowPos & this$static._posStateMask);
        for (var i = 0; i < 5; ++i) {
            $ShiftLow(this$static._rangeEncoder);
        }
    }
    
    function $GetOptimum(this$static, position) {
        var cur, curAnd1Price, curAndLenCharPrice, curAndLenPrice, curBack, curPrice, currentByte, distance, i, len, lenEnd, lenMain, lenRes, lenTest, lenTest2, lenTestTemp, matchByte, matchPrice, newLen, nextIsChar, nextMatchPrice, nextOptimum, nextRepMatchPrice, normalMatchPrice, numAvailableBytes, numAvailableBytesFull, numDistancePairs, offs, offset, opt, optimum, pos, posPrev, posState, posStateNext, price_4, repIndex, repLen, repMatchPrice, repMaxIndex, shortRepPrice, startLen, state, state2, t, price, price_0, price_1, price_2, price_3;
        if (this$static._optimumEndIndex != this$static._optimumCurrentIndex) {
            lenRes = this$static._optimum[this$static._optimumCurrentIndex].PosPrev - this$static._optimumCurrentIndex;
            this$static.backRes = this$static._optimum[this$static._optimumCurrentIndex].BackPrev;
            this$static._optimumCurrentIndex = this$static._optimum[this$static._optimumCurrentIndex].PosPrev;
            return lenRes;
        }
        this$static._optimumCurrentIndex = this$static._optimumEndIndex = 0;
        if (this$static._longestMatchWasFound) {
            lenMain = this$static._longestMatchLength;
            this$static._longestMatchWasFound = 0;
        } else {
            lenMain = $ReadMatchDistances(this$static);
        }
        numDistancePairs = this$static._numDistancePairs;
        numAvailableBytes = $GetNumAvailableBytes(this$static._matchFinder) + 1;
        if (numAvailableBytes < 2) {
            this$static.backRes = -1;
            return 1;
        }
        if (numAvailableBytes > 273) {
            numAvailableBytes = 273;
        }
        repMaxIndex = 0;
        for (i = 0; i < 4; ++i) {
            this$static.reps[i] = this$static._repDistances[i];
            this$static.repLens[i] = $GetMatchLen(this$static._matchFinder, -1, this$static.reps[i], 273);
            if (this$static.repLens[i] > this$static.repLens[repMaxIndex]) {
                repMaxIndex = i;
            }
        }
        if (this$static.repLens[repMaxIndex] >= this$static._numFastBytes) {
            this$static.backRes = repMaxIndex;
            lenRes = this$static.repLens[repMaxIndex];
            $MovePos(this$static, lenRes - 1);
            return lenRes;
        }
        if (lenMain >= this$static._numFastBytes) {
            this$static.backRes = this$static._matchDistances[numDistancePairs - 1] + 4;
            $MovePos(this$static, lenMain - 1);
            return lenMain;
        }
        currentByte = $GetIndexByte(this$static._matchFinder, -1);
        matchByte = $GetIndexByte(this$static._matchFinder, -this$static._repDistances[0] - 1 - 1);
        if (lenMain < 2 && currentByte != matchByte && this$static.repLens[repMaxIndex] < 2) {
            this$static.backRes = -1;
            return 1;
        }
        this$static._optimum[0].State = this$static._state;
        posState = position & this$static._posStateMask;
        this$static._optimum[1].Price = ProbPrices[this$static._isMatch[(this$static._state << 4) + posState] >>> 2] + $GetPrice_0($GetSubCoder(this$static._literalEncoder, position, this$static._previousByte), this$static._state >= 7, matchByte, currentByte);
        $MakeAsChar(this$static._optimum[1]);
        matchPrice = ProbPrices[2048 - this$static._isMatch[(this$static._state << 4) + posState] >>> 2];
        repMatchPrice = matchPrice + ProbPrices[2048 - this$static._isRep[this$static._state] >>> 2];
        if (matchByte == currentByte) {
            shortRepPrice = repMatchPrice + $GetRepLen1Price(this$static, this$static._state, posState);
            if (shortRepPrice < this$static._optimum[1].Price) {
                this$static._optimum[1].Price = shortRepPrice;
                $MakeAsShortRep(this$static._optimum[1]);
            }
        }
        lenEnd = lenMain >= this$static.repLens[repMaxIndex]?lenMain:this$static.repLens[repMaxIndex];
        if (lenEnd < 2) {
            this$static.backRes = this$static._optimum[1].BackPrev;
            return 1;
        }
        this$static._optimum[1].PosPrev = 0;
        this$static._optimum[0].Backs0 = this$static.reps[0];
        this$static._optimum[0].Backs1 = this$static.reps[1];
        this$static._optimum[0].Backs2 = this$static.reps[2];
        this$static._optimum[0].Backs3 = this$static.reps[3];
        len = lenEnd;
        do {
            this$static._optimum[len--].Price = 268435455;
        } while (len >= 2);
        for (i = 0; i < 4; ++i) {
            repLen = this$static.repLens[i];
            if (repLen < 2) {
                continue;
            }
            price_4 = repMatchPrice + $GetPureRepPrice(this$static, i, this$static._state, posState);
            do {
                curAndLenPrice = price_4 + $GetPrice(this$static._repMatchLenEncoder, repLen - 2, posState);
                optimum = this$static._optimum[repLen];
                if (curAndLenPrice < optimum.Price) {
                    optimum.Price = curAndLenPrice;
                    optimum.PosPrev = 0;
                    optimum.BackPrev = i;
                    optimum.Prev1IsChar = 0;
                }
            } while (--repLen >= 2);
        }
        normalMatchPrice = matchPrice + ProbPrices[this$static._isRep[this$static._state] >>> 2];
        len = this$static.repLens[0] >= 2?this$static.repLens[0] + 1:2;
        if (len <= lenMain) {
            offs = 0;
            while (len > this$static._matchDistances[offs]) {
                offs += 2;
            }
            for (;; ++len) {
                distance = this$static._matchDistances[offs + 1];
                curAndLenPrice = normalMatchPrice + $GetPosLenPrice(this$static, distance, len, posState);
                optimum = this$static._optimum[len];
                if (curAndLenPrice < optimum.Price) {
                    optimum.Price = curAndLenPrice;
                    optimum.PosPrev = 0;
                    optimum.BackPrev = distance + 4;
                    optimum.Prev1IsChar = 0;
                }
                if (len == this$static._matchDistances[offs]) {
                    offs += 2;
                    if (offs == numDistancePairs) {
                        break;
                    }
                }
            }
        }
        cur = 0;
        while (1) {
            ++cur;
            if (cur == lenEnd) {
                return $Backward(this$static, cur);
            }
            newLen = $ReadMatchDistances(this$static);
            numDistancePairs = this$static._numDistancePairs;
            if (newLen >= this$static._numFastBytes) {
                this$static._longestMatchLength = newLen;
                this$static._longestMatchWasFound = 1;
                return $Backward(this$static, cur);
            }
            ++position;
            posPrev = this$static._optimum[cur].PosPrev;
            if (this$static._optimum[cur].Prev1IsChar) {
                --posPrev;
                if (this$static._optimum[cur].Prev2) {
                    state = this$static._optimum[this$static._optimum[cur].PosPrev2].State;
                    if (this$static._optimum[cur].BackPrev2 < 4) {
                        state = (state < 7) ? 8 : 11;
                    } else {
                        state = (state < 7) ? 7 : 10;
                    }
                } else {
                    state = this$static._optimum[posPrev].State;
                }
                state = StateUpdateChar(state);
            } else {
                state = this$static._optimum[posPrev].State;
            }
            if (posPrev == cur - 1) {
                if (!this$static._optimum[cur].BackPrev) {
                    state = state < 7?9:11;
                } else {
                    state = StateUpdateChar(state);
                }
            } else {
                if (this$static._optimum[cur].Prev1IsChar && this$static._optimum[cur].Prev2) {
                    posPrev = this$static._optimum[cur].PosPrev2;
                    pos = this$static._optimum[cur].BackPrev2;
                    state = state < 7?8:11;
                } else {
                    pos = this$static._optimum[cur].BackPrev;
                    if (pos < 4) {
                        state = state < 7?8:11;
                    } else {
                        state = state < 7?7:10;
                    }
                }
                opt = this$static._optimum[posPrev];
                if (pos < 4) {
                    if (!pos) {
                        this$static.reps[0] = opt.Backs0;
                        this$static.reps[1] = opt.Backs1;
                        this$static.reps[2] = opt.Backs2;
                        this$static.reps[3] = opt.Backs3;
                    } else if (pos == 1) {
                        this$static.reps[0] = opt.Backs1;
                        this$static.reps[1] = opt.Backs0;
                        this$static.reps[2] = opt.Backs2;
                        this$static.reps[3] = opt.Backs3;
                    } else if (pos == 2) {
                        this$static.reps[0] = opt.Backs2;
                        this$static.reps[1] = opt.Backs0;
                        this$static.reps[2] = opt.Backs1;
                        this$static.reps[3] = opt.Backs3;
                    } else {
                        this$static.reps[0] = opt.Backs3;
                        this$static.reps[1] = opt.Backs0;
                        this$static.reps[2] = opt.Backs1;
                        this$static.reps[3] = opt.Backs2;
                    }
                } else {
                    this$static.reps[0] = pos - 4;
                    this$static.reps[1] = opt.Backs0;
                    this$static.reps[2] = opt.Backs1;
                    this$static.reps[3] = opt.Backs2;
                }
            }
            this$static._optimum[cur].State = state;
            this$static._optimum[cur].Backs0 = this$static.reps[0];
            this$static._optimum[cur].Backs1 = this$static.reps[1];
            this$static._optimum[cur].Backs2 = this$static.reps[2];
            this$static._optimum[cur].Backs3 = this$static.reps[3];
            curPrice = this$static._optimum[cur].Price;
            currentByte = $GetIndexByte(this$static._matchFinder, -1);
            matchByte = $GetIndexByte(this$static._matchFinder, -this$static.reps[0] - 1 - 1);
            posState = position & this$static._posStateMask;
            curAnd1Price = curPrice + ProbPrices[this$static._isMatch[(state << 4) + posState] >>> 2] + $GetPrice_0($GetSubCoder(this$static._literalEncoder, position, $GetIndexByte(this$static._matchFinder, -2)), state >= 7, matchByte, currentByte);
            nextOptimum = this$static._optimum[cur + 1];
            nextIsChar = 0;
            if (curAnd1Price < nextOptimum.Price) {
                nextOptimum.Price = curAnd1Price;
                nextOptimum.PosPrev = cur;
                nextOptimum.BackPrev = -1;
                nextOptimum.Prev1IsChar = 0;
                nextIsChar = 1;
            }
            matchPrice = curPrice + ProbPrices[2048 - this$static._isMatch[(state << 4) + posState] >>> 2];
            repMatchPrice = matchPrice + ProbPrices[2048 - this$static._isRep[state] >>> 2];
            if (matchByte == currentByte && !(nextOptimum.PosPrev < cur && !nextOptimum.BackPrev)) {
                shortRepPrice = repMatchPrice + (ProbPrices[this$static._isRepG0[state] >>> 2] + ProbPrices[this$static._isRep0Long[(state << 4) + posState] >>> 2]);
                if (shortRepPrice <= nextOptimum.Price) {
                    nextOptimum.Price = shortRepPrice;
                    nextOptimum.PosPrev = cur;
                    nextOptimum.BackPrev = 0;
                    nextOptimum.Prev1IsChar = 0;
                    nextIsChar = 1;
                }
            }
            numAvailableBytesFull = $GetNumAvailableBytes(this$static._matchFinder) + 1;
            numAvailableBytesFull = 4095 - cur < numAvailableBytesFull?4095 - cur:numAvailableBytesFull;
            numAvailableBytes = numAvailableBytesFull;
            if (numAvailableBytes < 2) {
                continue;
            }
            if (numAvailableBytes > this$static._numFastBytes) {
                numAvailableBytes = this$static._numFastBytes;
            }
            if (!nextIsChar && matchByte != currentByte) {
                t = Math.min(numAvailableBytesFull - 1, this$static._numFastBytes);
                lenTest2 = $GetMatchLen(this$static._matchFinder, 0, this$static.reps[0], t);
                if (lenTest2 >= 2) {
                    state2 = StateUpdateChar(state);
                    posStateNext = position + 1 & this$static._posStateMask;
                    nextRepMatchPrice = curAnd1Price + ProbPrices[2048 - this$static._isMatch[(state2 << 4) + posStateNext] >>> 2] + ProbPrices[2048 - this$static._isRep[state2] >>> 2];
                    offset = cur + 1 + lenTest2;
                    while (lenEnd < offset) {
                        this$static._optimum[++lenEnd].Price = 268435455;
                    }
                    curAndLenPrice = nextRepMatchPrice + (price = $GetPrice(this$static._repMatchLenEncoder, lenTest2 - 2, posStateNext) , price + $GetPureRepPrice(this$static, 0, state2, posStateNext));
                    optimum = this$static._optimum[offset];
                    if (curAndLenPrice < optimum.Price) {
                        optimum.Price = curAndLenPrice;
                        optimum.PosPrev = cur + 1;
                        optimum.BackPrev = 0;
                        optimum.Prev1IsChar = 1;
                        optimum.Prev2 = 0;
                    }
                }
            }
            startLen = 2;
            for (repIndex = 0; repIndex < 4; ++repIndex) {
                lenTest = $GetMatchLen(this$static._matchFinder, -1, this$static.reps[repIndex], numAvailableBytes);
                if (lenTest < 2) {
                    continue;
                }
                lenTestTemp = lenTest;
                do {
                    while (lenEnd < cur + lenTest) {
                        this$static._optimum[++lenEnd].Price = 268435455;
                    }
                    curAndLenPrice = repMatchPrice + (price_0 = $GetPrice(this$static._repMatchLenEncoder, lenTest - 2, posState) , price_0 + $GetPureRepPrice(this$static, repIndex, state, posState));
                    optimum = this$static._optimum[cur + lenTest];
                    if (curAndLenPrice < optimum.Price) {
                        optimum.Price = curAndLenPrice;
                        optimum.PosPrev = cur;
                        optimum.BackPrev = repIndex;
                        optimum.Prev1IsChar = 0;
                    }
                } while (--lenTest >= 2);
                lenTest = lenTestTemp;
                if (!repIndex) {
                    startLen = lenTest + 1;
                }
                if (lenTest < numAvailableBytesFull) {
                    t = Math.min(numAvailableBytesFull - 1 - lenTest, this$static._numFastBytes);
                    lenTest2 = $GetMatchLen(this$static._matchFinder, lenTest, this$static.reps[repIndex], t);
                    if (lenTest2 >= 2) {
                        state2 = state < 7?8:11;
                        posStateNext = position + lenTest & this$static._posStateMask;
                        curAndLenCharPrice = repMatchPrice + (price_1 = $GetPrice(this$static._repMatchLenEncoder, lenTest - 2, posState) , price_1 + $GetPureRepPrice(this$static, repIndex, state, posState)) + ProbPrices[this$static._isMatch[(state2 << 4) + posStateNext] >>> 2] + $GetPrice_0($GetSubCoder(this$static._literalEncoder, position + lenTest, $GetIndexByte(this$static._matchFinder, lenTest - 1 - 1)), 1, $GetIndexByte(this$static._matchFinder, lenTest - 1 - (this$static.reps[repIndex] + 1)), $GetIndexByte(this$static._matchFinder, lenTest - 1));
                        state2 = StateUpdateChar(state2);
                        posStateNext = position + lenTest + 1 & this$static._posStateMask;
                        nextMatchPrice = curAndLenCharPrice + ProbPrices[2048 - this$static._isMatch[(state2 << 4) + posStateNext] >>> 2];
                        nextRepMatchPrice = nextMatchPrice + ProbPrices[2048 - this$static._isRep[state2] >>> 2];
                        offset = lenTest + 1 + lenTest2;
                        while (lenEnd < cur + offset) {
                            this$static._optimum[++lenEnd].Price = 268435455;
                        }
                        curAndLenPrice = nextRepMatchPrice + (price_2 = $GetPrice(this$static._repMatchLenEncoder, lenTest2 - 2, posStateNext) , price_2 + $GetPureRepPrice(this$static, 0, state2, posStateNext));
                        optimum = this$static._optimum[cur + offset];
                        if (curAndLenPrice < optimum.Price) {
                            optimum.Price = curAndLenPrice;
                            optimum.PosPrev = cur + lenTest + 1;
                            optimum.BackPrev = 0;
                            optimum.Prev1IsChar = 1;
                            optimum.Prev2 = 1;
                            optimum.PosPrev2 = cur;
                            optimum.BackPrev2 = repIndex;
                        }
                    }
                }
            }
            if (newLen > numAvailableBytes) {
                newLen = numAvailableBytes;
                for (numDistancePairs = 0; newLen > this$static._matchDistances[numDistancePairs]; numDistancePairs += 2) {}
                this$static._matchDistances[numDistancePairs] = newLen;
                numDistancePairs += 2;
            }
            if (newLen >= startLen) {
            normalMatchPrice = matchPrice + ProbPrices[this$static._isRep[state] >>> 2];
            while (lenEnd < cur + newLen) {
                this$static._optimum[++lenEnd].Price = 268435455;
            }
            offs = 0;
            while (startLen > this$static._matchDistances[offs]) {
                offs += 2;
            }
            for (lenTest = startLen;; ++lenTest) {
                curBack = this$static._matchDistances[offs + 1];
                curAndLenPrice = normalMatchPrice + $GetPosLenPrice(this$static, curBack, lenTest, posState);
                optimum = this$static._optimum[cur + lenTest];
                if (curAndLenPrice < optimum.Price) {
                    optimum.Price = curAndLenPrice;
                    optimum.PosPrev = cur;
                    optimum.BackPrev = curBack + 4;
                    optimum.Prev1IsChar = 0;
                }
                if (lenTest == this$static._matchDistances[offs]) {
                    if (lenTest < numAvailableBytesFull) {
                        t = Math.min(numAvailableBytesFull - 1 - lenTest, this$static._numFastBytes);
                        lenTest2 = $GetMatchLen(this$static._matchFinder, lenTest, curBack, t);
                        if (lenTest2 >= 2) {
                            state2 = state < 7?7:10;
                            posStateNext = position + lenTest & this$static._posStateMask;
                            curAndLenCharPrice = curAndLenPrice + ProbPrices[this$static._isMatch[(state2 << 4) + posStateNext] >>> 2] + $GetPrice_0($GetSubCoder(this$static._literalEncoder, position + lenTest, $GetIndexByte(this$static._matchFinder, lenTest - 1 - 1)), 1, $GetIndexByte(this$static._matchFinder, lenTest - (curBack + 1) - 1), $GetIndexByte(this$static._matchFinder, lenTest - 1));
                            state2 = StateUpdateChar(state2);
                            posStateNext = position + lenTest + 1 & this$static._posStateMask;
                            nextMatchPrice = curAndLenCharPrice + ProbPrices[2048 - this$static._isMatch[(state2 << 4) + posStateNext] >>> 2];
                            nextRepMatchPrice = nextMatchPrice + ProbPrices[2048 - this$static._isRep[state2] >>> 2];
                            offset = lenTest + 1 + lenTest2;
                            while (lenEnd < cur + offset) {
                                this$static._optimum[++lenEnd].Price = 268435455;
                            }
                            curAndLenPrice = nextRepMatchPrice + (price_3 = $GetPrice(this$static._repMatchLenEncoder, lenTest2 - 2, posStateNext) , price_3 + $GetPureRepPrice(this$static, 0, state2, posStateNext));
                            optimum = this$static._optimum[cur + offset];
                            if (curAndLenPrice < optimum.Price) {
                                optimum.Price = curAndLenPrice;
                                optimum.PosPrev = cur + lenTest + 1;
                                optimum.BackPrev = 0;
                                optimum.Prev1IsChar = 1;
                                optimum.Prev2 = 1;
                                optimum.PosPrev2 = cur;
                                optimum.BackPrev2 = curBack + 4;
                            }
                        }
                    }
                    offs += 2;
                    if (offs == numDistancePairs)
                        break;
                    }
                }
            }
        }
    }
    
    function $GetPosLenPrice(this$static, pos, len, posState) {
        var price, lenToPosState = GetLenToPosState(len);
        if (pos < 128) {
            price = this$static._distancesPrices[lenToPosState * 128 + pos];
        } else {
            price = this$static._posSlotPrices[(lenToPosState << 6) + GetPosSlot2(pos)] + this$static._alignPrices[pos & 15];
        }
        return price + $GetPrice(this$static._lenEncoder, len - 2, posState);
    }
    
    function $GetPureRepPrice(this$static, repIndex, state, posState) {
        var price;
        if (!repIndex) {
            price = ProbPrices[this$static._isRepG0[state] >>> 2];
            price += ProbPrices[2048 - this$static._isRep0Long[(state << 4) + posState] >>> 2];
        } else {
            price = ProbPrices[2048 - this$static._isRepG0[state] >>> 2];
            if (repIndex == 1) {
                price += ProbPrices[this$static._isRepG1[state] >>> 2];
            } else {
                price += ProbPrices[2048 - this$static._isRepG1[state] >>> 2];
                price += GetPrice(this$static._isRepG2[state], repIndex - 2);
            }
        }
        return price;
    }
    
    function $GetRepLen1Price(this$static, state, posState) {
        return ProbPrices[this$static._isRepG0[state] >>> 2] + ProbPrices[this$static._isRep0Long[(state << 4) + posState] >>> 2];
    }
    
    function $Init_4(this$static) {
        $BaseInit(this$static);
        $Init_9(this$static._rangeEncoder);
        InitBitModels(this$static._isMatch);
        InitBitModels(this$static._isRep0Long);
        InitBitModels(this$static._isRep);
        InitBitModels(this$static._isRepG0);
        InitBitModels(this$static._isRepG1);
        InitBitModels(this$static._isRepG2);
        InitBitModels(this$static._posEncoders);
        $Init_3(this$static._literalEncoder);
        for (var i = 0; i < 4; ++i) {
            InitBitModels(this$static._posSlotEncoder[i].Models);
        }
        $Init_2(this$static._lenEncoder, 1 << this$static._posStateBits);
        $Init_2(this$static._repMatchLenEncoder, 1 << this$static._posStateBits);
        InitBitModels(this$static._posAlignEncoder.Models);
        this$static._longestMatchWasFound = 0;
        this$static._optimumEndIndex = 0;
        this$static._optimumCurrentIndex = 0;
        this$static._additionalOffset = 0;
    }
    
    function $MovePos(this$static, num) {
        if (num > 0) {
            $Skip(this$static._matchFinder, num);
            this$static._additionalOffset += num;
        }
    }
    
    function $ReadMatchDistances(this$static) {
        var lenRes = 0;
        this$static._numDistancePairs = $GetMatches(this$static._matchFinder, this$static._matchDistances);
        if (this$static._numDistancePairs > 0) {
            lenRes = this$static._matchDistances[this$static._numDistancePairs - 2];
            if (lenRes == this$static._numFastBytes)
            lenRes += $GetMatchLen(this$static._matchFinder, lenRes - 1, this$static._matchDistances[this$static._numDistancePairs - 1], 273 - lenRes);
        }
        ++this$static._additionalOffset;
        return lenRes;
    }
    
    function $ReleaseMFStream(this$static) {
        if (this$static._matchFinder && this$static._needReleaseMFStream) {
            this$static._matchFinder._stream = null;
            this$static._needReleaseMFStream = 0;
        }
    }
    
    function $ReleaseStreams(this$static) {
        $ReleaseMFStream(this$static);
        this$static._rangeEncoder.Stream = null;
    }
    
    function $SetDictionarySize_0(this$static, dictionarySize) {
        this$static._dictionarySize = dictionarySize;
        for (var dicLogSize = 0; dictionarySize > 1 << dicLogSize; ++dicLogSize) {}
        this$static._distTableSize = dicLogSize * 2;
    }
    
    function $SetMatchFinder(this$static, matchFinderIndex) {
        var matchFinderIndexPrev = this$static._matchFinderType;
        this$static._matchFinderType = matchFinderIndex;
        if (this$static._matchFinder && matchFinderIndexPrev != this$static._matchFinderType) {
            this$static._dictionarySizePrev = -1;
            this$static._matchFinder = null;
        }
    }
    
    function $WriteCoderProperties(this$static, outStream) {
        this$static.properties[0] = (this$static._posStateBits * 5 + this$static._numLiteralPosStateBits) * 9 + this$static._numLiteralContextBits << 24 >> 24;
        for (var i = 0; i < 4; ++i) {
            this$static.properties[1 + i] = this$static._dictionarySize >> 8 * i << 24 >> 24;
        }
        $write_0(outStream, this$static.properties, 0, 5);
    }
    
    function $WriteEndMarker(this$static, posState) {
        if (!this$static._writeEndMark) {
            return;
        }
        $Encode_3(this$static._rangeEncoder, this$static._isMatch, (this$static._state << 4) + posState, 1);
        $Encode_3(this$static._rangeEncoder, this$static._isRep, this$static._state, 0);
        this$static._state = this$static._state < 7?7:10;
        $Encode_0(this$static._lenEncoder, this$static._rangeEncoder, 0, posState);
        var lenToPosState = GetLenToPosState(2);
        $Encode_2(this$static._posSlotEncoder[lenToPosState], this$static._rangeEncoder, 63);
        $EncodeDirectBits(this$static._rangeEncoder, 67108863, 26);
        $ReverseEncode(this$static._posAlignEncoder, this$static._rangeEncoder, 15);
    }
    
    function GetPosSlot(pos) {
        if (pos < 2048) {
            return g_FastPos[pos];
        }
        if (pos < 2097152) {
            return g_FastPos[pos >> 10] + 20;
        }
        return g_FastPos[pos >> 20] + 40;
    }
    
    function GetPosSlot2(pos) {
        if (pos < 131072) {
            return g_FastPos[pos >> 6] + 12;
        }
        if (pos < 134217728) {
            return g_FastPos[pos >> 16] + 32;
        }
        return g_FastPos[pos >> 26] + 52;
    }
    
    function $Encode(this$static, rangeEncoder, symbol, posState) {
        if (symbol < 8) {
            $Encode_3(rangeEncoder, this$static._choice, 0, 0);
            $Encode_2(this$static._lowCoder[posState], rangeEncoder, symbol);
        } else {
            symbol -= 8;
            $Encode_3(rangeEncoder, this$static._choice, 0, 1);
            if (symbol < 8) {
                $Encode_3(rangeEncoder, this$static._choice, 1, 0);
                $Encode_2(this$static._midCoder[posState], rangeEncoder, symbol);
            } else {
                $Encode_3(rangeEncoder, this$static._choice, 1, 1);
                $Encode_2(this$static._highCoder, rangeEncoder, symbol - 8);
            }
        }
    }
    
    function $Encoder$LenEncoder(this$static) {
        this$static._choice = initDim(2);
        this$static._lowCoder = initDim(16);
        this$static._midCoder = initDim(16);
        this$static._highCoder = $BitTreeEncoder({}, 8);
        for (var posState = 0; posState < 16; ++posState) {
            this$static._lowCoder[posState] = $BitTreeEncoder({}, 3);
            this$static._midCoder[posState] = $BitTreeEncoder({}, 3);
        }
        return this$static;
    }
    
    function $Init_2(this$static, numPosStates) {
        InitBitModels(this$static._choice);
        for (var posState = 0; posState < numPosStates; ++posState) {
            InitBitModels(this$static._lowCoder[posState].Models);
            InitBitModels(this$static._midCoder[posState].Models);
        }
        InitBitModels(this$static._highCoder.Models);
    }
    
    function $SetPrices(this$static, posState, numSymbols, prices, st) {
        var a0, a1, b0, b1, i;
        a0 = ProbPrices[this$static._choice[0] >>> 2];
        a1 = ProbPrices[2048 - this$static._choice[0] >>> 2];
        b0 = a1 + ProbPrices[this$static._choice[1] >>> 2];
        b1 = a1 + ProbPrices[2048 - this$static._choice[1] >>> 2];
        i = 0;
        for (i = 0; i < 8; ++i) {
            if (i >= numSymbols)
            return;
            prices[st + i] = a0 + $GetPrice_1(this$static._lowCoder[posState], i);
        }
        for (; i < 16; ++i) {
            if (i >= numSymbols)
            return;
            prices[st + i] = b0 + $GetPrice_1(this$static._midCoder[posState], i - 8);
        }
        for (; i < numSymbols; ++i) {
            prices[st + i] = b1 + $GetPrice_1(this$static._highCoder, i - 8 - 8);
        }
    }
    
    function $Encode_0(this$static, rangeEncoder, symbol, posState) {
        $Encode(this$static, rangeEncoder, symbol, posState);
        if (--this$static._counters[posState] == 0) {
            $SetPrices(this$static, posState, this$static._tableSize, this$static._prices, posState * 272);
            this$static._counters[posState] = this$static._tableSize;
        }
    }
    
    function $Encoder$LenPriceTableEncoder(this$static) {
        $Encoder$LenEncoder(this$static);
        this$static._prices = [];
        this$static._counters = [];
        return this$static;
    }
    
    function $GetPrice(this$static, symbol, posState) {
        return this$static._prices[posState * 272 + symbol];
    }
    
    function $UpdateTables(this$static, numPosStates) {
        for (var posState = 0; posState < numPosStates; ++posState) {
            $SetPrices(this$static, posState, this$static._tableSize, this$static._prices, posState * 272);
            this$static._counters[posState] = this$static._tableSize;
        }
    }
    
    function $Create_1(this$static, numPosBits, numPrevBits) {
        var i, numStates;
        if (this$static.m_Coders != null && this$static.m_NumPrevBits == numPrevBits && this$static.m_NumPosBits == numPosBits) {
            return;
        }
        this$static.m_NumPosBits = numPosBits;
        this$static.m_PosMask = (1 << numPosBits) - 1;
        this$static.m_NumPrevBits = numPrevBits;
        numStates = 1 << this$static.m_NumPrevBits + this$static.m_NumPosBits;
        this$static.m_Coders = initDim(numStates);
        for (i = 0; i < numStates; ++i) {
            this$static.m_Coders[i] = $Encoder$LiteralEncoder$Encoder2({});
        }
    }
    
    function $GetSubCoder(this$static, pos, prevByte) {
        return this$static.m_Coders[((pos & this$static.m_PosMask) << this$static.m_NumPrevBits) + ((prevByte & 255) >>> 8 - this$static.m_NumPrevBits)];
    }
    
    function $Init_3(this$static) {
        var i, numStates = 1 << this$static.m_NumPrevBits + this$static.m_NumPosBits;
        for (i = 0; i < numStates; ++i) {
            InitBitModels(this$static.m_Coders[i].m_Encoders);
        }
    }
    
    function $Encode_1(this$static, rangeEncoder, symbol) {
        var bit, i, context = 1;
        for (i = 7; i >= 0; --i) {
            bit = symbol >> i & 1;
            $Encode_3(rangeEncoder, this$static.m_Encoders, context, bit);
            context = context << 1 | bit;
        }
    }
    
    function $EncodeMatched(this$static, rangeEncoder, matchByte, symbol) {
        var bit, i, matchBit, state, same = 1, context = 1;
        for (i = 7; i >= 0; --i) {
            bit = symbol >> i & 1;
            state = context;
            if (same) {
                matchBit = matchByte >> i & 1;
                state += 1 + matchBit << 8;
                same = matchBit == bit;
            }
            $Encode_3(rangeEncoder, this$static.m_Encoders, state, bit);
            context = context << 1 | bit;
        }
    }
    
    function $Encoder$LiteralEncoder$Encoder2(this$static) {
        this$static.m_Encoders = initDim(768);
        return this$static;
    }
    
    function $GetPrice_0(this$static, matchMode, matchByte, symbol) {
        var bit, context = 1, i = 7, matchBit, price = 0;
        if (matchMode) {
            for (; i >= 0; --i) {
                matchBit = matchByte >> i & 1;
                bit = symbol >> i & 1;
                price += GetPrice(this$static.m_Encoders[(1 + matchBit << 8) + context], bit);
                context = context << 1 | bit;
                if (matchBit != bit) {
                    --i;
                    break;
                }
            }
        }
        for (; i >= 0; --i) {
            bit = symbol >> i & 1;
            price += GetPrice(this$static.m_Encoders[context], bit);
            context = context << 1 | bit;
        }
        return price;
    }
    
    function $MakeAsChar(this$static) {
        this$static.BackPrev = -1;
        this$static.Prev1IsChar = 0;
    }
    
    function $MakeAsShortRep(this$static) {
        this$static.BackPrev = 0;
        this$static.Prev1IsChar = 0;
    }
    /** ce */
    /** ds */
    function $BitTreeDecoder(this$static, numBitLevels) {
        this$static.NumBitLevels = numBitLevels;
        this$static.Models = initDim(1 << numBitLevels);
        return this$static;
    }
    
    function $Decode_0(this$static, rangeDecoder) {
        var bitIndex, m = 1;
        for (bitIndex = this$static.NumBitLevels; bitIndex != 0; --bitIndex) {
            m = (m << 1) + $DecodeBit(rangeDecoder, this$static.Models, m);
        }
        return m - (1 << this$static.NumBitLevels);
    }
    
    function $ReverseDecode(this$static, rangeDecoder) {
        var bit, bitIndex, m = 1, symbol = 0;
        for (bitIndex = 0; bitIndex < this$static.NumBitLevels; ++bitIndex) {
            bit = $DecodeBit(rangeDecoder, this$static.Models, m);
            m <<= 1;
            m += bit;
            symbol |= bit << bitIndex;
        }
        return symbol;
    }
    
    function ReverseDecode(Models, startIndex, rangeDecoder, NumBitLevels) {
        var bit, bitIndex, m = 1, symbol = 0;
        for (bitIndex = 0; bitIndex < NumBitLevels; ++bitIndex) {
            bit = $DecodeBit(rangeDecoder, Models, startIndex + m);
            m <<= 1;
            m += bit;
            symbol |= bit << bitIndex;
        }
        return symbol;
    }
    /** de */
    /** cs */
    function $BitTreeEncoder(this$static, numBitLevels) {
        this$static.NumBitLevels = numBitLevels;
        this$static.Models = initDim(1 << numBitLevels);
        return this$static;
    }
    
    function $Encode_2(this$static, rangeEncoder, symbol) {
        var bit, bitIndex, m = 1;
        for (bitIndex = this$static.NumBitLevels; bitIndex != 0;) {
            --bitIndex;
            bit = symbol >>> bitIndex & 1;
            $Encode_3(rangeEncoder, this$static.Models, m, bit);
            m = m << 1 | bit;
        }
    }
    
    function $GetPrice_1(this$static, symbol) {
        var bit, bitIndex, m = 1, price = 0;
        for (bitIndex = this$static.NumBitLevels; bitIndex != 0;) {
            --bitIndex;
            bit = symbol >>> bitIndex & 1;
            price += GetPrice(this$static.Models[m], bit);
            m = (m << 1) + bit;
        }
        return price;
    }
    
    function $ReverseEncode(this$static, rangeEncoder, symbol) {
        var bit, i, m = 1;
        for (i = 0; i < this$static.NumBitLevels; ++i) {
            bit = symbol & 1;
            $Encode_3(rangeEncoder, this$static.Models, m, bit);
            m = m << 1 | bit;
            symbol >>= 1;
        }
    }
    
    function $ReverseGetPrice(this$static, symbol) {
        var bit, i, m = 1, price = 0;
        for (i = this$static.NumBitLevels; i != 0; --i) {
            bit = symbol & 1;
            symbol >>>= 1;
            price += GetPrice(this$static.Models[m], bit);
            m = m << 1 | bit;
        }
        return price;
    }
    
    function ReverseEncode(Models, startIndex, rangeEncoder, NumBitLevels, symbol) {
        var bit, i, m = 1;
        for (i = 0; i < NumBitLevels; ++i) {
            bit = symbol & 1;
            $Encode_3(rangeEncoder, Models, startIndex + m, bit);
            m = m << 1 | bit;
            symbol >>= 1;
        }
    }
    
    function ReverseGetPrice(Models, startIndex, NumBitLevels, symbol) {
        var bit, i, m = 1, price = 0;
        for (i = NumBitLevels; i != 0; --i) {
            bit = symbol & 1;
            symbol >>>= 1;
            price += ProbPrices[((Models[startIndex + m] - bit ^ -bit) & 2047) >>> 2];
            m = m << 1 | bit;
        }
        return price;
    }
    /** ce */
    /** ds */
    function $DecodeBit(this$static, probs, index) {
        var newBound, prob = probs[index];
        newBound = (this$static.Range >>> 11) * prob;
        if ((this$static.Code ^ -2147483648) < (newBound ^ -2147483648)) {
            this$static.Range = newBound;
            probs[index] = prob + (2048 - prob >>> 5) << 16 >> 16;
            if (!(this$static.Range & -16777216)) {
                this$static.Code = this$static.Code << 8 | $read(this$static.Stream);
                this$static.Range <<= 8;
            }
            return 0;
        } else {
            this$static.Range -= newBound;
            this$static.Code -= newBound;
            probs[index] = prob - (prob >>> 5) << 16 >> 16;
            if (!(this$static.Range & -16777216)) {
                this$static.Code = this$static.Code << 8 | $read(this$static.Stream);
                this$static.Range <<= 8;
            }
            return 1;
        }
    }
    
    function $DecodeDirectBits(this$static, numTotalBits) {
        var i, t, result = 0;
        for (i = numTotalBits; i != 0; --i) {
            this$static.Range >>>= 1;
            t = this$static.Code - this$static.Range >>> 31;
            this$static.Code -= this$static.Range & t - 1;
            result = result << 1 | 1 - t;
            if (!(this$static.Range & -16777216)) {
                this$static.Code = this$static.Code << 8 | $read(this$static.Stream);
                this$static.Range <<= 8;
            }
        }
        return result;
    }
    
    function $Init_8(this$static) {
        this$static.Code = 0;
        this$static.Range = -1;
        for (var i = 0; i < 5; ++i) {
            this$static.Code = this$static.Code << 8 | $read(this$static.Stream);
        }
    }
    /** de */
    
    function InitBitModels(probs) {
        for (var i = probs.length - 1; i >= 0; --i) {
            probs[i] = 1024;
        }
    }
    /** cs */
    var ProbPrices = (function () {
        var end, i, j, start, ProbPrices = [];
        for (i = 8; i >= 0; --i) {
            start = 1 << 9 - i - 1;
            end = 1 << 9 - i;
            for (j = start; j < end; ++j) {
                ProbPrices[j] = (i << 6) + (end - j << 6 >>> 9 - i - 1);
            }
        }
        return ProbPrices;
    }());
    
    function $Encode_3(this$static, probs, index, symbol) {
        var newBound, prob = probs[index];
        newBound = (this$static.Range >>> 11) * prob;
        if (!symbol) {
            this$static.Range = newBound;
            probs[index] = prob + (2048 - prob >>> 5) << 16 >> 16;
        } else {
            this$static.Low = add(this$static.Low, and(fromInt(newBound), [4294967295, 0]));
            this$static.Range -= newBound;
            probs[index] = prob - (prob >>> 5) << 16 >> 16;
        }
        if (!(this$static.Range & -16777216)) {
            this$static.Range <<= 8;
            $ShiftLow(this$static);
        }
    }
    
    function $EncodeDirectBits(this$static, v, numTotalBits) {
        for (var i = numTotalBits - 1; i >= 0; --i) {
            this$static.Range >>>= 1;
            if ((v >>> i & 1) == 1) {
                this$static.Low = add(this$static.Low, fromInt(this$static.Range));
            }
            if (!(this$static.Range & -16777216)) {
                this$static.Range <<= 8;
                $ShiftLow(this$static);
            }
        }
    }
    
    function $GetProcessedSizeAdd(this$static) {
        return add(add(fromInt(this$static._cacheSize), this$static._position), [4, 0]);
    }
    
    function $Init_9(this$static) {
        this$static._position = P0_longLit;
        this$static.Low = P0_longLit;
        this$static.Range = -1;
        this$static._cacheSize = 1;
        this$static._cache = 0;
    }
    
    function $ShiftLow(this$static) {
        var temp, LowHi = lowBits_0(shru(this$static.Low, 32));
        if (LowHi != 0 || compare(this$static.Low, [4278190080, 0]) < 0) {
            this$static._position = add(this$static._position, fromInt(this$static._cacheSize));
            temp = this$static._cache;
            do {
                $write(this$static.Stream, temp + LowHi);
                temp = 255;
            } while (--this$static._cacheSize != 0);
            this$static._cache = lowBits_0(this$static.Low) >>> 24;
        }
        ++this$static._cacheSize;
        this$static.Low = shl(and(this$static.Low, [16777215, 0]), 8);
    }
    
    function GetPrice(Prob, symbol) {
        return ProbPrices[((Prob - symbol ^ -symbol) & 2047) >>> 2];
    }
    
    /** ce */
    /** ds */
    function decode(utf) {
        var i = 0, j = 0, x, y, z, l = utf.length, buf = [], charCodes = [];
        for (; i < l; ++i, ++j) {
            x = utf[i] & 255;
            if (!(x & 128)) {
                if (!x) {
                    /// It appears that this is binary data, so it cannot be converted to a string, so just send it back.
                    return utf;
                }
                charCodes[j] = x;
            } else if ((x & 224) == 192) {
                if (i + 1 >= l) {
                    /// It appears that this is binary data, so it cannot be converted to a string, so just send it back.
                    return utf;
                }
                y = utf[++i] & 255;
                if ((y & 192) != 128) {
                    /// It appears that this is binary data, so it cannot be converted to a string, so just send it back.
                    return utf;
                }
                charCodes[j] = ((x & 31) << 6) | (y & 63);
            } else if ((x & 240) == 224) {
                if (i + 2 >= l) {
                    /// It appears that this is binary data, so it cannot be converted to a string, so just send it back.
                    return utf;
                }
                y = utf[++i] & 255;
                if ((y & 192) != 128) {
                    /// It appears that this is binary data, so it cannot be converted to a string, so just send it back.
                    return utf;
                }
                z = utf[++i] & 255;
                if ((z & 192) != 128) {
                    /// It appears that this is binary data, so it cannot be converted to a string, so just send it back.
                    return utf;
                }
                charCodes[j] = ((x & 15) << 12) | ((y & 63) << 6) | (z & 63);
            } else {
                /// It appears that this is binary data, so it cannot be converted to a string, so just send it back.
                return utf;
            }
            if (j == 16383) {
                buf.push(String.fromCharCode.apply(String, charCodes));
                j = -1;
            }
        }
        if (j > 0) {
            charCodes.length = j;
            buf.push(String.fromCharCode.apply(String, charCodes));
        }
        return buf.join("");
    }
    /** de */
    /** cs */
    function encode(s) {
        var ch, chars = [], data, elen = 0, i, l = s.length;
        /// Be able to handle binary arrays and buffers.
        if (typeof s == "object") {
            return s;
        } else {
            $getChars(s, 0, l, chars, 0);
        }
        /// Add extra spaces in the array to break up the unicode symbols.
        for (i = 0; i < l; ++i) {
            ch = chars[i];
            if (ch >= 1 && ch <= 127) {
                ++elen;
            } else if (!ch || ch >= 128 && ch <= 2047) {
                elen += 2;
            } else {
                elen += 3;
            }
        }
        data = [];
        elen = 0;
        for (i = 0; i < l; ++i) {
            ch = chars[i];
            if (ch >= 1 && ch <= 127) {
                data[elen++] = ch << 24 >> 24;
            } else if (!ch || ch >= 128 && ch <= 2047) {
                data[elen++] = (192 | ch >> 6 & 31) << 24 >> 24;
                data[elen++] = (128 | ch & 63) << 24 >> 24;
            } else {
                data[elen++] = (224 | ch >> 12 & 15) << 24 >> 24;
                data[elen++] = (128 | ch >> 6 & 63) << 24 >> 24;
                data[elen++] = (128 | ch & 63) << 24 >> 24;
            }
        }
        return data;
    }
    /** ce */
    
    function toDouble(a) {
        return a[1] + a[0];
    }
    
    /** cs */
    function compress(str, mode, on_finish, on_progress) {
        var this$static = {},
            percent,
            cbn, /// A callback number should be supplied instead of on_finish() if we are using Web Workers.
            sync = typeof on_finish == "undefined" && typeof on_progress == "undefined";
        
        if (typeof on_finish != "function") {
            cbn = on_finish;
            on_finish = on_progress = 0;
        }
        
        on_progress = on_progress || function(percent) {
            if (typeof cbn == "undefined")
                return;
            
            return update_progress(percent, cbn);
        };
        
        on_finish = on_finish || function(res, err) {
            if (typeof cbn == "undefined")
                return;
            
            return postMessage({
                action: action_compress,
                cbn: cbn,
                result: res,
                error: err
            });
        };

        if (sync) {
            this$static.c = $LZMAByteArrayCompressor({}, encode(str), get_mode_obj(mode));
            while ($processChunk(this$static.c.chunker));
            return $toByteArray(this$static.c.output);
        }
        
        try {
            this$static.c = $LZMAByteArrayCompressor({}, encode(str), get_mode_obj(mode));
            
            on_progress(0);
        } catch (err) {
            return on_finish(null, err);
        }
        
        function do_action() {
            try {
                var res, start = (new Date()).getTime();
                
                while ($processChunk(this$static.c.chunker)) {
                    percent = toDouble(this$static.c.chunker.inBytesProcessed) / toDouble(this$static.c.length_0);
                    /// If about 200 miliseconds have passed, update the progress.
                    if ((new Date()).getTime() - start > 200) {
                        on_progress(percent);
                        
                        wait(do_action, 0);
                        return 0;
                    }
                }
                
                on_progress(1);
                
                res = $toByteArray(this$static.c.output);
                
                /// delay so we donâ€™t catch errors from the on_finish handler
                wait(on_finish.bind(null, res), 0);
            } catch (err) {
                on_finish(null, err);
            }
        }
        
        ///NOTE: We need to wait to make sure it is always async.
        wait(do_action, 0);
    }
    /** ce */
    /** ds */
    function decompress(byte_arr, on_finish, on_progress) {
        var this$static = {},
            percent,
            cbn, /// A callback number should be supplied instead of on_finish() if we are using Web Workers.
            has_progress,
            len,
            sync = typeof on_finish == "undefined" && typeof on_progress == "undefined";

        if (typeof on_finish != "function") {
            cbn = on_finish;
            on_finish = on_progress = 0;
        }
        
        on_progress = on_progress || function(percent) {
            if (typeof cbn == "undefined")
                return;
            
            return update_progress(has_progress ? percent : -1, cbn);
        };
        
        on_finish = on_finish || function(res, err) {
            if (typeof cbn == "undefined")
                return;
            
            return postMessage({
                action: action_decompress,
                cbn: cbn,
                result: res,
                error: err
            });
        };

        if (sync) {
            this$static.d = $LZMAByteArrayDecompressor({}, byte_arr);
            while ($processChunk(this$static.d.chunker));
            return decode($toByteArray(this$static.d.output));
        }
        
        try {
            this$static.d = $LZMAByteArrayDecompressor({}, byte_arr);
            
            len = toDouble(this$static.d.length_0);
            
            ///NOTE: If the data was created via a stream, it will not have a length value, and therefore we can't calculate the progress.
            has_progress = len > -1;
            
            on_progress(0);
        } catch (err) {
            return on_finish(null, err);
        }
        
        function do_action() {
            try {
                var res, i = 0, start = (new Date()).getTime();
                while ($processChunk(this$static.d.chunker)) {
                    if (++i % 1000 == 0 && (new Date()).getTime() - start > 200) {
                        if (has_progress) {
                            percent = toDouble(this$static.d.chunker.decoder.nowPos64) / len;
                            /// If about 200 miliseconds have passed, update the progress.
                            on_progress(percent);
                        }
                        
                        ///NOTE: This allows other code to run, like the browser to update.
                        wait(do_action, 0);
                        return 0;
                    }
                }
                
                on_progress(1);
                
                res = decode($toByteArray(this$static.d.output));
                
                /// delay so we donâ€™t catch errors from the on_finish handler
                wait(on_finish.bind(null, res), 0);
            } catch (err) {
                on_finish(null, err);
            }
        }
        
        ///NOTE: We need to wait to make sure it is always async.
        wait(do_action, 0);
    }
    /** de */
    /** cs */
    var get_mode_obj = (function () {
        /// s is dictionarySize
        /// f is fb
        /// m is matchFinder
        ///NOTE: Because some values are always the same, they have been removed.
        /// lc is always 3
        /// lp is always 0
        /// pb is always 2
        var modes = [
            {s: 16, f:  64, m: 0},
            {s: 20, f:  64, m: 0},
            {s: 19, f:  64, m: 1},
            {s: 20, f:  64, m: 1},
            {s: 21, f: 128, m: 1},
            {s: 22, f: 128, m: 1},
            {s: 23, f: 128, m: 1},
            {s: 24, f: 255, m: 1},
            {s: 25, f: 255, m: 1}
        ];
        
        return function (mode) {
            return modes[mode - 1] || modes[6];
        };
    }());
    /** ce */
    
    /// If we're in a Web Worker, create the onmessage() communication channel.
    ///NOTE: This seems to be the most reliable way to detect this.
    if (typeof onmessage != "undefined" && (typeof window == "undefined" || typeof window.document == "undefined")) {
        (function () {
            /* jshint -W020 */
            /// Create the global onmessage function.
            onmessage = function (e) {
                if (e && e.data) {
                    /** xs */
                    if (e.data.action == action_decompress) {
                        LZMA.decompress(e.data.data, e.data.cbn);
                    } else if (e.data.action == action_compress) {
                        LZMA.compress(e.data.data, e.data.mode, e.data.cbn);
                    }
                    /** xe */
                    /// co:if (e.data.action == action_compress) {
                    /// co:    LZMA.compress(e.data.data, e.data.mode, e.data.cbn);
                    /// co:}
                    /// do:if (e.data.action == action_decompress) {
                    /// do:    LZMA.decompress(e.data.data, e.data.cbn);
                    /// do:}
                }
            };
        }());
    }
        
    return {
        /** xs */
        compress:   compress,
        decompress: decompress,
        /** xe */
        /// co:compress:   compress
        /// do:decompress: decompress
    };
}());

/// This is used by browsers that do not support web workers (and possibly Node.js).
this.LZMA = this.LZMA_WORKER = LZMA;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(100).setImmediate))

/***/ }),
/* 579 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _regenerator = __webpack_require__(3);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _promise = __webpack_require__(4);

var _promise2 = _interopRequireDefault(_promise);

var _typeof2 = __webpack_require__(26);

var _typeof3 = _interopRequireDefault(_typeof2);

var _api = __webpack_require__(10);

var _api2 = _interopRequireDefault(_api);

var _bcxjsCores = __webpack_require__(7);

var _helper = __webpack_require__(34);

var _helper2 = _interopRequireDefault(_helper);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var initialState = {
    contract_cache: {}
};

var _lua_types = {
    0: "init",
    1: "number",
    2: "string",
    3: "boolean",
    4: "table",
    5: "function",
    6: "memo_data",
    7: "asset"
};

var toTable = function toTable(obj) {
    var result = [];
    for (var key in obj) {
        var keyObj = {},
            valueObj = {},
            v = obj[key];

        keyObj.dataType = typeof key === 'undefined' ? 'undefined' : (0, _typeof3.default)(key);
        keyObj.value = key;
        if (key % 1 === 0) keyObj.dataType = "int";

        valueObj.dataType = typeof v === 'undefined' ? 'undefined' : (0, _typeof3.default)(v);
        if (valueObj.dataType == "object") {
            valueObj.dataType = "table";
            valueObj.value = toTable(v);
        } else {
            valueObj.value = v;
        }

        if (v != "" && v % 1 === 0) valueObj.dataType = "int";

        result.push([{ key: keyObj }, valueObj]);
    }

    return result;
};

var formatValueList = function formatValueList(valueList) {
    var _valueList = [],
        valueItem = void 0,
        v = void 0,
        dataType = "";
    for (var i = 0; i < valueList.length; i++) {
        try {
            v = valueList[i];
            dataType = typeof v === 'undefined' ? 'undefined' : (0, _typeof3.default)(v);

            if (dataType == "number" && v % 1 === 0) {
                dataType = "int";
            }

            if (dataType == "object") {
                dataType = "table"; //JSON.stringify(v);
                v = toTable(v);
                // console.info("v",v);
            }

            valueItem = {
                value: v,
                dataType: dataType
            };

            _valueList.push(valueItem);
        } catch (e) {
            return { code: 0, message: e.message };
        }
    }

    return _valueList;
};

var formatTableWithStructs = function formatTableWithStructs(table) {
    var result = [];
    table.forEach(function (item) {
        var key = item[0].key[1].v;
        var key_type = _lua_types[item[0].key[0]];
        var value = item[1][1].v;
        var lua_type = item[1][0];
        // console.info("ChainTypes.lua_type",ChainTypes.lua_type);
        var obj = { key_type: key_type, key: key, value_type: _lua_types[lua_type] };
        switch (lua_type) {
            case 4:
                obj.value = formatTableWithStructs(value);
                //   result[key].value=formatTableWithStructs(value);
                break;
            case 0:
            case 1:
                obj.value = Number(value);
                break;
            default:
                obj.value = value;
        }
        result.push(obj);
    });
    return result;
};

var actions = {
    queryAccountContractData: function queryAccountContractData(_ref, params) {
        var dispatch = _ref.dispatch;

        _helper2.default.trimParams(params);

        var account = params.account,
            contractNameOrId = params.contractNameOrId,
            callback = params.callback;

        var p_getUserInfo = dispatch("user/getUserInfo", { account: account, isCache: true }, { root: true });
        var p_getContract = dispatch("getContract", { nameOrId: contractNameOrId, isCache: true });

        var res = void 0;
        return _promise2.default.all([p_getUserInfo, p_getContract]).then(function (results) {
            var paramsOk = results.every(function (item) {
                if (item.code != 1) {
                    res = item;
                }
                return item.code == 1;
            });
            if (paramsOk) {
                return dispatch("getAccountContractData", {
                    account: results[0].data.account.id,
                    contractNameOrId: results[1].data.id
                });
            } else {
                return res;
            }
        });
    },
    createContract: function createContract(_ref2, params) {
        var dispatch = _ref2.dispatch;

        if (!_helper2.default.trimParams(params, { authority: "" })) {
            return { code: 101, message: "Parameter is missing" };
        }
        var name = params.name,
            data = params.data,
            authority = params.authority,
            onlyGetFee = params.onlyGetFee;

        if (!/^contract\.([a-z0-9\.-]){5,54}/.test(name)) {
            return { code: 130, message: "Please enter the correct contract name(/^contract.[a-z]([a-z0-9\.-]){15,63}/)" };
        }
        return dispatch('transactions/_transactionOperations', {
            operations: [{
                type: "contract_create",
                params: {
                    name: name,
                    data: data,
                    authority: authority
                }
            }],
            onlyGetFee: onlyGetFee
        }, { root: true });
    },
    updateContract: function updateContract(_ref3, params) {
        var dispatch = _ref3.dispatch;
        var nameOrId, data, onlyGetFee, contract_res;
        return _regenerator2.default.async(function updateContract$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        if (_helper2.default.trimParams(params)) {
                            _context.next = 2;
                            break;
                        }

                        return _context.abrupt('return', { code: 101, message: "Parameter is missing" });

                    case 2:
                        nameOrId = params.nameOrId, data = params.data, onlyGetFee = params.onlyGetFee;
                        _context.next = 5;
                        return _regenerator2.default.awrap(dispatch("getContract", { nameOrId: nameOrId }));

                    case 5:
                        contract_res = _context.sent;

                        if (!(contract_res.code != 1)) {
                            _context.next = 8;
                            break;
                        }

                        return _context.abrupt('return', contract_res);

                    case 8:
                        return _context.abrupt('return', dispatch('transactions/_transactionOperations', {
                            operations: [{
                                type: "revise_contract",
                                params: {
                                    contract_id: contract_res.data.id,
                                    data: data
                                }
                            }],
                            onlyGetFee: onlyGetFee
                        }, { root: true }));

                    case 9:
                    case 'end':
                        return _context.stop();
                }
            }
        }, null, undefined);
    },
    getContract: function getContract(_ref4, _ref5) {
        var dispatch = _ref4.dispatch,
            state = _ref4.state;
        var _ref5$nameOrId = _ref5.nameOrId,
            nameOrId = _ref5$nameOrId === undefined ? "" : _ref5$nameOrId,
            _ref5$isCache = _ref5.isCache,
            isCache = _ref5$isCache === undefined ? false : _ref5$isCache;

        var res, _res$data, name, owner, contract_ABI, contract_data, check_contract_authority, creation_date, id, contract_authority, previous_version, lua_code, current_version, acc_res, abi_actions, data;

        return _regenerator2.default.async(function getContract$(_context2) {
            while (1) {
                switch (_context2.prev = _context2.next) {
                    case 0:
                        if (nameOrId) {
                            _context2.next = 2;
                            break;
                        }

                        return _context2.abrupt('return', { code: 0, message: 'Parameter "nameOrId" can not be empty' });

                    case 2:
                        nameOrId = nameOrId.trim();

                        _context2.next = 5;
                        return _regenerator2.default.awrap(_api2.default.Contract.getContract(nameOrId, isCache));

                    case 5:
                        res = _context2.sent;

                        if (!(res.code != 1)) {
                            _context2.next = 8;
                            break;
                        }

                        return _context2.abrupt('return', res);

                    case 8:
                        _res$data = res.data, name = _res$data.name, owner = _res$data.owner, contract_ABI = _res$data.contract_ABI, contract_data = _res$data.contract_data, check_contract_authority = _res$data.check_contract_authority, creation_date = _res$data.creation_date, id = _res$data.id, contract_authority = _res$data.contract_authority, previous_version = _res$data.previous_version, lua_code = _res$data.lua_code, current_version = _res$data.current_version;
                        _context2.next = 11;
                        return _regenerator2.default.awrap(dispatch("user/getUserInfo", { account: owner, isCache: true }, { root: true }));

                    case 11:
                        acc_res = _context2.sent;

                        if (!(acc_res.code != 1)) {
                            _context2.next = 14;
                            break;
                        }

                        return _context2.abrupt('return', acc_res);

                    case 14:
                        abi_actions = [];

                        contract_ABI.forEach(function (item) {
                            abi_actions.push({
                                name: item[0].key[1].v,
                                arglist: item[1][1].arglist
                            });
                        });

                        data = {
                            check_contract_authority: check_contract_authority,
                            abi_actions: abi_actions,
                            contract_authority: contract_authority,
                            contract_data: _helper2.default.formatTable(contract_data),
                            contract_data_type: formatTableWithStructs(contract_data),
                            create_date: new Date(creation_date + "Z").format("yyyy/MM/dd HH:mm:ss"),
                            current_version: current_version,
                            id: id,
                            lua_code: lua_code,
                            contract_name: name,
                            owner_account_name: acc_res.data.account.name
                        };


                        res.data = data;
                        return _context2.abrupt('return', res);

                    case 19:
                    case 'end':
                        return _context2.stop();
                }
            }
        }, null, undefined);
    },
    getAccountContractData: function getAccountContractData(_ref6, _ref7) {
        var dispatch = _ref6.dispatch;
        var account = _ref7.account,
            contractNameOrId = _ref7.contractNameOrId;

        var get_c_res, res, _res$data2, contract_data, owner, acc_res;

        return _regenerator2.default.async(function getAccountContractData$(_context3) {
            while (1) {
                switch (_context3.prev = _context3.next) {
                    case 0:
                        _context3.next = 2;
                        return _regenerator2.default.awrap(_api2.default.Contract.getContract(contractNameOrId));

                    case 2:
                        get_c_res = _context3.sent;

                        if (!(get_c_res.code != 1)) {
                            _context3.next = 5;
                            break;
                        }

                        return _context3.abrupt('return', get_c_res);

                    case 5:
                        _context3.next = 7;
                        return _regenerator2.default.awrap(_api2.default.Contract.getAccountContractData(account, contractNameOrId));

                    case 7:
                        res = _context3.sent;

                        if (!(res.code != 1)) {
                            _context3.next = 10;
                            break;
                        }

                        return _context3.abrupt('return', res);

                    case 10:
                        _res$data2 = res.data, contract_data = _res$data2.contract_data, owner = _res$data2.owner;


                        res.data.contract_data = _helper2.default.formatTable(contract_data);
                        res.data.contract_data_type = formatTableWithStructs(contract_data);

                        res.data.contract_name = get_c_res.data.name;

                        _context3.next = 16;
                        return _regenerator2.default.awrap(dispatch("user/getUserInfo", { account: owner, isCache: true }, { root: true }));

                    case 16:
                        acc_res = _context3.sent;

                        if (!(acc_res.code != 1)) {
                            _context3.next = 19;
                            break;
                        }

                        return _context3.abrupt('return', acc_res);

                    case 19:
                        res.data.owner_account_name = acc_res.data.account.name;
                        return _context3.abrupt('return', res);

                    case 21:
                    case 'end':
                        return _context3.stop();
                }
            }
        }, null, undefined);
    },
    callContractFunction: function callContractFunction(_ref8, params) {
        var dispatch = _ref8.dispatch;

        var nameOrId, functionName, valueList, onlyGetFee, contract_res, _valueList;

        return _regenerator2.default.async(function callContractFunction$(_context4) {
            while (1) {
                switch (_context4.prev = _context4.next) {
                    case 0:
                        if (_helper2.default.trimParams(params)) {
                            _context4.next = 2;
                            break;
                        }

                        return _context4.abrupt('return', { code: 101, message: "Parameter is missing" });

                    case 2:
                        nameOrId = params.nameOrId, functionName = params.functionName, valueList = params.valueList, onlyGetFee = params.onlyGetFee;

                        if (Array.isArray(valueList)) {
                            _context4.next = 5;
                            break;
                        }

                        return _context4.abrupt('return', { code: 135, message: "Please check parameter data type" });

                    case 5:
                        if (/1\.\d+\.\d+\./.test(nameOrId)) {
                            _context4.next = 18;
                            break;
                        }

                        _context4.next = 8;
                        return _regenerator2.default.awrap(dispatch("getContract", { nameOrId: nameOrId }));

                    case 8:
                        contract_res = _context4.sent;

                        if (!(contract_res.code == 1)) {
                            _context4.next = 17;
                            break;
                        }

                        nameOrId = contract_res.data.id;
                        _valueList = formatValueList(valueList);

                        if (!("code" in _valueList)) {
                            _context4.next = 14;
                            break;
                        }

                        return _context4.abrupt('return', _valueList);

                    case 14:
                        return _context4.abrupt('return', dispatch('transactions/_transactionOperations', {
                            operations: [{
                                type: "call_contract_function",
                                params: {
                                    contractId: nameOrId,
                                    functionName: functionName,
                                    valueList: _valueList
                                }
                            }],
                            onlyGetFee: onlyGetFee
                        }, { root: true }));

                    case 17:
                        return _context4.abrupt('return', contract_res);

                    case 18:
                    case 'end':
                        return _context4.stop();
                }
            }
        }, null, undefined);
    },
    parseContractAffecteds: function parseContractAffecteds(_ref9, contract_affecteds) {
        var dispatch = _ref9.dispatch;
    }
};

exports.default = {
    state: initialState,
    actions: actions,
    //getters,
    namespaced: true
};

/***/ }),
/* 580 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(27);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _regenerator = __webpack_require__(3);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _promise = __webpack_require__(4);

var _promise2 = _interopRequireDefault(_promise);

var _mutations;

var _vue = __webpack_require__(19);

var _vue2 = _interopRequireDefault(_vue);

var _mutations2 = __webpack_require__(14);

var types = _interopRequireWildcard(_mutations2);

var _api = __webpack_require__(10);

var _api2 = _interopRequireDefault(_api);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var actions = {
  fetch: function fetch(store, _ref) {
    var assetsIds = _ref.assetsIds,
        baseId = _ref.baseId,
        days = _ref.days;
    var commit = store.commit,
        rootGetters = store.rootGetters;

    var assets = rootGetters['assets/getAssets'];
    var baseAsset = assets[baseId];

    commit(types.FETCH_PRICES_HISTORY_REQUEST, { baseId: baseId });
    _promise2.default.all(assetsIds.map(function _callee(assetId) {
      var prices;
      return _regenerator2.default.async(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return _regenerator2.default.awrap(_api2.default.Assets.fetchPriceHistory(baseAsset, assets[assetId], days));

            case 2:
              prices = _context.sent;

              if (prices) {
                _context.next = 5;
                break;
              }

              throw new Error('error market history');

            case 5:
              return _context.abrupt('return', {
                assetId: assetId,
                prices: prices
              });

            case 6:
            case 'end':
              return _context.stop();
          }
        }
      }, null, undefined);
    })).then(function (pricesObjects) {
      var prices = pricesObjects.reduce(function (result, obj) {
        result[obj.assetId] = obj.prices;
        return result;
      }, {});
      // console.info('prices',prices);
      commit(types.FETCH_PRICES_HISTORY_COMPLETE, { days: days, prices: prices });
    }).catch(function (err) {
      commit(types.FETCH_PRICES_HISTORY_ERROR);
      console.log(err);
    });
  }
};

var getters = {
  getByDay: function getByDay(state) {
    return function (days) {
      return state.days[days] || {};
    };
  },
  isFetching: function isFetching(state) {
    return state.fetching;
  },
  getAssetHistoryByDay: function getAssetHistoryByDay(state) {
    return function (id, day) {
      if (!state.days[day]) return { first: 0, last: 0 };
      return state.days[day][id] || { first: 0, last: 0 };
    };
  },
  getHistoryAssetMultiplier: function getHistoryAssetMultiplier(state) {
    return function (days, assetId) {
      if (!state.days[days] || !state.days[days][assetId]) {
        return {
          first: 0,
          last: 0
        };
      }
      return {
        first: 1 / state.days[days][assetId].first,
        last: 1 / state.days[days][assetId].last
      };
    };
  }
};

var initialState = {
  days: {},
  fetching: false,
  error: false,
  baseId: ''
};

var mutations = (_mutations = {}, (0, _defineProperty3.default)(_mutations, types.FETCH_PRICES_HISTORY_REQUEST, function (state, _ref2) {
  var baseId = _ref2.baseId;

  state.fetching = true;
  state.baseAssetId = baseId;
}), (0, _defineProperty3.default)(_mutations, types.FETCH_PRICES_HISTORY_COMPLETE, function (state, _ref3) {
  var prices = _ref3.prices,
      days = _ref3.days;

  state.fetching = false;
  _vue2.default.set(state.days, days, prices);
}), (0, _defineProperty3.default)(_mutations, types.FETCH_PRICES_HISTORY_ERROR, function (state) {
  state.fetching = false;
  state.error = true;
}), _mutations);

exports.default = {
  state: initialState,
  actions: actions,
  getters: getters,
  mutations: mutations,
  namespaced: true
};

/***/ }),
/* 581 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(27);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _regenerator = __webpack_require__(3);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _mutations;

var _mutations2 = __webpack_require__(14);

var types = _interopRequireWildcard(_mutations2);

var _api = __webpack_require__(10);

var _api2 = _interopRequireDefault(_api);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var initialState = {
  all_witnesses: [],
  all_committee: [],
  all_type: "witnesses",
  globalObject: null,
  votes_state: null,
  getVoteObjects_callback: null,
  vote_ids_obj: null,
  vote_ids: [],
  queryAccount: "",
  isExplorer: false
};

var getters = {
  alls: function alls(state) {
    var all_witnesses = state.all_witnesses,
        all_committee = state.all_committee;

    return { all_witnesses: all_witnesses, all_committee: all_committee };
  },
  all_type: function all_type(state) {
    return state.all_type;
  },
  globalObject: function globalObject(state) {
    return state.globalObject;
  },
  getVotesState: function getVotesState(state) {
    return state.votes_state;
  },
  vote_ids_obj: function vote_ids_obj(state) {
    return state.vote_ids_obj;
  },
  vote_ids: function vote_ids(state) {
    return state.vote_ids;
  },
  queryAccount: function queryAccount(state) {
    return state.queryAccount;
  },
  isExplorer: function isExplorer(state) {
    return state.isExplorer;
  }

};

var actions = {
  getVoteObjects: function getVoteObjects(store, _ref) {
    var _ref$type = _ref.type,
        type = _ref$type === undefined ? "witnesses" : _ref$type,
        callback = _ref.callback,
        _ref$queryAccount = _ref.queryAccount,
        queryAccount = _ref$queryAccount === undefined ? "" : _ref$queryAccount,
        _ref$isExplorer = _ref.isExplorer,
        isExplorer = _ref$isExplorer === undefined ? false : _ref$isExplorer,
        _ref$isCache = _ref.isCache,
        isCache = _ref$isCache === undefined ? false : _ref$isCache;
    var dispatch = store.dispatch,
        rootGetters = store.rootGetters,
        commit = store.commit,
        state = store.state;

    commit(types.SET_ALL_TYPE, type);
    commit(types.set_getVoteObjects_callback, callback);
    commit(types.SET_QUERY_ACCOUNT, queryAccount);
    state.isExplorer = isExplorer;
    isCache = isCache || false;
    _api2.default.Vote._getVoteObjects(store, type, null, isCache);
  },
  // publishVotes:async (store,{witnesses_ids=null,committee_ids=null,votes,callback})=>{
  //     let {commit,getters,dispatch}=store;
  //     dispatch("getVoteObjects",{type:"witnesses",callback:(res)=>{
  //             if(res.code!=1){
  //               callback&&callback(res);
  //               return;
  //             }
  //             let {witnesses,committee,proxy_account_id}=getters.getVotesState;
  //             if(!witnesses_ids){
  //               witnesses_ids=witnesses.toArray();
  //             }
  //             if(!committee_ids){
  //               committee_ids=committee.toArray();
  //             }
  //             API.Vote.publishVotes(store,witnesses_ids,committee_ids,votes,callback);
  //     }})
  // },

  publishVotes: function publishVotes(store, _ref2) {
    var vote_ids = _ref2.vote_ids,
        votes = _ref2.votes,
        _ref2$type = _ref2.type,
        type = _ref2$type === undefined ? "witnesses" : _ref2$type,
        callback = _ref2.callback;
    return _regenerator2.default.async(function publishVotes$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _api2.default.Vote.publishVotes(store, vote_ids, votes, type, callback);

          case 1:
          case 'end':
            return _context.stop();
        }
      }
    }, null, undefined);
  },
  setGlobalObject: function setGlobalObject(_ref3, GB) {
    var commit = _ref3.commit;

    commit(types.SET_GLOBAL_OBJECT, GB);
  },
  witnessCreate: function witnessCreate(_ref4, _ref5) {
    var dispatch = _ref4.dispatch;
    var _ref5$url = _ref5.url,
        url = _ref5$url === undefined ? "" : _ref5$url,
        blockSigningKey = _ref5.blockSigningKey,
        account = _ref5.account;

    if (!blockSigningKey) {
      return { code: 179, message: "blockSigningKey can not be empty" };
    }
    url = url || "";
    return dispatch('transactions/_transactionOperations', {
      operations: [{
        op_type: 18,
        type: "witness_create",
        params: {
          witness_account: account.id,
          url: url,
          block_signing_key: blockSigningKey
        }
      }]
    }, { root: true });
  },
  committeeMemberCreate: function committeeMemberCreate(_ref6, _ref7) {
    var dispatch = _ref6.dispatch;
    var _ref7$url = _ref7.url,
        url = _ref7$url === undefined ? "" : _ref7$url,
        account = _ref7.account;

    url = url || "";
    return dispatch('transactions/_transactionOperations', {
      operations: [{
        op_type: 23,
        type: "committee_member_create",
        params: {
          committee_member_account: account.id,
          url: url
        }
      }]
    }, { root: true });
  },
  witnessUpdate: function witnessUpdate(_ref8, params) {
    var dispatch = _ref8.dispatch;

    var account, witness_id, witness_res, _witness_res$data$, url, signing_key, work_status;

    return _regenerator2.default.async(function witnessUpdate$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            account = params.account;

            if (!account.witness_status) {
              _context2.next = 15;
              break;
            }

            witness_id = account.witness_status[0];
            _context2.next = 5;
            return _regenerator2.default.awrap(dispatch("explorer/getDataByIds", { ids: [witness_id] }, { root: true }));

          case 5:
            witness_res = _context2.sent;

            if (!(witness_res.code != 1)) {
              _context2.next = 8;
              break;
            }

            return _context2.abrupt('return', witness_res);

          case 8:
            _witness_res$data$ = witness_res.data[0], url = _witness_res$data$.url, signing_key = _witness_res$data$.signing_key, work_status = _witness_res$data$.work_status;

            if (params.newUrl != undefined) url = params.newUrl;
            if (params.newSigningKey != undefined && params.newSigningKey != "") signing_key = params.newSigningKey;
            if (params.workStatus != undefined) work_status = !!params.workStatus;
            return _context2.abrupt('return', dispatch('transactions/_transactionOperations', {
              operations: [{
                op_type: 19,
                type: "witness_update",
                params: {
                  witness: witness_id,
                  witness_account: account.id,
                  new_url: url,
                  new_signing_key: signing_key,
                  work_status: work_status
                }
              }]
            }, { root: true }));

          case 15:
            return _context2.abrupt('return', {
              code: 180, message: "Not a witness"
            });

          case 16:
          case 'end':
            return _context2.stop();
        }
      }
    }, null, undefined);
  },
  committeeMemberUpdate: function committeeMemberUpdate(_ref9, params) {
    var dispatch = _ref9.dispatch;

    var account, committee_id, committee_res, _committee_res$data$, url, work_status;

    return _regenerator2.default.async(function committeeMemberUpdate$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            account = params.account;

            if (!account.committee_status) {
              _context3.next = 14;
              break;
            }

            committee_id = account.committee_status[0];
            _context3.next = 5;
            return _regenerator2.default.awrap(dispatch("explorer/getDataByIds", { ids: [committee_id] }, { root: true }));

          case 5:
            committee_res = _context3.sent;

            if (!(committee_res.code != 1)) {
              _context3.next = 8;
              break;
            }

            return _context3.abrupt('return', committee_res);

          case 8:
            _committee_res$data$ = committee_res.data[0], url = _committee_res$data$.url, work_status = _committee_res$data$.work_status;

            if (params.newUrl != undefined) url = params.newUrl;
            if (params.workStatus != undefined) work_status = !!params.workStatus;
            return _context3.abrupt('return', dispatch('transactions/_transactionOperations', {
              operations: [{
                op_type: 24,
                type: "committee_member_update",
                params: {
                  committee_member: committee_id,
                  committee_member_account: account.id,
                  new_url: url,
                  work_status: work_status
                }
              }]
            }, { root: true }));

          case 14:
            return _context3.abrupt('return', {
              code: 180, message: "Not a committee"
            });

          case 15:
          case 'end':
            return _context3.stop();
        }
      }
    }, null, undefined);
  }
};

var mutations = (_mutations = {}, (0, _defineProperty3.default)(_mutations, types.SET_ALL_WITNESSES_COMMITTEE, function (state, params) {
  state.all_witnesses = params.all_witnesses;
  state.all_committee = params.all_committee;
}), (0, _defineProperty3.default)(_mutations, types.SET_ALL_TYPE, function (state, type) {
  state.all_type = type;
}), (0, _defineProperty3.default)(_mutations, types.SET_GLOBAL_OBJECT, function (state, globalObject) {
  state.globalObject = globalObject;
}), (0, _defineProperty3.default)(_mutations, types.SET_VOTES_STATE, function (state, votes_state) {
  state.votes_state = votes_state;
}), (0, _defineProperty3.default)(_mutations, types.set_getVoteObjects_callback, function (state, callback) {
  state.getVoteObjects_callback = callback;
}), (0, _defineProperty3.default)(_mutations, types.set_publishVotes_callback, function (state, callback) {
  state.publishVotes_callback = callback;
}), (0, _defineProperty3.default)(_mutations, types.SET_VOTE_IDS_OBJ, function (state, vote_ids_obj) {
  state.vote_ids_obj = vote_ids_obj;
}), (0, _defineProperty3.default)(_mutations, types.SET_VOTE_IDS, function (state, ids) {
  state.vote_ids = ids;
}), (0, _defineProperty3.default)(_mutations, types.SET_QUERY_ACCOUNT, function (state, account) {
  state.queryAccount = account;
}), _mutations);

exports.default = {
  state: initialState,
  actions: actions,
  mutations: mutations,
  getters: getters,
  namespaced: true
};

/***/ }),
/* 582 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _stringify = __webpack_require__(18);

var _stringify2 = _interopRequireDefault(_stringify);

var _typeof2 = __webpack_require__(26);

var _typeof3 = _interopRequireDefault(_typeof2);

var _keys = __webpack_require__(24);

var _keys2 = _interopRequireDefault(_keys);

var _regenerator = __webpack_require__(3);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _api = __webpack_require__(10);

var _api2 = _interopRequireDefault(_api);

var _helper = __webpack_require__(34);

var _helper2 = _interopRequireDefault(_helper);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var initialState = {};

var actions = {
    relateNHAsset: function relateNHAsset(_ref, params) {
        var dispatch = _ref.dispatch;
        return _regenerator2.default.async(function relateNHAsset$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                    case 'end':
                        return _context.stop();
                }
            }
        }, null, undefined);
    },
    registerCreator: function registerCreator(_ref2) {
        var dispatch = _ref2.dispatch;

        return dispatch('transactions/_transactionOperations', {
            operations: [{
                op_type: 37,
                type: "register_nh_asset_creator",
                params: {}
            }]
        }, { root: true });
    },
    creatWorldView: function creatWorldView(_ref3, _ref4) {
        var dispatch = _ref3.dispatch;
        var _ref4$worldView = _ref4.worldView,
            worldView = _ref4$worldView === undefined ? "" : _ref4$worldView;

        if (!worldView) {
            return { code: 131, message: "Parameter 'worldView' can not be empty" };
        }
        worldView = worldView.trim();
        return dispatch('transactions/_transactionOperations', {
            operations: [{
                op_type: 38,
                type: "create_world_view",
                params: {
                    world_view: worldView
                }
            }]
        }, { root: true });
    },
    lookupNHAssets: function lookupNHAssets(store, _ref5) {
        var NHAssetIds = _ref5.NHAssetIds,
            _ref5$owner = _ref5.owner,
            owner = _ref5$owner === undefined ? false : _ref5$owner;
        return _regenerator2.default.async(function lookupNHAssets$(_context2) {
            while (1) {
                switch (_context2.prev = _context2.next) {
                    case 0:
                        if (Array.isArray(NHAssetIds)) {
                            _context2.next = 2;
                            break;
                        }

                        return _context2.abrupt('return', { code: 141, message: "Please check the data in parameter 'NHAssetIds'" });

                    case 2:
                        if (NHAssetIds.length) {
                            _context2.next = 4;
                            break;
                        }

                        return _context2.abrupt('return', { code: 137, message: "Parameter 'NHAssetIds' can not be empty" });

                    case 4:
                        NHAssetIds = NHAssetIds.map(function (id) {
                            return id ? id.trim() : "";
                        });

                        _context2.next = 7;
                        return _regenerator2.default.awrap(_api2.default.NHAssets.lookupNHAssets(NHAssetIds, owner, store.rootGetters["account/getAccountUserId"]));

                    case 7:
                        return _context2.abrupt('return', _context2.sent);

                    case 8:
                    case 'end':
                        return _context2.stop();
                }
            }
        }, null, undefined);
    },
    queryAccountNHAssets: function queryAccountNHAssets(_ref6, params) {
        var dispatch = _ref6.dispatch;
        var result;
        return _regenerator2.default.async(function queryAccountNHAssets$(_context3) {
            while (1) {
                switch (_context3.prev = _context3.next) {
                    case 0:
                        _context3.next = 2;
                        return _regenerator2.default.awrap(_api2.default.NHAssets.listAccountNHAssets(params));

                    case 2:
                        result = _context3.sent;
                        return _context3.abrupt('return', result);

                    case 4:
                    case 'end':
                        return _context3.stop();
                }
            }
        }, null, undefined);
    },
    formatItems: function formatItems(_ref7, result) {
        var dispatch = _ref7.dispatch;
        var items, i, item_wv_ids, wvs_id, contract_name, ii;
        return _regenerator2.default.async(function formatItems$(_context4) {
            while (1) {
                switch (_context4.prev = _context4.next) {
                    case 0:
                        if (!(result.code == 1)) {
                            _context4.next = 21;
                            break;
                        }

                        items = result.data;
                        i = 0;

                    case 3:
                        if (!(i < items.length)) {
                            _context4.next = 21;
                            break;
                        }

                        item_wv_ids = (0, _keys2.default)(items[i].world_view);
                        wvs_id = "";
                        contract_name = "";
                        ii = 0;

                    case 8:
                        if (!(ii < item_wv_ids.length)) {
                            _context4.next = 18;
                            break;
                        }

                        wvs_id = item_wv_ids[ii];
                        _context4.next = 12;
                        return _regenerator2.default.awrap(dispatch("contract/getContract", { nameOrId: wvs_id }, { root: true }));

                    case 12:
                        contract_name = _context4.sent.data.contract_name;

                        items[i].world_view[contract_name] = items[i].world_view[wvs_id];
                        delete items[i].world_view[wvs_id];

                    case 15:
                        ii++;
                        _context4.next = 8;
                        break;

                    case 18:
                        i++;
                        _context4.next = 3;
                        break;

                    case 21:
                        return _context4.abrupt('return', result);

                    case 22:
                    case 'end':
                        return _context4.stop();
                }
            }
        }, null, undefined);
    },
    queryNHAssetOrders: function queryNHAssetOrders(store, params) {
        var dispatch;
        return _regenerator2.default.async(function queryNHAssetOrders$(_context5) {
            while (1) {
                switch (_context5.prev = _context5.next) {
                    case 0:
                        dispatch = store.dispatch;


                        _helper2.default.trimParams(params);

                        if (params) {
                            _context5.next = 4;
                            break;
                        }

                        return _context5.abrupt('return', { code: 101, message: "Parameter is missing" });

                    case 4:
                        _context5.next = 6;
                        return _regenerator2.default.awrap(_api2.default.NHAssets.listNHAssetOrders(params, store));

                    case 6:
                        return _context5.abrupt('return', _context5.sent);

                    case 7:
                    case 'end':
                        return _context5.stop();
                }
            }
        }, null, undefined);
    },
    queryAccountNHAssetOrders: function queryAccountNHAssetOrders(store, params) {
        return _regenerator2.default.async(function queryAccountNHAssetOrders$(_context6) {
            while (1) {
                switch (_context6.prev = _context6.next) {
                    case 0:
                        _context6.next = 2;
                        return _regenerator2.default.awrap(_api2.default.NHAssets.listAccountNHAssetOrders(params));

                    case 2:
                        return _context6.abrupt('return', _context6.sent);

                    case 3:
                    case 'end':
                        return _context6.stop();
                }
            }
        }, null, undefined);
    },
    queryNHCreator: function queryNHCreator(_ref8, _ref9) {
        var dispatch = _ref8.dispatch;
        var account_id = _ref9.account_id;

        return _api2.default.NHAssets.getNHCreator(account_id);
    },
    queryNHAssetsByCreator: function queryNHAssetsByCreator(store, params) {
        return _regenerator2.default.async(function queryNHAssetsByCreator$(_context7) {
            while (1) {
                switch (_context7.prev = _context7.next) {
                    case 0:
                        _context7.next = 2;
                        return _regenerator2.default.awrap(_api2.default.NHAssets.listNHAssetsByCreator(params));

                    case 2:
                        return _context7.abrupt('return', _context7.sent);

                    case 3:
                    case 'end':
                        return _context7.stop();
                }
            }
        }, null, undefined);
    },
    lookupWorldViews: function lookupWorldViews(store, _ref10) {
        var worldViews = _ref10.worldViews;

        return _api2.default.NHAssets.lookupWorldViews(worldViews);
    },
    creatNHAsset: function creatNHAsset(_ref11, params) {
        var dispatch = _ref11.dispatch,
            rootGetters = _ref11.rootGetters;

        var _params$assetId, assetId, _params$worldView, worldView, _params$baseDescribe, baseDescribe, _params$type, type, _params$NHAssetsCount, NHAssetsCount, _params$NHAssets, NHAssets, ownerAccount, _params$onlyGetFee, onlyGetFee, proposeAccount, operations, overLimit0, acc_res, operation, i, overLimit1, j, _acc_res;

        return _regenerator2.default.async(function creatNHAsset$(_context8) {
            while (1) {
                switch (_context8.prev = _context8.next) {
                    case 0:
                        _helper2.default.trimParams(params);
                        //type:0 for single creation, 2 for batch creation
                        _params$assetId = params.assetId, assetId = _params$assetId === undefined ? "" : _params$assetId, _params$worldView = params.worldView, worldView = _params$worldView === undefined ? "" : _params$worldView, _params$baseDescribe = params.baseDescribe, baseDescribe = _params$baseDescribe === undefined ? "" : _params$baseDescribe, _params$type = params.type, type = _params$type === undefined ? 0 : _params$type, _params$NHAssetsCount = params.NHAssetsCount, NHAssetsCount = _params$NHAssetsCount === undefined ? 1 : _params$NHAssetsCount, _params$NHAssets = params.NHAssets, NHAssets = _params$NHAssets === undefined ? null : _params$NHAssets, ownerAccount = params.ownerAccount, _params$onlyGetFee = params.onlyGetFee, onlyGetFee = _params$onlyGetFee === undefined ? false : _params$onlyGetFee, proposeAccount = params.proposeAccount;
                        operations = [];

                        if (!(type == 0)) {
                            _context8.next = 25;
                            break;
                        }

                        overLimit0 = _isOverLimit(rootGetters, NHAssetsCount, "Create item");

                        if (!(overLimit0.code != 1)) {
                            _context8.next = 7;
                            break;
                        }

                        return _context8.abrupt('return', overLimit0);

                    case 7:
                        if (!(!assetId || !worldView)) {
                            _context8.next = 9;
                            break;
                        }

                        return _context8.abrupt('return', { code: 101, message: "Parameter is missing" });

                    case 9:
                        if (!ownerAccount) {
                            _context8.next = 20;
                            break;
                        }

                        _context8.next = 12;
                        return _regenerator2.default.awrap(dispatch("user/getUserInfo", { account: ownerAccount, isCache: true }, { root: true }));

                    case 12:
                        acc_res = _context8.sent;

                        if (!(acc_res.code == 1)) {
                            _context8.next = 17;
                            break;
                        }

                        ownerAccount = acc_res.data.account.id;
                        _context8.next = 18;
                        break;

                    case 17:
                        return _context8.abrupt('return', acc_res);

                    case 18:
                        _context8.next = 21;
                        break;

                    case 20:
                        ownerAccount = rootGetters["account/getAccountUserId"];

                    case 21:
                        operation = {
                            op_type: 40,
                            type: "create_nh_asset",
                            params: {
                                asset_id: assetId,
                                world_view: worldView,
                                base_describe: (typeof baseDescribe === 'undefined' ? 'undefined' : (0, _typeof3.default)(baseDescribe)) == "object" ? (0, _stringify2.default)(baseDescribe) : baseDescribe,
                                owner: ownerAccount
                            }
                        };


                        for (i = 0; i < NHAssetsCount; i++) {
                            operations.push(operation);
                        }

                        _context8.next = 49;
                        break;

                    case 25:
                        if (!(type == 1)) {
                            _context8.next = 49;
                            break;
                        }

                        if (!(NHAssets && Array.isArray(NHAssets) && NHAssets.length)) {
                            _context8.next = 48;
                            break;
                        }

                        overLimit1 = _isOverLimit(rootGetters, NHAssets.length, "create NHAsset");

                        if (!(overLimit1.code != 1)) {
                            _context8.next = 30;
                            break;
                        }

                        return _context8.abrupt('return', overLimit1);

                    case 30:
                        j = 0;

                    case 31:
                        if (!(j < NHAssets.length)) {
                            _context8.next = 46;
                            break;
                        }

                        if (!(!NHAssets[j].assetId || !NHAssets[j].worldView || !NHAssets[j].ownerAccount)) {
                            _context8.next = 34;
                            break;
                        }

                        return _context8.abrupt('return', { code: 141, message: "Please check the data in parameter 'NHAssets'" });

                    case 34:
                        _context8.next = 36;
                        return _regenerator2.default.awrap(dispatch("user/getUserInfo", { account: NHAssets[j].ownerAccount, isCache: true }, { root: true }));

                    case 36:
                        _acc_res = _context8.sent;

                        if (!(_acc_res.code == 1)) {
                            _context8.next = 41;
                            break;
                        }

                        NHAssets[j].ownerAccount = _acc_res.data.account.id;
                        _context8.next = 42;
                        break;

                    case 41:
                        return _context8.abrupt('return', _acc_res);

                    case 42:
                        operations.push({
                            op_type: 40,
                            type: "create_nh_asset",
                            params: {
                                asset_id: NHAssets[j].assetId,
                                world_view: NHAssets[j].worldView,
                                base_describe: (0, _typeof3.default)(NHAssets[j].baseDescribe) == "object" ? (0, _stringify2.default)(NHAssets[j].baseDescribe) : NHAssets[j].baseDescribe,
                                owner: NHAssets[j].ownerAccount
                            }
                        });

                    case 43:
                        j++;
                        _context8.next = 31;
                        break;

                    case 46:
                        _context8.next = 49;
                        break;

                    case 48:
                        return _context8.abrupt('return', { code: 142, message: "Please check the data type of parameter 'NHAssets'" });

                    case 49:
                        return _context8.abrupt('return', dispatch('transactions/_transactionOperations', {
                            operations: operations,
                            onlyGetFee: onlyGetFee,
                            proposeAccount: proposeAccount
                        }, { root: true }));

                    case 50:
                    case 'end':
                        return _context8.stop();
                }
            }
        }, null, undefined);
    },
    deleteNHAsset: function deleteNHAsset(_ref12, params) {
        var dispatch = _ref12.dispatch,
            rootGetters = _ref12.rootGetters;

        var callback, itemId, NHAssetIds, _params$onlyGetFee2, onlyGetFee, _params$owner, owner, overLimit, nhs_res, operations;

        return _regenerator2.default.async(function deleteNHAsset$(_context9) {
            while (1) {
                switch (_context9.prev = _context9.next) {
                    case 0:
                        _helper2.default.trimParams(params);
                        callback = params.callback, itemId = params.itemId, NHAssetIds = params.NHAssetIds, _params$onlyGetFee2 = params.onlyGetFee, onlyGetFee = _params$onlyGetFee2 === undefined ? false : _params$onlyGetFee2, _params$owner = params.owner, owner = _params$owner === undefined ? false : _params$owner;

                        if (NHAssetIds) {
                            _context9.next = 4;
                            break;
                        }

                        return _context9.abrupt('return', { code: 101, message: "Parameter is missing" });

                    case 4:
                        if (Array.isArray(NHAssetIds)) {
                            _context9.next = 6;
                            break;
                        }

                        return _context9.abrupt('return', { code: 135, message: "Please check parameter data type	" });

                    case 6:
                        overLimit = _isOverLimit(rootGetters, NHAssetIds.length, "delete item");

                        if (!(overLimit.code != 1)) {
                            _context9.next = 9;
                            break;
                        }

                        return _context9.abrupt('return', overLimit);

                    case 9:
                        _context9.next = 11;
                        return _regenerator2.default.awrap(_api2.default.NHAssets.lookupNHAssets(NHAssetIds, owner, rootGetters['account/getAccountUserId']));

                    case 11:
                        nhs_res = _context9.sent;

                        if (!(nhs_res.code == 1)) {
                            _context9.next = 19;
                            break;
                        }

                        if (nhs_res.data.length) {
                            _context9.next = 15;
                            break;
                        }

                        return _context9.abrupt('return', { code: 176, message: "You are not the owner of " + NHAssetIds });

                    case 15:
                        operations = nhs_res.data.map(function (_ref13) {
                            var id = _ref13.id;

                            return {
                                op_type: 41,
                                type: "delete_nh_asset",
                                params: {
                                    nh_asset: id
                                }
                            };
                        });
                        return _context9.abrupt('return', dispatch('transactions/_transactionOperations', {
                            operations: operations,
                            onlyGetFee: onlyGetFee
                        }, { root: true }));

                    case 19:
                        return _context9.abrupt('return', nhs_res);

                    case 20:
                    case 'end':
                        return _context9.stop();
                }
            }
        }, null, undefined);
    },
    transferNHAsset: function transferNHAsset(_ref14, _ref15) {
        var dispatch = _ref14.dispatch,
            rootGetters = _ref14.rootGetters;
        var to_account_id = _ref15.to_account_id,
            NHAssetIds = _ref15.NHAssetIds;
        var overLimit, nhs_res, operations;
        return _regenerator2.default.async(function transferNHAsset$(_context10) {
            while (1) {
                switch (_context10.prev = _context10.next) {
                    case 0:
                        if (NHAssetIds) {
                            _context10.next = 2;
                            break;
                        }

                        return _context10.abrupt('return', { code: 101, message: "Parameter is missing" });

                    case 2:
                        if (Array.isArray(NHAssetIds)) {
                            _context10.next = 4;
                            break;
                        }

                        return _context10.abrupt('return', { code: 135, message: "Please check parameter data type	" });

                    case 4:
                        overLimit = _isOverLimit(rootGetters, NHAssetIds.length, "transfer item");

                        if (!(overLimit.code != 1)) {
                            _context10.next = 7;
                            break;
                        }

                        return _context10.abrupt('return', overLimit);

                    case 7:
                        _context10.next = 9;
                        return _regenerator2.default.awrap(_api2.default.NHAssets.lookupNHAssets(NHAssetIds));

                    case 9:
                        nhs_res = _context10.sent;

                        if (!(nhs_res.code == 1)) {
                            _context10.next = 15;
                            break;
                        }

                        operations = nhs_res.data.map(function (_ref16) {
                            var id = _ref16.id;

                            return {
                                op_type: 42,
                                type: "transfer_nh_asset",
                                params: {
                                    to: to_account_id,
                                    nh_asset: id
                                }
                            };
                        });
                        return _context10.abrupt('return', dispatch('transactions/_transactionOperations', {
                            operations: operations
                        }, { root: true }));

                    case 15:
                        return _context10.abrupt('return', nhs_res);

                    case 16:
                    case 'end':
                        return _context10.stop();
                }
            }
        }, null, undefined);
    },
    creatNHAssetOrder: function creatNHAssetOrder(_ref17, params) {
        var dispatch = _ref17.dispatch;

        var otc_account_id, orderFee, NHAssetId, _params$memo, memo, price, _params$priceAssetId, priceAssetId, _params$expiration, expiration, _params$onlyGetFee3, onlyGetFee, priceAssetRes, _priceAssetRes$data$, precision, dynamic, nhs_res;

        return _regenerator2.default.async(function creatNHAssetOrder$(_context11) {
            while (1) {
                switch (_context11.prev = _context11.next) {
                    case 0:
                        _helper2.default.trimParams(params);
                        otc_account_id = params.otc_account_id, orderFee = params.orderFee, NHAssetId = params.NHAssetId, _params$memo = params.memo, memo = _params$memo === undefined ? "" : _params$memo, price = params.price, _params$priceAssetId = params.priceAssetId, priceAssetId = _params$priceAssetId === undefined ? "1.3.0" : _params$priceAssetId, _params$expiration = params.expiration, expiration = _params$expiration === undefined ? 3600 * 48 : _params$expiration, _params$onlyGetFee3 = params.onlyGetFee, onlyGetFee = _params$onlyGetFee3 === undefined ? false : _params$onlyGetFee3;

                        if (!(!NHAssetId || !priceAssetId)) {
                            _context11.next = 4;
                            break;
                        }

                        return _context11.abrupt('return', { code: 101, message: "Parameter is missing" });

                    case 4:
                        if (!(isNaN(Number(orderFee)) || isNaN(Number(price)) || isNaN(Number(expiration)))) {
                            _context11.next = 6;
                            break;
                        }

                        return _context11.abrupt('return', { code: 135, message: "Please check parameter data type" });

                    case 6:
                        _context11.next = 8;
                        return _regenerator2.default.awrap(dispatch("assets/queryAssets", { assetId: priceAssetId }, { root: true }));

                    case 8:
                        priceAssetRes = _context11.sent;

                        if (!(priceAssetRes.code != 1)) {
                            _context11.next = 11;
                            break;
                        }

                        return _context11.abrupt('return', priceAssetRes);

                    case 11:
                        _priceAssetRes$data$ = priceAssetRes.data[0], precision = _priceAssetRes$data$.precision, dynamic = _priceAssetRes$data$.dynamic;

                        if (!(price > dynamic.current_supply)) {
                            _context11.next = 14;
                            break;
                        }

                        return _context11.abrupt('return', { code: 177, message: "Prices exceed current supply" });

                    case 14:
                        _context11.next = 16;
                        return _regenerator2.default.awrap(_api2.default.NHAssets.lookupNHAssets([NHAssetId]));

                    case 16:
                        nhs_res = _context11.sent;

                        if (!(nhs_res.code == 1)) {
                            _context11.next = 22;
                            break;
                        }

                        NHAssetId = nhs_res.data[0].id;
                        return _context11.abrupt('return', dispatch('transactions/_transactionOperations', {
                            operations: [{
                                op_type: 43,
                                type: "create_nh_asset_order",
                                params: {
                                    otcaccount: otc_account_id,
                                    pending_orders_fee: orderFee,
                                    nh_asset: NHAssetId,
                                    memo: memo,
                                    price: price,
                                    priceAssetId: priceAssetId,
                                    expiration: parseInt(new Date().getTime() / 1000 + Number(expiration))
                                }
                            }],
                            onlyGetFee: onlyGetFee
                        }, { root: true }));

                    case 22:
                        return _context11.abrupt('return', nhs_res);

                    case 23:
                    case 'end':
                        return _context11.stop();
                }
            }
        }, null, undefined);
    },
    cancelNHAssetOrder: function cancelNHAssetOrder(_ref18, _ref19) {
        var dispatch = _ref18.dispatch;
        var orderId = _ref19.orderId,
            _ref19$onlyGetFee = _ref19.onlyGetFee,
            onlyGetFee = _ref19$onlyGetFee === undefined ? false : _ref19$onlyGetFee;

        if (!orderId) {
            return { code: 136, message: "Parameter 'orderId' can not be empty" };
        }
        orderId = orderId.trim();
        return dispatch('transactions/_transactionOperations', {
            operations: [{
                op_type: 44,
                type: "cancel_nh_asset_order",
                params: {
                    order: orderId,
                    extensions: []
                }
            }],
            onlyGetFee: onlyGetFee
        }, { root: true });
    },
    fillNHAssetOrder: function fillNHAssetOrder(_ref20, _ref21) {
        var dispatch = _ref20.dispatch;
        var orderId = _ref21.orderId,
            _ref21$onlyGetFee = _ref21.onlyGetFee,
            onlyGetFee = _ref21$onlyGetFee === undefined ? false : _ref21$onlyGetFee;

        var order_res, _order_res$data, nh_asset_id, seller, price_amount, price_asset_id, price_asset_symbol;

        return _regenerator2.default.async(function fillNHAssetOrder$(_context12) {
            while (1) {
                switch (_context12.prev = _context12.next) {
                    case 0:
                        if (orderId) {
                            _context12.next = 2;
                            break;
                        }

                        return _context12.abrupt('return', { code: 101, message: "Parameter is missing" });

                    case 2:
                        orderId = orderId.trim();
                        _context12.next = 5;
                        return _regenerator2.default.awrap(_api2.default.NHAssets.queryOrderDetail(orderId));

                    case 5:
                        order_res = _context12.sent;

                        if (!(order_res.code != 1)) {
                            _context12.next = 8;
                            break;
                        }

                        return _context12.abrupt('return', order_res);

                    case 8:
                        _order_res$data = order_res.data, nh_asset_id = _order_res$data.nh_asset_id, seller = _order_res$data.seller, price_amount = _order_res$data.price_amount, price_asset_id = _order_res$data.price_asset_id, price_asset_symbol = _order_res$data.price_asset_symbol;
                        return _context12.abrupt('return', dispatch('transactions/_transactionOperations', {
                            operations: [{
                                op_type: 45,
                                type: "fill_nh_asset_order",
                                params: {
                                    order: orderId,
                                    seller: seller,
                                    nh_asset: nh_asset_id,
                                    price_amount: price_amount + "",
                                    price_asset_id: price_asset_id,
                                    price_asset_symbol: price_asset_symbol,
                                    extensions: []
                                }
                            }],
                            onlyGetFee: onlyGetFee
                        }, { root: true }));

                    case 10:
                    case 'end':
                        return _context12.stop();
                }
            }
        }, null, undefined);
    },
    proposeRelateWorldView: function proposeRelateWorldView(_ref22, _ref23) {
        var dispatch = _ref22.dispatch,
            rootGetters = _ref22.rootGetters;
        var worldView = _ref23.worldView,
            _ref23$onlyGetFee = _ref23.onlyGetFee,
            onlyGetFee = _ref23$onlyGetFee === undefined ? false : _ref23$onlyGetFee,
            _ref23$proposeAccount = _ref23.proposeAccount,
            proposeAccount = _ref23$proposeAccount === undefined ? "" : _ref23$proposeAccount;
        var wv_detail, view_owner_id;
        return _regenerator2.default.async(function proposeRelateWorldView$(_context13) {
            while (1) {
                switch (_context13.prev = _context13.next) {
                    case 0:
                        _context13.next = 2;
                        return _regenerator2.default.awrap(_api2.default.NHAssets.lookupWorldViews([worldView]));

                    case 2:
                        wv_detail = _context13.sent;

                        if (!(wv_detail.code != 1)) {
                            _context13.next = 5;
                            break;
                        }

                        return _context13.abrupt('return', wv_detail);

                    case 5:
                        view_owner_id = wv_detail.data[0].creators[0].creator;
                        return _context13.abrupt('return', dispatch('transactions/_transactionOperations', {
                            operations: [{
                                op_type: 39,
                                type: "relate_world_view",
                                params: {
                                    world_view: worldView,
                                    view_owner: view_owner_id
                                }
                            }],
                            proposeAccount: rootGetters["account/getAccountUserId"],
                            onlyGetFee: onlyGetFee
                        }, { root: true }));

                    case 7:
                    case 'end':
                        return _context13.stop();
                }
            }
        }, null, undefined);
    }
};

var mutations = {};

var _isOverLimit = function _isOverLimit(rootGetters, params_count, title) {

    var ops_limit = rootGetters["setting/ops_limit"];
    if (params_count > ops_limit) {
        return { code: 144, message: "Your current batch " + title + " number is " + params_count + ", and batch operations can not exceed " + ops_limit };
    }

    return { code: 1 };
};

exports.default = {
    state: initialState,
    actions: actions,
    //getters,
    mutations: mutations,
    namespaced: true
};

/***/ }),
/* 583 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _regenerator = __webpack_require__(3);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _api = __webpack_require__(10);

var _api2 = _interopRequireDefault(_api);

var _helper = __webpack_require__(34);

var _helper2 = _interopRequireDefault(_helper);

var _permission_utils = __webpack_require__(584);

var _permission_utils2 = _interopRequireDefault(_permission_utils);

var _utils = __webpack_require__(59);

var _utils2 = _interopRequireDefault(_utils);

var _immutable = __webpack_require__(23);

var _immutable2 = _interopRequireDefault(_immutable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var initialState = {};

var actions = {
    loadAccountProposals: function loadAccountProposals(store, _ref) {
        var account_id = _ref.account_id;

        var rootGetters, dispatch, userId, acc_res, proposals, acc_proposals, acc_proposal, _loop, i, time;

        return _regenerator2.default.async(function loadAccountProposals$(_context2) {
            while (1) {
                switch (_context2.prev = _context2.next) {
                    case 0:
                        rootGetters = store.rootGetters, dispatch = store.dispatch;
                        _context2.prev = 1;
                        userId = account_id || rootGetters["account/getAccountUserId"];

                        if (userId) {
                            _context2.next = 5;
                            break;
                        }

                        return _context2.abrupt('return', { code: 170, message: "Missing parameter account or login first" });

                    case 5:
                        _context2.next = 7;
                        return _regenerator2.default.awrap(dispatch("user/getUserInfo", { account: userId }, { root: true }));

                    case 7:
                        acc_res = _context2.sent;
                        proposals = [];
                        acc_proposals = acc_res.data.proposals;
                        acc_proposal = void 0;

                        _loop = function _callee(i) {
                            var operation, _acc_proposal, id, expiration_time, required_active_approvals, permissions_type, required, available, availableKeys, requiredPermissions, status, pushStatusItem, _operations$, parse_operations, parse_operations_text, raw_data, type, type_name;

                            return _regenerator2.default.async(function _callee$(_context) {
                                while (1) {
                                    switch (_context.prev = _context.next) {
                                        case 0:
                                            acc_proposal = acc_proposals[i];
                                            operation = acc_proposal.proposed_transaction.operations[0];
                                            _acc_proposal = acc_proposal, id = _acc_proposal.id, expiration_time = _acc_proposal.expiration_time, required_active_approvals = _acc_proposal.required_active_approvals;
                                            permissions_type = required_active_approvals.length ? "active" : "owner";
                                            required = acc_proposal['required_' + permissions_type + '_approvals'];
                                            available = acc_proposal['available_' + permissions_type + '_approvals'];
                                            availableKeys = acc_proposal["available_key_approvals"];


                                            required = _permission_utils2.default.listToIDs(required);
                                            _context.next = 10;
                                            return _regenerator2.default.awrap(_permission_utils2.default.unnest(_immutable2.default.fromJS(required), permissions_type));

                                        case 10:
                                            requiredPermissions = _context.sent;
                                            status = [];

                                            pushStatusItem = function pushStatusItem(permission, threshold) {
                                                // permission.threshold=requiredPermissions.threshold;
                                                var id = permission.id,
                                                    account_name = permission.account_name,
                                                    weight = permission.weight;

                                                var isNested = permission.isNested();
                                                var isMultiSig = permission.isMultiSig();

                                                var notNestedWeight = threshold && threshold > 10 ? _utils2.default.get_percentage(permission.weight, threshold) : permission.weight;

                                                var nestedWeight = permission && permission.threshold > 10 ? '' + _utils2.default.get_percentage(permission.getStatus(available, availableKeys), permission.threshold) : permission.getStatus(available, availableKeys) + ' / ' + permission.threshold;

                                                if (weight) status.push({
                                                    id: id,
                                                    account_name: account_name,
                                                    weight: weight,
                                                    weight_percentage: !isNested && notNestedWeight ? notNestedWeight : nestedWeight, //permission.weight/requiredPermissions[0].threshold,
                                                    isAgree: permission.isAvailable(available)
                                                });

                                                if (isNested || isMultiSig) {
                                                    permission.accounts.forEach(function (subAccount) {
                                                        pushStatusItem(subAccount, permission.threshold * 2);
                                                    });
                                                }
                                            };

                                            requiredPermissions.forEach(function (permission) {
                                                pushStatusItem(permission);
                                            });

                                            _context.next = 16;
                                            return _regenerator2.default.awrap(_api2.default.Operations.parseOperations({
                                                operations: [{ op: operation }],
                                                store: store
                                            }));

                                        case 16:
                                            _operations$ = _context.sent.operations[0];
                                            parse_operations = _operations$.parse_operations;
                                            parse_operations_text = _operations$.parse_operations_text;
                                            raw_data = _operations$.raw_data;
                                            type = _operations$.type;
                                            type_name = _operations$.type_name;

                                            proposals.push({
                                                id: id,
                                                expiration: new Date(expiration_time + "Z").format("yyyy/MM/dd HH:mm:ss"),
                                                parse_operations: parse_operations,
                                                parse_operations_text: parse_operations_text,
                                                raw_data: raw_data,
                                                type: type,
                                                type_name: type_name,
                                                status: status
                                            });

                                        case 23:
                                        case 'end':
                                            return _context.stop();
                                    }
                                }
                            }, null, undefined);
                        };

                        i = 0;

                    case 13:
                        if (!(i < acc_proposals.length)) {
                            _context2.next = 19;
                            break;
                        }

                        _context2.next = 16;
                        return _regenerator2.default.awrap(_loop(i));

                    case 16:
                        i++;
                        _context2.next = 13;
                        break;

                    case 19:
                        time = void 0;

                        proposals = proposals.sort(function (a, b) {
                            return Number(b.id.split(".")[2]) - Number(a.id.split(".")[2]);
                        });
                        return _context2.abrupt('return', { code: 1, data: proposals });

                    case 24:
                        _context2.prev = 24;
                        _context2.t0 = _context2['catch'](1);
                        return _context2.abrupt('return', { code: 0, message: _context2.t0.message, error: _context2.t0 });

                    case 27:
                    case 'end':
                        return _context2.stop();
                }
            }
        }, null, undefined, [[1, 24]]);
    },
    submitProposal: function submitProposal(_ref2, _ref3) {
        var dispatch = _ref2.dispatch,
            rootGetters = _ref2.rootGetters;
        var proposalId = _ref3.proposalId,
            _ref3$onlyGetFee = _ref3.onlyGetFee,
            onlyGetFee = _ref3$onlyGetFee === undefined ? false : _ref3$onlyGetFee;
        var account_id, proposal;
        return _regenerator2.default.async(function submitProposal$(_context3) {
            while (1) {
                switch (_context3.prev = _context3.next) {
                    case 0:
                        account_id = rootGetters["account/getAccountUserId"];
                        proposal = {
                            fee_paying_account: account_id,
                            proposal: proposalId,
                            active_approvals_to_add: [account_id],
                            active_approvals_to_remove: [],
                            owner_approvals_to_add: [],
                            owner_approvals_to_remove: [],
                            key_approvals_to_add: [],
                            key_approvals_to_remove: []
                        };
                        return _context3.abrupt('return', dispatch('transactions/_transactionOperations', {
                            operations: [{
                                op_type: 21,
                                type: "proposal_update",
                                params: proposal
                            }],
                            onlyGetFee: onlyGetFee
                        }, { root: true }));

                    case 3:
                    case 'end':
                        return _context3.stop();
                }
            }
        }, null, undefined);
    }
};

var mutations = {};

exports.default = {
    state: initialState,
    actions: actions,
    //getters,
    mutations: mutations,
    namespaced: true
};

/***/ }),
/* 584 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _regenerator = __webpack_require__(3);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _promise = __webpack_require__(4);

var _promise2 = _interopRequireDefault(_promise);

var _bcxjsCores = __webpack_require__(7);

var _immutable = __webpack_require__(23);

var _immutable2 = _interopRequireDefault(_immutable);

var _api = __webpack_require__(10);

var _api2 = _interopRequireDefault(_api);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var KeyAuth = function KeyAuth(auth) {
    var _this = this;

    this.id = auth.toJS ? auth.get(0) : auth[0];
    this.weight = auth.toJS ? auth.get(1) : auth[1];

    this.isAvailable = function (auths) {
        return auths.includes ? auths.includes(_this.id) : auths.indexOf(_this) !== -1;
    };
};

var permissionUtils = {

    AccountPermission: function AccountPermission(account, weight, type) {
        var _this2 = this;

        this.id = account.get("id");
        this.account_name = account.get("name");
        this.weight = weight;
        this.threshold = account.getIn([type, "weight_threshold"]);
        // console.info("account",type,JSON.parse(JSON.stringify(account)));
        this.accounts = [];
        this.keys = account.getIn([type, "key_auths"]).map(function (auth) {
            return new KeyAuth(auth);
        }).toArray();
        this.isAvailable = function (auths) {
            return auths.includes ? auths.includes(_this2.id) : auths.indexOf(_this2) !== -1;
        };

        this._sumWeights = function (auths) {

            if (!_this2.isNested() && !_this2.isMultiSig()) {
                return _this2.isAvailable(auths) ? _this2.weight : 0;
            } else {
                var sum = _this2.accounts.reduce(function (status, account) {
                    return status + (account._sumWeights(auths) ? account.weight : 0);
                }, 0);
                return Math.floor(sum / _this2.threshold);
            }
        };
        this.getStatus = function (auths, keyAuths) {
            if (!_this2.isNested()) {
                var sum = _this2._sumWeights(auths);

                if (_this2.isMultiSig()) {
                    sum += _this2.sumKeys(keyAuths);
                }
                return sum;
            } else {
                var _sum = _this2.accounts.reduce(function (status, account) {
                    return status + account._sumWeights(auths);
                }, 0);

                if (_this2.keys.length) {
                    _sum += _this2.sumKeys(keyAuths);
                }

                return _sum;
            }
        };

        this.sumKeys = function (keyAuths) {
            var keySum = _this2.keys.reduce(function (s, key) {
                return s + (key.isAvailable(keyAuths) ? key.weight : 0);
            }, 0);
            return keySum;
        };

        this.isNested = function () {
            return _this2.accounts.length > 0;
        };

        this.isMultiSig = function () {
            return _this2.keys.reduce(function (final, key) {
                return final || key.weight < _this2.threshold;
            }, false);
        };

        this.getMissingSigs = function (auths) {
            var missing = [];
            var nested = [];
            if (_this2.isNested()) {
                nested = _this2.accounts.reduce(function (a, account) {
                    return a.concat(account.getMissingSigs(auths));
                }, []);
            } else if (!_this2.isAvailable(auths)) {
                missing.push(_this2.id);
            }

            return missing.concat(nested);
        };

        this.getMissingKeys = function (auths) {
            var missing = [];
            var nested = [];
            if (_this2.keys.length && (_this2.isNested() || _this2.isMultiSig())) {
                _this2.keys.forEach(function (key) {
                    if (!key.isAvailable(auths)) {
                        missing.push(key.id);
                    }
                });
            }

            if (_this2.isNested()) {
                nested = _this2.accounts.reduce(function (a, account) {
                    return a.concat(account.getMissingKeys(auths));
                }, []);
            };

            return missing.concat(nested);
        };
    },

    listToIDs: function listToIDs(accountList) {
        var allAccounts = [];
        accountList.forEach(function (account) {
            if (account) {
                allAccounts.push(account.id ? account.id : account);
            }
        });

        return allAccounts;
    },

    unravel: function unravel(accountPermission, type) {
        var _this3 = this;

        var recursive_count = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var account;
        return _regenerator2.default.async(function unravel$(_context2) {
            while (1) {
                switch (_context2.prev = _context2.next) {
                    case 0:
                        if (!(recursive_count < 3)) {
                            _context2.next = 9;
                            break;
                        }

                        _context2.t0 = _immutable2.default;
                        _context2.next = 4;
                        return _regenerator2.default.awrap(_api2.default.Account.getAccount(accountPermission.id, false));

                    case 4:
                        _context2.t1 = _context2.sent.data.account;
                        account = _context2.t0.fromJS.call(_context2.t0, _context2.t1);

                        if (!(account && account.getIn([type, "account_auths"]).size)) {
                            _context2.next = 9;
                            break;
                        }

                        _context2.next = 9;
                        return _regenerator2.default.awrap(_promise2.default.all(account.getIn([type, "account_auths"]).map(function _callee(auth) {
                            var nestedAccount;
                            return _regenerator2.default.async(function _callee$(_context) {
                                while (1) {
                                    switch (_context.prev = _context.next) {
                                        case 0:
                                            _context.next = 2;
                                            return _regenerator2.default.awrap(_api2.default.Account.getAccount(auth.get(0), false));

                                        case 2:
                                            nestedAccount = _context.sent.data.account;

                                            if (!nestedAccount) {
                                                _context.next = 9;
                                                break;
                                            }

                                            _context.t0 = accountPermission.accounts;
                                            _context.next = 7;
                                            return _regenerator2.default.awrap(_this3.unravel(new _this3.AccountPermission(_immutable2.default.fromJS(nestedAccount), auth.get(1), type), type, recursive_count + 1));

                                        case 7:
                                            _context.t1 = _context.sent;

                                            _context.t0.push.call(_context.t0, _context.t1);

                                        case 9:
                                            return _context.abrupt("return", true);

                                        case 10:
                                        case "end":
                                            return _context.stop();
                                    }
                                }
                            }, null, _this3);
                        })));

                    case 9:
                        return _context2.abrupt("return", accountPermission);

                    case 10:
                    case "end":
                        return _context2.stop();
                }
            }
        }, null, this);
    },


    unnest: function unnest(accounts, type) {
        var _this4 = this;

        return _promise2.default.all(accounts.map(function _callee2(id) {
            var fullAccount, currentPermission;
            return _regenerator2.default.async(function _callee2$(_context3) {
                while (1) {
                    switch (_context3.prev = _context3.next) {
                        case 0:
                            _context3.next = 2;
                            return _regenerator2.default.awrap(_api2.default.Account.getAccount(id, false));

                        case 2:
                            fullAccount = _context3.sent.data.account;
                            _context3.next = 5;
                            return _regenerator2.default.awrap(_this4.unravel(new _this4.AccountPermission(_immutable2.default.fromJS(fullAccount), null, type), type));

                        case 5:
                            currentPermission = _context3.sent;
                            return _context3.abrupt("return", currentPermission);

                        case 7:
                        case "end":
                            return _context3.stop();
                    }
                }
            }, null, _this4);
        }));
    },

    flatten_auths: function flatten_auths(auths) {
        var existingAuths = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _immutable2.default.List();

        if (!auths.size) {
            return existingAuths;
        }

        auths.forEach(function (owner) {
            if (!existingAuths.includes(owner.get(0))) {
                existingAuths = existingAuths.push(owner.get(0));
            }
        });
        return existingAuths;
    }
};

exports.default = permissionUtils;

/***/ }),
/* 585 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = __webpack_require__(27);

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _promise = __webpack_require__(4);

var _promise2 = _interopRequireDefault(_promise);

var _stringify = __webpack_require__(18);

var _stringify2 = _interopRequireDefault(_stringify);

var _regenerator = __webpack_require__(3);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _mutations2 = __webpack_require__(14);

var types = _interopRequireWildcard(_mutations2);

var _api = __webpack_require__(10);

var _api2 = _interopRequireDefault(_api);

var _helper = __webpack_require__(34);

var _helper2 = _interopRequireDefault(_helper);

var _bcxjsCores = __webpack_require__(7);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var initialState = {
  //ex_global_object:null
  last_current_aslot: 0
};

// let _last_current_aslot=0;
var _last_date_now = 0;
var actions = {
  getDataByIds: function getDataByIds(store, _ref) {
    var ids = _ref.ids;

    return _api2.default.Explorer.getDataByIds(ids);
  },
  queryTransaction: function queryTransaction(store, _ref2) {
    var _ref2$transactionId = _ref2.transactionId,
        transactionId = _ref2$transactionId === undefined ? "" : _ref2$transactionId;
    var result, transaction, operations, block_num, operation_results, parse_ops;
    return _regenerator2.default.async(function queryTransaction$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!/^[a-zA-Z\d]{64}$/.test(transactionId)) {
              _context.next = 20;
              break;
            }

            _context.next = 3;
            return _regenerator2.default.awrap(_api2.default.Explorer.getTransactionById(transactionId));

          case 3:
            result = _context.sent;

            if (!(result.code != 1)) {
              _context.next = 6;
              break;
            }

            return _context.abrupt('return', result);

          case 6:
            transaction = result.data;
            operations = transaction.operations, block_num = transaction.block_num, operation_results = transaction.operation_results;
            parse_ops = operations.map(function (op, op_index) {
              return {
                op: op,
                block_num: block_num,
                result: operation_results[op_index]
              };
            });
            _context.next = 11;
            return _regenerator2.default.awrap(_api2.default.Operations.parseOperations({ operations: parse_ops, store: store }));

          case 11:
            parse_ops = _context.sent;

            transaction.parse_ops = parse_ops.operations;
            transaction.trx_id = transactionId;
            transaction.expiration = new Date(transaction.expiration + "Z").format("yyyy/MM/dd HH:mm:ss");
            delete transaction.operations;
            delete transaction.operation_results;

            return _context.abrupt('return', {
              code: 1,
              data: transaction
            });

          case 20:
            return _context.abrupt('return', { code: 1011, message: "Parameter error" });

          case 21:
          case 'end':
            return _context.stop();
        }
      }
    }, null, undefined);
  },
  queryBlock: function queryBlock(store, params) {
    var _params$block, block, _params$isReqTrx, isReqTrx, _params$isParseTrx, isParseTrx, _params$maxOpCount, maxOpCount, _params$block_res, block_res, result;

    return _regenerator2.default.async(function queryBlock$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _params$block = params.block, block = _params$block === undefined ? "" : _params$block, _params$isReqTrx = params.isReqTrx, isReqTrx = _params$isReqTrx === undefined ? true : _params$isReqTrx, _params$isParseTrx = params.isParseTrx, isParseTrx = _params$isParseTrx === undefined ? true : _params$isParseTrx, _params$maxOpCount = params.maxOpCount, maxOpCount = _params$maxOpCount === undefined ? 1000000 : _params$maxOpCount, _params$block_res = params.block_res, block_res = _params$block_res === undefined ? null : _params$block_res;

            if (isParseTrx == undefined) {
              isParseTrx = true;
            }
            if (block && typeof block == "string") block = block.trim();

            if (/^\d+$/.test(block)) {
              _context4.next = 5;
              break;
            }

            return _context4.abrupt('return', {
              code: 1011,
              message: "Parameter error"
            });

          case 5:
            if (!(block_res && !isReqTrx)) {
              _context4.next = 9;
              break;
            }

            _context4.t0 = block_res;
            _context4.next = 12;
            break;

          case 9:
            _context4.next = 11;
            return _regenerator2.default.awrap(_api2.default.Operations.getBlock(block));

          case 11:
            _context4.t0 = _context4.sent;

          case 12:
            result = _context4.t0;

            if (!(result.code == 1)) {
              _context4.next = 16;
              break;
            }

            _context4.next = 16;
            return _regenerator2.default.awrap(function _callee2() {
              var _result$data, head_block_id, time, current_witness, current_transaction_count, blockInfo;

              return _regenerator2.default.async(function _callee2$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:

                      if (block_res && !isReqTrx) {
                        _result$data = result.data, head_block_id = _result$data.head_block_id, time = _result$data.time, current_witness = _result$data.current_witness, current_transaction_count = _result$data.current_transaction_count;

                        result.data = {
                          block_num: block,
                          block_height: block,
                          block_id: head_block_id,
                          witness: current_witness,
                          timestamp: time,
                          trx_count: current_transaction_count,
                          op_count: current_transaction_count
                        };
                      }

                      blockInfo = result.data;

                      blockInfo.time = new Date(blockInfo.timestamp + "Z").format("yyyy/MM/dd HH:mm:ss");
                      blockInfo.block_height = block;
                      _context3.next = 6;
                      return _regenerator2.default.awrap(_api2.default.Explorer.getWitnessName(blockInfo.witness));

                    case 6:
                      blockInfo.witness_name = _context3.sent;

                      if (!isReqTrx) {
                        _context3.next = 10;
                        break;
                      }

                      _context3.next = 10;
                      return _regenerator2.default.awrap(function _callee() {
                        var transactions, parse_ops, transaction, filter_transactions, trx_ops_count, i;
                        return _regenerator2.default.async(function _callee$(_context2) {
                          while (1) {
                            switch (_context2.prev = _context2.next) {
                              case 0:
                                transactions = blockInfo.transactions;
                                parse_ops = void 0;
                                transaction = void 0;
                                filter_transactions = [];
                                trx_ops_count = 0;

                                blockInfo.op_count = 0;
                                i = 0;

                              case 7:
                                if (!(i < transactions.length)) {
                                  _context2.next = 28;
                                  break;
                                }

                                transaction = transactions[i][1];
                                trx_ops_count = transaction.operations.length;
                                blockInfo.op_count += trx_ops_count;

                                if (!(!block_res && blockInfo.op_count < maxOpCount && isParseTrx)) {
                                  _context2.next = 22;
                                  break;
                                }

                                parse_ops = transaction.operations.map(function (op, op_index) {
                                  return {
                                    op: op,
                                    block_num: block,
                                    result: transaction.operation_results[op_index]
                                  };
                                });
                                _context2.next = 15;
                                return _regenerator2.default.awrap(_api2.default.Operations.parseOperations({ operations: parse_ops, store: store }));

                              case 15:
                                parse_ops = _context2.sent;

                                transaction.parse_ops = parse_ops.operations;
                                transaction.parse_ops = transaction.parse_ops.map(function (item) {
                                  item.date = blockInfo.time;
                                  return item;
                                });
                                delete transaction.operations;
                                delete transaction.operation_results;
                                _context2.next = 23;
                                break;

                              case 22:
                                parse_ops = transaction.operations;

                              case 23:

                                transaction.trx_id = transactions[i][0];
                                filter_transactions.push(transaction);

                              case 25:
                                i++;
                                _context2.next = 7;
                                break;

                              case 28:
                                blockInfo.transactions = filter_transactions;
                                blockInfo.trx_count = transactions.length;

                              case 30:
                              case 'end':
                                return _context2.stop();
                            }
                          }
                        }, null, undefined);
                      }());

                    case 10:
                    case 'end':
                      return _context3.stop();
                  }
                }
              }, null, undefined);
            }());

          case 16:
            return _context4.abrupt('return', result);

          case 17:
          case 'end':
            return _context4.stop();
        }
      }
    }, null, undefined);
  },
  set_last_current_aslot: function set_last_current_aslot(_ref3) {
    var commit = _ref3.commit;

    commit(types.SET_LAST_CURRENT_ASLOT, 0);
  },
  getDynGlobalObject: function getDynGlobalObject(store) {
    return _api2.default.Explorer.getDynGlobalObject(true, true);
  },
  getExplorerWitnesses: function getExplorerWitnesses(store) {
    var dispatch, rootGetters, state, commit, _last_current_aslot, globalObject, dynGlobalObject, _globalObject, active_witnesses, parameters, _dynGlobalObject, current_witness, current_witness_name, participation, witness_budget, next_maintenance_time, current_aslot, coreAsset, pow_precision;

    return _regenerator2.default.async(function getExplorerWitnesses$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            dispatch = store.dispatch, rootGetters = store.rootGetters, state = store.state, commit = store.commit;
            _last_current_aslot = state.last_current_aslot;
            globalObject = rootGetters["vote/globalObject"];

            if (globalObject) {
              _context5.next = 12;
              break;
            }

            _context5.next = 6;
            return _regenerator2.default.awrap(_api2.default.Explorer.getGlobalObject());

          case 6:
            globalObject = _context5.sent;

            if (!(globalObject.code != 1)) {
              _context5.next = 9;
              break;
            }

            return _context5.abrupt('return', globalObject);

          case 9:
            globalObject = globalObject.data;
            _context5.next = 13;
            break;

          case 12:
            globalObject = JSON.parse((0, _stringify2.default)(globalObject));

          case 13:
            _context5.next = 15;
            return _regenerator2.default.awrap(_api2.default.Explorer.getDynGlobalObject(true, true));

          case 15:
            dynGlobalObject = _context5.sent;

            if (!(dynGlobalObject.code != 1)) {
              _context5.next = 18;
              break;
            }

            return _context5.abrupt('return', dynGlobalObject);

          case 18:
            dynGlobalObject = dynGlobalObject.data;
            _globalObject = globalObject, active_witnesses = _globalObject.active_witnesses, parameters = _globalObject.parameters;
            _dynGlobalObject = dynGlobalObject, current_witness = _dynGlobalObject.current_witness, current_witness_name = _dynGlobalObject.current_witness_name, participation = _dynGlobalObject.participation, witness_budget = _dynGlobalObject.witness_budget, next_maintenance_time = _dynGlobalObject.next_maintenance_time, current_aslot = _dynGlobalObject.current_aslot;
            _context5.next = 23;
            return _regenerator2.default.awrap(dispatch("assets/fetchAssets", { assets: ["1.3.0"], isOne: true }, { root: true }));

          case 23:
            coreAsset = _context5.sent;
            pow_precision = Math.pow(10, coreAsset.precision);
            //  let all_witness=

            return _context5.abrupt('return', new _promise2.default(function (resolve) {
              dispatch("vote/getVoteObjects", { type: "witnesses", isExplorer: true, callback: function callback(res) {
                  if (res.code == 1) {
                    var date_now = void 0;
                    var witnesses = res.data.filter(function (item) {
                      return ("," + active_witnesses.join(",") + ",").indexOf("," + item.witness_id + ",") >= 0;
                    });
                    witnesses = witnesses.map(function (item) {
                      if (_last_current_aslot != current_aslot) {
                        commit(types.SET_LAST_CURRENT_ASLOT, current_aslot);
                        date_now = Date.now();
                        _last_date_now = date_now;
                      } else {
                        date_now = _last_date_now;
                      }
                      item.last_aslot_time = new Date(date_now - (current_aslot - item.last_aslot) * parameters.block_interval * 1000).format("yyyy/MM/dd HH:mm:ss");

                      return item;
                    });

                    participation = participation || 100;
                    resolve({
                      code: 1,
                      data: {
                        current_witness: current_witness,
                        current_witness_name: current_witness_name,
                        active_witnesses: active_witnesses,
                        participation: participation,
                        witness_pay_per_block: _helper2.default.getFullNum(parameters.witness_pay_per_block / pow_precision),
                        witness_budget: _helper2.default.getFullNum(witness_budget / pow_precision),
                        next_maintenance_time: new Date(next_maintenance_time + "Z").format("yyyy/MM/dd HH:mm:ss"),
                        witnesses: witnesses,
                        core_asset_symbol: coreAsset.symbol
                      }
                    });
                  } else {
                    resolve(res);
                  }
                } }, { root: true });
            }));

          case 26:
          case 'end':
            return _context5.stop();
        }
      }
    }, null, undefined);
  }
};

var mutations = (0, _defineProperty3.default)({}, types.SET_LAST_CURRENT_ASLOT, function (state, aslot) {
  state.last_current_aslot = aslot;
});

exports.default = {
  state: initialState,
  actions: actions,
  // getters,
  mutations: mutations,
  namespaced: true
};

/***/ }),
/* 586 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _promise = __webpack_require__(4);

var _promise2 = _interopRequireDefault(_promise);

var _getIterator2 = __webpack_require__(52);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _set = __webpack_require__(245);

var _set2 = _interopRequireDefault(_set);

var _mutations = __webpack_require__(14);

var types = _interopRequireWildcard(_mutations);

var _idbInstance = __webpack_require__(60);

var _idbInstance2 = _interopRequireDefault(_idbInstance);

var _bcxjsCores = __webpack_require__(7);

var _bcxjsWs = __webpack_require__(8);

var _immutable = __webpack_require__(23);

var _immutable2 = _interopRequireDefault(_immutable);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _saveAddyMapTimeout = 0;
var _loadAddyMapPromise;
var initialState = {
    addresses: _immutable2.default.Map(),
    saving: false,
    pubkeys: new _set2.default()
};
var getters = {};

var actions = {
    add: function add(_ref, pubkey) {
        var dispatch = _ref.dispatch,
            state = _ref.state;

        dispatch("loadAddyMap").then(function () {
            var dirty = false;
            if (state.pubkeys[pubkey]) return;
            state.pubkeys.add(pubkey);
            dispatch("saving");
            // Gather all 5 legacy address formats (see key.addresses)
            var address_strings = _bcxjsCores.key.addresses(pubkey);
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = (0, _getIterator3.default)(address_strings), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var address = _step.value;

                    state.addresses = state.addresses.set(address, pubkey);
                    dirty = true;
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            if (dirty) {
                dispatch("saveAddyMap");
            } else state.saving = false;
        }).catch(function (e) {
            throw e;
        });
    },
    /** Worker thread implementation (for more than 10K keys) */
    addAll: function addAll(_ref2, pubkeys) {
        var dispatch = _ref2.dispatch,
            state = _ref2.state;

        return new _promise2.default(function (resolve, reject) {
            state.saving = true;
            dispatch("loadAddyMap").then(function () {
                // var AddressIndexWorker = require("worker?name=/[hash].js!../workers/AddressIndexWorker")
                // var worker = new AddressIndexWorker
                // worker.postMessage({ pubkeys, address_prefix: ChainConfig.address_prefix });


                // try {
                //     console.log("AddressIndexWorker start");
                //     var {pubkeys, address_prefix} = event.data
                //     var results = []
                //     for (let pubkey of pubkeys) {
                //         results.push( key.addresses(pubkey, address_prefix) )
                //     }
                //     postMessage( results )
                //     console.log("AddressIndexWorker done");
                // } catch( e ) { 
                //     console.error("AddressIndexWorker", e) 
                // } 
                // console.info("key",key);
                var results = [_bcxjsCores.key.addresses(pubkeys[0], _bcxjsWs.ChainConfig.address_prefix)];
                try {
                    var key_addresses = results;
                    var dirty = false;
                    var addresses = state.addresses.withMutations(function (addresses) {
                        for (var i = 0; i < pubkeys.length; i++) {
                            var pubkey = pubkeys[i];
                            if (state.pubkeys.has(pubkey)) continue;
                            state.pubkeys.add(pubkey);
                            // Gather all 5 legacy address formats (see key.addresses)
                            var address_strings = key_addresses[i];
                            var _iteratorNormalCompletion2 = true;
                            var _didIteratorError2 = false;
                            var _iteratorError2 = undefined;

                            try {
                                for (var _iterator2 = (0, _getIterator3.default)(address_strings), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                    var address = _step2.value;

                                    addresses.set(address, pubkey);
                                    dirty = true;
                                }
                            } catch (err) {
                                _didIteratorError2 = true;
                                _iteratorError2 = err;
                            } finally {
                                try {
                                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                                        _iterator2.return();
                                    }
                                } finally {
                                    if (_didIteratorError2) {
                                        throw _iteratorError2;
                                    }
                                }
                            }
                        }
                    });
                    if (dirty) {
                        state.addresses = addresses;
                        dispatch("saveAddyMap");
                    } else {
                        state.saving = false;
                    }
                    resolve();
                } catch (e) {
                    console.error('AddressIndex.addAll', e);reject(e);
                }
            }).catch(function (e) {
                throw e;
            });
        });
    },
    loadAddyMap: function loadAddyMap(_ref3) {
        var commit = _ref3.commit,
            state = _ref3.state;

        if (_loadAddyMapPromise) return _loadAddyMapPromise;
        _loadAddyMapPromise = _idbInstance2.default.root.getProperty("AddressIndex").then(function (map) {
            state.addresses = map ? _immutable2.default.Map(map) : _immutable2.default.Map();
            // console.log("AddressIndex load", this.state.addresses.size)
            state.addresses.valueSeq().forEach(function (pubkey) {
                return state.pubkeys.add(pubkey);
            });
        });
        return _loadAddyMapPromise;
    },
    saving: function saving(_ref4) {
        var state = _ref4.state;

        if (state.saving) return;
        state.saving = true;
    },

    saveAddyMap: function saveAddyMap(_ref5) {
        var state = _ref5.state;

        clearTimeout(_saveAddyMapTimeout);
        _saveAddyMapTimeout = setTimeout(function () {
            console.log("AddressIndex save", state.addresses.size);
            state.saving = false;
            // If indexedDB fails to save, it will re-try via PrivateKeyStore calling this.add
            return _idbInstance2.default.root.setProperty("AddressIndex", state.addresses.toObject());
        }, 100);
    }
};

var mutations = {};

exports.default = {
    state: initialState,
    actions: actions,
    mutations: mutations,
    getters: getters,
    namespaced: true
};

/***/ }),
/* 587 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _getIterator2 = __webpack_require__(52);

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _regenerator = __webpack_require__(3);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _keys = __webpack_require__(24);

var _keys2 = _interopRequireDefault(_keys);

var _promise = __webpack_require__(4);

var _promise2 = _interopRequireDefault(_promise);

var _mutations = __webpack_require__(14);

var types = _interopRequireWildcard(_mutations);

var _idbInstance = __webpack_require__(60);

var _idbInstance2 = _interopRequireDefault(_idbInstance);

var _immutable = __webpack_require__(23);

var _immutable2 = _interopRequireDefault(_immutable);

var _bcxjsCores = __webpack_require__(7);

var _PrivateKeyStore = __webpack_require__(150);

var _PrivateKeyStore2 = _interopRequireDefault(_PrivateKeyStore);

var _api = __webpack_require__(10);

var _api2 = _interopRequireDefault(_api);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _chainstore_account_ids_by_key = void 0;
var _no_account_refs = void 0;
var initialState = {
    account_refs: _immutable2.default.Set()
};
var getters = {
    account_refs: function account_refs(state) {
        return state.account_refs;
    }
};

var actions = {
    loadDbData: function loadDbData(_ref) {
        var commit = _ref.commit,
            dispatch = _ref.dispatch;

        commit("_getInitialState");
        return loadNoAccountRefs().then(function (no_account_refs) {
            return _no_account_refs = no_account_refs;
        }).then(function () {
            chainStoreUpdate({ dispatch: dispatch });
        });
    },
    checkPrivateKeyStore: function checkPrivateKeyStore(_ref2) {
        var rootGetters = _ref2.rootGetters,
            state = _ref2.state;
        var no_account_refs, account_refs, keys;
        return _regenerator2.default.async(function checkPrivateKeyStore$(_context3) {
            while (1) {
                switch (_context3.prev = _context3.next) {
                    case 0:
                        no_account_refs = _no_account_refs;
                        account_refs = _immutable2.default.Set();
                        //.keySeq()

                        keys = rootGetters["PrivateKeyStore/keys"];
                        _context3.next = 5;
                        return _regenerator2.default.awrap(_promise2.default.all((0, _keys2.default)(keys).map(function _callee(pubkey) {
                            var refs, private_key_object;
                            return _regenerator2.default.async(function _callee$(_context) {
                                while (1) {
                                    switch (_context.prev = _context.next) {
                                        case 0:
                                            if (!no_account_refs.has(pubkey)) {
                                                _context.next = 2;
                                                break;
                                            }

                                            return _context.abrupt("return");

                                        case 2:
                                            if (!(pubkey != "undefined")) {
                                                _context.next = 7;
                                                break;
                                            }

                                            _context.next = 5;
                                            return _regenerator2.default.awrap(_api2.default.Account.getAccountIdByOwnerPubkey(pubkey));

                                        case 5:
                                            refs = _context.sent;
                                            //ChainStore.getAccountRefsOfKey(pubkey)
                                            refs = _immutable2.default.fromJS(refs);

                                        case 7:
                                            if (!(refs === undefined)) {
                                                _context.next = 9;
                                                break;
                                            }

                                            return _context.abrupt("return");

                                        case 9:
                                            if (refs.size) {
                                                _context.next = 15;
                                                break;
                                            }

                                            // Do Not block brainkey generated keys.. Those are new and
                                            // account references may be pending.
                                            private_key_object = rootGetters["PrivateKeyStore/keys"][pubkey];

                                            if (!(typeof private_key_object.brainkey_sequence === 'number')) {
                                                _context.next = 13;
                                                break;
                                            }

                                            return _context.abrupt("return");

                                        case 13:
                                            no_account_refs = no_account_refs.add(pubkey);
                                            return _context.abrupt("return");

                                        case 15:
                                            account_refs = account_refs.add(refs.valueSeq());

                                        case 16:
                                        case "end":
                                            return _context.stop();
                                    }
                                }
                            }, null, undefined);
                        })));

                    case 5:
                        account_refs = account_refs.flatten();

                        _context3.next = 8;
                        return _regenerator2.default.awrap(_promise2.default.all(account_refs.map(function _callee2(account) {
                            var refs;
                            return _regenerator2.default.async(function _callee2$(_context2) {
                                while (1) {
                                    switch (_context2.prev = _context2.next) {
                                        case 0:
                                            _context2.next = 2;
                                            return _regenerator2.default.awrap(_api2.default.Account.getAccountRefsOfAccount(account));

                                        case 2:
                                            refs = _context2.sent;
                                            //ChainStore.getAccountRefsOfAccount(account);
                                            refs = _immutable2.default.fromJS(refs);

                                            if (!(refs === undefined)) {
                                                _context2.next = 6;
                                                break;
                                            }

                                            return _context2.abrupt("return");

                                        case 6:
                                            if (refs.size) {
                                                _context2.next = 8;
                                                break;
                                            }

                                            return _context2.abrupt("return");

                                        case 8:
                                            account_refs = account_refs.add(refs.valueSeq());

                                        case 9:
                                        case "end":
                                            return _context2.stop();
                                    }
                                }
                            }, null, undefined);
                        })));

                    case 8:

                        account_refs = account_refs.flatten();

                        if (!state.account_refs.equals(account_refs)) {
                            state.account_refs = account_refs;
                        }
                        if (!_no_account_refs.equals(no_account_refs)) {
                            _no_account_refs = no_account_refs;
                            saveNoAccountRefs(no_account_refs);
                        }
                        return _context3.abrupt("return", true);

                    case 12:
                    case "end":
                        return _context3.stop();
                }
            }
        }, null, undefined);
    }
};

function saveNoAccountRefs(no_account_refs) {
    var array = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = (0, _getIterator3.default)(no_account_refs), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var pubkey = _step.value;
            array.push(pubkey);
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    _idbInstance2.default.root.setProperty("no_account_refs", array);
}

// Performance optimization for large wallets
function loadNoAccountRefs() {
    return _idbInstance2.default.root.getProperty("no_account_refs", []).then(function (array) {
        return _immutable2.default.Set(array);
    });
}

var chainStoreUpdate = function chainStoreUpdate(_ref3) {
    var dispatch = _ref3.dispatch;

    if (_chainstore_account_ids_by_key === _bcxjsCores.ChainStore.account_ids_by_key) return;
    _chainstore_account_ids_by_key = _bcxjsCores.ChainStore.account_ids_by_key;
    dispatch("checkPrivateKeyStore");
};
var mutations = {
    _getInitialState: function _getInitialState(state) {
        _chainstore_account_ids_by_key = null;
        state.account_refs = _immutable2.default.Set();
    }
};

exports.default = {
    state: initialState,
    actions: actions,
    mutations: mutations,
    getters: getters,
    namespaced: true
};

/***/ }),
/* 588 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _promise = __webpack_require__(4);

var _promise2 = _interopRequireDefault(_promise);

var _regenerator = __webpack_require__(3);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _mutations = __webpack_require__(14);

var types = _interopRequireWildcard(_mutations);

var _idbInstance = __webpack_require__(60);

var _idbInstance2 = _interopRequireDefault(_idbInstance);

var _immutable = __webpack_require__(23);

var _immutable2 = _interopRequireDefault(_immutable);

var _bcxjsCores = __webpack_require__(7);

var _PrivateKeyStore = __webpack_require__(150);

var _PrivateKeyStore2 = _interopRequireDefault(_PrivateKeyStore);

var _bcxjsWs = __webpack_require__(8);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var initialState = {
    new_wallet: undefined, // pending restore
    current_wallet: undefined,
    wallet_names: _immutable2.default.Set()
};

var getters = {
    current_wallet: function current_wallet(state) {
        return state.current_wallet;
    },
    wallet: function wallet(state) {
        return state;
    }
};

var actions = {
    init: function init(_ref) {
        var state = _ref.state;

        return _idbInstance2.default.root.getProperty("current_wallet").then(function (current_wallet) {
            return _idbInstance2.default.root.getProperty("wallet_names", []).then(function (wallet_names) {
                state.wallet_names = _immutable2.default.Set(wallet_names);
                state.current_wallet = current_wallet;
            });
        });
    },
    setWallet: function setWallet(_ref2, _ref3) {
        var dispatch = _ref2.dispatch;
        var wallet_name = _ref3.wallet_name,
            create_wallet_password = _ref3.create_wallet_password,
            brnkey = _ref3.brnkey;
        return _regenerator2.default.async(function setWallet$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        // WalletUnlockActions.lock();
                        if (!wallet_name) wallet_name = "default";

                        return _context.abrupt("return", dispatch("onSetWallet", { wallet_name: wallet_name, create_wallet_password: create_wallet_password, brnkey: brnkey }));

                    case 2:
                    case "end":
                        return _context.stop();
                }
            }
        }, null, undefined);
    },
    onSetWallet: function onSetWallet(_ref4, _ref5) {
        var state = _ref4.state,
            dispatch = _ref4.dispatch;
        var _ref5$wallet_name = _ref5.wallet_name,
            wallet_name = _ref5$wallet_name === undefined ? "default" : _ref5$wallet_name,
            create_wallet_password = _ref5.create_wallet_password,
            brnkey = _ref5.brnkey,
            resolve = _ref5.resolve;

        var p = new _promise2.default(function (resolve) {
            if (/[^a-z0-9_-]/.test(wallet_name) || wallet_name === "") throw new Error("Invalid wallet name");

            if (state.current_wallet === wallet_name) {
                resolve();
                return;
            }

            var add = void 0;
            if (!state.wallet_names.has(wallet_name)) {
                var wallet_names = state.wallet_names.add(wallet_name);
                add = _idbInstance2.default.root.setProperty("wallet_names", wallet_names);
                state.wallet_names = wallet_names;
            }

            var current = _idbInstance2.default.root.setProperty("current_wallet", wallet_name);
            resolve(_promise2.default.all([add, current]).then(function () {
                // Restart the database before current application initializing its new status
                _idbInstance2.default.close();
                _bcxjsCores.ChainStore.clearCache();
                // BalanceClaimActiveStore.reset()
                // Store may be reset when calling loadDbData
                // United Labs of BCTech.

                return _idbInstance2.default.init_instance().init_promise.then(function () {
                    // before calling CachedPropertyStore.reset(), make sure the database is standby
                    // CachedPropertyStore.reset()

                    dispatch("CachedPropertyStore/reset", null, { root: true });
                    return _promise2.default.all([dispatch("WalletDb/loadDbData", null, { root: true }).then(function () {
                        dispatch("AccountStore/loadDbData", null, { root: true });
                    }), dispatch("PrivateKeyStore/loadDbData", null, { root: true }).then(function () {
                        return dispatch("AccountRefsStore/loadDbData", null, { root: true });
                    })]).then(function () {
                        // Update status again in order to re-render listeners
                        if (!create_wallet_password) {
                            state.current_wallet = wallet_name;
                            return;
                        }
                        return dispatch("WalletDb/_createWallet", { password_plaintext: create_wallet_password,
                            brainkey_plaintext: brnkey, //brainkey,
                            unlock: true, //unlock
                            public_name: wallet_name
                        }, { root: true }).then(function (res) {
                            state.current_wallet = wallet_name;
                        });
                    });
                });
            }));
        }).catch(function (error) {
            console.error(error);
            return _promise2.default.reject(error);
        });
        return p;
        // if (resolve) resolve(p)
    },
    getBackupName: function getBackupName(_ref6) {
        var getters = _ref6.getters;

        var name = getters.current_wallet;
        var address_prefix = _bcxjsWs.ChainConfig.address_prefix.toLowerCase();
        if (name.indexOf(address_prefix) !== 0) name = address_prefix + "_" + name;
        var date = new Date();
        var month = date.getMonth() + 1;
        var day = date.getDate();
        var stampedName = name + "_" + date.getFullYear() + (month >= 10 ? month : "0" + month) + (day >= 10 ? day : "0" + day);
        name = stampedName + ".bin";
        return name;
    },
    setNewWallet: function setNewWallet(_ref7, new_wallet) {
        var state = _ref7.state;

        state.new_wallet = new_wallet;
    },
    restore: function restore(_ref8, _ref9) {
        var dispatch = _ref8.dispatch;
        var wallet_name = _ref9.wallet_name,
            wallet_object = _ref9.wallet_object;

        return _idbInstance2.default.restore(wallet_name, wallet_object).then(function () {
            return dispatch("onSetWallet", { wallet_name: wallet_name });
        }).catch(function (error) {
            console.error(error);
            return _promise2.default.reject(error);
        });
    },
    deleteWallet: function deleteWallet(_ref10) {
        var state = _ref10.state,
            dispatch = _ref10.dispatch;

        var delete_wallet_name = state.current_wallet;
        dispatch("AccountStore/setCurrentAccount", null, { root: true });
        if (!delete_wallet_name) {
            return { code: 154, message: "Please restore your wallet first" };
        }
        return new _promise2.default(function (resolve) {
            var current_wallet = state.current_wallet,
                wallet_names = state.wallet_names;


            if (!wallet_names.has(delete_wallet_name)) {
                return { code: 157, message: "Can't delete wallet, does not exist in index"
                    // throw new Error("Can't delete wallet, does not exist in index. United Labs of BCTech.")
                };
            }
            wallet_names = wallet_names.delete(delete_wallet_name);

            var add = true,
                current = true;
            add = _idbInstance2.default.root.setProperty("wallet_names", wallet_names);

            if (current_wallet === delete_wallet_name) {
                current_wallet = wallet_names.size ? wallet_names.first() : undefined;
                current = _idbInstance2.default.root.setProperty("current_wallet", current_wallet);
                if (current_wallet) dispatch("onSetWallet", { wallet_name: current_wallet });
            }
            state.current_wallet = current_wallet;
            state.wallet_names = wallet_names;

            _promise2.default.all([add, current]).then(function () {
                var database_name = _idbInstance2.default.getDatabaseName(delete_wallet_name);
                var req = _idbInstance2.default.impl.deleteDatabase(database_name);
                _idbInstance2.default.close();
                dispatch("WalletDb/deleteWallet", null, { root: true });
                dispatch("account/_logout", null, { root: true });
                resolve({ code: 1, data: database_name });
            });
        });
    }
};

var mutations = {
    _getInitialState: function _getInitialState(state) {
        _chainstore_account_ids_by_key = null;
        state.account_refs = _immutable2.default.Set();
    }
};

exports.default = {
    state: initialState,
    actions: actions,
    mutations: mutations,
    getters: getters,
    namespaced: true
};

/***/ }),
/* 589 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _mutations = __webpack_require__(14);

var types = _interopRequireWildcard(_mutations);

var _idbInstance = __webpack_require__(60);

var _idbInstance2 = _interopRequireDefault(_idbInstance);

var _immutable = __webpack_require__(23);

var _immutable2 = _interopRequireDefault(_immutable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var initialState = {
    props: _immutable2.default.Map()
};

var getters = {};

var actions = {
    reset: function reset(_ref) {
        var state = _ref.state;

        state.props = _immutable2.default.Map();
    },
    Set: function Set(_ref2, _ref3) {
        var state = _ref2.state;
        var name = _ref3.name,
            value = _ref3.value;

        if (state.props.get(name) === value) return;
        var props = state.props.set(name, value);
        state.props = props;
        _idbInstance2.default.setCachedProperty(name, value).then(function () {
            //state.props = props
        });
    }
};

var mutations = {};

exports.default = {
    state: initialState,
    actions: actions,
    mutations: mutations,
    getters: getters,
    namespaced: true
};

/***/ }),
/* 590 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _regenerator = __webpack_require__(3);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _promise = __webpack_require__(4);

var _promise2 = _interopRequireDefault(_promise);

var _assign = __webpack_require__(56);

var _assign2 = _interopRequireDefault(_assign);

var _mutations = __webpack_require__(14);

var types = _interopRequireWildcard(_mutations);

var _idbInstance = __webpack_require__(60);

var _idbInstance2 = _interopRequireDefault(_idbInstance);

var _immutable = __webpack_require__(23);

var _immutable2 = _interopRequireDefault(_immutable);

var _bcxjsCores = __webpack_require__(7);

var _fileSaver = __webpack_require__(591);

var _backup = __webpack_require__(407);

var _bcxjsWs = __webpack_require__(8);

var _api = __webpack_require__(10);

var _api2 = _interopRequireDefault(_api);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _chainstore_account_ids_by_key = void 0;
var _no_account_refs = void 0;
var initialState = {
    backup: {
        name: null,
        contents: null,
        sha1: null,
        size: null,
        last_modified: null,
        public_key: null,
        wallet_object: null
    }
};
var getters = {
    backup: function backup(state) {
        return state.backup;
    }
};

var actions = {
    reset: function reset(_ref) {
        var state = _ref.state;

        state.backup = {
            name: null,
            contents: null,
            sha1: null,
            size: null,
            last_modified: null,
            public_key: null,
            wallet_object: null
        };
    },
    incommingBuffer: function incommingBuffer(_ref2, _ref3) {
        var dispatch = _ref2.dispatch,
            state = _ref2.state;
        var name = _ref3.name,
            contents = _ref3.contents,
            public_key = _ref3.public_key;

        dispatch("reset");
        var sha1 = _bcxjsCores.hash.sha1(contents).toString('hex');
        var size = contents.length;
        if (!public_key) public_key = getBackupPublicKey(contents);
        // state.backup={
        //     name,
        //     contents,
        //     sha1,
        //     size,
        //     public_key
        // }
        state.backup = (0, _assign2.default)(state.backup, {
            name: name, contents: contents, sha1: sha1, size: size, public_key: public_key
        });
        return { code: 1 };
    },
    download: function download(_ref4) {
        var getters = _ref4.getters,
            dispatch = _ref4.dispatch;

        var isFileSaverSupported = false;
        try {
            isFileSaverSupported = !!new Blob();
        } catch (e) {}
        if (!isFileSaverSupported) {
            return { code: 151, message: "File saving is not supported" };
        }
        var backup = getters.backup;
        var blob = new Blob([backup.contents], {
            type: "application/octet-stream; charset=us-ascii"
            //type: "text/plain;charset=us-ascii"
        });

        if (blob.size !== backup.size) {
            return { code: 152, message: "Invalid backup to download conversion" };
        }
        saveFile(blob, backup.name);
        dispatch("WalletDb/setBackupDate", null, { root: true });

        return { code: 1 };
    },
    incommingWebFile: function incommingWebFile(_ref5, _ref6) {
        var dispatch = _ref5.dispatch;
        var file = _ref6.file;

        return new _promise2.default(function (resolve) {
            var reader = new FileReader();
            reader.onload = function (evt) {
                var contents = new Buffer(evt.target.result, "binary");
                var name = file.name;
                var last_modified = file.lastModifiedDate.toString();

                resolve({ name: name, contents: contents, last_modified: last_modified });
            };
            reader.readAsBinaryString(file);
        }).then(function (result) {
            return dispatch("onIncommingFile", result);
        }).catch(function (error) {
            return { code: 155, message: "Your browser may not support wallet file recovery", error: error };
        });
    },
    onIncommingFile: function onIncommingFile(_ref7, _ref8) {
        var state = _ref7.state;
        var name = _ref8.name,
            contents = _ref8.contents,
            last_modified = _ref8.last_modified;

        var sha1 = _bcxjsCores.hash.sha1(contents).toString('hex');
        var size = contents.length;
        var public_key = getBackupPublicKey(contents);
        if (!public_key) {
            return { code: 173, message: "Please select the correct wallet file" };
        }
        state.backup = (0, _assign2.default)(state.backup, {
            name: name, contents: contents, sha1: sha1, size: size, last_modified: last_modified, public_key: public_key
        });
        return { code: 1, data: state.backup };
        // this.setState({ name, contents, sha1, size, last_modified, public_key })
    },

    onRestore: function onRestore(_ref9, _ref10) {
        var dispatch = _ref9.dispatch,
            state = _ref9.state,
            rootGetters = _ref9.rootGetters;
        var password = _ref10.password;
        var backup, wallet, has_current_wallet, wallet_name, private_key, contents;
        return _regenerator2.default.async(function onRestore$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        if (!rootGetters["WalletDb/wallet"]) {
                            _context.next = 4;
                            break;
                        }

                        return _context.abrupt("return", { code: 163, message: "The wallet already exists. Please try importing the private key" });

                    case 4:
                        _context.next = 6;
                        return _regenerator2.default.awrap(dispatch("account/_logout", null, { root: true }));

                    case 6:
                        backup = state.backup;
                        wallet = rootGetters["WalletManagerStore/wallet"];
                        has_current_wallet = !!wallet.current_wallet;
                        wallet_name = "";

                        if (!has_current_wallet) {
                            wallet_name = "default";
                        } else if (backup.name) {
                            wallet_name = backup.name.match(/[a-z0-9_-]*/)[0];
                        }

                        private_key = _bcxjsCores.PrivateKey.fromSeed(password || "");
                        contents = backup.contents;
                        return _context.abrupt("return", (0, _backup.decryptWalletBackup)(private_key.toWif(), contents).then(function (wallet_object) {
                            var brainkey_pubkey = wallet_object.wallet[0].brainkey_pubkey;
                            var coreAssetSymbol = brainkey_pubkey.substr(0, brainkey_pubkey.length - 50);
                            if (_bcxjsWs.ChainConfig.address_prefix != coreAssetSymbol) {
                                return { code: 158, message: 'Imported Wallet core assets can not be ' + coreAssetSymbol + ", and it should be " + _bcxjsWs.ChainConfig.address_prefix };
                            }
                            var g_wallet = rootGetters["WalletDb/wallet"];
                            if (g_wallet && wallet_object.wallet[0].brainkey_pubkey == g_wallet.brainkey_pubkey) {
                                return { code: 156, message: 'The wallet has been imported. Do not repeat import' };
                            }
                            var wallet_chain_id = wallet_object.wallet[0].chain_id;
                            if (wallet_chain_id != _bcxjsWs.ChainConfig.chain_id) {
                                return { code: 166, message: "The Wallet Chain ID does not match the current chain configuration information. The chain ID of the wallet is:" + wallet_chain_id };
                            }

                            state.backup.wallet_object = wallet_object;
                            wallet_object.private_keys.forEach(function (keyObj) {
                                dispatch("PrivateKeyStore/setKeys", keyObj, { root: true });
                            });

                            return dispatch("checkNewName", password);
                        }).catch(function (error) {
                            console.log("Error verifying wallet " + backup.name, error);
                            if (error === "invalid_decryption_key") {
                                return { code: 105, message: "wrong password" };
                            } else {
                                return { code: 0, message: error.message, error: error };
                            }
                        }));

                    case 14:
                    case "end":
                        return _context.stop();
                }
            }
        }, null, undefined);
    },
    checkNewName: function checkNewName(_ref11) {
        var dispatch = _ref11.dispatch,
            state = _ref11.state,
            rootGetters = _ref11.rootGetters;
        var has_current_wallet, backup, walletName, new_wallet, userId, acc_res;
        return _regenerator2.default.async(function checkNewName$(_context2) {
            while (1) {
                switch (_context2.prev = _context2.next) {
                    case 0:
                        has_current_wallet = !!rootGetters["WalletManagerStore/wallet"].current_wallet;
                        backup = state.backup;

                        if (has_current_wallet) {
                            _context2.next = 11;
                            break;
                        }

                        walletName = "default";

                        if (backup.name) {
                            walletName = backup.name.match(/[a-z0-9_-]*/)[0];
                        }
                        _context2.next = 7;
                        return _regenerator2.default.awrap(dispatch("WalletManagerStore/setNewWallet", walletName, { root: true }));

                    case 7:
                        // WalletActions.restore(name, this.props.backup.wallet_object);
                        state.accept = true;
                        state.new_wallet = walletName;
                        _context2.next = 11;
                        return _regenerator2.default.awrap(dispatch("WalletManagerStore/restore", { wallet_name: walletName, wallet_object: backup.wallet_object }, { root: true }));

                    case 11:

                        if (has_current_wallet && backup.name && !state.new_wallet) {
                            new_wallet = backup.name.match(/[a-z0-9_-]*/)[0];

                            if (new_wallet) state.new_wallet = new_wallet;
                        }

                        _context2.next = 14;
                        return _regenerator2.default.awrap(_api2.default.Account.getAccountIdByOwnerPubkey(backup.wallet_object.private_keys[0].pubkey));

                    case 14:
                        userId = _context2.sent;

                        userId = userId && userId[0];

                        if (userId) {
                            _context2.next = 18;
                            break;
                        }

                        return _context2.abrupt("return", { code: 165, message: "There is no account information in the wallet on the chain" });

                    case 18:
                        _context2.next = 20;
                        return _regenerator2.default.awrap(_api2.default.Account.getUser(userId, true));

                    case 20:
                        acc_res = _context2.sent;

                        if (!(acc_res.code != 1)) {
                            _context2.next = 23;
                            break;
                        }

                        return _context2.abrupt("return", acc_res);

                    case 23:

                        if (!backup.wallet_object.linked_accounts.length) {
                            backup.wallet_object.linked_accounts = [{
                                name: acc_res.data.account.name,
                                chainId: backup.wallet_object.wallet[0].chain_id
                            }];
                        }

                        _context2.next = 26;
                        return _regenerator2.default.awrap(dispatch("AccountStore/setCurrentAccount", backup.wallet_object.linked_accounts[0].name, { root: true }));

                    case 26:
                        _context2.next = 28;
                        return _regenerator2.default.awrap(dispatch("account/getAccountInfo", null, { root: true }));

                    case 28:
                        return _context2.abrupt("return", _context2.sent);

                    case 29:
                    case "end":
                        return _context2.stop();
                }
            }
        }, null, undefined);
    }

};

function saveFile(obj, name) {
    if (window.requestFileSystem !== undefined) {
        console.debug('use window.requestFileSystem');
        window.requestFileSystem(LocalFileSystem.PERSISTENT, 0, function (fileSystem) {
            fileSystem.root.getDirectory('Download', { create: true }, function (dirTry) {
                dirTry.getFile(name, { create: true, exclusive: false }, function (entry) {
                    var fileUrl = entry.toURL();
                    entry.createWriter(function (writer) {
                        writer.onwriteend = function (evt) {
                            //console.debug("Successfully saved file to " + fileUrl);
                            NotificationActions.success("Successfully saved file to " + fileUrl);
                        };
                        // Write to the file
                        writer.write(obj);
                    }, function (error) {
                        //console.debug("Error: Could not create file writer, " + error.code);
                        NotificationActions.error("Could not create file writer, " + error.code);
                    });
                }, function (error) {
                    //console.debug("Error: Could not create file, " + error.code);
                    NotificationActions.error("Could not create file, " + error.code);
                });
            }, function (error) {
                NotificationActions.error("Could not create dir, " + error.code);
            });
        }, function (evt) {
            //console.debug("Error: Could not access file system, " + evt.target.error.code);
            NotificationActions.error("Could not access file system, " + evt.target.error.code);
        });
    } else {
        console.debug('not window.requestFileSystem');
        // console.info("saveAs",saveAs);
        (0, _fileSaver.saveAs)(obj, name);
    }
}

function getBackupPublicKey(contents) {
    try {
        return _bcxjsCores.PublicKey.fromBuffer(contents.slice(0, 33));
    } catch (e) {
        //console.error(e, e.stack);
        return false;
    }
}

exports.default = {
    state: initialState,
    actions: actions,
    getters: getters,
    namespaced: true
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ }),
/* 591 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/* FileSaver.js
 * A saveAs() FileSaver implementation.
 * 1.3.2
 * 2016-06-16 18:25:19
 *
 * By Eli Grey, http://eligrey.com
 * License: MIT
 *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
 */

/*global self */
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

var saveAs = saveAs || (function(view) {
	"use strict";
	// IE <10 is explicitly unsupported
	if (typeof view === "undefined" || typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
		return;
	}
	var
		  doc = view.document
		  // only get URL when necessary in case Blob.js hasn't overridden it yet
		, get_URL = function() {
			return view.URL || view.webkitURL || view;
		}
		, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
		, can_use_save_link = "download" in save_link
		, click = function(node) {
			var event = new MouseEvent("click");
			node.dispatchEvent(event);
		}
		, is_safari = /constructor/i.test(view.HTMLElement) || view.safari
		, is_chrome_ios =/CriOS\/[\d]+/.test(navigator.userAgent)
		, throw_outside = function(ex) {
			(view.setImmediate || view.setTimeout)(function() {
				throw ex;
			}, 0);
		}
		, force_saveable_type = "application/octet-stream"
		// the Blob API is fundamentally broken as there is no "downloadfinished" event to subscribe to
		, arbitrary_revoke_timeout = 1000 * 40 // in ms
		, revoke = function(file) {
			var revoker = function() {
				if (typeof file === "string") { // file is an object URL
					get_URL().revokeObjectURL(file);
				} else { // file is a File
					file.remove();
				}
			};
			setTimeout(revoker, arbitrary_revoke_timeout);
		}
		, dispatch = function(filesaver, event_types, event) {
			event_types = [].concat(event_types);
			var i = event_types.length;
			while (i--) {
				var listener = filesaver["on" + event_types[i]];
				if (typeof listener === "function") {
					try {
						listener.call(filesaver, event || filesaver);
					} catch (ex) {
						throw_outside(ex);
					}
				}
			}
		}
		, auto_bom = function(blob) {
			// prepend BOM for UTF-8 XML and text/* types (including HTML)
			// note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF
			if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
				return new Blob([String.fromCharCode(0xFEFF), blob], {type: blob.type});
			}
			return blob;
		}
		, FileSaver = function(blob, name, no_auto_bom) {
			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
			// First try a.download, then web filesystem, then object URLs
			var
				  filesaver = this
				, type = blob.type
				, force = type === force_saveable_type
				, object_url
				, dispatch_all = function() {
					dispatch(filesaver, "writestart progress write writeend".split(" "));
				}
				// on any filesys errors revert to saving with object URLs
				, fs_error = function() {
					if ((is_chrome_ios || (force && is_safari)) && view.FileReader) {
						// Safari doesn't allow downloading of blob urls
						var reader = new FileReader();
						reader.onloadend = function() {
							var url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');
							var popup = view.open(url, '_blank');
							if(!popup) view.location.href = url;
							url=undefined; // release reference before dispatching
							filesaver.readyState = filesaver.DONE;
							dispatch_all();
						};
						reader.readAsDataURL(blob);
						filesaver.readyState = filesaver.INIT;
						return;
					}
					// don't create more object URLs than needed
					if (!object_url) {
						object_url = get_URL().createObjectURL(blob);
					}
					if (force) {
						view.location.href = object_url;
					} else {
						var opened = view.open(object_url, "_blank");
						if (!opened) {
							// Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html
							view.location.href = object_url;
						}
					}
					filesaver.readyState = filesaver.DONE;
					dispatch_all();
					revoke(object_url);
				}
			;
			filesaver.readyState = filesaver.INIT;

			if (can_use_save_link) {
				object_url = get_URL().createObjectURL(blob);
				setTimeout(function() {
					save_link.href = object_url;
					save_link.download = name;
					click(save_link);
					dispatch_all();
					revoke(object_url);
					filesaver.readyState = filesaver.DONE;
				});
				return;
			}

			fs_error();
		}
		, FS_proto = FileSaver.prototype
		, saveAs = function(blob, name, no_auto_bom) {
			return new FileSaver(blob, name || blob.name || "download", no_auto_bom);
		}
	;
	// IE 10+ (native saveAs)
	if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
		return function(blob, name, no_auto_bom) {
			name = name || blob.name || "download";

			if (!no_auto_bom) {
				blob = auto_bom(blob);
			}
			return navigator.msSaveOrOpenBlob(blob, name);
		};
	}

	FS_proto.abort = function(){};
	FS_proto.readyState = FS_proto.INIT = 0;
	FS_proto.WRITING = 1;
	FS_proto.DONE = 2;

	FS_proto.error =
	FS_proto.onwritestart =
	FS_proto.onprogress =
	FS_proto.onwrite =
	FS_proto.onabort =
	FS_proto.onerror =
	FS_proto.onwriteend =
		null;

	return saveAs;
}(
	   typeof self !== "undefined" && self
	|| typeof window !== "undefined" && window
	|| this.content
));
// `self` is undefined in Firefox for Android content script context
// while `this` is nsIContentFrameMessageManager
// with an attribute `content` that corresponds to the window

if (typeof module !== "undefined" && module.exports) {
  module.exports.saveAs = saveAs;
} else if (("function" !== "undefined" && __webpack_require__(592) !== null) && (__webpack_require__(237) !== null)) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
    return saveAs;
  }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}


/***/ }),
/* 592 */
/***/ (function(module, exports) {

module.exports = function() {
	throw new Error("define cannot be used indirect");
};


/***/ }),
/* 593 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _regenerator = __webpack_require__(3);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _typeof2 = __webpack_require__(26);

var _typeof3 = _interopRequireDefault(_typeof2);

var _promise = __webpack_require__(4);

var _promise2 = _interopRequireDefault(_promise);

var _mutations = __webpack_require__(14);

var types = _interopRequireWildcard(_mutations);

var _idbInstance = __webpack_require__(60);

var _idbInstance2 = _interopRequireDefault(_idbInstance);

var _immutable = __webpack_require__(23);

var _immutable2 = _interopRequireDefault(_immutable);

var _bcxjsCores = __webpack_require__(7);

var _PrivateKeyStore = __webpack_require__(150);

var _PrivateKeyStore2 = _interopRequireDefault(_PrivateKeyStore);

var _bcxjsWs = __webpack_require__(8);

var _localStorage = __webpack_require__(395);

var _localStorage2 = _interopRequireDefault(_localStorage);

var _api = __webpack_require__(10);

var _api2 = _interopRequireDefault(_api);

var _url = __webpack_require__(594);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var STORAGE_KEY = "__gph__";

var accountStorage = new _localStorage2.default(STORAGE_KEY);

var _chainstore_account_ids_by_key = void 0;
var _no_account_refs = void 0;

var initialState = {
    update: false,
    subbed: false,
    currentAccount: null,
    linkedAccounts: _immutable2.default.Set(),
    myIgnoredAccounts: _immutable2.default.Set(),
    unFollowedAccounts: _immutable2.default.Set(process.browser || true ? accountStorage.get("unfollowed_accounts", []) : []),
    searchAccounts: _immutable2.default.Map(),
    searchTerm: "",
    initial_account_refs_load: true,
    account_refs: null
};

var getters = {
    linkedAccounts: function linkedAccounts(state) {
        return state.linkedAccounts;
    }
};

var actions = {
    loadDbData: function loadDbData(_ref) {
        var dispatch = _ref.dispatch,
            state = _ref.state;

        var linkedAccounts = _immutable2.default.Set().asMutable();
        var chainId = _bcxjsWs.Apis.instance().chain_id;
        return new _promise2.default(function (resolve, reject) {
            _idbInstance2.default.load_data("linked_accounts").then(function (data) {
                if (!data.length) {
                    //config current account
                    accountStorage.set("currentAccount", null);
                }
                var accountPromises = data.filter(function (a) {
                    if (a.chainId) {
                        return a.chainId === chainId;
                    } else {
                        return true;
                    }
                }).map(function (a) {
                    linkedAccounts.add(a.name);
                    dispatch("_addIgnoredAccount", a.name);
                    return (0, _bcxjsCores.FetchChain)("getAccount", a.name);
                });
                _promise2.default.all(accountPromises).then(function (results) {
                    state.linkedAccounts = linkedAccounts.asImmutable();
                    dispatch("tryToSetCurrentAccount", null).then(function (acc_res) {
                        _bcxjsCores.ChainStore.subscribe(function () {
                            dispatch("chainStoreUpdate");
                        });
                        resolve(true);
                        state.subbed = true;
                    });
                }).catch(function (err) {
                    _bcxjsCores.ChainStore.subscribe(function () {
                        dispatch("chainStoreUpdate");
                    });
                    state.subbed = true;
                    reject(err);
                });
            }).catch(function (err) {
                // alert(err);
                reject(err);
            });
        });
    },
    _addIgnoredAccount: function _addIgnoredAccount(_ref2, name) {
        var state = _ref2.state;

        if (state.unFollowedAccounts.includes(name) && !state.myIgnoredAccounts.has(name)) {
            state.myIgnoredAccounts = state.myIgnoredAccounts.add(name);
        }
    },

    chainStoreUpdate: function chainStoreUpdate(_ref3) {
        var dispatch = _ref3.dispatch,
            state = _ref3.state;

        if (state.update) {
            state.update = false;
        }
        dispatch("addAccountRefs");
    },
    addAccountRefs: function addAccountRefs(_ref4) {
        var rootGetters = _ref4.rootGetters,
            state = _ref4.state,
            dispatch = _ref4.dispatch;

        //  Simply add them to the linkedAccounts list (no need to persist them)
        var account_refs = rootGetters["AccountRefsStore/account_refs"];
        if (!state.initial_account_refs_load && state.account_refs === account_refs) return;
        state.account_refs = account_refs;
        var pending = false;
        state.linkedAccounts = state.linkedAccounts.withMutations(function (linkedAccounts) {
            account_refs.forEach(function (id) {
                var account = _bcxjsCores.ChainStore.getAccount(id);
                if (account === undefined) {
                    pending = true;
                    return;
                }
                if (account && !state.unFollowedAccounts.includes(account.get("name"))) {
                    linkedAccounts.add(account.get("name"));
                } else {
                    dispatch("_addIgnoredAccount", account.get("name"));
                }
            });
        });
        state.initial_account_refs_load = pending;
        return dispatch("tryToSetCurrentAccount");
    },
    tryToSetCurrentAccount: function tryToSetCurrentAccount(_ref5) {
        var dispatch = _ref5.dispatch,
            state = _ref5.state;

        if (accountStorage.get("currentAccount", null)) {
            return dispatch("setCurrentAccount", accountStorage.get("currentAccount", null));
        }
        if (state.linkedAccounts.size) {
            return dispatch("setCurrentAccount", state.linkedAccounts.first());
        }
        return true;
    },
    setCurrentAccount: function setCurrentAccount(_ref6, name) {
        var dispatch = _ref6.dispatch,
            state = _ref6.state;
        var isCreateAccount;
        return _regenerator2.default.async(function setCurrentAccount$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        isCreateAccount = false;

                        if (name && (typeof name === "undefined" ? "undefined" : (0, _typeof3.default)(name)) == "object") {
                            isCreateAccount = !!name.isCreateAccount;
                            name = name.account;
                        }
                        if (!name) {
                            state.currentAccount = null;
                            state.linkedAccounts = _immutable2.default.Set();
                        } else {
                            state.currentAccount = name;
                            state.linkedAccounts = state.linkedAccounts.add(name);
                        }
                        accountStorage.set("currentAccount", state.currentAccount);

                        if (!name) {
                            _context.next = 8;
                            break;
                        }

                        return _context.abrupt("return", new _promise2.default(function (resolve) {
                            setTimeout(function () {
                                dispatch("user/fetchUserForIsSave", { nameOrId: name, isSave: true }, { root: true }).then(function (acc_res) {
                                    delete acc_res.success;
                                    // console.info("acc_res",acc_res);
                                    resolve(acc_res);
                                });
                            }, isCreateAccount ? 2000 : 100);
                        }));

                    case 8:
                        return _context.abrupt("return", { code: 0, message: "Name can not be empty" });

                    case 9:
                    case "end":
                        return _context.stop();
                }
            }
        }, null, undefined);
    },
    onCreateAccount: function onCreateAccount(_ref7, _ref8) {
        var state = _ref7.state,
            dispatch = _ref7.dispatch;
        var name_or_account = _ref8.name_or_account,
            owner_pubkey = _ref8.owner_pubkey;

        var account = name_or_account;
        if (typeof account === "string") {
            account = {
                name: account
            };
        }

        if (account["toJS"]) account = account.toJS();

        if (account.name == "" || state.linkedAccounts.get(account.name)) return _promise2.default.resolve();

        if (!_bcxjsCores.ChainValidation.is_account_name(account.name)) throw new Error("Invalid account name: " + account.name);
        return _idbInstance2.default.add_to_store("linked_accounts", {
            name: account.name,
            chainId: _bcxjsWs.Apis.instance().chain_id
        }).then(function () {
            //console.log("[AccountStore.js] ----- Added account to store: ----->", account.name);
            // return dispatch("AccountRefsStore/loadDbData",null,{root:true}).then(()=>{
            //     return dispatch("loadDbData").then(()=>{

            //     })  
            // })  
            state.linkedAccounts = state.linkedAccounts.add(account.name);

            if (state.linkedAccounts.size === 1) {
                return dispatch("setCurrentAccount", { account: account.name, isCreateAccount: true }).then(function (acc_res) {
                    if (owner_pubkey) {
                        return _api2.default.Account.getAccountIdByOwnerPubkey(owner_pubkey).then(function (userId) {
                            var id = userId && userId[0];
                            if (id) {
                                id = userId[0];
                                return id;
                            }
                            dispatch("account/account_signup_complete", { userId: id }, { root: true });
                        });
                    }
                });
            } else {
                return { code: 1 };
            }
        });
    }
};

var mutations = {};

exports.default = {
    state: initialState,
    actions: actions,
    mutations: mutations,
    getters: getters,
    namespaced: true
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9)))

/***/ }),
/* 594 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = __webpack_require__(595);
var util = __webpack_require__(596);

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(597);

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ }),
/* 595 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(143)(module), __webpack_require__(12)))

/***/ }),
/* 596 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),
/* 597 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(598);
exports.encode = exports.stringify = __webpack_require__(599);


/***/ }),
/* 598 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),
/* 599 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),
/* 600 */
/***/ (function(module, exports) {

var idbModules = {  // jshint ignore:line
    util: {
        cleanInterface: false
    }
};

(function () {
    'use strict';

    var testObject = {test: true};
    //Test whether Object.defineProperty really works.
    if (Object.defineProperty) {
        try {
            Object.defineProperty(testObject, 'test', { enumerable: false });
            if (testObject.test) {
                idbModules.util.cleanInterface = true;      // jshint ignore:line
            }
        } catch (e) {
        //Object.defineProperty does not work as intended.
        }
    }
})();

(function(idbModules) {
    'use strict';

    /**
     * A utility method to callback onsuccess, onerror, etc as soon as the calling function's context is over
     * @param {Object} fn
     * @param {Object} context
     * @param {Object} argArray
     */
    function callback(fn, context, event) {
        //window.setTimeout(function(){
        event.target = context;
        (typeof context[fn] === "function") && context[fn].apply(context, [event]);
        //}, 1);
    }

    /**
     * Shim the DOMStringList object.
     *
     */
    var StringList = function() {
        this.length = 0;
        this._items = [];
        //Internal functions on the prototype have been made non-enumerable below.
        if (idbModules.util.cleanInterface) {
            Object.defineProperty(this, '_items', {
                enumerable: false
            });
        }
    };
    StringList.prototype = {
        // Interface.
        contains: function(str) {
            return -1 !== this._items.indexOf(str);
        },
        item: function(key) {
            return this._items[key];
        },

        // Helpers. Should only be used internally.
        indexOf: function(str) {
            return this._items.indexOf(str);
        },
        push: function(item) {
            this._items.push(item);
            this.length += 1;
            for (var i = 0; i < this._items.length; i++) {
                this[i] = this._items[i];
            }
        },
        splice: function(/*index, howmany, item1, ..., itemX*/) {
            this._items.splice.apply(this._items, arguments);
            this.length = this._items.length;
            for (var i in this) {
                if (i === String(parseInt(i, 10))) {
                    delete this[i];
                }
            }
            for (i = 0; i < this._items.length; i++) {
                this[i] = this._items[i];
            }
        }
    };
    if (idbModules.util.cleanInterface) {
        for (var i in {
            'indexOf': false,
            'push': false,
            'splice': false
        }) {
            Object.defineProperty(StringList.prototype, i, {
                enumerable: false
            });
        }
    }

    idbModules.util.callback = callback;
    idbModules.util.StringList = StringList;
    idbModules.util.quote = function(arg) {
        return "\"" + arg + "\"";
    };

}(idbModules));

(function (idbModules) {
    'use strict';

    /**
     * Polyfills missing features in the browser's native IndexedDB implementation.
     * This is used for browsers that DON'T support WebSQL but DO support IndexedDB
     */
    function polyfill() {
        if (navigator.userAgent.match(/MSIE/) ||
            navigator.userAgent.match(/Trident/) ||
            navigator.userAgent.match(/Edge/)) {
            // Internet Explorer's native IndexedDB does not support compound keys
            compoundKeyPolyfill();
        }
    }

    /**
     * Polyfills support for compound keys
     */
    function compoundKeyPolyfill() {
        var cmp = IDBFactory.prototype.cmp;
        var createObjectStore = IDBDatabase.prototype.createObjectStore;
        var createIndex = IDBObjectStore.prototype.createIndex;
        var add = IDBObjectStore.prototype.add;
        var put = IDBObjectStore.prototype.put;
        var indexGet = IDBIndex.prototype.get;
        var indexGetKey = IDBIndex.prototype.getKey;
        var indexCursor = IDBIndex.prototype.openCursor;
        var indexKeyCursor = IDBIndex.prototype.openKeyCursor;
        var storeGet = IDBObjectStore.prototype.get;
        var storeDelete = IDBObjectStore.prototype.delete;
        var storeCursor = IDBObjectStore.prototype.openCursor;
        var storeKeyCursor = IDBObjectStore.prototype.openKeyCursor;
        var bound = IDBKeyRange.bound;
        var upperBound = IDBKeyRange.upperBound;
        var lowerBound = IDBKeyRange.lowerBound;
        var only = IDBKeyRange.only;
        var requestResult = Object.getOwnPropertyDescriptor(IDBRequest.prototype, 'result');
        var cursorPrimaryKey = Object.getOwnPropertyDescriptor(IDBCursor.prototype, 'primaryKey');
        var cursorKey = Object.getOwnPropertyDescriptor(IDBCursor.prototype, 'key');
        var cursorValue = Object.getOwnPropertyDescriptor(IDBCursorWithValue.prototype, 'value');

        IDBFactory.prototype.cmp = function(key1, key2) {
            var args = Array.prototype.slice.call(arguments);
            if (key1 instanceof Array) {
                args[0] = encodeCompoundKey(key1);
            }
            if (key2 instanceof Array) {
                args[1] = encodeCompoundKey(key2);
            }
            return cmp.apply(this, args);
        };

        IDBDatabase.prototype.createObjectStore = function(name, opts) {
            if (opts && opts.keyPath instanceof Array) {
                opts.keyPath = encodeCompoundKeyPath(opts.keyPath);
            }
            return createObjectStore.apply(this, arguments);
        };

        IDBObjectStore.prototype.createIndex = function(name, keyPath, opts) {
            var args = Array.prototype.slice.call(arguments);
            if (keyPath instanceof Array) {
                args[1] = encodeCompoundKeyPath(keyPath);
            }
            return createIndex.apply(this, args);
        };

        IDBObjectStore.prototype.add = function(value, key) {
            return this.__insertData(add, arguments);
        };

        IDBObjectStore.prototype.put = function(value, key) {
            return this.__insertData(put, arguments);
        };

        IDBObjectStore.prototype.__insertData = function(method, args) {
            args = Array.prototype.slice.call(args);
            var value = args[0];
            var key = args[1];

            // out-of-line key
            if (key instanceof Array) {
                args[1] = encodeCompoundKey(key);
            }

            if (typeof value === 'object') {
                // inline key
                if (isCompoundKey(this.keyPath)) {
                    setInlineCompoundKey(value, this.keyPath);
                }

                // inline indexes
                for (var i = 0; i < this.indexNames.length; i++) {
                    var index = this.index(this.indexNames[i]);
                    if (isCompoundKey(index.keyPath)) {
                        try {
                            setInlineCompoundKey(value, index.keyPath);
                        }
                        catch (e) {
                            // The value doesn't have a valid key for this index.
                        }
                    }
                }
            }
            return method.apply(this, args);
        };

        IDBIndex.prototype.get = function(key) {
            var args = Array.prototype.slice.call(arguments);
            if (key instanceof Array) {
                args[0] = encodeCompoundKey(key);
            }
            return indexGet.apply(this, args);
        };

        IDBIndex.prototype.getKey = function(key) {
            var args = Array.prototype.slice.call(arguments);
            if (key instanceof Array) {
                args[0] = encodeCompoundKey(key);
            }
            return indexGetKey.apply(this, args);
        };

        IDBIndex.prototype.openCursor = function(key) {
            var args = Array.prototype.slice.call(arguments);
            if (key instanceof Array) {
                args[0] = encodeCompoundKey(key);
            }
            return indexCursor.apply(this, args);
        };

        IDBIndex.prototype.openKeyCursor = function(key) {
            var args = Array.prototype.slice.call(arguments);
            if (key instanceof Array) {
                args[0] = encodeCompoundKey(key);
            }
            return indexKeyCursor.apply(this, args);
        };

        IDBObjectStore.prototype.get = function(key) {
            var args = Array.prototype.slice.call(arguments);
            if (key instanceof Array) {
                args[0] = encodeCompoundKey(key);
            }
            return storeGet.apply(this, args);
        };

        IDBObjectStore.prototype.delete = function(key) {
            var args = Array.prototype.slice.call(arguments);
            if (key instanceof Array) {
                args[0] = encodeCompoundKey(key);
            }
            return storeDelete.apply(this, args);
        };

        IDBObjectStore.prototype.openCursor = function(key) {
            var args = Array.prototype.slice.call(arguments);
            if (key instanceof Array) {
                args[0] = encodeCompoundKey(key);
            }
            return storeCursor.apply(this, args);
        };

        IDBObjectStore.prototype.openKeyCursor = function(key) {
            var args = Array.prototype.slice.call(arguments);
            if (key instanceof Array) {
                args[0] = encodeCompoundKey(key);
            }
            return storeKeyCursor.apply(this, args);
        };

        IDBKeyRange.bound = function(lower, upper, lowerOpen, upperOpen) {
            var args = Array.prototype.slice.call(arguments);
            if (lower instanceof Array) {
                args[0] = encodeCompoundKey(lower);
            }
            if (upper instanceof Array) {
                args[1] = encodeCompoundKey(upper);
            }
            return bound.apply(IDBKeyRange, args);
        };

        IDBKeyRange.upperBound = function(key, open) {
            var args = Array.prototype.slice.call(arguments);
            if (key instanceof Array) {
                args[0] = encodeCompoundKey(key);
            }
            return upperBound.apply(IDBKeyRange, args);
        };

        IDBKeyRange.lowerBound = function(key, open) {
            var args = Array.prototype.slice.call(arguments);
            if (key instanceof Array) {
                args[0] = encodeCompoundKey(key);
            }
            return lowerBound.apply(IDBKeyRange, args);
        };

        IDBKeyRange.only = function(key) {
            var args = Array.prototype.slice.call(arguments);
            if (key instanceof Array) {
                args[0] = encodeCompoundKey(key);
            }
            return only.apply(IDBKeyRange, args);
        };

        Object.defineProperty(IDBRequest.prototype, 'result', {
            enumerable: requestResult.enumerable,
            configurable: requestResult.configurable,
            get: function() {
                var result = requestResult.get.call(this);
                return removeInlineCompoundKey(result);
            }
        });

        Object.defineProperty(IDBCursor.prototype, 'primaryKey', {
            enumerable: cursorPrimaryKey.enumerable,
            configurable: cursorPrimaryKey.configurable,
            get: function() {
                var result = cursorPrimaryKey.get.call(this);
                return removeInlineCompoundKey(result);
            }
        });

        Object.defineProperty(IDBCursor.prototype, 'key', {
            enumerable: cursorKey.enumerable,
            configurable: cursorKey.configurable,
            get: function() {
                var result = cursorKey.get.call(this);
                return removeInlineCompoundKey(result);
            }
        });

        Object.defineProperty(IDBCursorWithValue.prototype, 'value', {
            enumerable: cursorValue.enumerable,
            configurable: cursorValue.configurable,
            get: function() {
                var result = cursorValue.get.call(this);
                return removeInlineCompoundKey(result);
            }
        });

        try {
            if (!IDBTransaction.VERSION_CHANGE) {
                IDBTransaction.VERSION_CHANGE = 'versionchange';
            }
        }
        catch (e) {}
    }

    var compoundKeysPropertyName = '__$$compoundKey';
    var propertySeparatorRegExp = /\$\$/g;
    var propertySeparator = '$$$$';         // "$$" after RegExp escaping
    var keySeparator = '$_$';

    function isCompoundKey(keyPath) {
        return keyPath && (keyPath.indexOf(compoundKeysPropertyName + '.') === 0);
    }

    function encodeCompoundKeyPath(keyPath) {
        // Encoded dotted properties
        // ["name.first", "name.last"] ==> ["name$$first", "name$$last"]
        for (var i = 0; i < keyPath.length; i++) {
            keyPath[i] = keyPath[i].replace(/\./g, propertySeparator);
        }

        // Encode the array as a single property
        // ["name$$first", "name$$last"] => "__$$compoundKey.name$$first$_$name$$last"
        return compoundKeysPropertyName + '.' + keyPath.join(keySeparator);
    }

    function decodeCompoundKeyPath(keyPath) {
        // Remove the "__$$compoundKey." prefix
        keyPath = keyPath.substr(compoundKeysPropertyName.length + 1);

        // Split the properties into an array
        // "name$$first$_$name$$last" ==> ["name$$first", "name$$last"]
        keyPath = keyPath.split(keySeparator);

        // Decode dotted properties
        // ["name$$first", "name$$last"] ==> ["name.first", "name.last"]
        for (var i = 0; i < keyPath.length; i++) {
            keyPath[i] = keyPath[i].replace(propertySeparatorRegExp, '.');
        }
        return keyPath;
    }

    function setInlineCompoundKey(value, encodedKeyPath) {
        // Encode the key
        var keyPath = decodeCompoundKeyPath(encodedKeyPath);
        var key = idbModules.Key.getValue(value, keyPath);
        var encodedKey = encodeCompoundKey(key);

        // Store the encoded key inline
        encodedKeyPath = encodedKeyPath.substr(compoundKeysPropertyName.length + 1);
        value[compoundKeysPropertyName] = value[compoundKeysPropertyName] || {};
        value[compoundKeysPropertyName][encodedKeyPath] = encodedKey;
    }

    function removeInlineCompoundKey(value) {
        if (typeof value === "string" && isCompoundKey(value)) {
            return decodeCompoundKey(value);
        }
        else if (value && typeof value[compoundKeysPropertyName] === "object") {
            delete value[compoundKeysPropertyName];
        }
        return value;
    }

    function encodeCompoundKey(key) {
        // Validate and encode the key
        idbModules.Key.validate(key);
        key = idbModules.Key.encode(key);

        // Prepend the "__$$compoundKey." prefix
        key = compoundKeysPropertyName + '.' + key;

        validateKeyLength(key);
        return key;
    }

    function decodeCompoundKey(key) {
        validateKeyLength(key);

        // Remove the "__$$compoundKey." prefix
        key = key.substr(compoundKeysPropertyName.length + 1);

        // Decode the key
        key = idbModules.Key.decode(key);
        return key;
    }

    function validateKeyLength(key) {
        // BUG: Internet Explorer truncates string keys at 889 characters
        if (key.length > 889) {
            throw idbModules.util.createDOMException("DataError", "The encoded key is " + key.length + " characters long, but IE only allows 889 characters. Consider replacing numeric keys with strings to reduce the encoded length.");
        }
    }

    idbModules.polyfill = polyfill;
})(idbModules);

(function(idbModules){
    'use strict';

    /**
     * Implementation of the Structured Cloning Algorithm.  Supports the
     * following object types:
     * - Blob
     * - Boolean
     * - Date object
     * - File object (deserialized as Blob object).
     * - Number object
     * - RegExp object
     * - String object
     * This is accomplished by doing the following:
     * 1) Using the cycle/decycle functions from:
     *    https://github.com/douglascrockford/JSON-js/blob/master/cycle.js
     * 2) Serializing/deserializing objects to/from string that don't work with
     *    JSON.stringify and JSON.parse by using object specific logic (eg use 
     *    the FileReader API to convert a Blob or File object to a data URL.   
     * 3) JSON.stringify and JSON.parse do the final conversion to/from string.
     */
    var Sca = (function(){
        return {
            decycle: function(object, callback) {
                //From: https://github.com/douglascrockford/JSON-js/blob/master/cycle.js
                // Contains additional logic to convert the following object types to string
                // so that they can properly be encoded using JSON.stringify:
                //  *Boolean
                //  *Date
                //  *File
                //  *Blob
                //  *Number
                //  *Regex
                // Make a deep copy of an object or array, assuring that there is at most
                // one instance of each object or array in the resulting structure. The
                // duplicate references (which might be forming cycles) are replaced with
                // an object of the form
                //      {$ref: PATH}
                // where the PATH is a JSONPath string that locates the first occurance.
                // So,
                //      var a = [];
                //      a[0] = a;
                //      return JSON.stringify(JSON.decycle(a));
                // produces the string '[{"$ref":"$"}]'.

                // JSONPath is used to locate the unique object. $ indicates the top level of
                // the object or array. [NUMBER] or [STRING] indicates a child member or
                // property.

                var objects = [],   // Keep a reference to each unique object or array
                paths = [],     // Keep the path to each unique object or array
                queuedObjects = [],
                returnCallback = callback;

                /**
                 * Check the queue to see if all objects have been processed.
                 * if they have, call the callback with the converted object.
                 */
                function checkForCompletion() {
                    if (queuedObjects.length === 0) {
                        returnCallback(derezObj);
                    }    
                }

                /**
                 * Convert a blob to a data URL.
                 * @param {Blob} blob to convert.
                 * @param {String} path of blob in object being encoded.
                 */
                function readBlobAsDataURL(blob, path) {
                    var reader = new FileReader();
                    reader.onloadend = function(loadedEvent) {
                        var dataURL = loadedEvent.target.result;
                        var blobtype = 'Blob';
                        if (blob instanceof File) {
                            //blobtype = 'File';
                        }
                        updateEncodedBlob(dataURL, path, blobtype);
                    };
                    reader.readAsDataURL(blob);
                }
                
                /**
                 * Async handler to update a blob object to a data URL for encoding.
                 * @param {String} dataURL
                 * @param {String} path
                 * @param {String} blobtype - file if the blob is a file; blob otherwise
                 */
                function updateEncodedBlob(dataURL, path, blobtype) {
                    var encoded = queuedObjects.indexOf(path);
                    path = path.replace('$','derezObj');
                    path['$enc']=dataURL;
                    path['$type']=encoded;
                    queuedObjects.splice(encoded, 1);
                    checkForCompletion();
                }

                function derez(value, path) {

                    // The derez recurses through the object, producing the deep copy.

                    var i,          // The loop counter
                    name,       // Property name
                    nu;         // The new object or array

                    // typeof null === 'object', so go on if this value is really an object but not
                    // one of the weird builtin objects.

                    if (typeof value === 'object' && value !== null &&
                        !(value instanceof Boolean) &&
                        !(value instanceof Date)    &&
                        !(value instanceof Number)  &&
                        !(value instanceof RegExp)  &&
                        !(value instanceof Blob)  &&
                        !(value instanceof String)) {

                        // If the value is an object or array, look to see if we have already
                        // encountered it. If so, return a $ref/path object. This is a hard way,
                        // linear search that will get slower as the number of unique objects grows.

                        for (i = 0; i < objects.length; i += 1) {
                            if (objects[i] === value) {
                                return {$ref: paths[i]};
                            }
                        }

                        // Otherwise, accumulate the unique value and its path.

                        objects.push(value);
                        paths.push(path);

                        // If it is an array, replicate the array.

                        if (Object.prototype.toString.apply(value) === '[object Array]') {
                            nu = [];
                            for (i = 0; i < value.length; i += 1) {
                                nu[i] = derez(value[i], path + '[' + i + ']');
                            }
                        } else {
                            // If it is an object, replicate the object.
                            nu = {};
                            for (name in value) {
                                if (Object.prototype.hasOwnProperty.call(value, name)) {
                                    nu[name] = derez(value[name],
                                     path + '[' + JSON.stringify(name) + ']');
                                }
                            }
                        }

                        return nu;
                    } else if (value instanceof Blob) {
                        //Queue blob for conversion
                        queuedObjects.push(path);
                        readBlobAsDataURL(value, path);
                    } else if (value instanceof Boolean) {
                        value = {
                            '$type': 'Boolean',
                            '$enc': value.toString()
                        };
                    } else if (value instanceof Date) {
                        value = {
                            '$type': 'Date',
                            '$enc': value.getTime()
                        };
                    } else if (value instanceof Number) {
                        value = {
                            '$type': 'Number',
                            '$enc': value.toString()
                        };
                    } else if (value instanceof RegExp) {
                        value = {
                            '$type': 'RegExp',
                            '$enc': value.toString()
                        };
                    } else if (typeof value === 'number') {
                        value = {
                            '$type': 'number',
                            '$enc': value + ''  // handles NaN, Infinity, Negative Infinity
                        };
                    } else if (value === undefined) {
                        value = {
                            '$type': 'undefined'
                        };
                    }
                    return value;
                }
                var derezObj = derez(object, '$');
                checkForCompletion();
            },
                
            retrocycle: function retrocycle($) {
                //From: https://github.com/douglascrockford/JSON-js/blob/master/cycle.js
                // Contains additional logic to convert strings to the following object types 
                // so that they can properly be decoded:
                //  *Boolean
                //  *Date
                //  *File
                //  *Blob
                //  *Number
                //  *Regex
                // Restore an object that was reduced by decycle. Members whose values are
                // objects of the form
                //      {$ref: PATH}
                // are replaced with references to the value found by the PATH. This will
                // restore cycles. The object will be mutated.

                // The eval function is used to locate the values described by a PATH. The
                // root object is kept in a $ variable. A regular expression is used to
                // assure that the PATH is extremely well formed. The regexp contains nested
                // * quantifiers. That has been known to have extremely bad performance
                // problems on some browsers for very long strings. A PATH is expected to be
                // reasonably short. A PATH is allowed to belong to a very restricted subset of
                // Goessner's JSONPath.

                // So,
                //      var s = '[{"$ref":"$"}]';
                //      return JSON.retrocycle(JSON.parse(s));
                // produces an array containing a single element which is the array itself.

                var px = /^\$(?:\[(?:\d+|\"(?:[^\\\"\u0000-\u001f]|\\([\\\"\/bfnrt]|u[0-9a-zA-Z]{4}))*\")\])*$/;
                
                /**
                 * Converts the specified data URL to a Blob object
                 * @param {String} dataURL to convert to a Blob
                 * @returns {Blob} the converted Blob object
                 */
                function dataURLToBlob(dataURL) {
                    var BASE64_MARKER = ';base64,',
                        contentType,
                        parts,
                        raw;
                    if (dataURL.indexOf(BASE64_MARKER) === -1) {
                        parts = dataURL.split(',');
                        contentType = parts[0].split(':')[1];
                        raw = parts[1];

                        return new Blob([raw], {type: contentType});
                    }

                    parts = dataURL.split(BASE64_MARKER);
                    contentType = parts[0].split(':')[1];
                    raw = window.atob(parts[1]);
                    var rawLength = raw.length;
                    var uInt8Array = new Uint8Array(rawLength);

                    for (var i = 0; i < rawLength; ++i) {
                        uInt8Array[i] = raw.charCodeAt(i);
                    }
                    return new Blob([uInt8Array.buffer], {type: contentType});
                }
                
                function rez(value) {
                    // The rez function walks recursively through the object looking for $ref
                    // properties. When it finds one that has a value that is a path, then it
                    // replaces the $ref object with a reference to the value that is found by
                    // the path.

                    var i, item, name, path;

                    if (value && typeof value === 'object') {
                        if (Object.prototype.toString.apply(value) === '[object Array]') {
                            for (i = 0; i < value.length; i += 1) {
                                item = value[i];
                                if (item && typeof item === 'object') {
                                    path = item.$ref;
                                    if (typeof path === 'string' && px.test(path)) {
                                        value[i] = path//eval(path);
                                    } else {
                                        value[i] = rez(item);
                                    }
                                }
                            }
                        } else {
                            if (value.$type !== undefined) {
                                switch(value.$type) {
                                    case 'Blob':
                                    case 'File':
                                        value = dataURLToBlob(value.$enc);
                                        break;
                                    case 'Boolean':
                                        value = Boolean(value.$enc === 'true');
                                        break;
                                    case 'Date':
                                        value = new Date(value.$enc);
                                        break;
                                    case 'Number':
                                        value = Number(value.$enc);
                                        break;
                                    case 'RegExp':
                                        value = value.$enc//eval(value.$enc);
                                        break;
                                    case 'number':
                                        value = parseFloat(value.$enc);
                                        break;
                                    case 'undefined':
                                        value = undefined;
                                        break;
                                }
                            } else {
                                for (name in value) {
                                    if (typeof value[name] === 'object') {
                                        item = value[name];
                                        if (item) {
                                            path = item.$ref;
                                            if (typeof path === 'string' && px.test(path)) {
                                                value[name] =path// eval(path);
                                            } else {
                                                value[name] = rez(item);
                                            }
                                        }
                                    }   
                                }
                            }
                        }
                    }
                    return value;
                }
                return rez($);

            },

            /**
             * Encode the specified object as a string.  Because of the asynchronus
             * conversion of Blob/File to string, the encode function requires
             * a callback
             * @param {Object} val the value to convert.
             * @param {function} callback the function to call once conversion is
             * complete.  The callback gets called with the converted value.
             */
            "encode": function(val, callback){
                function finishEncode(val) {
                    callback(JSON.stringify(val));
                }
                this.decycle(val, finishEncode);                        
            },
                    
            /**
             * Deserialize the specified string to an object
             * @param {String} val the serialized string
             * @returns {Object} the deserialized object
             */
            "decode": function(val){
                return this.retrocycle(JSON.parse(val));
            }
        };
    }());
    idbModules.Sca = Sca;
}(idbModules));

(function(idbModules) {
    "use strict";

    /**
     * Encodes the keys based on their types. This is required to maintain collations
     */
    var collations = ["undefined", "number", "date", "string", "array"];

    /**
     * The sign values for numbers, ordered from least to greatest.
     *  - "negativeInfinity": Sorts below all other values.
     *  - "bigNegative": Negative values less than or equal to negative one.
     *  - "smallNegative": Negative values between negative one and zero, noninclusive.
     *  - "smallPositive": Positive values between zero and one, including zero but not one.
     *  - "largePositive": Positive values greater than or equal to one.
     *  - "positiveInfinity": Sorts above all other values.
     */
    var signValues = ["negativeInfinity", "bigNegative", "smallNegative", "smallPositive", "bigPositive", "positiveInfinity"];

    var types = {
        // Undefined is not a valid key type.  It's only used when there is no key.
        undefined: {
            encode: function(key) {
                return collations.indexOf("undefined") + "-";
            },
            decode: function(key) {
                return undefined;
            }
        },

        // Dates are encoded as ISO 8601 strings, in UTC time zone.
        date: {
            encode: function(key) {
                return collations.indexOf("date") + "-" + key.toJSON();
            },
            decode: function(key) {
                return new Date(key.substring(2));
            }
        },

        // Numbers are represented in a lexically sortable base-32 sign-exponent-mantissa
        // notation.
        //
        // sign: takes a value between zero and five, inclusive. Represents infinite cases
        //     and the signs of both the exponent and the fractional part of the number.
        // exponent: paded to two base-32 digits, represented by the 32's compliment in the
        //     "smallPositive" and "bigNegative" cases to ensure proper lexical sorting.
        // mantissa: also called the fractional part. Normed 11-digit base-32 representation.
        //     Represented by the 32's compliment in the "smallNegative" and "bigNegative"
        //     cases to ensure proper lexical sorting.
        number: {
            // The encode step checks for six numeric cases and generates 14-digit encoded
            // sign-exponent-mantissa strings.
            encode: function(key) {
                var key32 = Math.abs(key).toString(32);
                // Get the index of the decimal.
                var decimalIndex = key32.indexOf(".");
                // Remove the decimal.
                key32 = (decimalIndex !== -1) ? key32.replace(".", "") : key32;
                // Get the index of the first significant digit.
                var significantDigitIndex = key32.search(/[^0]/);
                // Truncate leading zeros.
                key32 = key32.slice(significantDigitIndex);
                var sign, exponent = zeros(2), mantissa = zeros(11);

                // Finite cases:
                if (isFinite(key)) {
                    // Negative cases:
                    if (key < 0) {
                        // Negative exponent case:
                        if (key > -1) {
                            sign = signValues.indexOf("smallNegative");
                            exponent = padBase32Exponent(significantDigitIndex);
                            mantissa = flipBase32(padBase32Mantissa(key32));
                        }
                        // Non-negative exponent case:
                        else {
                            sign = signValues.indexOf("bigNegative");
                            exponent = flipBase32(padBase32Exponent(
                                (decimalIndex !== -1) ? decimalIndex : key32.length
                            ));
                            mantissa = flipBase32(padBase32Mantissa(key32));
                        }
                    }
                    // Non-negative cases:
                    else {
                        // Negative exponent case:
                        if (key < 1) {
                            sign = signValues.indexOf("smallPositive");
                            exponent = flipBase32(padBase32Exponent(significantDigitIndex));
                            mantissa = padBase32Mantissa(key32);
                        }
                        // Non-negative exponent case:
                        else {
                            sign = signValues.indexOf("bigPositive");
                            exponent = padBase32Exponent(
                                (decimalIndex !== -1) ? decimalIndex : key32.length
                            );
                            mantissa = padBase32Mantissa(key32);
                        }
                    }
                }
                // Infinite cases:
                else {
                    sign = signValues.indexOf(
                        key > 0 ? "positiveInfinity" : "negativeInfinity"
                    );
                }

                return collations.indexOf("number") + "-" + sign + exponent + mantissa;
            },
            // The decode step must interpret the sign, reflip values encoded as the 32's complements,
            // apply signs to the exponent and mantissa, do the base-32 power operation, and return
            // the original JavaScript number values.
            decode: function(key) {
                var sign = +key.substr(2, 1);
                var exponent = key.substr(3, 2);
                var mantissa = key.substr(5, 11);

                switch (signValues[sign]) {
                    case "negativeInfinity":
                        return -Infinity;
                    case "positiveInfinity":
                        return Infinity;
                    case "bigPositive":
                        return pow32(mantissa, exponent);
                    case "smallPositive":
                        exponent = negate(flipBase32(exponent));
                        return pow32(mantissa, exponent);
                    case "smallNegative":
                        exponent = negate(exponent);
                        mantissa = flipBase32(mantissa);
                        return -pow32(mantissa, exponent);
                    case "bigNegative":
                        exponent = flipBase32(exponent);
                        mantissa = flipBase32(mantissa);
                        return -pow32(mantissa, exponent);
                    default:
                        throw new Error("Invalid number.");
                }
            }
        },

        // Strings are encoded as JSON strings (with quotes and unicode characters escaped).
        //
        // IF the strings are in an array, then some extra encoding is done to make sorting work correctly:
        // Since we can't force all strings to be the same length, we need to ensure that characters line-up properly
        // for sorting, while also accounting for the extra characters that are added when the array itself is encoded as JSON.
        // To do this, each character of the string is prepended with a dash ("-"), and a space is added to the end of the string.
        // This effectively doubles the size of every string, but it ensures that when two arrays of strings are compared,
        // the indexes of each string's characters line up with each other.
        string: {
            encode: function(key, inArray) {
                if (inArray) {
                    // prepend each character with a dash, and append a space to the end
                    key = key.replace(/(.)/g, '-$1') + ' ';
                }
                return collations.indexOf("string") + "-" + key;
            },
            decode: function(key, inArray) {
                key = key.substring(2);
                if (inArray) {
                    // remove the space at the end, and the dash before each character
                    key = key.substr(0, key.length - 1).replace(/-(.)/g, '$1');
                }
                return key;
            }
        },

        // Arrays are encoded as JSON strings.
        // An extra, value is added to each array during encoding to make empty arrays sort correctly.
        array: {
            encode: function(key) {
                var encoded = [];
                for (var i = 0; i < key.length; i++) {
                    var item = key[i];
                    var encodedItem = idbModules.Key.encode(item, true);        // encode the array item
                    encoded[i] = encodedItem;
                }
                encoded.push(collations.indexOf("undefined") + "-");            // append an extra item, so empty arrays sort correctly
                return collations.indexOf("array") + "-" + JSON.stringify(encoded);
            },
            decode: function(key) {
                var decoded = JSON.parse(key.substring(2));
                decoded.pop();                                                  // remove the extra item
                for (var i = 0; i < decoded.length; i++) {
                    var item = decoded[i];
                    var decodedItem = idbModules.Key.decode(item, true);        // decode the item
                    decoded[i] = decodedItem;
                }
                return decoded;
            }
        }
    };

    /**
     * Return a padded base-32 exponent value.
     * @param {number}
     * @return {string}
     */
    function padBase32Exponent(n) {
        n = n.toString(32);
        return (n.length === 1) ? "0" + n : n;
    }

    /**
     * Return a padded base-32 mantissa.
     * @param {string}
     * @return {string}
     */
    function padBase32Mantissa(s) {
        return (s + zeros(11)).slice(0, 11);
    }

    /**
     * Flips each digit of a base-32 encoded string.
     * @param {string} encoded
     */
    function flipBase32(encoded) {
        var flipped = "";
        for (var i = 0; i < encoded.length; i++) {
            flipped += (31 - parseInt(encoded[i], 32)).toString(32);
        }
        return flipped;
    }

    /**
     * Base-32 power function.
     * RESEARCH: This function does not precisely decode floats because it performs
     * floating point arithmetic to recover values. But can the original values be
     * recovered exactly?
     * Someone may have already figured out a good way to store JavaScript floats as
     * binary strings and convert back. Barring a better method, however, one route
     * may be to generate decimal strings that `parseFloat` decodes predictably.
     * @param {string}
     * @param {string}
     * @return {number}
     */
    function pow32(mantissa, exponent) {
        var whole, fraction, expansion;
        exponent = parseInt(exponent, 32);
        if (exponent < 0) {
            return roundToPrecision(
                parseInt(mantissa, 32) * Math.pow(32, exponent - 10)
            );
        }
        else {
            if (exponent < 11) {
                whole = mantissa.slice(0, exponent);
                whole = parseInt(whole, 32);
                fraction = mantissa.slice(exponent);
                fraction = parseInt(fraction, 32) * Math.pow(32, exponent - 11);
                return roundToPrecision(whole + fraction);
            }
            else {
                expansion = mantissa + zeros(exponent - 11);
                return parseInt(expansion, 32);
            }
        }
    }

    /**
     *
     */
    function roundToPrecision(num, precision) {
        precision = precision || 16;
        return parseFloat(num.toPrecision(precision));
    }

    /**
     * Returns a string of n zeros.
     * @param {number}
     * @return {string}
     */
    function zeros(n) {
        var result = "";
        while (n--) {
            result = result + "0";
        }
        return result;
    }

    /**
     * Negates numeric strings.
     * @param {string}
     * @return {string}
     */
    function negate(s) {
        return "-" + s;
    }

    /**
     * Returns the string "number", "date", "string", or "array".
     */
    function getType(key) {
        if (key instanceof Date) {
            return "date";
        }
        if (key instanceof Array) {
            return "array";
        }
        return typeof key;
    }

    /**
     * Keys must be strings, numbers, Dates, or Arrays
     */
    function validate(key) {
        var type = getType(key);
        if (type === "array") {
            for (var i = 0; i < key.length; i++) {
                validate(key[i]);
            }
        }
        else if (!types[type] || (type !== "string" && isNaN(key))) {
            throw idbModules.util.createDOMException("DataError", "Not a valid key");
        }
    }

    /**
     * Returns the value of an inline key
     * @param {object} source
     * @param {string|array} keyPath
     */
    function getValue(source, keyPath) {
        try {
            if (keyPath instanceof Array) {
                var arrayValue = [];
                for (var i = 0; i < keyPath.length; i++) {
                    arrayValue.push(source[keyPath[i]]);
                }
                return arrayValue;
            } else {
                return source[keyPath];
            }
        }
        catch (e) {
            return undefined;
        }
    }

    /**
     * Sets the inline key value
     * @param {object} source
     * @param {string} keyPath
     * @param {*} value
     */
    function setValue(source, keyPath, value) {
        var props = keyPath.split('.');
        for (var i = 0; i < props.length - 1; i++) {
            var prop = props[i];
            source = source[prop] = source[prop] || {};
        }
        source[props[props.length - 1]] = value;
    }

    /**
     * Determines whether an index entry matches a multi-entry key value.
     * @param {string} encodedEntry     The entry value (already encoded)
     * @param {string} encodedKey       The full index key (already encoded)
     * @returns {boolean}
     */
    function isMultiEntryMatch(encodedEntry, encodedKey) {
        var keyType = collations[encodedKey.substring(0, 1)];

        if (keyType === "array") {
            return encodedKey.indexOf(encodedEntry) > 1;
        }
        else {
            return encodedKey === encodedEntry;
        }
    }

    function isKeyInRange(key, range) {
        var lowerMatch = range.lower === undefined;
        var upperMatch = range.upper === undefined;
        var encodedKey = idbModules.Key.encode(key, true);

        if (range.lower !== undefined) {
            if (range.lowerOpen && encodedKey > range.__lower) {
                lowerMatch = true;
            }
            if (!range.lowerOpen && encodedKey >= range.__lower) {
                lowerMatch = true;
            }
        }
        if (range.upper !== undefined) {
            if (range.upperOpen && encodedKey < range.__upper) {
                upperMatch = true;
            }
            if (!range.upperOpen && encodedKey <= range.__upper) {
                upperMatch = true;
            }
        }

        return lowerMatch && upperMatch;
    }

    function findMultiEntryMatches(keyEntry, range) {
        var matches = [];

        if (keyEntry instanceof Array) {
            for (var i = 0; i < keyEntry.length; i++) {
                var key = keyEntry[i];

                if (key instanceof Array) {
                    if (range.lower === range.upper) {
                        continue;
                    }
                    if (key.length === 1) {
                        key = key[0];
                    } else {
                        var nested = findMultiEntryMatches(key, range);
                        if (nested.length > 0) {
                            matches.push(key);
                        }
                        continue;
                    }
                }

                if (isKeyInRange(key, range)) {
                    matches.push(key);
                }
            }
        } else {
            if (isKeyInRange(keyEntry, range)) {
                matches.push(keyEntry);
            }
        }
        return matches;
    }

    idbModules.Key = {
        encode: function(key, inArray) {
            if (key === undefined) {
                return null;
            }
            return types[getType(key)].encode(key, inArray);
        },
        decode: function(key, inArray) {
            if (typeof key !== "string") {
                return undefined;
            }
            return types[collations[key.substring(0, 1)]].decode(key, inArray);
        },
        validate: validate,
        getValue: getValue,
        setValue: setValue,
        isMultiEntryMatch: isMultiEntryMatch,
        findMultiEntryMatches: findMultiEntryMatches
    };
}(idbModules));

(function(idbModules) {
    'use strict';

    /**
     * Creates a native Event object, for browsers that support it
     * @returns {Event}
     */
    function createNativeEvent(type, debug) {
        var event = new Event(type);
        event.debug = debug;

        // Make the "target" writable
        Object.defineProperty(event, 'target', {
            writable: true
        });

        return event;
    }

    /**
     * A shim Event class, for browsers that don't allow us to create native Event objects.
     * @constructor
     */
    function ShimEvent(type, debug) {
        this.type = type;
        this.debug = debug;
        this.bubbles = false;
        this.cancelable = false;
        this.eventPhase = 0;
        this.timeStamp = new Date().valueOf();
    }

    var useNativeEvent = false;
    try {
        // Test whether we can use the browser's native Event class
        var test = createNativeEvent('test type', 'test debug');
        var target = {test: 'test target'};
        test.target = target;

        if (test instanceof Event && test.type === 'test type' && test.debug === 'test debug' && test.target === target) {
            // Native events work as expected
            useNativeEvent = true;
        }
    }
    catch (e) {}

    if (useNativeEvent) {
        idbModules.Event = Event;
        idbModules.IDBVersionChangeEvent = Event;
        idbModules.util.createEvent = createNativeEvent;
    }
    else {
        idbModules.Event = ShimEvent;
        idbModules.IDBVersionChangeEvent = ShimEvent;
        idbModules.util.createEvent = function(type, debug) {
            return new ShimEvent(type, debug);
        };
    }
}(idbModules));

(function(idbModules) {
    'use strict';

    /**
     * Creates a native DOMException, for browsers that support it
     * @returns {DOMException}
     */
    function createNativeDOMException(name, message) {
        var e = new DOMException.prototype.constructor(0, message);
        e.name = name || 'DOMException';
        e.message = message;
        return e;
    }

    /**
     * Creates a native DOMError, for browsers that support it
     * @returns {DOMError}
     */
    function createNativeDOMError(name, message) {
        name = name || 'DOMError';
        var e = new DOMError(name, message);
        e.name === name || (e.name = name);
        e.message === message || (e.message = message);
        return e;
    }

    /**
     * Creates a generic Error object
     * @returns {Error}
     */
    function createError(name, message) {
        var e = new Error(message);
        e.name = name || 'DOMException';
        e.message = message;
        return e;
    }

    /**
     * Logs detailed error information to the console.
     * @param {string} name
     * @param {string} message
     * @param {string|Error|null} error
     */
    idbModules.util.logError = function(name, message, error) {
        if (idbModules.DEBUG) {
            if (error && error.message) {
                error = error.message;
            }

            var method = typeof(console.error) === 'function' ? 'error' : 'log';
            console[method](name + ': ' + message + '. ' + (error || ''));
            console.trace && console.trace();
        }
    };

    /**
     * Finds the error argument.  This is useful because some WebSQL callbacks
     * pass the error as the first argument, and some pass it as the second argument.
     * @param {array} args
     * @returns {Error|DOMException|undefined}
     */
    idbModules.util.findError = function(args) {
        var err;
        if (args) {
            if (args.length === 1) {
                return args[0];
            }
            for (var i = 0; i < args.length; i++) {
                var arg = args[i];
                if (arg instanceof Error || arg instanceof DOMException) {
                    return arg;
                }
                else if (arg && typeof arg.message === "string") {
                    err = arg;
                }
            }
        }
        return err;
    };

    var test, useNativeDOMException = false, useNativeDOMError = false;

    // Test whether we can use the browser's native DOMException class
    try {
        test = createNativeDOMException('test name', 'test message');
        if (test instanceof DOMException && test.name === 'test name' && test.message === 'test message') {
            // Native DOMException works as expected
            useNativeDOMException = true;
        }
    }
    catch (e) {}

    // Test whether we can use the browser's native DOMError class
    try {
        test = createNativeDOMError('test name', 'test message');
        if (test instanceof DOMError && test.name === 'test name' && test.message === 'test message') {
            // Native DOMError works as expected
            useNativeDOMError = true;
        }
    }
    catch (e) {}

    if (useNativeDOMException) {
        idbModules.DOMException = DOMException;
        idbModules.util.createDOMException = function(name, message, error) {
            idbModules.util.logError(name, message, error);
            return createNativeDOMException(name, message);
        };
    }
    else {
        idbModules.DOMException = Error;
        idbModules.util.createDOMException = function(name, message, error) {
            idbModules.util.logError(name, message, error);
            return createError(name, message);
        };
    }

    if (useNativeDOMError) {
        idbModules.DOMError = DOMError;
        idbModules.util.createDOMError = function(name, message, error) {
            idbModules.util.logError(name, message, error);
            return createNativeDOMError(name, message);
        };
    }
    else {
        idbModules.DOMError = Error;
        idbModules.util.createDOMError = function(name, message, error) {
            idbModules.util.logError(name, message, error);
            return createError(name, message);
        };
    }
}(idbModules));

(function(idbModules){
    'use strict';

    /**
     * The IDBRequest Object that is returns for all async calls
     * http://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#request-api
     */
    function IDBRequest(){
        this.onsuccess = this.onerror = this.result = this.error = this.source = this.transaction = null;
        this.readyState = "pending";
    }

    /**
     * The IDBOpenDBRequest called when a database is opened
     */
    function IDBOpenDBRequest(){
        this.onblocked = this.onupgradeneeded = null;
    }
    IDBOpenDBRequest.prototype = new IDBRequest();
    IDBOpenDBRequest.prototype.constructor = IDBOpenDBRequest;
    
    idbModules.IDBRequest = IDBRequest;
    idbModules.IDBOpenDBRequest = IDBOpenDBRequest;
    
}(idbModules));

(function(idbModules, undefined){
    'use strict';

    /**
     * The IndexedDB KeyRange object
     * http://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#dfn-key-range
     * @param {Object} lower
     * @param {Object} upper
     * @param {Object} lowerOpen
     * @param {Object} upperOpen
     */
    function IDBKeyRange(lower, upper, lowerOpen, upperOpen){
        if (lower !== undefined) {
            idbModules.Key.validate(lower);
        }
        if (upper !== undefined) {
            idbModules.Key.validate(upper);
        }

        this.lower = lower;
        this.upper = upper;
        this.lowerOpen = !!lowerOpen;
        this.upperOpen = !!upperOpen;
    }

    IDBKeyRange.only = function(value){
        return new IDBKeyRange(value, value, false, false);
    };

    IDBKeyRange.lowerBound = function(value, open){
        return new IDBKeyRange(value, undefined, open, undefined);
    };
    IDBKeyRange.upperBound = function(value, open){
        return new IDBKeyRange(undefined, value, undefined, open);
    };
    IDBKeyRange.bound = function(lower, upper, lowerOpen, upperOpen){
        return new IDBKeyRange(lower, upper, lowerOpen, upperOpen);
    };

    idbModules.IDBKeyRange = IDBKeyRange;

}(idbModules));

(function(idbModules, undefined){
    'use strict';

    /**
     * The IndexedDB Cursor Object
     * http://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#idl-def-IDBCursor
     * @param {IDBKeyRange} range
     * @param {string} direction
     * @param {IDBObjectStore} store
     * @param {IDBObjectStore|IDBIndex} source
     * @param {string} keyColumnName
     * @param {string} valueColumnName
     * @param {boolean} count
     */
    function IDBCursor(range, direction, store, source, keyColumnName, valueColumnName, count){
        // Calling openCursor on an index or objectstore with null is allowed but we treat it as undefined internally
        if (range === null) {
            range = undefined;
        }
        if (range !== undefined && !(range instanceof idbModules.IDBKeyRange)) {
            range = new idbModules.IDBKeyRange(range, range, false, false);
        }
        store.transaction.__assertActive();
        if (direction !== undefined && ["next", "prev", "nextunique", "prevunique"].indexOf(direction) === -1) {
            throw new TypeError(direction + "is not a valid cursor direction");
        }

        this.source = source;
        this.direction = direction || "next";
        this.key = undefined;
        this.primaryKey = undefined;
        this.__store = store;
        this.__range = range;
        this.__req = new idbModules.IDBRequest();
        this.__keyColumnName = keyColumnName;
        this.__valueColumnName = valueColumnName;
        this.__valueDecoder = valueColumnName === "value" ? idbModules.Sca : idbModules.Key;
        this.__count = count;
        this.__offset = -1; // Setting this to -1 as continue will set it to 0 anyway
        this.__lastKeyContinued = undefined; // Used when continuing with a key
        this.__multiEntryIndex = source instanceof idbModules.IDBIndex ? source.multiEntry : false;
        this.__unique = this.direction.indexOf("unique") !== -1;

        if (range !== undefined) {
            // Encode the key range and cache the encoded values, so we don't have to re-encode them over and over
            range.__lower = range.lower !== undefined && idbModules.Key.encode(range.lower, this.__multiEntryIndex);
            range.__upper = range.upper !== undefined && idbModules.Key.encode(range.upper, this.__multiEntryIndex);
        }

        this["continue"]();
    }

    IDBCursor.prototype.__find = function (/* key, tx, success, error, recordsToLoad */) {
        var args = Array.prototype.slice.call(arguments);
        if (this.__multiEntryIndex) {
            this.__findMultiEntry.apply(this, args);
        } else {
            this.__findBasic.apply(this, args);
        }
    };

    IDBCursor.prototype.__findBasic = function (key, tx, success, error, recordsToLoad) {
        recordsToLoad = recordsToLoad || 1;

        var me = this;
        var quotedKeyColumnName = idbModules.util.quote(me.__keyColumnName);
        var sql = ["SELECT * FROM", idbModules.util.quote(me.__store.name)];
        var sqlValues = [];
        sql.push("WHERE", quotedKeyColumnName, "NOT NULL");
        if (me.__range && (me.__range.lower !== undefined || me.__range.upper !== undefined )) {
            sql.push("AND");
            if (me.__range.lower !== undefined) {
                sql.push(quotedKeyColumnName, (me.__range.lowerOpen ? ">" : ">="), "?");
                sqlValues.push(me.__range.__lower);
            }
            (me.__range.lower !== undefined && me.__range.upper !== undefined) && sql.push("AND");
            if (me.__range.upper !== undefined) {
                sql.push(quotedKeyColumnName, (me.__range.upperOpen ? "<" : "<="), "?");
                sqlValues.push(me.__range.__upper);
            }
        }
        if (typeof key !== "undefined") {
            me.__lastKeyContinued = key;
            me.__offset = 0;
        }
        if (me.__lastKeyContinued !== undefined) {
            sql.push("AND", quotedKeyColumnName, ">= ?");
            idbModules.Key.validate(me.__lastKeyContinued);
            sqlValues.push(idbModules.Key.encode(me.__lastKeyContinued));
        }

        // Determine the ORDER BY direction based on the cursor.
        var direction = me.direction === 'prev' || me.direction === 'prevunique' ? 'DESC' : 'ASC';

        if (!me.__count) {
            sql.push("ORDER BY", quotedKeyColumnName, direction);
            sql.push("LIMIT", recordsToLoad, "OFFSET", me.__offset);
        }
        sql = sql.join(" ");
        idbModules.DEBUG && console.log(sql, sqlValues);

        me.__prefetchedData = null;
        me.__prefetchedIndex = 0;
        tx.executeSql(sql, sqlValues, function (tx, data) {
            if (me.__count) {
                success(undefined, data.rows.length, undefined);
            }
            else if (data.rows.length > 1) {
                me.__prefetchedData = data.rows;
                me.__prefetchedIndex = 0;
                idbModules.DEBUG && console.log("Preloaded " + me.__prefetchedData.length + " records for cursor");
                me.__decode(data.rows.item(0), success);
            }
            else if (data.rows.length === 1) {
                me.__decode(data.rows.item(0), success);
            }
            else {
                idbModules.DEBUG && console.log("Reached end of cursors");
                success(undefined, undefined, undefined);
            }
        }, function (tx, err) {
            idbModules.DEBUG && console.log("Could not execute Cursor.continue", sql, sqlValues);
            error(err);
        });
    };

    IDBCursor.prototype.__findMultiEntry = function (key, tx, success, error) {
        var me = this;

        if (me.__prefetchedData && me.__prefetchedData.length === me.__prefetchedIndex) {
            idbModules.DEBUG && console.log("Reached end of multiEntry cursor");
            success(undefined, undefined, undefined);
            return;
        }

        var quotedKeyColumnName = idbModules.util.quote(me.__keyColumnName);
        var sql = ["SELECT * FROM", idbModules.util.quote(me.__store.name)];
        var sqlValues = [];
        sql.push("WHERE", quotedKeyColumnName, "NOT NULL");
        if (me.__range && (me.__range.lower !== undefined && me.__range.upper !== undefined)) {
            if (me.__range.upper.indexOf(me.__range.lower) === 0) {
                sql.push("AND", quotedKeyColumnName, "LIKE ?");
                sqlValues.push("%" + me.__range.__lower.slice(0, -1) + "%");
            }
        }
        if (typeof key !== "undefined") {
            me.__lastKeyContinued = key;
            me.__offset = 0;
        }
        if (me.__lastKeyContinued !== undefined) {
            sql.push("AND", quotedKeyColumnName, ">= ?");
            idbModules.Key.validate(me.__lastKeyContinued);
            sqlValues.push(idbModules.Key.encode(me.__lastKeyContinued));
        }

        // Determine the ORDER BY direction based on the cursor.
        var direction = me.direction === 'prev' || me.direction === 'prevunique' ? 'DESC' : 'ASC';

        if (!me.__count) {
            sql.push("ORDER BY key", direction);
        }
        sql = sql.join(" ");
        idbModules.DEBUG && console.log(sql, sqlValues);

        me.__prefetchedData = null;
        me.__prefetchedIndex = 0;
        tx.executeSql(sql, sqlValues, function (tx, data) {
            me.__multiEntryOffset = data.rows.length;

            if (data.rows.length > 0) {
                var rows = [];

                for (var i = 0; i < data.rows.length; i++) {
                    var rowItem = data.rows.item(i);
                    var rowKey = idbModules.Key.decode(rowItem[me.__keyColumnName], true);
                    var matches = idbModules.Key.findMultiEntryMatches(rowKey, me.__range);

                    for (var j = 0; j < matches.length; j++) {
                        var matchingKey = matches[j];
                        var clone = {
                            matchingKey: idbModules.Key.encode(matchingKey, true),
                            key: rowItem.key
                        };
                        clone[me.__keyColumnName] = rowItem[me.__keyColumnName];
                        clone[me.__valueColumnName] = rowItem[me.__valueColumnName];
                        rows.push(clone);
                    }
                }

                var reverse = me.direction.indexOf("prev") === 0;
                rows.sort(function (a, b) {
                    if (a.matchingKey.replace('[','z') < b.matchingKey.replace('[','z')) {
                        return reverse ? 1 : -1;
                    }
                    if (a.matchingKey.replace('[','z') > b.matchingKey.replace('[','z')) {
                        return reverse ? -1 : 1;
                    }
                    if (a.key < b.key) {
                        return me.direction === "prev" ? 1 : -1;
                    }
                    if (a.key > b.key) {
                        return me.direction === "prev" ? -1 : 1;
                    }
                    return 0;
                });

                me.__prefetchedData = {
                    data: rows,
                    length: rows.length,
                    item: function (index) {
                        return this.data[index];
                    }
                };
                me.__prefetchedIndex = 0;

                if (me.__count) {
                    success(undefined, rows.length, undefined);
                }
                else if (rows.length > 1) {
                    idbModules.DEBUG && console.log("Preloaded " + me.__prefetchedData.length + " records for multiEntry cursor");
                    me.__decode(rows[0], success);
                } else if (rows.length === 1) {
                    idbModules.DEBUG && console.log("Reached end of multiEntry cursor");
                    me.__decode(rows[0], success);
                } else {
                    idbModules.DEBUG && console.log("Reached end of multiEntry cursor");
                    success(undefined, undefined, undefined);
                }
            }
            else {
                idbModules.DEBUG && console.log("Reached end of multiEntry cursor");
                success(undefined, undefined, undefined);
            }
        }, function (tx, err) {
            idbModules.DEBUG && console.log("Could not execute Cursor.continue", sql, sqlValues);
            error(err);
        });
    };

    /**
     * Creates an "onsuccess" callback
     * @private
     */
    IDBCursor.prototype.__onsuccess = function(success) {
        var me = this;
        return function(key, value, primaryKey) {
            if (me.__count) {
                success(value, me.__req);
            }
            else {
                me.key = key === undefined ? null : key;
                me.value = value === undefined ? null : value;
                me.primaryKey = primaryKey === undefined ? null : primaryKey;
                var result = key === undefined ? null : me;
                success(result, me.__req);
            }
        };
    };

    IDBCursor.prototype.__decode = function (rowItem, callback) {
        if (this.__multiEntryIndex && this.__unique) {
            if (!this.__matchedKeys) {
                this.__matchedKeys = {};
            }
            if (this.__matchedKeys[rowItem.matchingKey]) {
                callback(undefined, undefined, undefined);
                return;
            }
            this.__matchedKeys[rowItem.matchingKey] = true;
        }
        var key = idbModules.Key.decode(this.__multiEntryIndex ? rowItem.matchingKey : rowItem[this.__keyColumnName], this.__multiEntryIndex);
        var val = this.__valueDecoder.decode(rowItem[this.__valueColumnName]);
        var primaryKey = idbModules.Key.decode(rowItem.key);
        callback(key, val, primaryKey);
    };

    IDBCursor.prototype["continue"] = function (key) {
        var recordsToPreloadOnContinue = idbModules.cursorPreloadPackSize || 100;
        var me = this;

        this.__store.transaction.__pushToQueue(me.__req, function cursorContinue(tx, args, success, error) {
            me.__offset++;

            if (me.__prefetchedData) {
                // We have pre-loaded data for the cursor
                me.__prefetchedIndex++;
                if (me.__prefetchedIndex < me.__prefetchedData.length) {
                    me.__decode(me.__prefetchedData.item(me.__prefetchedIndex), me.__onsuccess(success));
                    return;
                }
            }

            // No pre-fetched data, do query
            me.__find(key, tx, me.__onsuccess(success), error, recordsToPreloadOnContinue);
        });
    };

    IDBCursor.prototype.advance = function(count){
        if (count <= 0) {
            throw idbModules.util.createDOMException("Type Error", "Count is invalid - 0 or negative", count);
        }
        var me = this;
        this.__store.transaction.__pushToQueue(me.__req, function cursorAdvance(tx, args, success, error){
            me.__offset += count;
            me.__find(undefined, tx, me.__onsuccess(success), error);
        });
    };

    IDBCursor.prototype.update = function(valueToUpdate){
        var me = this;
        me.__store.transaction.__assertWritable();
        return me.__store.transaction.__addToTransactionQueue(function cursorUpdate(tx, args, success, error){
            idbModules.Sca.encode(valueToUpdate, function(encoded) {
                me.__find(undefined, tx, function(key, value, primaryKey){
                    var store = me.__store;
                    var params = [encoded];
                    var sql = ["UPDATE", idbModules.util.quote(store.name), "SET value = ?"];
                    idbModules.Key.validate(primaryKey);

                    // Also correct the indexes in the table
                    for (var i = 0; i < store.indexNames.length; i++) {
                        var index = store.__indexes[store.indexNames[i]];
                        var indexKey = idbModules.Key.getValue(valueToUpdate, index.keyPath);
                        sql.push(",", idbModules.util.quote(index.name), "= ?");
                        params.push(idbModules.Key.encode(indexKey, index.multiEntry));
                    }

                    sql.push("WHERE key = ?");
                    params.push(idbModules.Key.encode(primaryKey));

                    idbModules.DEBUG && console.log(sql.join(" "), encoded, key, primaryKey);
                    tx.executeSql(sql.join(" "), params, function(tx, data){
                        me.__prefetchedData = null;
                        me.__prefetchedIndex = 0;
                        if (data.rowsAffected === 1) {
                            success(key);
                        }
                        else {
                            error("No rows with key found" + key);
                        }
                    }, function(tx, data){
                        error(data);
                    });
                }, error);
            });
        });
    };

    IDBCursor.prototype["delete"] = function(){
        var me = this;
        me.__store.transaction.__assertWritable();
        return this.__store.transaction.__addToTransactionQueue(function cursorDelete(tx, args, success, error){
            me.__find(undefined, tx, function(key, value, primaryKey){
                var sql = "DELETE FROM  " + idbModules.util.quote(me.__store.name) + " WHERE key = ?";
                idbModules.DEBUG && console.log(sql, key, primaryKey);
                idbModules.Key.validate(primaryKey);
                tx.executeSql(sql, [idbModules.Key.encode(primaryKey)], function(tx, data){
                    me.__prefetchedData = null;
                    me.__prefetchedIndex = 0;
                    if (data.rowsAffected === 1) {
                        // lower the offset or we will miss a row
                        me.__offset--;
                        success(undefined);
                    }
                    else {
                        error("No rows with key found" + key);
                    }
                }, function(tx, data){
                    error(data);
                });
            }, error);
        });
    };

    idbModules.IDBCursor = IDBCursor;
}(idbModules));

(function(idbModules, undefined) {
    'use strict';

    /**
     * IDB Index
     * http://www.w3.org/TR/IndexedDB/#idl-def-IDBIndex
     * @param {IDBObjectStore} store
     * @param {IDBIndexProperties} indexProperties
     * @constructor
     */
    function IDBIndex(store, indexProperties) {
        this.objectStore = store;
        this.name = indexProperties.columnName;
        this.keyPath = indexProperties.keyPath;
        this.multiEntry = indexProperties.optionalParams && indexProperties.optionalParams.multiEntry;
        this.unique = indexProperties.optionalParams && indexProperties.optionalParams.unique;
        this.__deleted = !!indexProperties.__deleted;
    }

    /**
     * Clones an IDBIndex instance for a different IDBObjectStore instance.
     * @param {IDBIndex} index
     * @param {IDBObjectStore} store
     * @protected
     */
    IDBIndex.__clone = function(index, store) {
        return new IDBIndex(store, {
            columnName: index.name,
            keyPath: index.keyPath,
            optionalParams: {
                multiEntry: index.multiEntry,
                unique: index.unique
            }
        });
    };

    /**
     * Creates a new index on an object store.
     * @param {IDBObjectStore} store
     * @param {IDBIndex} index
     * @returns {IDBIndex}
     * @protected
     */
    IDBIndex.__createIndex = function(store, index) {
        var columnExists = !!store.__indexes[index.name] && store.__indexes[index.name].__deleted;

        // Add the index to the IDBObjectStore
        store.__indexes[index.name] = index;
        store.indexNames.push(index.name);

        // Create the index in WebSQL
        var transaction = store.transaction;
        transaction.__addToTransactionQueue(function createIndex(tx, args, success, failure) {
            function error(tx, err) {
                failure(idbModules.util.createDOMException(0, "Could not create index \"" + index.name + "\"", err));
            }

            function applyIndex(tx) {
                // Update the object store's index list
                IDBIndex.__updateIndexList(store, tx, function() {
                    // Add index entries for all existing records
                    tx.executeSql("SELECT * FROM " + idbModules.util.quote(store.name), [], function(tx, data) {
                        idbModules.DEBUG && console.log("Adding existing " + store.name + " records to the " + index.name + " index");
                        addIndexEntry(0);

                        function addIndexEntry(i) {
                            if (i < data.rows.length) {
                                try {
                                    var value = idbModules.Sca.decode(data.rows.item(i).value);
                                    var indexKey = idbModules.Key.getValue(value, index.keyPath);
                                    indexKey = idbModules.Key.encode(indexKey, index.multiEntry);

                                    tx.executeSql("UPDATE " + idbModules.util.quote(store.name) + " set " + idbModules.util.quote(index.name) + " = ? where key = ?", [indexKey, data.rows.item(i).key], function(tx, data) {
                                        addIndexEntry(i + 1);
                                    }, error);
                                }
                                catch (e) {
                                    // Not a valid value to insert into index, so just continue
                                    addIndexEntry(i + 1);
                                }
                            }
                            else {
                                success(store);
                            }
                        }
                    }, error);
                }, error);
            }

            if (columnExists) {
                // For a previously existing index, just update the index entries in the existing column
                applyIndex(tx);
            }
            else {
                // For a new index, add a new column to the object store, then apply the index
                var sql = ["ALTER TABLE", idbModules.util.quote(store.name), "ADD", idbModules.util.quote(index.name), "BLOB"].join(" ");
                idbModules.DEBUG && console.log(sql);
                tx.executeSql(sql, [], applyIndex, error);
            }
        });
    };

    /**
     * Deletes an index from an object store.
     * @param {IDBObjectStore} store
     * @param {IDBIndex} index
     * @protected
     */
    IDBIndex.__deleteIndex = function(store, index) {
        // Remove the index from the IDBObjectStore
        store.__indexes[index.name].__deleted = true;
        store.indexNames.splice(store.indexNames.indexOf(index.name), 1);

        // Remove the index in WebSQL
        var transaction = store.transaction;
        transaction.__addToTransactionQueue(function createIndex(tx, args, success, failure) {
            function error(tx, err) {
                failure(idbModules.util.createDOMException(0, "Could not delete index \"" + index.name + "\"", err));
            }

            // Update the object store's index list
            IDBIndex.__updateIndexList(store, tx, success, error);
        });
    };

    /**
     * Updates index list for the given object store.
     * @param {IDBObjectStore} store
     * @param {object} tx
     * @param {function} success
     * @param {function} failure
     */
    IDBIndex.__updateIndexList = function(store, tx, success, failure) {
        var indexList = {};
        for (var i = 0; i < store.indexNames.length; i++) {
            var idx = store.__indexes[store.indexNames[i]];
            /** @type {IDBIndexProperties} **/
            indexList[idx.name] = {
                columnName: idx.name,
                keyPath: idx.keyPath,
                optionalParams: {
                    unique: idx.unique,
                    multiEntry: idx.multiEntry
                },
                deleted: !!idx.deleted
            };
        }

        idbModules.DEBUG && console.log("Updating the index list for " + store.name, indexList);
        tx.executeSql("UPDATE __sys__ set indexList = ? where name = ?", [JSON.stringify(indexList), store.name], function() {
            success(store);
        }, failure);
    };

    /**
     * Retrieves index data for the given key
     * @param {*|IDBKeyRange} key
     * @param {string} opType
     * @returns {IDBRequest}
     * @private
     */
    IDBIndex.prototype.__fetchIndexData = function(key, opType) {
        var me = this;
        var hasKey, encodedKey;

        // key is optional
        if (arguments.length === 1) {
            opType = key;
            hasKey = false;
        }
        else {
            idbModules.Key.validate(key);
            encodedKey = idbModules.Key.encode(key, me.multiEntry);
            hasKey = true;
        }

        return me.objectStore.transaction.__addToTransactionQueue(function fetchIndexData(tx, args, success, error) {
            var sql = ["SELECT * FROM", idbModules.util.quote(me.objectStore.name), "WHERE", idbModules.util.quote(me.name), "NOT NULL"];
            var sqlValues = [];
            if (hasKey) {
                if (me.multiEntry) {
                    sql.push("AND", idbModules.util.quote(me.name), "LIKE ?");
                    sqlValues.push("%" + encodedKey + "%");
                }
                else {
                    sql.push("AND", idbModules.util.quote(me.name), "= ?");
                    sqlValues.push(encodedKey);
                }
            }
            idbModules.DEBUG && console.log("Trying to fetch data for Index", sql.join(" "), sqlValues);
            tx.executeSql(sql.join(" "), sqlValues, function(tx, data) {
                var recordCount = 0, record = null;
                if (me.multiEntry) {
                    for (var i = 0; i < data.rows.length; i++) {
                        var row = data.rows.item(i);
                        var rowKey = idbModules.Key.decode(row[me.name]);
                        if (hasKey && idbModules.Key.isMultiEntryMatch(encodedKey, row[me.name])) {
                            recordCount++;
                            record = record || row;
                        }
                        else if (!hasKey && rowKey !== undefined) {
                            recordCount = recordCount + (rowKey instanceof Array ? rowKey.length : 1);
                            record = record || row;
                        }
                    }
                }
                else {
                    recordCount = data.rows.length;
                    record = recordCount && data.rows.item(0);
                }

                if (opType === "count") {
                    success(recordCount);
                }
                else if (recordCount === 0) {
                    success(undefined);
                }
                else if (opType === "key") {
                    success(idbModules.Key.decode(record.key));
                }
                else { // when opType is value
                    success(idbModules.Sca.decode(record.value));
                }
            }, error);
        });
    };

    /**
     * Opens a cursor over the given key range.
     * @param {IDBKeyRange} range
     * @param {string} direction
     * @returns {IDBRequest}
     */
    IDBIndex.prototype.openCursor = function(range, direction) {
        return new idbModules.IDBCursor(range, direction, this.objectStore, this, this.name, "value").__req;
    };

    /**
     * Opens a cursor over the given key range.  The cursor only includes key values, not data.
     * @param {IDBKeyRange} range
     * @param {string} direction
     * @returns {IDBRequest}
     */
    IDBIndex.prototype.openKeyCursor = function(range, direction) {
        return new idbModules.IDBCursor(range, direction, this.objectStore, this, this.name, "key").__req;
    };

    IDBIndex.prototype.get = function(key) {
        if (arguments.length === 0) {
            throw new TypeError("No key was specified");
        }

        return this.__fetchIndexData(key, "value");
    };

    IDBIndex.prototype.getKey = function(key) {
        if (arguments.length === 0) {
            throw new TypeError("No key was specified");
        }

        return this.__fetchIndexData(key, "key");
    };

    IDBIndex.prototype.count = function(key) {
        // key is optional
        if (key === undefined) {
            return this.__fetchIndexData("count");
        }
        else if (key instanceof idbModules.IDBKeyRange) {
            return new idbModules.IDBCursor(key, "next", this.objectStore, this, this.name, "value", true).__req;
        }
        else {
            return this.__fetchIndexData(key, "count");
        }
    };

    idbModules.IDBIndex = IDBIndex;
}(idbModules));

(function(idbModules) {
    'use strict';

    /**
     * IndexedDB Object Store
     * http://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#idl-def-IDBObjectStore
     * @param {IDBObjectStoreProperties} storeProperties
     * @param {IDBTransaction} transaction
     * @constructor
     */
    function IDBObjectStore(storeProperties, transaction) {
        this.name = storeProperties.name;
        this.keyPath = JSON.parse(storeProperties.keyPath);
        this.transaction = transaction;

        // autoInc is numeric (0/1) on WinPhone
        this.autoIncrement = typeof storeProperties.autoInc === "string" ? storeProperties.autoInc === "true" : !!storeProperties.autoInc;

        this.__indexes = {};
        this.indexNames = new idbModules.util.StringList();
        var indexList = JSON.parse(storeProperties.indexList);
        for (var indexName in indexList) {
            if (indexList.hasOwnProperty(indexName)) {
                var index = new idbModules.IDBIndex(this, indexList[indexName]);
                this.__indexes[index.name] = index;
                if (!index.__deleted) {
                    this.indexNames.push(index.name);
                }
            }
        }
    }

    /**
     * Clones an IDBObjectStore instance for a different IDBTransaction instance.
     * @param {IDBObjectStore} store
     * @param {IDBTransaction} transaction
     * @protected
     */
    IDBObjectStore.__clone = function(store, transaction) {
        var newStore = new IDBObjectStore({
            name: store.name,
            keyPath: JSON.stringify(store.keyPath),
            autoInc: JSON.stringify(store.autoIncrement),
            indexList: "{}"
        }, transaction);
        newStore.__indexes = store.__indexes;
        newStore.indexNames = store.indexNames;
        return newStore;
    };

    /**
     * Creates a new object store in the database.
     * @param {IDBDatabase} db
     * @param {IDBObjectStore} store
     * @protected
     */
    IDBObjectStore.__createObjectStore = function(db, store) {
        // Add the object store to the IDBDatabase
        db.__objectStores[store.name] = store;
        db.objectStoreNames.push(store.name);

        // Add the object store to WebSQL
        var transaction = db.__versionTransaction;
        idbModules.IDBTransaction.__assertVersionChange(transaction);
        transaction.__addToTransactionQueue(function createObjectStore(tx, args, success, failure) {
            function error(tx, err) {
                throw idbModules.util.createDOMException(0, "Could not create object store \"" + store.name + "\"", err);
            }

            //key INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL UNIQUE
            var sql = ["CREATE TABLE", idbModules.util.quote(store.name), "(key BLOB", store.autoIncrement ? "UNIQUE, inc INTEGER PRIMARY KEY AUTOINCREMENT" : "PRIMARY KEY", ", value BLOB)"].join(" ");
            idbModules.DEBUG && console.log(sql);
            tx.executeSql(sql, [], function(tx, data) {
                tx.executeSql("INSERT INTO __sys__ VALUES (?,?,?,?)", [store.name, JSON.stringify(store.keyPath), store.autoIncrement, "{}"], function() {
                    success(store);
                }, error);
            }, error);
        });
    };

    /**
     * Deletes an object store from the database.
     * @param {IDBDatabase} db
     * @param {IDBObjectStore} store
     * @protected
     */
    IDBObjectStore.__deleteObjectStore = function(db, store) {
        // Remove the object store from the IDBDatabase
        db.__objectStores[store.name] = undefined;
        db.objectStoreNames.splice(db.objectStoreNames.indexOf(store.name), 1);

        // Remove the object store from WebSQL
        var transaction = db.__versionTransaction;
        idbModules.IDBTransaction.__assertVersionChange(transaction);
        transaction.__addToTransactionQueue(function deleteObjectStore(tx, args, success, failure) {
            function error(tx, err) {
                failure(idbModules.util.createDOMException(0, "Could not delete ObjectStore", err));
            }

            tx.executeSql("SELECT * FROM __sys__ where name = ?", [store.name], function(tx, data) {
                if (data.rows.length > 0) {
                    tx.executeSql("DROP TABLE " + idbModules.util.quote(store.name), [], function() {
                        tx.executeSql("DELETE FROM __sys__ WHERE name = ?", [store.name], function() {
                            success();
                        }, error);
                    }, error);
                }
            });
        });
    };

    /**
     * Determines whether the given inline or out-of-line key is valid, according to the object store's schema.
     * @param {*} value     Used for inline keys
     * @param {*} key       Used for out-of-line keys
     * @private
     */
    IDBObjectStore.prototype.__validateKey = function(value, key) {
        if (this.keyPath) {
            if (typeof key !== "undefined") {
                throw idbModules.util.createDOMException("DataError", "The object store uses in-line keys and the key parameter was provided", this);
            }
            else if (value && typeof value === "object") {
                key = idbModules.Key.getValue(value, this.keyPath);
                if (key === undefined) {
                    if (this.autoIncrement) {
                        // A key will be generated
                        return;
                    }
                    else {
                        throw idbModules.util.createDOMException("DataError", "Could not eval key from keyPath");
                    }
                }
            }
            else {
                throw idbModules.util.createDOMException("DataError", "KeyPath was specified, but value was not an object");
            }
        }
        else {
            if (typeof key === "undefined") {
                if (this.autoIncrement) {
                    // A key will be generated
                    return;
                }
                else {
                    throw idbModules.util.createDOMException("DataError", "The object store uses out-of-line keys and has no key generator and the key parameter was not provided. ", this);
                }
            }
        }

        idbModules.Key.validate(key);
    };

    /**
     * From the store properties and object, extracts the value for the key in hte object Store
     * If the table has auto increment, get the next in sequence
     * @param {Object} tx
     * @param {Object} value
     * @param {Object} key
     * @param {function} success
     * @param {function} failure
     */
    IDBObjectStore.prototype.__deriveKey = function(tx, value, key, success, failure) {
        var me = this;

        function getNextAutoIncKey(callback) {
            tx.executeSql("SELECT * FROM sqlite_sequence where name like ?", [me.name], function(tx, data) {
                if (data.rows.length !== 1) {
                    callback(1);
                }
                else {
                    callback(data.rows.item(0).seq + 1);
                }
            }, function(tx, error) {
                failure(idbModules.util.createDOMException("DataError", "Could not get the auto increment value for key", error));
            });
        }

        if (me.keyPath) {
            var primaryKey = idbModules.Key.getValue(value, me.keyPath);
            if (primaryKey === undefined && me.autoIncrement) {
                getNextAutoIncKey(function(primaryKey) {
                    try {
                        // Update the value with the new key
                        idbModules.Key.setValue(value, me.keyPath, primaryKey);
                        success(primaryKey);
                    }
                    catch (e) {
                        failure(idbModules.util.createDOMException("DataError", "Could not assign a generated value to the keyPath", e));
                    }
                });
            }
            else {
                success(primaryKey);
            }
        }
        else {
            if (typeof key === "undefined" && me.autoIncrement) {
                // Looks like this has autoInc, so lets get the next in sequence and return that.
                getNextAutoIncKey(success);
            }
            else {
                success(key);
            }
        }
    };

    IDBObjectStore.prototype.__insertData = function(tx, encoded, value, primaryKey, success, error) {
        try {
            var paramMap = {};
            if (typeof primaryKey !== "undefined") {
                idbModules.Key.validate(primaryKey);
                paramMap.key = idbModules.Key.encode(primaryKey);
            }
            for (var i = 0; i < this.indexNames.length; i++) {
                var index = this.__indexes[this.indexNames[i]];
                paramMap[index.name] = idbModules.Key.encode(idbModules.Key.getValue(value, index.keyPath), index.multiEntry);
            }
            var sqlStart = ["INSERT INTO ", idbModules.util.quote(this.name), "("];
            var sqlEnd = [" VALUES ("];
            var sqlValues = [];
            for (var key in paramMap) {
                sqlStart.push(idbModules.util.quote(key) + ",");
                sqlEnd.push("?,");
                sqlValues.push(paramMap[key]);
            }
            // removing the trailing comma
            sqlStart.push("value )");
            sqlEnd.push("?)");
            sqlValues.push(encoded);

            var sql = sqlStart.join(" ") + sqlEnd.join(" ");

            idbModules.DEBUG && console.log("SQL for adding", sql, sqlValues);
            tx.executeSql(sql, sqlValues, function(tx, data) {
                idbModules.Sca.encode(primaryKey, function(primaryKey) {
                    primaryKey = idbModules.Sca.decode(primaryKey);
                    success(primaryKey);
                });
            }, function(tx, err) {
                error(idbModules.util.createDOMError("ConstraintError", err.message, err));
            });
        }
        catch (e) {
            error(e);
        }
    };

    IDBObjectStore.prototype.add = function(value, key) {
        var me = this;
        if (arguments.length === 0) {
            throw new TypeError("No value was specified");
        }
        this.__validateKey(value, key);
        me.transaction.__assertWritable();

        var request = me.transaction.__createRequest();
        me.transaction.__pushToQueue(request, function objectStoreAdd(tx, args, success, error) {
            me.__deriveKey(tx, value, key, function(primaryKey) {
                idbModules.Sca.encode(value, function(encoded) {
                    me.__insertData(tx, encoded, value, primaryKey, success, error);
                });
            }, error);
        });
        return request;
    };

    IDBObjectStore.prototype.put = function(value, key) {
        var me = this;
        if (arguments.length === 0) {
            throw new TypeError("No value was specified");
        }
        this.__validateKey(value, key);
        me.transaction.__assertWritable();

        var request = me.transaction.__createRequest();
        me.transaction.__pushToQueue(request, function objectStorePut(tx, args, success, error) {
            me.__deriveKey(tx, value, key, function(primaryKey) {
                idbModules.Sca.encode(value, function(encoded) {
                    // First try to delete if the record exists
                    idbModules.Key.validate(primaryKey);
                    var sql = "DELETE FROM " + idbModules.util.quote(me.name) + " where key = ?";
                    tx.executeSql(sql, [idbModules.Key.encode(primaryKey)], function(tx, data) {
                        idbModules.DEBUG && console.log("Did the row with the", primaryKey, "exist? ", data.rowsAffected);
                        me.__insertData(tx, encoded, value, primaryKey, success, error);
                    }, function(tx, err) {
                        error(err);
                    });
                });
            }, error);
        });
        return request;
    };

    IDBObjectStore.prototype.get = function(key) {
        // TODO Key should also be a key range
        var me = this;

        if (arguments.length === 0) {
            throw new TypeError("No key was specified");
        }

        idbModules.Key.validate(key);
        var primaryKey = idbModules.Key.encode(key);
        return me.transaction.__addToTransactionQueue(function objectStoreGet(tx, args, success, error) {
            idbModules.DEBUG && console.log("Fetching", me.name, primaryKey);
            tx.executeSql("SELECT * FROM " + idbModules.util.quote(me.name) + " where key = ?", [primaryKey], function(tx, data) {
                idbModules.DEBUG && console.log("Fetched data", data);
                var value;
                try {
                    // Opera can't deal with the try-catch here.
                    if (0 === data.rows.length) {
                        return success();
                    }

                    value = idbModules.Sca.decode(data.rows.item(0).value);
                }
                catch (e) {
                    // If no result is returned, or error occurs when parsing JSON
                    idbModules.DEBUG && console.log(e);
                }
                success(value);
            }, function(tx, err) {
                error(err);
            });
        });
    };

    IDBObjectStore.prototype["delete"] = function(key) {
        var me = this;

        if (arguments.length === 0) {
            throw new TypeError("No key was specified");
        }

        me.transaction.__assertWritable();
        idbModules.Key.validate(key);
        var primaryKey = idbModules.Key.encode(key);
        // TODO key should also support key ranges
        return me.transaction.__addToTransactionQueue(function objectStoreDelete(tx, args, success, error) {
            idbModules.DEBUG && console.log("Fetching", me.name, primaryKey);
            tx.executeSql("DELETE FROM " + idbModules.util.quote(me.name) + " where key = ?", [primaryKey], function(tx, data) {
                idbModules.DEBUG && console.log("Deleted from database", data.rowsAffected);
                success();
            }, function(tx, err) {
                error(err);
            });
        });
    };

    IDBObjectStore.prototype.clear = function() {
        var me = this;
        me.transaction.__assertWritable();
        return me.transaction.__addToTransactionQueue(function objectStoreClear(tx, args, success, error) {
            tx.executeSql("DELETE FROM " + idbModules.util.quote(me.name), [], function(tx, data) {
                idbModules.DEBUG && console.log("Cleared all records from database", data.rowsAffected);
                success();
            }, function(tx, err) {
                error(err);
            });
        });
    };

    IDBObjectStore.prototype.count = function(key) {
        if (key instanceof idbModules.IDBKeyRange) {
            return new idbModules.IDBCursor(key, "next", this, this, "key", "value", true).__req;
        }
        else {
            var me = this;
            var hasKey = false;

            // key is optional
            if (key !== undefined) {
                hasKey = true;
                idbModules.Key.validate(key);
            }

            return me.transaction.__addToTransactionQueue(function objectStoreCount(tx, args, success, error) {
                var sql = "SELECT * FROM " + idbModules.util.quote(me.name) + (hasKey ? " WHERE key = ?" : "");
                var sqlValues = [];
                hasKey && sqlValues.push(idbModules.Key.encode(key));
                tx.executeSql(sql, sqlValues, function(tx, data) {
                    success(data.rows.length);
                }, function(tx, err) {
                    error(err);
                });
            });
        }
    };

    IDBObjectStore.prototype.openCursor = function(range, direction) {
        return new idbModules.IDBCursor(range, direction, this, this, "key", "value").__req;
    };

    IDBObjectStore.prototype.index = function(indexName) {
        if (arguments.length === 0) {
            throw new TypeError("No index name was specified");
        }
        var index = this.__indexes[indexName];
        if (!index) {
            throw idbModules.util.createDOMException("NotFoundError", "Index \"" + indexName + "\" does not exist on " + this.name);
        }

        return idbModules.IDBIndex.__clone(index, this);
    };

    /**
     * Creates a new index on the object store.
     * @param {string} indexName
     * @param {string} keyPath
     * @param {object} optionalParameters
     * @returns {IDBIndex}
     */
    IDBObjectStore.prototype.createIndex = function(indexName, keyPath, optionalParameters) {
        if (arguments.length === 0) {
            throw new TypeError("No index name was specified");
        }
        if (arguments.length === 1) {
            throw new TypeError("No key path was specified");
        }
        if (keyPath instanceof Array && optionalParameters && optionalParameters.multiEntry) {
            throw idbModules.util.createDOMException("InvalidAccessError", "The keyPath argument was an array and the multiEntry option is true.");
        }
        if (this.__indexes[indexName] && !this.__indexes[indexName].__deleted) {
            throw idbModules.util.createDOMException("ConstraintError", "Index \"" + indexName + "\" already exists on " + this.name);
        }

        this.transaction.__assertVersionChange();

        optionalParameters = optionalParameters || {};
        /** @name IDBIndexProperties **/
        var indexProperties = {
            columnName: indexName,
            keyPath: keyPath,
            optionalParams: {
                unique: !!optionalParameters.unique,
                multiEntry: !!optionalParameters.multiEntry
            }
        };
        var index = new idbModules.IDBIndex(this, indexProperties);
        idbModules.IDBIndex.__createIndex(this, index);
        return index;
    };

    IDBObjectStore.prototype.deleteIndex = function(indexName) {
        if (arguments.length === 0) {
            throw new TypeError("No index name was specified");
        }
        var index = this.__indexes[indexName];
        if (!index) {
            throw idbModules.util.createDOMException("NotFoundError", "Index \"" + indexName + "\" does not exist on " + this.name);
        }
        this.transaction.__assertVersionChange();

        idbModules.IDBIndex.__deleteIndex(this, index);
    };

    idbModules.IDBObjectStore = IDBObjectStore;
}(idbModules));

(function(idbModules) {
    'use strict';

    var uniqueID = 0;

    /**
     * The IndexedDB Transaction
     * http://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#idl-def-IDBTransaction
     * @param {IDBDatabase} db
     * @param {string[]} storeNames
     * @param {string} mode
     * @constructor
     */
    function IDBTransaction(db, storeNames, mode) {
        this.__id = ++uniqueID; // for debugging simultaneous transactions
        this.__active = true;
        this.__running = false;
        this.__errored = false;
        this.__requests = [];
        this.__storeNames = storeNames;
        this.mode = mode;
        this.db = db;
        this.error = null;
        this.onabort = this.onerror = this.oncomplete = null;

        // Kick off the transaction as soon as all synchronous code is done.
        var me = this;
        setTimeout(function() { me.__executeRequests(); }, 0);
    }

    IDBTransaction.prototype.__executeRequests = function() {
        if (this.__running) {
            idbModules.DEBUG && console.log("Looks like the request set is already running", this.mode);
            return;
        }

        this.__running = true;
        var me = this;

        me.db.__db.transaction(function executeRequests(tx) {
                me.__tx = tx;
                var q = null, i = 0;

                function success(result, req) {
                    if (req) {
                        q.req = req;// Need to do this in case of cursors
                    }
                    q.req.readyState = "done";
                    q.req.result = result;
                    delete q.req.error;
                    var e = idbModules.util.createEvent("success");
                    idbModules.util.callback("onsuccess", q.req, e);
                    i++;
                    executeNextRequest();
                }

                function error(tx, err) {
                    err = idbModules.util.findError(arguments);
                    try {
                        // Fire an error event for the current IDBRequest
                        q.req.readyState = "done";
                        q.req.error = err || "DOMError";
                        q.req.result = undefined;
                        var e = idbModules.util.createEvent("error", err);
                        idbModules.util.callback("onerror", q.req, e);
                    }
                    finally {
                        // Fire an error event for the transaction
                        transactionError(err);
                    }
                }

                function executeNextRequest() {
                    if (i >= me.__requests.length) {
                        // All requests in the transaction are done
                        me.__requests = [];
                        if (me.__active) {
                            me.__active = false;
                            transactionFinished();
                        }
                    }
                    else {
                        try {
                            q = me.__requests[i];
                            q.op(tx, q.args, success, error);
                        }
                        catch (e) {
                            error(e);
                        }
                    }
                }

                executeNextRequest();
            },

            function webSqlError(err) {
                transactionError(err);
            }
        );

        function transactionError(err) {
            idbModules.util.logError("Error", "An error occurred in a transaction", err);

            if (me.__errored) {
                // We've already called "onerror", "onabort", or thrown, so don't do it again.
                return;
            }

            me.__errored = true;

            if (!me.__active) {
                // The transaction has already completed, so we can't call "onerror" or "onabort".
                // So throw the error instead.
                throw err;
            }

            try {
                me.error = err;
                var evt = idbModules.util.createEvent("error");
                idbModules.util.callback("onerror", me, evt);
                idbModules.util.callback("onerror", me.db, evt);
            }
            finally {
                me.abort();
            }
        }

        function transactionFinished() {
            idbModules.DEBUG && console.log("Transaction completed");
            var evt = idbModules.util.createEvent("complete");
            try {
                idbModules.util.callback("oncomplete", me, evt);
                idbModules.util.callback("__oncomplete", me, evt);
            }
            catch (e) {
                // An error occurred in the "oncomplete" handler.
                // It's too late to call "onerror" or "onabort". Throw a global error instead.
                // (this may seem odd/bad, but it's how all native IndexedDB implementations work)
                me.__errored = true;
                throw e;
            }
        }
    };

    /**
     * Creates a new IDBRequest for the transaction.
     * NOTE: The transaction is not queued util you call {@link IDBTransaction#__pushToQueue}
     * @returns {IDBRequest}
     * @protected
     */
    IDBTransaction.prototype.__createRequest = function() {
        var request = new idbModules.IDBRequest();
        request.source = this.db;
        request.transaction = this;
        return request;
    };

    /**
     * Adds a callback function to the transaction queue
     * @param {function} callback
     * @param {*} args
     * @returns {IDBRequest}
     * @protected
     */
    IDBTransaction.prototype.__addToTransactionQueue = function(callback, args) {
        var request = this.__createRequest();
        this.__pushToQueue(request, callback, args);
        return request;
    };

    /**
     * Adds an IDBRequest to the transaction queue
     * @param {IDBRequest} request
     * @param {function} callback
     * @param {*} args
     * @protected
     */
    IDBTransaction.prototype.__pushToQueue = function(request, callback, args) {
        this.__assertActive();
        this.__requests.push({
            "op": callback,
            "args": args,
            "req": request
        });
    };

    IDBTransaction.prototype.__assertActive = function() {
        if (!this.__active) {
            throw idbModules.util.createDOMException("TransactionInactiveError", "A request was placed against a transaction which is currently not active, or which is finished");
        }
    };

    IDBTransaction.prototype.__assertWritable = function() {
        if (this.mode === IDBTransaction.READ_ONLY) {
            throw idbModules.util.createDOMException("ReadOnlyError", "The transaction is read only");
        }
    };

    IDBTransaction.prototype.__assertVersionChange = function() {
        IDBTransaction.__assertVersionChange(this);
    };

    IDBTransaction.__assertVersionChange = function(tx) {
        if (!tx || tx.mode !== IDBTransaction.VERSION_CHANGE) {
            throw idbModules.util.createDOMException("InvalidStateError", "Not a version transaction");
        }
    };

    /**
     * Returns the specified object store.
     * @param {string} objectStoreName
     * @returns {IDBObjectStore}
     */
    IDBTransaction.prototype.objectStore = function(objectStoreName) {
        if (arguments.length === 0) {
            throw new TypeError("No object store name was specified");
        }
        if (!this.__active) {
            throw idbModules.util.createDOMException("InvalidStateError", "A request was placed against a transaction which is currently not active, or which is finished");
        }
        if (this.__storeNames.indexOf(objectStoreName) === -1 && this.mode !== IDBTransaction.VERSION_CHANGE) {
            throw idbModules.util.createDOMException("NotFoundError", objectStoreName + " is not participating in this transaction");
        }
        var store = this.db.__objectStores[objectStoreName];
        if (!store) {
            throw idbModules.util.createDOMException("NotFoundError", objectStoreName + " does not exist in " + this.db.name);
        }

        return idbModules.IDBObjectStore.__clone(store, this);
    };

    IDBTransaction.prototype.abort = function() {
        var me = this;
        idbModules.DEBUG && console.log("The transaction was aborted", me);
        me.__active = false;
        var evt = idbModules.util.createEvent("abort");

        // Fire the "onabort" event asynchronously, so errors don't bubble
        setTimeout(function() {
            idbModules.util.callback("onabort", me, evt);
        }, 0);
    };

    IDBTransaction.READ_ONLY = "readonly";
    IDBTransaction.READ_WRITE = "readwrite";
    IDBTransaction.VERSION_CHANGE = "versionchange";

    idbModules.IDBTransaction = IDBTransaction;
}(idbModules));

(function(idbModules){
    'use strict';

    /**
     * IDB Database Object
     * http://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#database-interface
     * @constructor
     */
    function IDBDatabase(db, name, version, storeProperties){
        this.__db = db;
        this.__closed = false;
        this.version = version;
        this.name = name;
        this.onabort = this.onerror = this.onversionchange = null;

        this.__objectStores = {};
        this.objectStoreNames = new idbModules.util.StringList();
        for (var i = 0; i < storeProperties.rows.length; i++) {
            var store = new idbModules.IDBObjectStore(storeProperties.rows.item(i));
            this.__objectStores[store.name] = store;
            this.objectStoreNames.push(store.name);
        }
    }

    /**
     * Creates a new object store.
     * @param {string} storeName
     * @param {object} [createOptions]
     * @returns {IDBObjectStore}
     */
    IDBDatabase.prototype.createObjectStore = function(storeName, createOptions){
        if (arguments.length === 0) {
            throw new TypeError("No object store name was specified");
        }
        if (this.__objectStores[storeName]) {
            throw idbModules.util.createDOMException("ConstraintError", "Object store \"" + storeName + "\" already exists in " + this.name);
        }
        this.__versionTransaction.__assertVersionChange();

        createOptions = createOptions || {};
        /** @name IDBObjectStoreProperties **/
        var storeProperties = {
            name: storeName,
            keyPath: JSON.stringify(createOptions.keyPath || null),
            autoInc: JSON.stringify(createOptions.autoIncrement),
            indexList: "{}"
        };
        var store = new idbModules.IDBObjectStore(storeProperties, this.__versionTransaction);
        idbModules.IDBObjectStore.__createObjectStore(this, store);
        return store;
    };

    /**
     * Deletes an object store.
     * @param {string} storeName
     */
    IDBDatabase.prototype.deleteObjectStore = function(storeName){
        if (arguments.length === 0) {
            throw new TypeError("No object store name was specified");
        }
        var store = this.__objectStores[storeName];
        if (!store) {
            throw idbModules.util.createDOMException("NotFoundError", "Object store \"" + storeName + "\" does not exist in " + this.name);
        }
        this.__versionTransaction.__assertVersionChange();

        idbModules.IDBObjectStore.__deleteObjectStore(this, store);
    };

    IDBDatabase.prototype.close = function(){
        this.__closed = true;
    };

    /**
     * Starts a new transaction.
     * @param {string|string[]} storeNames
     * @param {string} mode
     * @returns {IDBTransaction}
     */
    IDBDatabase.prototype.transaction = function(storeNames, mode){
        if (this.__closed) {
            throw idbModules.util.createDOMException("InvalidStateError", "An attempt was made to start a new transaction on a database connection that is not open");
        }

        if (typeof mode === "number") {
            mode = mode === 1 ? IDBTransaction.READ_WRITE : IDBTransaction.READ_ONLY;
            idbModules.DEBUG && console.log("Mode should be a string, but was specified as ", mode);
        }
        else {
            mode = mode || IDBTransaction.READ_ONLY;
        }

        if (mode !== IDBTransaction.READ_ONLY && mode !== IDBTransaction.READ_WRITE) {
            throw new TypeError("Invalid transaction mode: " + mode);
        }

        storeNames = typeof storeNames === "string" ? [storeNames] : storeNames;
        if (storeNames.length === 0) {
            throw idbModules.util.createDOMException("InvalidAccessError", "No object store names were specified");
        }
        for (var i = 0; i < storeNames.length; i++) {
            if (!this.objectStoreNames.contains(storeNames[i])) {
                throw idbModules.util.createDOMException("NotFoundError", "The \"" + storeNames[i] + "\" object store does not exist");
            }
        }

        var transaction = new idbModules.IDBTransaction(this, storeNames, mode);
        return transaction;
    };
    
    idbModules.IDBDatabase = IDBDatabase;
}(idbModules));

(function(idbModules) {
    'use strict';

    var DEFAULT_DB_SIZE = 4 * 1024 * 1024;
    var sysdb;

    /**
     * Craetes the sysDB to keep track of version numbers for databases
     **/
    function createSysDB(success, failure) {
        function sysDbCreateError(tx, err) {
            err = idbModules.util.findError(arguments);
            idbModules.DEBUG && console.log("Error in sysdb transaction - when creating dbVersions", err);
            failure(err);
        }

        if (sysdb) {
            success();
        }
        else {
            sysdb = window.openDatabase("__sysdb__", 1, "System Database", DEFAULT_DB_SIZE);
            sysdb.transaction(function(tx) {
                tx.executeSql("CREATE TABLE IF NOT EXISTS dbVersions (name VARCHAR(255), version INT);", [], success, sysDbCreateError);
            }, sysDbCreateError);
        }
    }

    /**
     * IDBFactory Class
     * https://w3c.github.io/IndexedDB/#idl-def-IDBFactory
     * @constructor
     */
    function IDBFactory() {
        this.modules = idbModules;
    }

    /**
     * The IndexedDB Method to create a new database and return the DB
     * @param {string} name
     * @param {number} version
     */
    IDBFactory.prototype.open = function(name, version) {
        var req = new idbModules.IDBOpenDBRequest();
        var calledDbCreateError = false;

        if (arguments.length === 0) {
            throw new TypeError('Database name is required');
        }
        else if (arguments.length === 2) {
            version = parseFloat(version);
            if (isNaN(version) || !isFinite(version) || version <= 0) {
                throw new TypeError('Invalid database version: ' + version);
            }
        }
        name = name + ''; // cast to a string

        function dbCreateError(tx, err) {
            if (calledDbCreateError) {
                return;
            }
            err = idbModules.util.findError(arguments);
            calledDbCreateError = true;
            var evt = idbModules.util.createEvent("error", arguments);
            req.readyState = "done";
            req.error = err || "DOMError";
            idbModules.util.callback("onerror", req, evt);
        }

        function openDB(oldVersion) {
            var db = window.openDatabase(name, 1, name, DEFAULT_DB_SIZE);
            req.readyState = "done";
            if (typeof version === "undefined") {
                version = oldVersion || 1;
            }
            if (version <= 0 || oldVersion > version) {
                var err = idbModules.util.createDOMError("VersionError", "An attempt was made to open a database using a lower version than the existing version.", version);
                dbCreateError(err);
                return;
            }

            db.transaction(function(tx) {
                tx.executeSql("CREATE TABLE IF NOT EXISTS __sys__ (name VARCHAR(255), keyPath VARCHAR(255), autoInc BOOLEAN, indexList BLOB)", [], function() {
                    tx.executeSql("SELECT * FROM __sys__", [], function(tx, data) {
                        var e = idbModules.util.createEvent("success");
                        req.source = req.result = new idbModules.IDBDatabase(db, name, version, data);
                        if (oldVersion < version) {
                            // DB Upgrade in progress
                            sysdb.transaction(function(systx) {
                                systx.executeSql("UPDATE dbVersions set version = ? where name = ?", [version, name], function() {
                                    var e = idbModules.util.createEvent("upgradeneeded");
                                    e.oldVersion = oldVersion;
                                    e.newVersion = version;
                                    req.transaction = req.result.__versionTransaction = new idbModules.IDBTransaction(req.source, [], idbModules.IDBTransaction.VERSION_CHANGE);
                                    req.transaction.__addToTransactionQueue(function onupgradeneeded(tx, args, success) {
                                        idbModules.util.callback("onupgradeneeded", req, e);
                                        success();
                                    });
                                    req.transaction.__oncomplete = function() {
                                        req.transaction = null;
                                        var e = idbModules.util.createEvent("success");
                                        idbModules.util.callback("onsuccess", req, e);
                                    };
                                }, dbCreateError);
                            }, dbCreateError);
                        } else {
                            idbModules.util.callback("onsuccess", req, e);
                        }
                    }, dbCreateError);
                }, dbCreateError);
            }, dbCreateError);
        }

        createSysDB(function() {
            sysdb.transaction(function(tx) {
                tx.executeSql("SELECT * FROM dbVersions where name = ?", [name], function(tx, data) {
                    if (data.rows.length === 0) {
                        // Database with this name does not exist
                        tx.executeSql("INSERT INTO dbVersions VALUES (?,?)", [name, version || 1], function() {
                            openDB(0);
                        }, dbCreateError);
                    } else {
                        openDB(data.rows.item(0).version);
                    }
                }, dbCreateError);
            }, dbCreateError);
        }, dbCreateError);

        return req;
    };

    /**
     * Deletes a database
     * @param {string} name
     * @returns {IDBOpenDBRequest}
     */
    IDBFactory.prototype.deleteDatabase = function(name) {
        var req = new idbModules.IDBOpenDBRequest();
        var calledDBError = false;
        var version = null;

        if (arguments.length === 0) {
            throw new TypeError('Database name is required');
        }
        name = name + ''; // cast to a string

        function dbError(tx, err) {
            if (calledDBError) {
                return;
            }
            err = idbModules.util.findError(arguments);
            req.readyState = "done";
            req.error = err || "DOMError";
            var e = idbModules.util.createEvent("error");
            e.debug = arguments;
            idbModules.util.callback("onerror", req, e);
            calledDBError = true;
        }

        function deleteFromDbVersions() {
            sysdb.transaction(function(systx) {
                systx.executeSql("DELETE FROM dbVersions where name = ? ", [name], function() {
                    req.result = undefined;
                    var e = idbModules.util.createEvent("success");
                    e.newVersion = null;
                    e.oldVersion = version;
                    idbModules.util.callback("onsuccess", req, e);
                }, dbError);
            }, dbError);
        }

        createSysDB(function() {
            sysdb.transaction(function(systx) {
                systx.executeSql("SELECT * FROM dbVersions where name = ?", [name], function(tx, data) {
                    if (data.rows.length === 0) {
                        req.result = undefined;
                        var e = idbModules.util.createEvent("success");
                        e.newVersion = null;
                        e.oldVersion = version;
                        idbModules.util.callback("onsuccess", req, e);
                        return;
                    }
                    version = data.rows.item(0).version;
                    var db = window.openDatabase(name, 1, name, DEFAULT_DB_SIZE);
                    db.transaction(function(tx) {
                        tx.executeSql("SELECT * FROM __sys__", [], function(tx, data) {
                            var tables = data.rows;
                            (function deleteTables(i) {
                                if (i >= tables.length) {
                                    // If all tables are deleted, delete the housekeeping tables
                                    tx.executeSql("DROP TABLE IF EXISTS __sys__", [], function() {
                                        // Finally, delete the record for this DB from sysdb
                                        deleteFromDbVersions();
                                    }, dbError);
                                } else {
                                    // Delete all tables in this database, maintained in the sys table
                                    tx.executeSql("DROP TABLE " + idbModules.util.quote(tables.item(i).name), [], function() {
                                        deleteTables(i + 1);
                                    }, function() {
                                        deleteTables(i + 1);
                                    });
                                }
                            }(0));
                        }, function(e) {
                            // __sysdb table does not exist, but that does not mean delete did not happen
                            deleteFromDbVersions();
                        });
                    });
                }, dbError);
            }, dbError);
        }, dbError);

        return req;
    };

    /**
     * Compares two keys
     * @param key1
     * @param key2
     * @returns {number}
     */
    IDBFactory.prototype.cmp = function(key1, key2) {
        if (arguments.length < 2) {
            throw new TypeError("You must provide two keys to be compared");
        }

        idbModules.Key.validate(key1);
        idbModules.Key.validate(key2);
        var encodedKey1 = idbModules.Key.encode(key1);
        var encodedKey2 = idbModules.Key.encode(key2);
        var result = encodedKey1 > encodedKey2 ? 1 : encodedKey1 === encodedKey2 ? 0 : -1;
        
        if (idbModules.DEBUG) {
            // verify that the keys encoded correctly
            var decodedKey1 = idbModules.Key.decode(encodedKey1);
            var decodedKey2 = idbModules.Key.decode(encodedKey2);
            if (typeof key1 === "object") {
                key1 = JSON.stringify(key1);
                decodedKey1 = JSON.stringify(decodedKey1);
            }
            if (typeof key2 === "object") {
                key2 = JSON.stringify(key2);
                decodedKey2 = JSON.stringify(decodedKey2);
            }

            // encoding/decoding mismatches are usually due to a loss of floating-point precision
            if (decodedKey1 !== key1) {
                console.warn(key1 + ' was incorrectly encoded as ' + decodedKey1);
            }
            if (decodedKey2 !== key2) {
                console.warn(key2 + ' was incorrectly encoded as ' + decodedKey2);
            }
        }
        
        return result;
    };


    idbModules.shimIndexedDB = new IDBFactory();
    idbModules.IDBFactory = IDBFactory;
}(idbModules));

(function(window, idbModules){
    'use strict';

    function shim(name, value) {
        try {
            // Try setting the property. This will fail if the property is read-only.
            window[name] = value;
        }
        catch (e) {}

        if (window[name] !== value && Object.defineProperty) {
            // Setting a read-only property failed, so try re-defining the property
            try {
                Object.defineProperty(window, name, {
                    value: value
                });
            }
            catch (e) {}

            if (window[name] !== value) {
                window.console && console.warn && console.warn('Unable to shim ' + name);
            }
        }
    }

    shim('shimIndexedDB', idbModules.shimIndexedDB);
    if (window.shimIndexedDB) {
        window.shimIndexedDB.__useShim = function(){
            if (typeof window.openDatabase !== "undefined") {
                // Polyfill ALL of IndexedDB, using WebSQL
                shim('indexedDB', idbModules.shimIndexedDB);
                shim('IDBFactory', idbModules.IDBFactory);
                shim('IDBDatabase', idbModules.IDBDatabase);
                shim('IDBObjectStore', idbModules.IDBObjectStore);
                shim('IDBIndex', idbModules.IDBIndex);
                shim('IDBTransaction', idbModules.IDBTransaction);
                shim('IDBCursor', idbModules.IDBCursor);
                shim('IDBKeyRange', idbModules.IDBKeyRange);
                shim('IDBRequest', idbModules.IDBRequest);
                shim('IDBOpenDBRequest', idbModules.IDBOpenDBRequest);
                shim('IDBVersionChangeEvent', idbModules.IDBVersionChangeEvent);
            }
            else if (typeof window.indexedDB === "object") {
                // Polyfill the missing IndexedDB features
                idbModules.polyfill();
            }
        };

        window.shimIndexedDB.__debug = function(val){
            idbModules.DEBUG = val;
        };
    }
    
    // Workaround to prevent an error in Firefox
    if(!('indexedDB' in window)) {
        window.indexedDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.oIndexedDB || window.msIndexedDB;
    }
    
    // Detect browsers with known IndexedDb issues (e.g. Android pre-4.4)
    var poorIndexedDbSupport = false;
    if (navigator.userAgent.match(/Android 2/) || navigator.userAgent.match(/Android 3/) || navigator.userAgent.match(/Android 4\.[0-3]/)) {
        /* Chrome is an exception. It supports IndexedDb */
        if (!navigator.userAgent.match(/Chrome/)) {
            poorIndexedDbSupport = true;
        }
    }

    if ((typeof window.indexedDB === "undefined" || !window.indexedDB || poorIndexedDbSupport) && typeof window.openDatabase !== "undefined") {
        window.shimIndexedDB.__useShim();
    }
    else {
        window.IDBDatabase = window.IDBDatabase || window.webkitIDBDatabase;
        window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction;
        window.IDBCursor = window.IDBCursor || window.webkitIDBCursor;
        window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange;
        if(!window.IDBTransaction){
            window.IDBTransaction = {};
        }
        /* Some browsers (e.g. Chrome 18 on Android) support IndexedDb but do not allow writing of these properties */
        try {
            window.IDBTransaction.READ_ONLY = window.IDBTransaction.READ_ONLY || "readonly";
            window.IDBTransaction.READ_WRITE = window.IDBTransaction.READ_WRITE || "readwrite";
        } catch (e) {}
    }
    
}(window, idbModules));



/***/ }),
/* 601 */,
/* 602 */,
/* 603 */,
/* 604 */,
/* 605 */,
/* 606 */,
/* 607 */,
/* 608 */,
/* 609 */,
/* 610 */,
/* 611 */,
/* 612 */,
/* 613 */,
/* 614 */,
/* 615 */,
/* 616 */,
/* 617 */,
/* 618 */,
/* 619 */,
/* 620 */,
/* 621 */,
/* 622 */,
/* 623 */,
/* 624 */,
/* 625 */,
/* 626 */,
/* 627 */,
/* 628 */,
/* 629 */,
/* 630 */,
/* 631 */,
/* 632 */,
/* 633 */,
/* 634 */,
/* 635 */,
/* 636 */,
/* 637 */,
/* 638 */,
/* 639 */,
/* 640 */,
/* 641 */,
/* 642 */,
/* 643 */,
/* 644 */,
/* 645 */,
/* 646 */,
/* 647 */,
/* 648 */,
/* 649 */,
/* 650 */,
/* 651 */,
/* 652 */,
/* 653 */,
/* 654 */,
/* 655 */,
/* 656 */,
/* 657 */,
/* 658 */,
/* 659 */,
/* 660 */,
/* 661 */,
/* 662 */,
/* 663 */,
/* 664 */,
/* 665 */,
/* 666 */,
/* 667 */,
/* 668 */,
/* 669 */,
/* 670 */,
/* 671 */,
/* 672 */,
/* 673 */,
/* 674 */,
/* 675 */,
/* 676 */,
/* 677 */,
/* 678 */,
/* 679 */,
/* 680 */,
/* 681 */,
/* 682 */,
/* 683 */,
/* 684 */,
/* 685 */,
/* 686 */,
/* 687 */,
/* 688 */,
/* 689 */,
/* 690 */,
/* 691 */,
/* 692 */,
/* 693 */,
/* 694 */,
/* 695 */,
/* 696 */,
/* 697 */,
/* 698 */,
/* 699 */,
/* 700 */,
/* 701 */,
/* 702 */,
/* 703 */,
/* 704 */,
/* 705 */,
/* 706 */,
/* 707 */,
/* 708 */,
/* 709 */,
/* 710 */,
/* 711 */,
/* 712 */,
/* 713 */,
/* 714 */,
/* 715 */,
/* 716 */,
/* 717 */,
/* 718 */,
/* 719 */,
/* 720 */,
/* 721 */,
/* 722 */,
/* 723 */,
/* 724 */,
/* 725 */,
/* 726 */,
/* 727 */,
/* 728 */,
/* 729 */,
/* 730 */,
/* 731 */,
/* 732 */,
/* 733 */,
/* 734 */,
/* 735 */,
/* 736 */,
/* 737 */,
/* 738 */,
/* 739 */,
/* 740 */,
/* 741 */,
/* 742 */,
/* 743 */,
/* 744 */,
/* 745 */,
/* 746 */,
/* 747 */,
/* 748 */,
/* 749 */,
/* 750 */,
/* 751 */,
/* 752 */,
/* 753 */,
/* 754 */,
/* 755 */,
/* 756 */,
/* 757 */,
/* 758 */,
/* 759 */,
/* 760 */,
/* 761 */,
/* 762 */,
/* 763 */,
/* 764 */,
/* 765 */,
/* 766 */,
/* 767 */,
/* 768 */,
/* 769 */,
/* 770 */,
/* 771 */,
/* 772 */,
/* 773 */,
/* 774 */,
/* 775 */,
/* 776 */,
/* 777 */,
/* 778 */,
/* 779 */,
/* 780 */,
/* 781 */,
/* 782 */,
/* 783 */,
/* 784 */,
/* 785 */,
/* 786 */,
/* 787 */,
/* 788 */,
/* 789 */,
/* 790 */,
/* 791 */,
/* 792 */,
/* 793 */,
/* 794 */,
/* 795 */,
/* 796 */,
/* 797 */,
/* 798 */,
/* 799 */,
/* 800 */,
/* 801 */,
/* 802 */,
/* 803 */,
/* 804 */,
/* 805 */,
/* 806 */,
/* 807 */,
/* 808 */,
/* 809 */,
/* 810 */,
/* 811 */,
/* 812 */,
/* 813 */,
/* 814 */,
/* 815 */,
/* 816 */,
/* 817 */,
/* 818 */,
/* 819 */,
/* 820 */,
/* 821 */,
/* 822 */,
/* 823 */,
/* 824 */,
/* 825 */,
/* 826 */,
/* 827 */,
/* 828 */,
/* 829 */,
/* 830 */,
/* 831 */,
/* 832 */,
/* 833 */,
/* 834 */,
/* 835 */,
/* 836 */,
/* 837 */,
/* 838 */,
/* 839 */,
/* 840 */,
/* 841 */,
/* 842 */,
/* 843 */,
/* 844 */,
/* 845 */,
/* 846 */,
/* 847 */,
/* 848 */,
/* 849 */,
/* 850 */,
/* 851 */,
/* 852 */,
/* 853 */,
/* 854 */,
/* 855 */,
/* 856 */,
/* 857 */,
/* 858 */,
/* 859 */,
/* 860 */,
/* 861 */,
/* 862 */,
/* 863 */,
/* 864 */,
/* 865 */,
/* 866 */,
/* 867 */,
/* 868 */,
/* 869 */,
/* 870 */,
/* 871 */,
/* 872 */,
/* 873 */,
/* 874 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_index_vue__ = __webpack_require__(910);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_index_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_index_vue__);
/* harmony namespace reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_index_vue__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_index_vue__[key]; }) }(__WEBPACK_IMPORT_KEY__));
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_6c1719d8_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_index_vue__ = __webpack_require__(955);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(952)
}
var normalizeComponent = __webpack_require__(93)
/* script */


/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = "data-v-6c1719d8"
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_index_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_6c1719d8_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_index_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/popup/pages/resource/index.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-6c1719d8", Component.options)
  } else {
    hotAPI.reload("data-v-6c1719d8", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 875 */,
/* 876 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//
//
//

exports.default = {
  name: 'navigation',
  props: {
    title: {
      type: String,
      default: ''
    }
  },
  methods: {
    goBack: function goBack() {
      this.$router.go(-1);
    }
  }
};

/***/ }),
/* 877 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_navigation_vue__ = __webpack_require__(876);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_navigation_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_navigation_vue__);
/* harmony namespace reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_navigation_vue__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_navigation_vue__[key]; }) }(__WEBPACK_IMPORT_KEY__));
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_300a417e_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_navigation_vue__ = __webpack_require__(880);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(878)
}
var normalizeComponent = __webpack_require__(93)
/* script */


/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = "data-v-300a417e"
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_navigation_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_300a417e_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_navigation_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/popup/components/navigation.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-300a417e", Component.options)
  } else {
    hotAPI.reload("data-v-300a417e", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 878 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(879);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(29)("4740bbd8", content, false, {});
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../../node_modules/css-loader/index.js?{\"minimize\":false}!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-300a417e\",\"scoped\":true,\"hasInlineConfig\":false}!../../../node_modules/sass-loader/lib/loader.js?{}!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./navigation.vue", function() {
     var newContent = require("!!../../../node_modules/css-loader/index.js?{\"minimize\":false}!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-300a417e\",\"scoped\":true,\"hasInlineConfig\":false}!../../../node_modules/sass-loader/lib/loader.js?{}!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./navigation.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 879 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(28)(false);
// imports


// module
exports.push([module.i, "\nnav[data-v-300a417e] {\n  position: relative;\n  padding: 0 50px;\n  border-bottom: 1px dashed #e6e6e6;\n}\n.back-icon[data-v-300a417e] {\n  position: absolute;\n  top: 10px;\n  left: 0;\n  width: 15px;\n  height: 30px;\n  text-align: center;\n  cursor: pointer;\n}\n.title[data-v-300a417e] {\n  display: inline-block;\n  width: 100%;\n  line-height: 50px;\n  text-align: center;\n  font-size: 18px;\n}\n", ""]);

// exports


/***/ }),
/* 880 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("nav", [
    _c(
      "span",
      { on: { click: _vm.goBack } },
      [
        _c("v-icon", {
          staticClass: "back-icon",
          attrs: { name: "angle-left" }
        })
      ],
      1
    ),
    _vm._v(" "),
    _c("span", { staticClass: "title" }, [_vm._v(_vm._s(_vm.title))])
  ])
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-300a417e", esExports)
  }
}

/***/ }),
/* 881 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = __webpack_require__(4);

var _promise2 = _interopRequireDefault(_promise);

var _extends2 = __webpack_require__(76);

var _extends3 = _interopRequireDefault(_extends2);

var _vuex = __webpack_require__(129);

var _vClickOutside = __webpack_require__(883);

var _vClickOutside2 = _interopRequireDefault(_vClickOutside);

var _storage = __webpack_require__(234);

var _storage2 = _interopRequireDefault(_storage);

var _bcxApi = __webpack_require__(438);

var _bcxApi2 = _interopRequireDefault(_bcxApi);

var _DialogComponent = __webpack_require__(884);

var _DialogComponent2 = _interopRequireDefault(_DialogComponent);

var _extension = __webpack_require__(891);

var _extension2 = _interopRequireDefault(_extension);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// import BCX from '../../lib/bcx-api'

// import '../../lib/bcx.min.js'

// import BCX from "bcxjs-test-xl-api";
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  components: {
    KDialog: _DialogComponent2.default
  },
  data: function data() {
    return {
      showNetworkDropdown: false,
      nodes: [],
      choose: "",

      changeNodeRemovePasswordShow: false,
      networkNode: {}
    };
  },

  computed: (0, _extends3.default)({}, (0, _vuex.mapState)(["route", "currentNetwork", "cocosAccount"])),
  directives: {
    clickOutside: _vClickOutside2.default.directive
  },
  mounted: function mounted() {
    var nodes = _storage2.default.get("node").concat(_storage2.default.get("add_node") ? _storage2.default.get("add_node") : []);
    var isArrayNodeIndex = '';
    for (var i = 0; i < nodes.length; i++) {
      if (Array.isArray(nodes[i])) {
        isArrayNodeIndex = i;
        break;
      }
    }
    if (isArrayNodeIndex != "") {
      nodes.splice(isArrayNodeIndex, 1);
    }
    this.nodes = nodes;
    this.choose = _storage2.default.get("choose_node");
  },

  methods: (0, _extends3.default)({}, (0, _vuex.mapActions)("account", ["logoutBCXAccount", "lockAccount"]), (0, _vuex.mapActions)("wallet", ["getAccounts", "deleteWallet"]), (0, _vuex.mapMutations)(["setAccountType", "setLogin", "setIsAccount", "setAccount", "setLoginNoAlert"]), (0, _vuex.mapActions)(["nodeLists", "apiConfig", "init", "switchAPINode", "lookupWSNodeList", "apiConfigChangeNode"]), {
    nodeSyncFn: function nodeSyncFn(changeNode) {
      var _this = this;
      _this.$router.push('initAccount', function () {
        console.log("extension.tabsSendMessage  /initAccount");
        // extension.tabsSendMessage().then( res => {
        //   console.log("extension.tabsSendMessage")
        // })
        // chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {
        //   // å‘é€ä¸€ä¸ªcopyæ¶ˆæ¯å‡ºåŽ»
        //   chrome.tabs.sendMessage(tabs[0].id, {type: "change", content: changeNode}, function (response) {
        //     // è¿™é‡Œçš„å›žè°ƒå‡½æ•°æŽ¥æ”¶åˆ°äº†è¦æŠ“å–çš„å€¼ï¼ŒèŽ·å–å€¼å¾—æ“ä½œåœ¨ä¸‹æ–¹content-script.js
        //     // å°†å€¼å­˜åœ¨background.jsçš„dataå±žæ€§é‡Œé¢ã€‚
        //     // var win = chrome.extension.getBackgroundPage();
        //     // win.data=response;
        //     console.log(response)
        //     Storage.set("choose_node", changeNode);
        //   });
        // });
      });
      // chrome.tabs.queryå¯ä»¥é€šè¿‡å›žè°ƒå‡½æ•°èŽ·å¾—å½“å‰é¡µé¢çš„ä¿¡æ¯tabs
    },
    onClickOutside: function onClickOutside() {
      this.showNetworkDropdown = false;
    },
    changeNetwork: function changeNetwork(network) {
      this.networkNode = {};
      this.changeNodeRemovePasswordShow = true;
      this.networkNode = network;
    },
    sureBtn: function sureBtn() {
      var _this = this;
      this.switchAPINodeAjax(_this.networkNode);
    },
    switchAPINodeAjax: function switchAPINodeAjax(network) {
      var _this2 = this;

      var _this = this;
      _promise2.default.all([this.deleteWallet(), this.logoutBCXAccount()]).then(function (res) {
        window.localStorage.setItem("delAccount", "sure");
        _this2.setLogin(false);
        _this2.setIsAccount(false);
        _this2.setAccount({
          account: "",
          password: ""
        });
      });
      console.log('begin change node...');
      var Node = network;

      var _configParams = {
        default_ws_node: network.ws,
        ws_node_list: [{ url: network.ws, name: network.name }],
        networks: [{
          core_asset: "COCOS",
          chain_id: network.chainId
        }],
        faucet_url: network.faucetUrl,
        auto_reconnect: true,
        real_sub: true,
        check_cached_nodes_data: false
      };
      _this.apiConfigChangeNode(_configParams, true).then(function (apiConfigres) {
        _this.$kalert({
          message: _this.$i18n.t("alert.modifySuccess")
        });
        _storage2.default.set("choose_node", network);
        _this.nodeSyncFn(network);
      });
    },
    switchAPINodeAjaxtest: function switchAPINodeAjaxtest(network) {
      var _this3 = this;

      var _this = this;
      _promise2.default.all([this.deleteWallet(), this.logoutBCXAccount()]).then(function (res) {
        window.localStorage.setItem("delAccount", "sure");
        _this3.setLogin(false);
        _this3.setIsAccount(false);
        _this3.setAccount({
          account: "",
          password: ""
        });
        // this.init().then( initRes => {
        //   return new Promise(function (resolve, reject) {
        //     _this.switchAPINode({
        //       url: network.ws
        //     }).then(res => {
        //       if (res.code === 1) {
        //           resolve(res)
        //       } else {
        //           _this.$kalert({
        //             message:  _this.$i18n.t("alert.modifyFailed")
        //           });
        //       }
        //     })
        //   })
        // })
        _this3.init().then(function (res) {
          return new _promise2.default(function (resolve, reject) {
            _this.switchAPINode({
              url: network.ws
            }).then(function (res) {
              resolve(res);
            });
          });
        }).then(function (res) {
          return new _promise2.default(function (resolve, reject) {

            if (res.data.selectedNodeUrl) {

              _this.apiConfig(network).then(function (apiConfigres) {
                resolve(apiConfigres);
              });
              // _this.apiConfig({
              //   faucet_url:"http://47.93.62.96:8042"   
              // })
              _this.choose = network;
            } else {
              _this.$kalert({
                message: _this.$i18n.t("alert.modifyFailed")
              });
            }
          });
        }).then(function (res) {
          _this.lookupWSNodeList().then(function (lookupWSNodeListRes) {
            if (lookupWSNodeListRes.data.selectedNodeUrl) {

              _this.nodeSyncFn(network);
            } else {
              _this.$kalert({
                message: _this.$i18n.t("alert.modifyFailed")
              });
            }
          });
        });
      });
    },
    lockAccountAjax: function lockAccountAjax() {
      var _this4 = this;

      var _this = this;
      this.lockAccount().then(function (res) {
        if (res.code == 1) {

          // _this.setLoginNoAlert(false);
          // _this.setAccount({
          //   account: _this.cocosAccount.accounts,
          //   password: ""
          // });
          // _this.setIsAccount(false);
          // _this.setLogin(false);
          _this.$router.push({ name: "unlockActive" });
        } else {
          if (res.message.indexOf("wrong password") > -1 || res.message.indexOf("password error") > -1) {
            _this4.$kalert({
              message: _this4.$i18n.t("error[105]")
            });
          } else {
            _this4.$kalert({
              message: _this.$i18n.t("chainInterfaceError[500]")
            });
          }
        }
      });
    },

    // changeNetwork  2019-12-26 å¤‡ä»½
    // changeNetwork123(network) {
    //   let _this = this
    //   console.log("network")
    //   console.log(network)
    //   // if (network.chainId === Storage.get("choose_node").chainId) {
    //   //   console.log('network.chainId === Storage.get("choose_node").chainId')
    //     this.switchAPINode({
    //       url: network.ws
    //     }).then(res => {
    //       if (res.code === 1) {
    //         return new Promise(function (resolve, reject) {
    //           resolve(res)
    //         })
    //       } else {
    //           _this.$kalert({
    //             message:  _this.$i18n.t("alert.modifyFailed")
    //           });
    //       }
    //     }).then(res =>{

    //         return new Promise(function (resolve, reject) {

    //           if (res.data.selectedNodeUrl) {

    //             // _this.apiConfig({
    //             //   faucet_url:"http://47.93.62.96:8042"   
    //             // })
    //             _this.choose = network;
    //             _this.lookupWSNodeList().then( lookupWSNodeListRes => {

    //                 if (lookupWSNodeListRes.data.selectedNodeUrl) {

    //                   resolve(lookupWSNodeListRes)

    //                 } else {
    //                   _this.$kalert({
    //                     message: _this.$i18n.t("alert.modifyFailed")
    //                   });
    //                 }


    //             })
    //           } else {
    //             _this.$kalert({
    //               message:  _this.$i18n.t("alert.modifyFailed")
    //             });
    //           }
    //         })
    //     }).then( res => {

    //       _this.apiConfig(network).then( apiConfigres => {
    //         console.log("apiConfigres")
    //         console.log(apiConfigres)
    //         Storage.set("choose_node", network);
    //         _this.removeCurrentAccount()
    //         // _this.init().then( initRes => {
    //         //   _this.$kalert({
    //         //     message: _this.$i18n.t("alert.modifySuccess")
    //         //   });
    //         //   _this.removeCurrentAccount()
    //         // })
    //       })
    //     });
    //   // } else {
    //   //   console.log('else   network.chainId === Storage.get("choose_node").chainId')
    //   //   let Node = network;


    //     // 2019-12-09 æ³¨é‡Šä¿®æ”¹ ç»“æŸ
    //     // this.NewBCX(Node);

    //     // _this.init().then(res => {
    //     //   console.log('-------change--------this.init()---------')
    //     //   console.log(res)
    //     //   if (res.code !== 1) {
    //     //     _this.$kalert({
    //     //       message: _this.$i18n.t(`error[${res.code}]`)
    //     //     });
    //     //     // this.init(this.nodes[0]);
    //     //     // this.init().then(change => {
    //     //     //   this.switchAPINode({
    //     //     //     url: this.nodes[0].ws
    //     //     //   }).then(change => {
    //     //     //     this.apiConfig(this.nodes[0]);
    //     //     //   });
    //     //     // });
    //     //   } else {
    //     //     _this.$kalert({
    //     //       message: _this.$i18n.t("alert.modifySuccess")
    //     //     });
    //     //     _this.choose = network;
    //     //   }
    //     // });
    //     // 2019-12-09 æ³¨é‡Šä¿®æ”¹  ç»“æŸ
    //   // }
    // },


    NewBCX: function NewBCX(Node) {

      var _configParams = {
        ws_node_list: [{
          url: Node.ws,
          name: Node.name
        }],
        networks: [{
          core_asset: "COCOS",
          chain_id: Node.chainId
        }],
        //Â faucet_url:"http://47.93.62.96:3000",
        faucetUrl: Node.faucetUrl,
        auto_reconnect: true,
        worker: false,
        real_sub: true,
        check_cached_nodes_data: true
        //Â app_keys:Â ["5HxzZncKDjx7NEaEv989Huh7yYY7RukcJLKBDQztXAmZYCHWPgd"]
      };
      return new _bcxApi2.default(_configParams);
      // return new BCX({
      //   default_ws_node: 'ws://test.cocosbcx.net',
      //   ws_node_list: [
      //     {
      //       url: Node.ws,
      //       name: Node.name
      //     }
      //   ],
      //   networks: [
      //     {
      //       core_asset: "COCOS",
      //       chain_id: Node.chainId
      //     }
      //   ],
      //   faucet_url: Node.url,
      //   auto_reconnect: false,
      //   worker: false
      // });
    },
    goSettings: function goSettings() {
      this.$router.push({ name: "settings" });
    },
    refreshData: function refreshData() {
      this.$emit("refresh");
    },
    removeCurrentAccount: function removeCurrentAccount(formName) {
      var _this5 = this;

      _promise2.default.all([this.deleteWallet(), this.logoutBCXAccount()]).then(function (res) {
        window.localStorage.setItem("delAccount", "sure");
        _this5.setLogin(false);
        _this5.setIsAccount(false);
        _this5.setAccount({
          account: "",
          password: ""
        });
        _this5.$router.replace({ name: "initAccount" });
      });
      // if (this.accountType === "account") {
      //   this.logoutBCXAccount().then(res => {
      //     if (res.code === 1) {
      //       this.setLogin(false);
      //       this.setIsAccount(false);
      //       this.setAccount({
      //         account: "",
      //         password: ""
      //       });
      //       this.$router.replace({ name: "initAccount" });
      //     }
      //   });
      // } else {
      //   this.deleteWallet().then(res => {
      //     if (res.code === 1) {

      //       this.$router.replace({ name: "initAccount" });
      //     }
      //   });
      // }

      // this.$refs[formName].validate(valid => {
      //   if (valid) {
      //     if (utils.hashPassword(this.formData.password) === this.pwdhash) {
      //       this.removeAccount(this.currentAccount);
      //       this.formData.password = "";
      //       this.removePasswordShow = false;
      //       if (this.accounts.length > 0) {
      //         this.setCurrentAccount(this.accounts[0]);
      //         this.selectAccount(this.accounts[0]);
      //       } else {
      //         this.setCurrentAccount({});
      //         this.$router.replace({ name: "initAccount" });
      //       }
      //     } else {
      //       this.$kalert({
      //         message: this.$i18n.t("alert.passwordError")
      //       });
      //     }
      //   }
      // });
    }
  })
};

/***/ }),
/* 882 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'k-dialog',
  props: {
    title: {
      type: String,
      default: 'æç¤º'
    },
    visible: {
      type: Boolean,
      default: false
    },
    showClose: {
      type: Boolean,
      default: true
    }
  },
  methods: {
    handleClose: function handleClose() {
      this.$emit('close');
    }
  }
};

/***/ }),
/* 883 */
/***/ (function(module, exports, __webpack_require__) {

!function(e,n){ true?module.exports=n():"function"==typeof define&&define.amd?define(n):e["v-click-outside"]=n()}(this,function(){var e="__v-click-outside",n="undefined"!=typeof window,t="undefined"!=typeof navigator,i=n&&("ontouchstart"in window||t&&navigator.msMaxTouchPoints>0)?["touchstart"]:["click"];function r(n,t){var r=function(e){var n="function"==typeof e;if(!n&&"object"!=typeof e)throw new Error("v-click-outside: Binding value must be a function or an object");return{handler:n?e:e.handler,middleware:e.middleware||function(e){return e},events:e.events||i,isActive:!(!1===e.isActive)}}(t.value),o=r.handler,d=r.middleware;r.isActive&&(n[e]=r.events.map(function(e){return{event:e,handler:function(e){return function(e){var n=e.el,t=e.event,i=e.handler,r=e.middleware;t.target!==n&&!n.contains(t.target)&&r(t,n)&&i(t,n)}({event:e,el:n,handler:o,middleware:d})}}}),n[e].forEach(function(e){var n=e.event,t=e.handler;return setTimeout(function(){return document.documentElement.addEventListener(n,t,!1)},0)}))}function o(n){(n[e]||[]).forEach(function(e){return document.documentElement.removeEventListener(e.event,e.handler,!1)}),delete n[e]}var d={bind:r,update:function(e,n){var t=n.value,i=n.oldValue;JSON.stringify(t)!==JSON.stringify(i)&&(o(e),r(e,{value:t}))},unbind:o};return{install:function(e){e.directive("click-outside",d)},directive:d}});
//# sourceMappingURL=v-click-outside.min.min.umd.js.map


/***/ }),
/* 884 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_DialogComponent_vue__ = __webpack_require__(882);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_DialogComponent_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_DialogComponent_vue__);
/* harmony namespace reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_DialogComponent_vue__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_DialogComponent_vue__[key]; }) }(__WEBPACK_IMPORT_KEY__));
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_b4be5b4a_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_DialogComponent_vue__ = __webpack_require__(890);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(888)
}
var normalizeComponent = __webpack_require__(93)
/* script */


/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = "data-v-b4be5b4a"
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_DialogComponent_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_b4be5b4a_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_DialogComponent_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/popup/components/dialog/DialogComponent.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-b4be5b4a", Component.options)
  } else {
    hotAPI.reload("data-v-b4be5b4a", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 885 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_app_header_vue__ = __webpack_require__(881);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_app_header_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_app_header_vue__);
/* harmony namespace reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_app_header_vue__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_app_header_vue__[key]; }) }(__WEBPACK_IMPORT_KEY__));
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_68225334_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_app_header_vue__ = __webpack_require__(892);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(886)
}
var normalizeComponent = __webpack_require__(93)
/* script */


/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = "data-v-68225334"
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_app_header_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_68225334_hasScoped_true_transformToRequire_video_src_source_src_img_src_image_xlink_href_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_app_header_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/popup/components/app-header.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-68225334", Component.options)
  } else {
    hotAPI.reload("data-v-68225334", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 886 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(887);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(29)("da20a2f4", content, false, {});
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../../node_modules/css-loader/index.js?{\"minimize\":false}!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-68225334\",\"scoped\":true,\"hasInlineConfig\":false}!../../../node_modules/sass-loader/lib/loader.js?{}!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./app-header.vue", function() {
     var newContent = require("!!../../../node_modules/css-loader/index.js?{\"minimize\":false}!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-68225334\",\"scoped\":true,\"hasInlineConfig\":false}!../../../node_modules/sass-loader/lib/loader.js?{}!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./app-header.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 887 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(28)(false);
// imports


// module
exports.push([module.i, "\nmain[data-v-68225334] {\n  background-color: #fff;\n}\n.eos-info[data-v-68225334] {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -moz-box;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: justify;\n  -webkit-justify-content: space-between;\n     -moz-box-pack: justify;\n      -ms-flex-pack: justify;\n          justify-content: space-between;\n  height: 60px;\n  margin: 0 auto;\n}\n.eos-main[data-v-68225334] {\n  padding-top: 20px;\n  text-align: center;\n  border-top: 1px dashed #e6e6e6;\n}\n.eos-main .eos-logo[data-v-68225334] {\n    margin-top: 20px;\n    border-radius: 100%;\n}\n.eos-main .eos-logo-small[data-v-68225334] {\n      width: 80px;\n      height: 80px;\n}\n.eos-main .go-active a[data-v-68225334] {\n    color: #ff5b5b;\n    text-decoration: underline;\n}\n.eos-main a.active-btn[data-v-68225334] {\n    display: block;\n    width: 100px;\n    height: 30px;\n    margin: 10px auto;\n    line-height: 30px;\n    text-align: center;\n    color: #fff;\n    border-radius: 4px;\n    background-color: #ff5b5b;\n    text-decoration: none;\n}\n.eos-main .translate-log-title[data-v-68225334] {\n    position: relative;\n    z-index: 1;\n}\n.eos-main .translate-log-title .log-line[data-v-68225334] {\n      width: 100%;\n      height: 1px;\n      background-color: #e6e6e6;\n      position: absolute;\n      top: 50%;\n      left: 0;\n      -webkit-transform: translate(0, -50%);\n              transform: translate(0, -50%);\n      z-index: -1;\n}\n.eos-main .translate-log-title .log-title[data-v-68225334] {\n      width: 80px;\n      background-color: #fff;\n      text-align: center;\n      color: #666;\n      margin: 0 auto;\n      font-size: 14px;\n}\n.eos-main .translate-log-title .log-option[data-v-68225334] {\n      position: absolute;\n      top: 50%;\n      right: 0;\n      -webkit-transform: translate(0, -50%);\n              transform: translate(0, -50%);\n      background-color: #fff;\n      width: 100px;\n}\n.no-result[data-v-68225334] {\n  font-size: 12px;\n  padding-bottom: 15px;\n  margin-bottom: 15px;\n  color: #999;\n}\n.account[data-v-68225334] {\n  width: 160px;\n  position: relative;\n  height: 40px;\n  line-height: 40px;\n}\n.account .avatar[data-v-68225334] {\n    position: absolute;\n    top: 5px;\n    left: 0;\n    width: 30px;\n    height: 30px;\n}\n.account .current-account[data-v-68225334] {\n    text-align: center;\n    font-size: 18px;\n    overflow: hidden;\n    width: 150px;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n}\n.account .account-arrow[data-v-68225334] {\n    position: absolute;\n    width: 10px;\n    height: 30px;\n    line-height: 30px;\n    top: 5px;\n    right: 0;\n}\nul[data-v-68225334],\nli[data-v-68225334] {\n  margin: 0;\n  padding: 0;\n}\nli[data-v-68225334] {\n  list-style: none;\n}\n.account-container[data-v-68225334] {\n  position: relative;\n  width: 160px;\n  height: 40px;\n  margin-top: 10px;\n  cursor: pointer;\n}\n.account-container i[data-v-68225334] {\n    font-size: 20px;\n}\n.account-container .account-list[data-v-68225334] {\n    position: absolute;\n    background-color: rgba(0, 0, 0, 0.7);\n    border-radius: 8px;\n    padding: 0 10px;\n    top: 40px;\n    left: 50%;\n    -webkit-transform: translate(-50%, 0);\n            transform: translate(-50%, 0);\n    width: 190px;\n    max-height: 240px;\n    z-index: 99;\n}\n.account-container .account-list ul[data-v-68225334] {\n      margin: 0;\n      padding: 0;\n}\n.account-container .account-list li[data-v-68225334] {\n      width: 100%;\n      position: relative;\n      margin: 0;\n      padding: 0;\n      font-size: 16px;\n      height: 40px;\n      line-height: 40px;\n      color: #fff;\n      cursor: pointer;\n}\n.account-container .account-list li .selected[data-v-68225334] {\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 20px;\n        line-height: 47px;\n}\n.account-container .account-list li .account-item[data-v-68225334] {\n        position: relative;\n        width: 100%;\n        padding: 0 0 0 25px;\n}\n.account-container .account-list li .account-item .avatar-small[data-v-68225334] {\n          top: 10px;\n          left: 25px;\n          position: absolute;\n          width: 20px;\n          height: 20px;\n}\n.account-container .account-list li .account-item .account-name[data-v-68225334] {\n          width: 100%;\n          padding-left: 25px;\n          font-size: 16px;\n          white-space: nowrap;\n          text-overflow: ellipsis;\n          overflow: hidden;\n}\n.account-container .account-list li .is-import[data-v-68225334] {\n        position: absolute;\n        width: 35px;\n        top: 0;\n        right: 5px;\n        color: #4679fe;\n}\n.account-container .account-list .operate-item[data-v-68225334] {\n      height: 30px;\n      line-height: 30px;\n}\n.dashed-line[data-v-68225334] {\n  width: 100%;\n  height: 0;\n  border-bottom: 1px dashed #e6e6e6;\n}\n.more[data-v-68225334] {\n  position: relative;\n  margin-top: 10px;\n}\n.more span[data-v-68225334] {\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -moz-box;\n    display: -ms-flexbox;\n    display: flex;\n    width: 40px;\n    height: 40px;\n    cursor: pointer;\n    -webkit-box-align: center;\n    -webkit-align-items: center;\n       -moz-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n}\n.more span i[data-v-68225334] {\n      font-size: 20px;\n}\n.more-btn[data-v-68225334] {\n    -webkit-box-pack: end;\n    -webkit-justify-content: flex-end;\n       -moz-box-pack: end;\n        -ms-flex-pack: end;\n            justify-content: flex-end;\n}\n.more .more-list[data-v-68225334] {\n    position: absolute;\n    background-color: rgba(0, 0, 0, 0.7);\n    top: 40px;\n    right: 0;\n    width: 160px;\n    padding: 0 10px;\n    border-radius: 8px;\n}\n.more .more-list .icon-img[data-v-68225334] {\n      vertical-align: middle;\n}\n.more .more-list li[data-v-68225334] {\n      width: 100%;\n      margin: 0;\n      padding: 0;\n      line-height: 40px;\n      color: #fff;\n      font-size: 16px;\n      white-space: nowrap;\n      text-overflow: ellipsis;\n      overflow: hidden;\n      cursor: pointer;\n}\n.more .more-list li a[data-v-68225334] {\n        color: #fff;\n        text-decoration: none;\n}\n.btn-group[data-v-68225334] {\n  position: relative;\n  z-index: 9;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -moz-box;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: justify;\n  -webkit-justify-content: space-between;\n     -moz-box-pack: justify;\n      -ms-flex-pack: justify;\n          justify-content: space-between;\n  margin-bottom: 10px;\n}\n.btn-group .charge[data-v-68225334] {\n    width: 130px;\n}\n.action-group[data-v-68225334] {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -moz-box;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-justify-content: space-around;\n      -ms-flex-pack: distribute;\n          justify-content: space-around;\n  margin-bottom: 10px;\n}\n.action-group .button[data-v-68225334] {\n    width: 130px;\n}\n.translate-container[data-v-68225334] {\n  margin: 0 -15px;\n}\n.translate-list[data-v-68225334] {\n  position: relative;\n  height: 200px;\n  padding: 0 15px;\n}\n.eos-style[data-v-68225334] {\n  line-height: 1.6;\n  font-size: 20px;\n  margin-bottom: 8px;\n  font-weight: normal;\n  color: #7046fe;\n}\n.eos-style-color[data-v-68225334] {\n  color: #333333;\n}\n.warning-tip[data-v-68225334] {\n  font-size: 12px;\n  color: #ff5b5b;\n}\n.key-container[data-v-68225334] {\n  margin-top: 15px;\n  background: rgba(70, 121, 254, 0.2);\n  border-radius: 8px;\n  padding: 10px 5px;\n  line-height: 1.6;\n}\n.copy-btn[data-v-68225334] {\n  width: 132px;\n  font-size: 14px;\n  height: 36px;\n  line-height: 26px;\n}\n.token-title[data-v-68225334] {\n  position: relative;\n  height: 60px;\n  line-height: 60px;\n  text-align: center;\n  border-bottom: 1px dashed #e6e6e6;\n}\n.token-title .token-user[data-v-68225334] {\n    display: inline-block;\n    font-size: 18px;\n    width: 100%;\n    padding-right: 40px;\n    padding-left: 15px;\n}\n.token-title .close-drawer[data-v-68225334] {\n    position: absolute;\n    right: 15px;\n    top: 10px;\n    width: 15px;\n    line-height: 35px;\n    height: 30px;\n    cursor: pointer;\n}\n.assets[data-v-68225334] {\n  position: relative;\n  height: 440px;\n}\n.assets ul[data-v-68225334] {\n    padding: 0 15px;\n    margin-top: 20px;\n}\n.assets li[data-v-68225334] {\n    list-style: none;\n    display: -webkit-box;\n    display: -webkit-flex;\n    display: -moz-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-pack: justify;\n    -webkit-justify-content: space-between;\n       -moz-box-pack: justify;\n        -ms-flex-pack: justify;\n            justify-content: space-between;\n    -webkit-box-align: center;\n    -webkit-align-items: center;\n       -moz-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    background-color: rgba(70, 121, 254, 0.2);\n    margin-bottom: 15px;\n    padding: 0 15px;\n    height: 50px;\n    cursor: pointer;\n    border-radius: 4px;\n}\n.assets li[data-v-68225334]:last-child {\n      margin-bottom: 0;\n}\n.assets li .asset-value[data-v-68225334] {\n      color: #7046fe;\n}\n.assets li .asset-name[data-v-68225334] {\n      display: -webkit-box;\n      display: -webkit-flex;\n      display: -moz-box;\n      display: -ms-flexbox;\n      display: flex;\n      -webkit-box-pack: start;\n      -webkit-justify-content: flex-start;\n         -moz-box-pack: start;\n          -ms-flex-pack: start;\n              justify-content: flex-start;\n      -webkit-box-align: center;\n      -webkit-align-items: center;\n         -moz-box-align: center;\n          -ms-flex-align: center;\n              align-items: center;\n}\n.assets li .asset-name span[data-v-68225334] {\n        font-size: 13px;\n        padding-left: 10px;\n}\n.warning-tit[data-v-68225334] {\n  font-size: 12px;\n  color: #333;\n}\n.header[data-v-68225334] {\n  width: 100%;\n  height: 60px;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -moz-box;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-align: center;\n  -webkit-align-items: center;\n     -moz-box-align: center;\n      -ms-flex-align: center;\n          align-items: center;\n  -webkit-box-pack: justify;\n  -webkit-justify-content: space-between;\n     -moz-box-pack: justify;\n      -ms-flex-pack: justify;\n          justify-content: space-between;\n  padding: 0 15px;\n  border-bottom: 1px solid #e6e6e6;\n  background-color: rgba(70, 121, 254, 0.2);\n}\n.setting-icon[data-v-68225334] {\n  width: 93px;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -moz-box;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: justify;\n  -webkit-justify-content: space-between;\n     -moz-box-pack: justify;\n      -ms-flex-pack: justify;\n          justify-content: space-between;\n}\n.setting-icon img[data-v-68225334] {\n    cursor: pointer;\n}\n.header-logo[data-v-68225334] {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -moz-box;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-align: center;\n  -webkit-align-items: center;\n     -moz-box-align: center;\n      -ms-flex-align: center;\n          align-items: center;\n  -webkit-box-pack: start;\n  -webkit-justify-content: flex-start;\n     -moz-box-pack: start;\n      -ms-flex-pack: start;\n          justify-content: flex-start;\n  width: 62px;\n}\n.header-logo img[data-v-68225334],\n.header-logo span[data-v-68225334] {\n  display: block;\n}\n.network[data-v-68225334] {\n  position: relative;\n  border: 1px solid #e6e6e6;\n  border-radius: 20px;\n}\n.network span[data-v-68225334] {\n    display: block;\n}\na.network-toggle[data-v-68225334] {\n  max-width: 170px;\n  width: 170px;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -moz-box;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-align: center;\n  -webkit-align-items: center;\n     -moz-box-align: center;\n      -ms-flex-align: center;\n          align-items: center;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n     -moz-box-pack: center;\n      -ms-flex-pack: center;\n          justify-content: center;\n  text-align: center;\n  font-size: 12px;\n  text-transform: uppercase;\n  padding: 6px 15px;\n  border-radius: 20px;\n  cursor: pointer;\n}\n.network-icon[data-v-68225334] {\n  width: 12px;\n  height: 12px;\n  background: #20ad00;\n  border-radius: 100%;\n}\n.icon[data-v-68225334] {\n  display: inline-block;\n  stroke-width: 0;\n  stroke: currentColor;\n  fill: currentColor;\n  width: 1em;\n  height: 1em;\n}\n.network-arrow[data-v-68225334] {\n  padding-top: 2px;\n}\n.network-name[data-v-68225334] {\n  -webkit-box-flex: 1;\n  -webkit-flex: 1;\n     -moz-box-flex: 1;\n      -ms-flex: 1;\n          flex: 1;\n  font-weight: 600;\n  color: #666;\n  padding: 0.1rem 0.3rem;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.network-dropdown[data-v-68225334] {\n  background: rgba(0, 0, 0, 0.8);\n  position: absolute;\n  top: 40px;\n  right: 0;\n  border-radius: 8px;\n  width: 170px;\n  z-index: 99;\n  padding: 10px;\n}\n.network-dropdown a[data-v-68225334] {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -moz-box;\n  display: -ms-flexbox;\n  display: flex;\n  padding: 0.375rem 0.75rem;\n  font-size: 0.75rem;\n  line-height: 1.25;\n  color: #fff;\n}\n.network-dropdown a[data-v-68225334]:hover,\n.network-dropdown a[data-v-68225334]:focus {\n  color: #ff5b5b;\n}\n.network-dropdown a span[data-v-68225334] {\n  display: block;\n}\n.network-dropdown-icon[data-v-68225334] {\n  padding: 3px 8px 0 0;\n  font-size: 0.625rem;\n}\n.dropdown-menu[data-v-68225334] {\n  box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);\n  background: #fff;\n  position: absolute;\n  top: 40px;\n  right: 10px;\n  padding: 0.5rem 0;\n  border-radius: 3px;\n  min-width: 125px;\n}\n.dropdown-menu a[data-v-68225334] {\n  display: block;\n  padding: 0.5rem 1rem;\n  font-size: 0.875rem;\n  color: #666;\n}\n.dropdown-menu a[data-v-68225334]:hover,\n.dropdown-menu a[data-v-68225334]:focus {\n  color: #ff5b5b;\n}\n.header-tabs[data-v-68225334] {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -moz-box;\n  display: -ms-flexbox;\n  display: flex;\n  width: 100%;\n}\n.header-tabs a[data-v-68225334] {\n  display: block;\n  -webkit-box-flex: 1;\n  -webkit-flex: 1;\n     -moz-box-flex: 1;\n      -ms-flex: 1;\n          flex: 1;\n  padding: 0.625rem;\n  color: #666;\n  font-size: 0.75rem;\n  text-transform: uppercase;\n  text-align: center;\n}\n.header-tabs a.active[data-v-68225334] {\n  color: #ff5b5b;\n  border-bottom: 2px solid #ff5b5b;\n}\n.header-tabs a[data-v-68225334]:hover,\n.header-tabs a[data-v-68225334]:focus {\n  color: #ff5b5b;\n}\n", ""]);

// exports


/***/ }),
/* 888 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(889);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(29)("474a8a79", content, false, {});
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../../../node_modules/css-loader/index.js?{\"minimize\":false}!../../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-b4be5b4a\",\"scoped\":true,\"hasInlineConfig\":false}!../../../../node_modules/sass-loader/lib/loader.js?{}!../../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./DialogComponent.vue", function() {
     var newContent = require("!!../../../../node_modules/css-loader/index.js?{\"minimize\":false}!../../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-b4be5b4a\",\"scoped\":true,\"hasInlineConfig\":false}!../../../../node_modules/sass-loader/lib/loader.js?{}!../../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./DialogComponent.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 889 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(28)(false);
// imports


// module
exports.push([module.i, "\n.mask[data-v-b4be5b4a] {\n  position: fixed;\n  top: 0;\n  left: 0;\n  bottom: 0;\n  right: 0;\n  background-color: rgba(0, 0, 0, 0.5);\n  z-index: 999;\n}\n.dialog[data-v-b4be5b4a] {\n  position: fixed;\n  width: 80%;\n  padding: 15px;\n  top: 50%;\n  left: 50%;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n  z-index: 999;\n  background-color: #fff;\n  border: 1px solid #e6e6e6;\n  border-radius: 10px;\n}\n.dialog-close[data-v-b4be5b4a] {\n    position: absolute;\n    top: 15px;\n    right: 15px;\n    cursor: pointer;\n    font-size: 16px;\n}\n.dialog-title[data-v-b4be5b4a] {\n    font-size: 16px;\n    text-align: center;\n    margin-bottom: 10px;\n    padding-bottom: 15px;\n    border-bottom: 1px dashed #e6e6e6;\n}\n.dialog-body[data-v-b4be5b4a] {\n    padding: 10px 0;\n}\n.dialog-footer[data-v-b4be5b4a] {\n    margin: 10px 0;\n}\n.fade-enter-active[data-v-b4be5b4a], .fade-leave-active[data-v-b4be5b4a] {\n  -webkit-transition: all .5s ease;\n  transition: all .5s ease;\n}\n.fade-enter[data-v-b4be5b4a], .fade-leave-to[data-v-b4be5b4a] {\n  bottom: 0;\n  opacity: 0;\n}\n", ""]);

// exports


/***/ }),
/* 890 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("transition", { attrs: { name: "fade" } }, [
    _c(
      "div",
      {
        directives: [
          {
            name: "show",
            rawName: "v-show",
            value: _vm.visible,
            expression: "visible"
          }
        ],
        staticClass: "mask"
      },
      [
        _c("div", { staticClass: "dialog" }, [
          _vm.showClose
            ? _c(
                "div",
                { staticClass: "dialog-close", on: { click: _vm.handleClose } },
                [_c("v-icon", { attrs: { name: "times" } })],
                1
              )
            : _vm._e(),
          _vm._v(" "),
          _c("div", { staticClass: "dialog-title" }, [
            _vm._v(_vm._s(_vm.title))
          ]),
          _vm._v(" "),
          _c("div", { staticClass: "dialog-body" }, [_vm._t("default")], 2),
          _vm._v(" "),
          _vm.$slots.footer
            ? _c("div", { staticClass: "dialog-footer" }, [_vm._t("footer")], 2)
            : _vm._e()
        ])
      ]
    )
  ])
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-b4be5b4a", esExports)
  }
}

/***/ }),
/* 891 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _promise = __webpack_require__(4);

var _promise2 = _interopRequireDefault(_promise);

var _storage = __webpack_require__(234);

var _storage2 = _interopRequireDefault(_storage);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var tabsSendMessage = function tabsSendMessage() {
    return new _promise2.default(function (resolve, reject) {
        chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {
            // å‘é€ä¸€ä¸ªcopyæ¶ˆæ¯å‡ºåŽ»
            var changeNode = _storage2.default.get("choose_node");
            chrome.tabs.sendMessage(tabs[0].id, { type: "change", content: changeNode }, function (response) {
                // è¿™é‡Œçš„å›žè°ƒå‡½æ•°æŽ¥æ”¶åˆ°äº†è¦æŠ“å–çš„å€¼ï¼ŒèŽ·å–å€¼å¾—æ“ä½œåœ¨ä¸‹æ–¹content-script.js
                // å°†å€¼å­˜åœ¨background.jsçš„dataå±žæ€§é‡Œé¢ã€‚
                // var win = chrome.extension.getBackgroundPage();
                // win.data=response;
                //   console.log(response)
                //   Storage.set("choose_node", changeNode);
                resolve(response);
            });
        });
    });
};

exports.default = {
    tabsSendMessage: tabsSendMessage
};

/***/ }),
/* 892 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "header",
    { staticClass: "header" },
    [
      _c("router-link", { staticClass: "header-logo", attrs: { to: "/" } }, [
        _c("img", { attrs: { src: "/icons/logo-small.png", alt: "Treasure" } })
      ]),
      _vm._v(" "),
      _c(
        "div",
        {
          directives: [
            {
              name: "click-outside",
              rawName: "v-click-outside",
              value: _vm.onClickOutside,
              expression: "onClickOutside"
            }
          ],
          staticClass: "network",
          on: {
            click: function($event) {
              _vm.showNetworkDropdown = !_vm.showNetworkDropdown
            }
          }
        },
        [
          _c("a", { staticClass: "network-toggle" }, [
            _c("span", { staticClass: "network-icon" }),
            _vm._v(" "),
            _c("span", { staticClass: "network-name" }, [
              _vm._v(_vm._s(_vm.choose.name))
            ]),
            _vm._v(" "),
            _c("span", { staticClass: "network-arrow" }, [
              _c(
                "svg",
                {
                  staticClass: "icon",
                  attrs: {
                    xmlns: "http://www.w3.org/2000/svg",
                    viewBox: "0 0 20 20"
                  }
                },
                [
                  _c("path", {
                    attrs: {
                      d:
                        "M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"
                    }
                  })
                ]
              )
            ])
          ]),
          _vm._v(" "),
          _c(
            "div",
            {
              directives: [
                {
                  name: "show",
                  rawName: "v-show",
                  value: _vm.showNetworkDropdown,
                  expression: "showNetworkDropdown"
                }
              ],
              staticClass: "network-dropdown"
            },
            _vm._l(_vm.nodes, function(network, index) {
              return _c(
                "a",
                {
                  key: index,
                  on: {
                    click: function($event) {
                      return _vm.changeNetwork(network)
                    }
                  }
                },
                [
                  _c("span", { staticClass: "network-dropdown-icon" }, [
                    network.ws === _vm.choose.ws
                      ? _c(
                          "svg",
                          {
                            staticClass: "icon",
                            attrs: {
                              xmlns: "http://www.w3.org/2000/svg",
                              viewBox: "-2 -1.5 24 24",
                              width: "24",
                              height: "24",
                              preserveAspectRatio: "xMinYMin"
                            }
                          },
                          [
                            _c("path", {
                              attrs: {
                                d:
                                  "M10 20.565c-5.523 0-10-4.477-10-10s4.477-10 10-10 10 4.477 10 10-4.477 10-10 10z"
                              }
                            })
                          ]
                        )
                      : _c(
                          "svg",
                          {
                            staticClass: "icon",
                            attrs: {
                              xmlns: "http://www.w3.org/2000/svg",
                              viewBox: "-2 -2 24 24",
                              width: "24",
                              height: "24",
                              preserveAspectRatio: "xMinYMin"
                            }
                          },
                          [
                            _c("path", {
                              attrs: {
                                d:
                                  "M10 18a8 8 0 1 0 0-16 8 8 0 0 0 0 16zm0 2C4.477 20 0 15.523 0 10S4.477 0 10 0s10 4.477 10 10-4.477 10-10 10z"
                              }
                            })
                          ]
                        )
                  ]),
                  _vm._v(" "),
                  _c("span", [_vm._v(_vm._s(network.name))])
                ]
              )
            }),
            0
          )
        ]
      ),
      _vm._v(" "),
      _c(
        "k-dialog",
        {
          attrs: {
            visible: _vm.changeNodeRemovePasswordShow,
            title: _vm.$t("title.switchingTheNetwork")
          },
          on: {
            close: function($event) {
              _vm.changeNodeRemovePasswordShow = false
            }
          }
        },
        [
          _c("div", { staticClass: "warning-tit" }, [
            _vm._v(
              _vm._s(_vm.$t("message.switchingTheNetworkWillExitTheAccount"))
            )
          ]),
          _vm._v(" "),
          _c("div", { staticClass: "warning-tip" }, [
            _vm._v(_vm._s(_vm.$t("confirm.removeAccount")))
          ]),
          _vm._v(" "),
          _c(
            "div",
            {
              staticClass: "text-center",
              attrs: { slot: "footer" },
              slot: "footer"
            },
            [
              _c(
                "el-button",
                {
                  staticClass: "full-btn",
                  attrs: { type: "primary" },
                  on: {
                    click: function($event) {
                      return _vm.sureBtn("removeForm")
                    }
                  }
                },
                [_vm._v(_vm._s(_vm.$t("button.sure")))]
              )
            ],
            1
          )
        ]
      ),
      _vm._v(" "),
      _c("div", { staticClass: "setting-icon" }, [
        _c("img", {
          attrs: { src: "/icons/shuaxin.png", alt: "" },
          on: { click: _vm.refreshData }
        }),
        _vm._v(" "),
        _c("img", {
          attrs: { src: "/icons/mima.png", alt: "" },
          on: { click: _vm.lockAccountAjax }
        }),
        _vm._v(" "),
        _c("img", {
          attrs: { src: "/icons/shezhi2.png", alt: "" },
          on: { click: _vm.goSettings }
        })
      ])
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-68225334", esExports)
  }
}

/***/ }),
/* 893 */,
/* 894 */,
/* 895 */,
/* 896 */,
/* 897 */,
/* 898 */,
/* 899 */,
/* 900 */,
/* 901 */,
/* 902 */,
/* 903 */,
/* 904 */,
/* 905 */,
/* 906 */,
/* 907 */,
/* 908 */,
/* 909 */,
/* 910 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = __webpack_require__(3);

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = __webpack_require__(101);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _extends2 = __webpack_require__(76);

var _extends3 = _interopRequireDefault(_extends2);

var _navigation = __webpack_require__(877);

var _navigation2 = _interopRequireDefault(_navigation);

var _appHeader = __webpack_require__(885);

var _appHeader2 = _interopRequireDefault(_appHeader);

var _utils = __webpack_require__(154);

var _utils2 = _interopRequireDefault(_utils);

var _vuex = __webpack_require__(129);

var _vue2Simplert = __webpack_require__(954);

var _vue2Simplert2 = _interopRequireDefault(_vue2Simplert);

var _InternalMessage = __webpack_require__(235);

var _InternalMessage2 = _interopRequireDefault(_InternalMessage);

var _InternalMessageTypes = __webpack_require__(236);

var InternalMessageTypes = _interopRequireWildcard(_InternalMessageTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  components: {
    Navigation: _navigation2.default,
    AppHeader: _appHeader2.default,
    Simplert: _vue2Simplert2.default
  },
  data: function data() {
    var _this = this;

    var amountValidator = function amountValidator(rule, value, callback) {
      if (!/^(-?\d+)(\.\d+)?$/.test(value)) {
        callback(new Error(_this.$i18n.t("verify.number")));
      } else if (value * 1 > 0) {
        callback();
      } else {
        callback(new Error(_this.$i18n.t("verify.numberGtZero")));
      }
    };
    return {
      assetTypes: [{ name: this.$i18n.t("type.bandWidth"), value: "BANDWIDTH" }, { name: this.$i18n.t("type.energy"), value: "ENERGY" }],
      pledgeVisible: false,
      redeemVisible: false,
      pledgeForm: {
        amount: 0,
        type: "BANDWIDTH"
      },
      pledgeRules: {
        amount: { validator: amountValidator, trigger: "blur" }
      },
      alertOption: {
        title: "",
        message: this.$i18n.t("alert.pledgeSuccess"),
        type: "info",
        customIconUrl: "/images/success-icon.png",
        onClose: this.onClose,
        customCloseBtnText: this.$i18n.t("button.close"),
        customCloseBtnClass: "el-button el-button--primary full-btn"
      }
    };
  },

  computed: (0, _extends3.default)({}, (0, _vuex.mapState)(["currentAccount"]), (0, _vuex.mapState)("account", ["cpu", "bandWidth", "frozenExpires"]), (0, _vuex.mapState)("account", {
    cocosPower: function cocosPower(state) {
      return _utils2.default.getTokenAmount(state.cocosPower);
    }
  })),
  created: function created() {
    this.loadAccount();
  },

  methods: (0, _extends3.default)({}, (0, _vuex.mapActions)("account", ["loadAccount"]), {
    pledgeHandler: function pledgeHandler(forName) {
      var _this2 = this;

      this.$refs[forName].validate(function (valid) {
        if (valid) {
          _this2.pledge();
        }
      });
    },
    redeemHandler: function redeemHandler() {
      this.redeem();
    },
    pledge: function pledge() {
      var _this3 = this;

      return (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
        var _ref, _result, success;

        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _this3.$store.commit("loading", true);
                _this3.pledgeVisible = false;
                _context.prev = 2;
                _context.next = 5;
                return _InternalMessage2.default.widthPayload(InternalMessageTypes.SIGNSENDTRANSACTION, { address: _this3.currentAccount.address, transaction: transaction }).send();

              case 5:
                _ref = _context.sent;
                _result = _ref.result;
                success = _result;

                _this3.$store.commit("loading", false);
                if (success) {
                  _this3.alertOption.message = _this3.$i18n.t("alert.pledgeSuccess");
                  _this3.alertOption.customIconUrl = "/images/success-icon.png";
                  _this3.$refs.simplert.openSimplert(_this3.alertOption);
                  _this3.loadAccount();
                } else {
                  _this3.alertOption.message = _this3.$i18n.t("alert.pledgeFail");
                  _this3.alertOption.customIconUrl = "/images/error-icon.png";
                  _this3.$refs.simplert.openSimplert(_this3.alertOption);
                }
                _context.next = 18;
                break;

              case 12:
                _context.prev = 12;
                _context.t0 = _context["catch"](2);

                _this3.$store.commit("loading", false);
                _this3.alertOption.message = _this3.$i18n.t("alert.pledgeFail");
                _this3.alertOption.customIconUrl = "/images/error-icon.png";
                _this3.$refs.simplert.openSimplert(_this3.alertOption);

              case 18:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, _this3, [[2, 12]]);
      }))();
    },
    redeem: function redeem() {
      var _this4 = this;

      return (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2() {
        var success;
        return _regenerator2.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _this4.$store.commit("loading", true);
                _this4.redeemVisible = false;
                try {
                  success = result;

                  _this4.$store.commit("loading", false);
                  if (success) {
                    _this4.$store.commit("loading", false);
                    _this4.alertOption.message = _this4.$i18n.t("alert.redeemSuccess");
                    _this4.alertOption.customIconUrl = "/images/success-icon.png";
                    _this4.$refs.simplert.openSimplert(_this4.alertOption);
                    _this4.loadAccount();
                  } else {
                    _this4.$store.commit("loading", false);
                    _this4.alertOption.message = _this4.$i18n.t("alert.redeemFail");
                    _this4.alertOption.customIconUrl = "/images/error-icon.png";
                    _this4.$refs.simplert.openSimplert(_this4.alertOption);
                  }
                } catch (e) {
                  _this4.$store.commit("loading", false);
                  _this4.alertOption.message = _this4.$i18n.t("alert.redeemFail");
                  _this4.alertOption.customIconUrl = "/images/error-icon.png";
                  _this4.$refs.simplert.openSimplert(_this4.alertOption);
                }

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, _this4);
      }))();
    },
    refresh: function refresh() {
      this.loadAccount();
    }
  })
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 911 */,
/* 912 */,
/* 913 */,
/* 914 */,
/* 915 */,
/* 916 */,
/* 917 */,
/* 918 */,
/* 919 */,
/* 920 */,
/* 921 */,
/* 922 */,
/* 923 */,
/* 924 */,
/* 925 */,
/* 926 */,
/* 927 */,
/* 928 */,
/* 929 */,
/* 930 */,
/* 931 */,
/* 932 */,
/* 933 */,
/* 934 */,
/* 935 */,
/* 936 */,
/* 937 */,
/* 938 */,
/* 939 */,
/* 940 */,
/* 941 */,
/* 942 */,
/* 943 */,
/* 944 */,
/* 945 */,
/* 946 */,
/* 947 */,
/* 948 */,
/* 949 */,
/* 950 */,
/* 951 */,
/* 952 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(953);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(29)("5a30ce86", content, false, {});
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../../../node_modules/css-loader/index.js?{\"minimize\":false}!../../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-6c1719d8\",\"scoped\":true,\"hasInlineConfig\":false}!../../../../node_modules/sass-loader/lib/loader.js?{}!../../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./index.vue", function() {
     var newContent = require("!!../../../../node_modules/css-loader/index.js?{\"minimize\":false}!../../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-6c1719d8\",\"scoped\":true,\"hasInlineConfig\":false}!../../../../node_modules/sass-loader/lib/loader.js?{}!../../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./index.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 953 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(28)(false);
// imports


// module
exports.push([module.i, "\n.resource-title[data-v-6c1719d8] {\n  font-size: 16px;\n  text-align: center;\n  color: #4679fe;\n  margin: 10px 0;\n}\n.resource-small-tip[data-v-6c1719d8] {\n  font-size: 12px;\n  color: #666;\n  line-height: 1.6;\n}\n.show-resource[data-v-6c1719d8] {\n  margin: 15px 0;\n}\n.show-vote[data-v-6c1719d8] {\n  border-top: 1px solid #e6e6e6;\n}\n.show-vote .title[data-v-6c1719d8] {\n    font-size: 16px;\n    text-align: center;\n    color: #7046fe;\n    margin: 10px 0;\n}\n.show-vote .vote[data-v-6c1719d8] {\n    width: 180px;\n    background-color: rgba(70, 121, 254, 0.2);\n    padding: 20px 10px;\n    margin: 0 auto;\n    border-radius: 4px;\n}\n.show-vote .vote span[data-v-6c1719d8] {\n      display: block;\n      text-align: center;\n}\n.show-vote .vote .name[data-v-6c1719d8] {\n      font-size: 14px;\n      color: #999;\n}\n.show-vote .vote .value[data-v-6c1719d8] {\n      font-size: 24px;\n      color: #333;\n      margin-top: 10px;\n}\n.show-vote .pledged[data-v-6c1719d8] {\n    text-align: center;\n    font-size: 14px;\n    margin-top: 10px;\n}\n.show-vote .redeem-time[data-v-6c1719d8] {\n    font-size: 12px;\n    color: #999;\n    text-align: center;\n    margin-top: 10px;\n}\n.btn-group[data-v-6c1719d8] {\n  position: relative;\n  z-index: 9;\n  margin-top: 20px;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -moz-box;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: justify;\n  -webkit-justify-content: space-between;\n     -moz-box-pack: justify;\n      -ms-flex-pack: justify;\n          justify-content: space-between;\n}\n.btn-group button[data-v-6c1719d8] {\n    width: 45%;\n}\n.show-resource[data-v-6c1719d8] {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -moz-box;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-pack: justify;\n  -webkit-justify-content: space-between;\n     -moz-box-pack: justify;\n      -ms-flex-pack: justify;\n          justify-content: space-between;\n}\n.show-resource .item[data-v-6c1719d8] {\n    position: relative;\n    width: 46%;\n    background-color: #fff;\n    text-align: center;\n    border-radius: 8px;\n    padding: 10px 5px;\n}\n.show-resource .item[data-v-6c1719d8]:after {\n      position: absolute;\n      top: -2px;\n      left: -2px;\n      bottom: -2px;\n      right: -2px;\n      background: -webkit-gradient(linear, left top, left bottom, from(#7046fe), to(#4679fe));\n      background: -webkit-linear-gradient(top, #7046fe, #4679fe);\n      background: linear-gradient(to bottom, #7046fe, #4679fe);\n      content: ' ';\n      z-index: -1;\n      border-radius: 8px;\n}\n.show-resource .item span[data-v-6c1719d8] {\n      display: block;\n}\n.show-resource .item .value[data-v-6c1719d8] {\n      font-size: 14px;\n      color: #666;\n      margin-top: 5px;\n}\n.show-resource .item .key[data-v-6c1719d8] {\n      margin-top: 5px;\n      font-size: 14px;\n      color: #999;\n}\n", ""]);

// exports


/***/ }),
/* 954 */
/***/ (function(module, exports, __webpack_require__) {

/*! Vue2-Simplert v.0.8.0 */
!function(n,e){ true?module.exports=e():"function"==typeof define&&define.amd?define("Simplert",[],e):"object"==typeof exports?exports.Simplert=e():n.Simplert=e()}("undefined"!=typeof self?self:this,function(){return function(n){function e(o){if(t[o])return t[o].exports;var s=t[o]={i:o,l:!1,exports:{}};return n[o].call(s.exports,s,s.exports,e),s.l=!0,s.exports}var t={};return e.m=n,e.c=t,e.d=function(n,t,o){e.o(n,t)||Object.defineProperty(n,t,{configurable:!1,enumerable:!0,get:o})},e.n=function(n){var t=n&&n.__esModule?function(){return n.default}:function(){return n};return e.d(t,"a",t),t},e.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},e.p="/dist",e(e.s=4)}([function(n,e,t){"use strict";function o(n,e){var t=n[1]||"",o=n[3];if(!o)return t;if(e&&"function"==typeof btoa){var i=s(o);return[t].concat(o.sources.map(function(n){return"/*# sourceURL="+o.sourceRoot+n+" */"})).concat([i]).join("\n")}return[t].join("\n")}function s(n){return"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(n))))+" */"}n.exports=function(n){var e=[];return e.toString=function(){return this.map(function(e){var t=o(e,n);return e[2]?"@media "+e[2]+"{"+t+"}":t}).join("")},e.i=function(n,t){"string"==typeof n&&(n=[[null,n,""]]);for(var o={},s=0;s<this.length;s++){var i=this[s][0];"number"==typeof i&&(o[i]=!0)}for(s=0;s<n.length;s++){var r=n[s];"number"==typeof r[0]&&o[r[0]]||(t&&!r[2]?r[2]=t:t&&(r[2]="("+r[2]+") and ("+t+")"),e.push(r))}},e}},function(n,e,t){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var o=t(2),s=function(n){return n&&n.__esModule?n:{default:n}}(o);e.default={name:"Simplert",props:{useRadius:{type:Boolean,default:!0},useIcon:{type:Boolean,default:!0},enableLog:{type:Boolean,default:!1}},data:function(){return{eventBus:null,showSimplert:!1,title:"",message:"",type:s.default.defaultCons.DEFAULT_TYPE,customClass:"",customIconUrl:"",onOpen:null,customCloseBtnText:s.default.defaultCons.DEFAULT_BTN_CLOSE_TEXT,customCloseBtnClass:"",onClose:null,useConfirmBtn:!1,customConfirmBtnText:s.default.defaultCons.DEFAULT_BTN_CONFIRM_TEXT,customConfirmBtnClass:"",onConfirm:null,disableOverlayClick:!1,hideAllButton:!1,showXclose:!1}},computed:{classSimplert:function(){var n=this.customClass;return this.showSimplert&&(n=this.customClass+" simplert--shown"),n},classContent:function(){var n="";return this.useRadius&&(n="simplert__content--radius"),n},classBtnClose:function(){var n="simplert__close";return this.useRadius&&(n="simplert__close simplert__close--radius"),this.customCloseBtnClass&&(n=this.customCloseBtnClass),n},classBtnConfirm:function(){var n="simplert__confirm";return this.useRadius&&(n="simplert__confirm simplert__confirm--radius"),this.customConfirmBtnClass&&(n=this.customConfirmBtnClass),n}},methods:{justCloseSimplert:function(){this.showSimplert=!1},closeOverlay:function(n){var e=this;n.target.className.indexOf("simplert--shown")>0&&!e.disableOverlayClick&&this.justCloseSimplert()},whenConfirm:function(n){var e=this;n.preventDefault(),this.justCloseSimplert(),null!==e.onConfirm&&e.onConfirm()},closeSimplert:function(n){var e=this;n.preventDefault(),this.justCloseSimplert(),null!==e.onClose&&e.onClose()},openSimplert:function(n){var e=this;void 0!==n&&(e.showSimplert=!0,e.title=n.title,void 0!==n.message?e.message=n.message:e.message="",void 0!==n.type?e.type=n.type:e.type=s.default.config.type,void 0!==n.customClass?e.customClass=n.customClass:e.customClass="",void 0!==n.customIconUrl&&""!==n.customIconUrl?(e.customIconUrl=n.customIconUrl,e.type=s.default.defaultCons.INVALID_TYPE):e.customIconUrl="",void 0!==n.customCloseBtnText&&""!==n.customCloseBtnText?e.customCloseBtnText=n.customCloseBtnText:e.customCloseBtnText=s.default.defaultCons.DEFAULT_BTN_CLOSE_TEXT,void 0!==n.customCloseBtnClass?e.customCloseBtnClass=n.customCloseBtnClass:e.customCloseBtnClass="",void 0!==n.onClose&&null!==n.onClose?e.onClose=n.onClose:e.onClose=null,void 0!==n.useConfirmBtn?e.useConfirmBtn=n.useConfirmBtn:e.useConfirmBtn=!1,void 0!==n.customConfirmBtnText&&""!==n.customConfirmBtnText?e.customConfirmBtnText=n.customConfirmBtnText:e.customConfirmBtnText=s.default.defaultCons.DEFAULT_BTN_CONFIRM_TEXT,void 0!==n.customConfirmBtnClass?e.customConfirmBtnClass=n.customConfirmBtnClass:e.customConfirmBtnClass="",void 0!==n.onConfirm&&null!==n.onConfirm?e.onConfirm=n.onConfirm:e.onConfirm=null,void 0!==n.disableOverlayClick?e.disableOverlayClick=n.disableOverlayClick:e.disableOverlayClick=!1,void 0!==n.hideAllButton?e.hideAllButton=n.hideAllButton:e.hideAllButton=!1,void 0!==n.showXclose?e.showXclose=n.showXclose:e.showXclose=!1,void 0!==n.onOpen?e.onOpen=n.onOpen:e.onOpen=null,null!==e.onOpen&&e.onOpen()),this.enableLog&&console.log(e)}}}},function(n,e,t){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var o={DEFAULT_TYPE:"info",DEFAULT_BTN_CLOSE_TEXT:"Close",DEFAULT_BTN_CONFIRM_TEXT:"Confirm",INVALID_TYPE:"INVALID_TYPE"};e.default={name:"simplertConfig",config:{show:!1,showSimplert:!1,title:"",message:"",type:o.DEFAULT_TYPE,customClass:"",customIconUrl:"",onOpen:null,customCloseBtnText:o.DEFAULT_BTN_CLOSE_TEXT,customCloseBtnClass:"",onClose:null,useConfirmBtn:!1,customConfirmBtnText:o.DEFAULT_BTN_CONFIRM_TEXT,customConfirmBtnClass:"",onConfirm:null,disableOverlayClick:!1,hideAllButton:!1,showXclose:!1},defaultCons:o}},function(n,e,t){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var o=t(1),s=function(n){return n&&n.__esModule?n:{default:n}}(o);e.default={name:"Simplert",mixins:[s.default]}},function(n,e,t){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var o=t(5),s=function(n){return n&&n.__esModule?n:{default:n}}(o),i={install:function(n){n.component(s.default.name,s.default)}};s.default.install=i.install,e.default=s.default},function(n,e,t){"use strict";function o(n){t(6)}Object.defineProperty(e,"__esModule",{value:!0});var s=t(3),i=t.n(s);for(var r in s)"default"!==r&&function(n){t.d(e,n,function(){return s[n]})}(r);var l=t(11),a=t(10),c=o,u=a(i.a,l.a,!1,c,null,null);e.default=u.exports},function(n,e,t){var o=t(7);"string"==typeof o&&(o=[[n.i,o,""]]),o.locals&&(n.exports=o.locals);t(8)("b60b2b4a",o,!0)},function(n,e,t){e=n.exports=t(0)(!1),e.push([n.i,"\n.simplert {\n  box-sizing: border-box;\n  font-size: 14px;\n  line-height: 1.15;\n}\n.simplert *, .simplert *:before, .simplert *:after {\n  box-sizing: inherit;\n}\n.simplert {\n  position: fixed;\n  z-index: 999;\n  top: 0;\n  left: 0;\n  display: none;\n  overflow: auto;\n  width: 100%;\n  height: 100%;\n  text-align: center;\n  background-color: black;\n  background-color: rgba(0, 0, 0, 0.4);\n}\n.simplert--shown {\n  display: flex;\n  align-items: center;\n}\n.simplert--shown .simplert__content {\n  animation-name: zoomIn;\n  animation-duration: .3s;\n  animation-fill-mode: both;\n}\n.simplert__x{\n  position: absolute;\n  right: 15px;\n  top: 15px;\n  cursor: pointer;\n  color: #b3aaaa;\n  font-weight: bold;\n  font-size: 11px;\n}\n.simplert__header {\n  padding: 2em 0;\n}\n.simplert__title {\n  font-size: 30px;\n  display: block;\n}\n.simplert__content {\n  position: relative;\n  width: 90%;\n  max-width: 400px;\n  margin: 0 auto;\n  padding: 0 20px;\n  background-color: #fff;\n  box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);\n}\n@media only screen and (min-width: 768px) {\n.simplert__content {\n    width: 30%;\n}\n}\n.simplert__content--radius {\n  -webkit-border-radius: 0.3em;\n  -moz-border-radius: 0.3em;\n  border-radius: 0.3em;\n}\n.simplert__body {\n  padding-bottom: 1em;\n}\n.simplert__icon {\n  position: relative;\n  width: 80px;\n  height: 80px;\n  margin: 10px auto;\n  -webkit-border-radius: 50%;\n  -moz-border-radius: 50%;\n  border-radius: 50%;\n}\n.simplert__icon--info {\n  border: 4px solid #c9dae1;\n}\n.simplert__icon--success {\n  border: 4px solid #a5dc86;\n}\n.simplert__icon--warning {\n  border: 4px solid #f8bb86;\n}\n.simplert__icon--error {\n  border: 4px solid #f27474;\n}\n.simplert__icon img {\n  width: 80px;\n  height: 80px;\n}\n.simplert__line {\n  position: absolute;\n  z-index: 2;\n  display: block;\n  height: 5px;\n  border-radius: 2px;\n}\n.simplert__line--info {\n  position: absolute;\n  top: 19px;\n  left: 50%;\n  width: 7px;\n  height: 7px;\n  margin-left: -3px;\n  border-radius: 50%;\n  background-color: #c9dae1;\n}\n.simplert__line--info-2 {\n  position: absolute;\n  bottom: 15px;\n  left: 50%;\n  width: 5px;\n  height: 29px;\n  margin-left: -2px;\n  border-radius: 2px;\n  background-color: #c9dae1;\n}\n.simplert__line--success {\n  top: 44px;\n  left: 6px;\n  width: 25px;\n  -webkit-transform: rotate(45deg);\n  transform: rotate(45deg);\n  background-color: #a5dc86;\n}\n.simplert__line--success-2 {\n  top: 38px;\n  right: 6px;\n  width: 47px;\n  -webkit-transform: rotate(-45deg);\n  transform: rotate(-45deg);\n  background-color: #a5dc86;\n}\n.simplert__line--warning {\n  position: absolute;\n  top: 10px;\n  left: 50%;\n  width: 5px;\n  height: 35px;\n  margin-left: -2px;\n  -webkit-border-radius: 2px;\n  border-radius: 2px;\n  background-color: #f8bb86;\n}\n.simplert__line--warning-2 {\n  position: absolute;\n  bottom: 10px;\n  left: 50%;\n  width: 7px;\n  height: 7px;\n  margin-left: -3px;\n  -webkit-border-radius: 50%;\n  border-radius: 50%;\n  background-color: #f8bb86;\n}\n.simplert__line--error {\n  top: 35px;\n  left: 13px;\n  width: 47px;\n  -webkit-transform: rotate(45deg);\n  transform: rotate(45deg);\n  background-color: #f27474;\n}\n.simplert__line--error-2 {\n  top: 35px;\n  right: 13px;\n  width: 47px;\n  -webkit-transform: rotate(-45deg);\n  transform: rotate(-45deg);\n  background-color: #f27474;\n}\n.simplert__footer {\n  padding: 1em 0;\n}\n.simplert__close, .simplert__confirm {\n  display: inline-block;\n  margin: 0 .5em;\n  padding: 10px 20px;\n  cursor: pointer;\n  text-align: center;\n  color: #fff;\n  border: none;\n  outline: none;\n  background-color: #068ac9;\n  -webkit-appearance: none;\n  -moz-appearance: none;\n}\n.simplert__close--radius, .simplert__confirm--radius {\n  -webkit-border-radius: 0.3em;\n  -moz-border-radius: 0.3em;\n  border-radius: 0.3em;\n}\n@keyframes zoomIn {\nfrom {\n    transform: scale3d(0.3, 0.3, 0.3);\n    opacity: 0;\n}\n50% {\n    opacity: 1;\n}\n}\n",""])},function(n,e,t){function o(n){for(var e=0;e<n.length;e++){var t=n[e],o=u[t.id];if(o){o.refs++;for(var s=0;s<o.parts.length;s++)o.parts[s](t.parts[s]);for(;s<t.parts.length;s++)o.parts.push(i(t.parts[s]));o.parts.length>t.parts.length&&(o.parts.length=t.parts.length)}else{for(var r=[],s=0;s<t.parts.length;s++)r.push(i(t.parts[s]));u[t.id]={id:t.id,refs:1,parts:r}}}}function s(){var n=document.createElement("style");return n.type="text/css",d.appendChild(n),n}function i(n){var e,t,o=document.querySelector('style[data-vue-ssr-id~="'+n.id+'"]');if(o){if(f)return _;o.parentNode.removeChild(o)}if(C){var i=m++;o=p||(p=s()),e=r.bind(null,o,i,!1),t=r.bind(null,o,i,!0)}else o=s(),e=l.bind(null,o),t=function(){o.parentNode.removeChild(o)};return e(n),function(o){if(o){if(o.css===n.css&&o.media===n.media&&o.sourceMap===n.sourceMap)return;e(n=o)}else t()}}function r(n,e,t,o){var s=t?"":o.css;if(n.styleSheet)n.styleSheet.cssText=v(e,s);else{var i=document.createTextNode(s),r=n.childNodes;r[e]&&n.removeChild(r[e]),r.length?n.insertBefore(i,r[e]):n.appendChild(i)}}function l(n,e){var t=e.css,o=e.media,s=e.sourceMap;if(o&&n.setAttribute("media",o),s&&(t+="\n/*# sourceURL="+s.sources[0]+" */",t+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(s))))+" */"),n.styleSheet)n.styleSheet.cssText=t;else{for(;n.firstChild;)n.removeChild(n.firstChild);n.appendChild(document.createTextNode(t))}}var a="undefined"!=typeof document;if("undefined"!=typeof DEBUG&&DEBUG&&!a)throw new Error("vue-style-loader cannot be used in a non-browser environment. Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.");var c=t(9),u={},d=a&&(document.head||document.getElementsByTagName("head")[0]),p=null,m=0,f=!1,_=function(){},C="undefined"!=typeof navigator&&/msie [6-9]\b/.test(navigator.userAgent.toLowerCase());n.exports=function(n,e,t){f=t;var s=c(n,e);return o(s),function(e){for(var t=[],i=0;i<s.length;i++){var r=s[i],l=u[r.id];l.refs--,t.push(l)}e?(s=c(n,e),o(s)):s=[];for(var i=0;i<t.length;i++){var l=t[i];if(0===l.refs){for(var a=0;a<l.parts.length;a++)l.parts[a]();delete u[l.id]}}}};var v=function(){var n=[];return function(e,t){return n[e]=t,n.filter(Boolean).join("\n")}}()},function(n,e,t){"use strict";n.exports=function(n,e){for(var t=[],o={},s=0;s<e.length;s++){var i=e[s],r=i[0],l=i[1],a=i[2],c=i[3],u={id:n+":"+s,css:l,media:a,sourceMap:c};o[r]?o[r].parts.push(u):t.push(o[r]={id:r,parts:[u]})}return t}},function(n,e){n.exports=function(n,e,t,o,s,i){var r,l=n=n||{},a=typeof n.default;"object"!==a&&"function"!==a||(r=n,l=n.default);var c="function"==typeof l?l.options:l;e&&(c.render=e.render,c.staticRenderFns=e.staticRenderFns,c._compiled=!0),t&&(c.functional=!0),s&&(c._scopeId=s);var u;if(i?(u=function(n){n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext,n||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),o&&o.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(i)},c._ssrRegister=u):o&&(u=o),u){var d=c.functional,p=d?c.render:c.beforeCreate;d?(c._injectStyles=u,c.render=function(n,e){return u.call(e),p(n,e)}):c.beforeCreate=p?[].concat(p,u):[u]}return{esModule:r,exports:l,options:c}}},function(n,e,t){"use strict";var o=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"simplert",class:n.classSimplert,attrs:{role:"modal"},on:{click:n.closeOverlay}},[t("div",{staticClass:"simplert__content",class:n.classContent},[t("div",{staticClass:"simplert__header"},[n.showXclose?t("div",{staticClass:"simplert__x",on:{click:n.justCloseSimplert}},[n._v("â•³")]):n._e(),n._v(" "),n.useIcon?t("div",["info"===n.type?t("div",{staticClass:"simplert__icon simplert__icon--info"},[t("div",{staticClass:"simplert__line simplert__line--info"}),n._v(" "),t("div",{staticClass:"simplert__line simplert__line--info-2"})]):n._e(),n._v(" "),"success"===n.type?t("div",{staticClass:"simplert__icon simplert__icon--success"},[t("div",{staticClass:"simplert__line simplert__line--success"}),n._v(" "),t("div",{staticClass:"simplert__line simplert__line--success-2"})]):n._e(),n._v(" "),"warning"===n.type?t("div",{staticClass:"simplert__icon simplert__icon--warning"},[t("div",{staticClass:"simplert__line simplert__line--warning"}),n._v(" "),t("div",{staticClass:"simplert__line simplert__line--warning-2"})]):n._e(),n._v(" "),"error"===n.type?t("div",{staticClass:"simplert__icon simplert__icon--error"},[t("div",{staticClass:"simplert__line simplert__line--error"}),n._v(" "),t("div",{staticClass:"simplert__line simplert__line--error-2"})]):n._e(),n._v(" "),""!==n.customIconUrl?t("div",{staticClass:"simplert__icon"},[t("img",{attrs:{src:n.customIconUrl}})]):n._e()]):n._e(),n._v(" "),t("b",{staticClass:"simplert__title"},[n._v(n._s(n.title))])]),n._v(" "),t("div",{staticClass:"simplert__body"},[t("div",{domProps:{innerHTML:n._s(n.message)}})]),n._v(" "),t("div",{staticClass:"simplert__footer"},[n.useConfirmBtn&&!n.hideAllButton?t("button",{class:n.classBtnConfirm,on:{click:n.whenConfirm}},[n._v("\n        "+n._s(n.customConfirmBtnText)+"\n      ")]):n._e(),n._v(" "),n.hideAllButton?n._e():t("button",{class:n.classBtnClose,on:{click:n.closeSimplert}},[n._v("\n        "+n._s(n.customCloseBtnText)+"\n      ")])])])])},s=[],i={render:o,staticRenderFns:s};e.a=i}])});
//# sourceMappingURL=simplert.umd.js.map

/***/ }),
/* 955 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "section",
    [
      _c("app-header", { on: { refresh: _vm.refresh } }),
      _vm._v(" "),
      _c(
        "section",
        { staticClass: "app-container" },
        [
          _c("navigation", { attrs: { title: _vm.$t("title.resourceTitle") } }),
          _vm._v(" "),
          _c("section", { staticClass: "resource-title" }, [
            _vm._v(_vm._s(_vm.$t("title.resource")))
          ]),
          _vm._v(" "),
          _c("section", { staticClass: "resource-small-tip text-justify" }, [
            _vm._v(_vm._s(_vm.$t("message.resourceTip")))
          ]),
          _vm._v(" "),
          _c("section", { staticClass: "show-resource" }, [
            _c("section", { staticClass: "item" }, [
              _c("span", { staticClass: "name" }, [
                _vm._v(_vm._s(_vm.$t("label.bandwidth")))
              ]),
              _vm._v(" "),
              _c("span", { staticClass: "value" }, [
                _vm._v(_vm._s(_vm.bandWidth))
              ]),
              _vm._v(" "),
              _c("span", { staticClass: "key" }, [_vm._v("Bandwidth points")])
            ]),
            _vm._v(" "),
            _c("section", { staticClass: "item" }, [
              _c("span", { staticClass: "name" }, [_vm._v("CPU")]),
              _vm._v(" "),
              _c("span", { staticClass: "value" }, [_vm._v(_vm._s(_vm.cpu))]),
              _vm._v(" "),
              _c("span", { staticClass: "key" }, [_vm._v("Energy")])
            ])
          ]),
          _vm._v(" "),
          _c("section", { staticClass: "show-vote" }, [
            _c("section", { staticClass: "title" }, [
              _vm._v(_vm._s(_vm.$t("label.vote")))
            ]),
            _vm._v(" "),
            _c("section", { staticClass: "vote" }, [
              _c("span", { staticClass: "name" }, [_vm._v("CocosPower")]),
              _vm._v(" "),
              _c("span", { staticClass: "value" }, [
                _vm._v(_vm._s(_vm.cocosPower) + " TP")
              ])
            ]),
            _vm._v(" "),
            _c("section", { staticClass: "pledged" }, [
              _vm._v(
                _vm._s(_vm.$t("label.donePledge")) +
                  "ï¼š" +
                  _vm._s(_vm.cocosPower)
              )
            ]),
            _vm._v(" "),
            _vm.cocosPower > 0
              ? _c("section", { staticClass: "redeem-time" }, [
                  _vm._v(
                    _vm._s(_vm.$t("label.redeemTime")) +
                      "ï¼š" +
                      _vm._s(
                        _vm._f("moment")(_vm.frozenExpires, "YYYY.MM.DD HH:mm")
                      )
                  )
                ])
              : _vm._e()
          ]),
          _vm._v(" "),
          _c(
            "section",
            { staticClass: "btn-group" },
            [
              _c(
                "el-button",
                {
                  attrs: { type: "primary" },
                  on: {
                    click: function($event) {
                      _vm.pledgeVisible = true
                    }
                  }
                },
                [_vm._v(_vm._s(_vm.$t("button.pledge")))]
              ),
              _vm._v(" "),
              _c(
                "el-button",
                {
                  attrs: { type: "primary", disabled: !(_vm.cocosPower > 0) },
                  on: {
                    click: function($event) {
                      _vm.redeemVisible = true
                    }
                  }
                },
                [_vm._v(_vm._s(_vm.$t("button.redeem")))]
              )
            ],
            1
          )
        ],
        1
      ),
      _vm._v(" "),
      _c(
        "el-dialog",
        {
          attrs: {
            top: "15vh",
            center: "",
            title: _vm.$t("title.pledgeTrx"),
            visible: _vm.pledgeVisible
          },
          on: {
            "update:visible": function($event) {
              _vm.pledgeVisible = $event
            }
          }
        },
        [
          _c("div", { staticClass: "warm-tip" }, [
            _vm._v(_vm._s(_vm.$t("message.pledgeTip")))
          ]),
          _vm._v(" "),
          _c(
            "el-form",
            {
              ref: "pledge",
              attrs: { model: _vm.pledgeForm, rules: _vm.pledgeRules }
            },
            [
              _c(
                "el-form-item",
                {
                  attrs: { label: _vm.$t("label.pledgeAmount"), prop: "amount" }
                },
                [
                  _c(
                    "el-input",
                    {
                      staticClass: "no-border",
                      attrs: { type: "text" },
                      model: {
                        value: _vm.pledgeForm.amount,
                        callback: function($$v) {
                          _vm.$set(_vm.pledgeForm, "amount", $$v)
                        },
                        expression: "pledgeForm.amount"
                      }
                    },
                    [_c("template", { slot: "append" }, [_vm._v("TRX")])],
                    2
                  )
                ],
                1
              ),
              _vm._v(" "),
              _c(
                "el-form-item",
                { attrs: { label: _vm.$t("label.pledgeType") } },
                [
                  _c(
                    "el-select",
                    {
                      staticClass: "no-border",
                      staticStyle: { width: "100%" },
                      model: {
                        value: _vm.pledgeForm.type,
                        callback: function($$v) {
                          _vm.$set(_vm.pledgeForm, "type", $$v)
                        },
                        expression: "pledgeForm.type"
                      }
                    },
                    _vm._l(_vm.assetTypes, function(item, index) {
                      return _c("el-option", {
                        key: index,
                        attrs: { label: item.name, value: item.value }
                      })
                    }),
                    1
                  )
                ],
                1
              )
            ],
            1
          ),
          _vm._v(" "),
          _c(
            "span",
            {
              staticClass: "dialog-footer",
              attrs: { slot: "footer" },
              slot: "footer"
            },
            [
              _c(
                "el-button",
                {
                  staticClass: "full-btn",
                  attrs: { type: "primary" },
                  on: {
                    click: function($event) {
                      return _vm.pledgeHandler("pledge")
                    }
                  }
                },
                [_vm._v(_vm._s(_vm.$t("button.pledgeSure")))]
              )
            ],
            1
          )
        ],
        1
      ),
      _vm._v(" "),
      _c(
        "el-dialog",
        {
          attrs: {
            top: "15vh",
            center: "",
            title: _vm.$t("title.redeemTrx"),
            visible: _vm.redeemVisible
          },
          on: {
            "update:visible": function($event) {
              _vm.redeemVisible = $event
            }
          }
        },
        [
          _c(
            "el-form",
            { ref: "redeem" },
            [
              _c(
                "el-form-item",
                { attrs: { label: _vm.$t("label.redeemAmount") } },
                [
                  _c(
                    "el-input",
                    {
                      staticClass: "no-border",
                      attrs: { type: "text", disabled: true },
                      model: {
                        value: _vm.cocosPower,
                        callback: function($$v) {
                          _vm.cocosPower = $$v
                        },
                        expression: "cocosPower"
                      }
                    },
                    [_c("template", { slot: "append" }, [_vm._v("TRX")])],
                    2
                  )
                ],
                1
              )
            ],
            1
          ),
          _vm._v(" "),
          _c(
            "span",
            {
              staticClass: "dialog-footer",
              attrs: { slot: "footer" },
              slot: "footer"
            },
            [
              _c(
                "el-button",
                {
                  staticClass: "full-btn",
                  attrs: { type: "primary" },
                  on: { click: _vm.redeemHandler }
                },
                [_vm._v(_vm._s(_vm.$t("button.redeemSure")))]
              )
            ],
            1
          )
        ],
        1
      ),
      _vm._v(" "),
      _c("simplert", {
        ref: "simplert",
        attrs: { useRadius: true, useIcon: true }
      })
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-6c1719d8", esExports)
  }
}

/***/ })
]);